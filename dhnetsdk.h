
#ifndef DHNETSDK_H
#define DHNETSDK_H


#if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
    #include <windows.h>
    #ifdef NETSDK_EXPORTS
        #define CLIENT_NET_API  __declspec(dllexport)
    #else
        #define CLIENT_NET_API  __declspec(dllimport)
    #endif

    #define CALLBACK        __stdcall
    #define CALL_METHOD     __stdcall  //__cdecl

    #define INT64           __int64
    #define TP_U64          unsigned __int64

    #ifndef LLONG
        #ifdef _WIN64
            #define LLONG   INT64
        #else 
            #define LLONG   LONG
        #endif
    #endif

    #ifndef LDWORD
        #ifdef _WIN64
            #define LDWORD  INT64
        #else 
            #define LDWORD  DWORD
        #endif
    #endif
#else    //non-windows
    #define CLIENT_NET_API  extern "C"
    #define CALL_METHOD 
    #define CALLBACK

    #ifndef INTERNAL_COMPILE
        #define RELEASE_HEADER
    #endif
 
    #ifdef RELEASE_HEADER
        #define WORD        unsigned short
        #define DWORD       unsigned int
        #define LONG        int
        #define LPDWORD     DWORD*

        #ifdef __OBJC__
            #include "objc/objc.h"
        #else
            #define BOOL    int
        #endif

        #ifndef TRUE
        #define TRUE        1
        #endif

        #ifndef FALSE
        #define FALSE       0
        #endif
        #define BYTE        unsigned char
        #define UINT        unsigned int
        #define HDC         void*
        #define HWND        void*
        #define LPVOID      void*

        #ifndef NULL
        #define NULL        0
        #endif

        #define LLONG       long
        #define INT64       long long
        #define TP_U64      unsigned long long
        #define LDWORD      long 

        #ifndef MAX_PATH
        #define MAX_PATH    260
        #endif

        #ifndef DEF_RECT
        typedef struct  tagRECT
        {
            LONG left;
            LONG top;
            LONG right;
            LONG bottom;
        } RECT;
        #define DEF_RECT
        #endif
    #else    //�ڲ�����
        #include "../Platform/osIndependent.h"
        #define INT64       int64
        #define TP_U64      uint64
    #endif // RELEASE_HEADER
#endif // linux

#ifndef LDWORD
    #if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
        #ifdef _WIN64
            #define LDWORD  __int64
        #else //WIN32 
            #define LDWORD  DWORD
        #endif
    #else    //linux
        #define LDWORD      long 
    #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
 ** ��������
 ***********************************************************************/
#define DH_SERIALNO_LEN                   48               // �豸���к��ַ�����
#define DH_MAX_DISKNUM                    256              // ���Ӳ�̸���
#define DH_MAX_SDCARDNUM                  32               // ���SD������
#define DH_MAX_BURNING_DEV_NUM            32               // ����¼�豸����
#define DH_BURNING_DEV_NAMELEN            32               // ��¼�豸������󳤶�
#define DH_MAX_LINK                       6                
#define DH_MAX_CHANNUM                    16               // ���ͨ������
#define DH_MAX_DECODER_CHANNUM            64               // ���������ͨ����
#define DH_MAX_ALARMIN                    128              // ��󱨾��������
#define DH_MAX_ALARMOUT                   64               // ��󱨾��������
#define DH_MAX_RIGHT_NUM                  100              // �û�Ȩ�޸�������
#define DH_MAX_GROUP_NUM                  20               // �û����������
#define DH_MAX_USER_NUM                   200              // �û���������
#define DH_RIGHT_NAME_LENGTH              32               // Ȩ��������
#define DH_USER_NAME_LENGTH               8                // �û�������
#define DH_USER_PSW_LENGTH                8                // �û����볤��
#define DH_CUSTOM_NAME_LENGTH             32               // �Զ������Ƴ���
#define DH_USER_NAME_LEN_EX               32               // �û�������,������ƽ̨��չ
#define DH_USER_PSW_LEN_EX                32               // �û����볤��,������ƽ̨��չ
#define DH_MEMO_LENGTH                    32               // ��ע����
#define DH_MAX_STRING_LEN                 128              
#define MAX_STRING_LINE_LEN               6                // �������
#define MAX_PER_STRING_LEN                20               // ÿ����󳤶�
#define DH_MAX_MAIL_NAME_LEN              64               // �µ��ʼ��ṹ��֧�ֵ��û�������
#define DH_MAX_MAIL_PSW_LEN               64               // �µ��ʼ��ṹ��֧�ֵ����볤��
#define DH_SPEEDLIMIT_TYPE_LEN            32               // ���������ַ�������
#define DH_VEHICLE_TYPE_LEN               32               // �����Զ�����Ϣ�����ַ�������
#define DH_VEHICLE_INFO_LEN               32               // �����Զ�����Ϣ�ַ�������
#define DH_VEHICLE_DRIVERNO_LEN           32               // �����Զ�����Ϣ˾�������ַ�������
#define DH_MAX_CROSSING_NUM               128              // ����λ
#define DH_MAX_CROSSING_ID                32               // ·�����к���󳤶�
#define DH_MAX_CARD_INFO_LEN              256              // ������Ϣ��󳤶�
#define DH_MAX_CHANNUM_EX                 32               // ���ͨ������չ  
#define DH_MAX_SAERCH_IP_NUM              256              // �������IP����
#define DH_MAX_HARDDISK_TYPE_LEN          32               // Ӳ���ͺ���󳤶�
#define DH_MAX_HARDDISK_SERIAL_LEN        32               // Ӳ�����к���󳤶�
#define DH_MAX_SIM_LEN                    16               // SIM����ֵ����󳤶�
#define DH_MAX_SIM_NUM                    10               // ����SIM��������
#define DH_MAX_VERSION_LEN                32               // ����汾����󳤶�
#define DH_MAX_MDN_LEN                    36               // MDN��ֵ����󳤶�
#define DH_MAX_NETINTERFACE_NUM           64               // ֧�ֵ���������
#define DH_EVENT_NAME_LEN                 128              // �¼����Ƴ���
#define DH_STORAGE_NAME_LEN               128              // �洢�豸���Ƴ���
#define DH_MAX_CARPORTLIGHT_NUM           4                // ���λ�Ƹ���
#define DH_STATION_NAME_LEN               32               // ��վվ�����Ƴ���   
#define PTZ_PRESET_NAME_LEN               64               // ��̨Ԥ�õ����Ƴ���
#define DH_MAX_GUARD_DETECT_ID_COUNT      64               // ���ĸ�ͤ���ID����
#define DH_MAX_VERSION_STR                64               // �汾�ַ�����󳤶�
#define DH_MAX_AUDIO_MATRIX_OUTPUT        8                // ÿ����Ƶ����֧�ֵ�������ͨ����
#define DH_MAX_CHANNEL_COUNT              16               // ֧�����ͨ��������
#define DH_COMMON_STRING_4                4                // ͨ���ַ�������4
#define DH_COMMON_STRING_8                8                // ͨ���ַ�������8
#define DH_COMMON_STRING_16               16               // ͨ���ַ�������16
#define DH_COMMON_STRING_32               32               // ͨ���ַ�������32
#define DH_COMMON_STRING_64               64               // ͨ���ַ�������64
#define DH_COMMON_STRING_128              128              // ͨ���ַ�������128
#define DH_COMMON_STRING_256              256              // ͨ���ַ�������256
#define DH_COMMON_STRING_512              512              // ͨ���ַ�������512
#define DH_COMMON_STRING_1024             1024             // ͨ���ַ�������1024
#define DH_COMMON_STRING_2048             2048             // ͨ���ַ�������2048
#define DH_MAX_ACCESS_NAME_LEN            64               // �Ž����Ƴ���
#define DH_MAX_EXALARMCHANNEL_NAME_LEN    128              // ��չģ�鱨��ͨ�����Ƴ���
#define DH_MAX_ALARM_SUBSYSTEM_NUM        256              // ��󱨾���ϵͳ����
#define DH_MAX_BELL_NUM                   4                // ��󾯺Ÿ���
#define DH_MAX_KEYBOARD_NUM               256              // ��������
#define MAX_GOURP_NUM                     128              // ������������
#define DH_MAX_POS_EXCHANGE_INFO          64               // ÿ�β�ѯPOS������Ϣʱ,������Ϣ��������ֵ
#define NET_INTERFACE_DEFAULT_TIMEOUT     3000             // �ӿ�Ĭ�ϳ�ʱʱ��
#define DH_MAX_BUSCARD_NUM                64               // ����������󳤶�
#define DH_MAX_POS_MAC_NUM                8                // ˢ����Mac����󳤶�
#define DH_MAX_MARK_FILE_NAME_LEN         124              // ¼������ļ�����󳤶�
#define NET_MAX_ATTACHMENT_NUM            8                // ������������
#define NET_MAX_ANNUUALINSPECTION_NUM     8                // �������ʶλ��
#define NET_MAX_EVENT_PIC_NUM             6                // ���ԭʼͼƬ����
#define NET_MAX_MONTH_NUM                 31               // ����·ݸ���
#define NET_IPADDRSTR_LEN                 46               // IP��ַ�ַ������� ֧�� ipv4-mapped-on-ipv6 
#define NET_MAX_AP_NUM                    3                // ���AP����
#define MAX_WEP_KEY_NUM                   4                // ���WEP�������
#define MAX_CARNO_LEN                     20               // ������ų���
#define MAX_COACHNO_LEN                   12               // �����ų���
#define MAX_WORKPATTERN_NUM               2                // �����ģʽ����
#define MAX_ANTIFLICKERMODE_COUNT         8                // ������˸ģʽ������
#define MAX_CATEGORY_LEN                  64               // ����������ͳ���

// Զ�����ýṹ����س���                 
#define DH_MAX_MAIL_ADDR_LEN              128              // �ʼ���(��)��ַ��󳤶�
#define DH_MAX_MAIL_SUBJECT_LEN           64               // �ʼ�������󳤶�
#define DH_MAX_IPADDR_LEN                 16               // IP��ַ�ַ�������
#define DH_MAX_IPADDR_LEN_EX              40               // ��չIP��ַ�ַ�������, ֧��IPV6
#define DH_MACADDR_LEN                    40               // MAC��ַ�ַ�������
#define DH_MAX_URL_LEN                    128              // URL�ַ�������
#define DH_MAX_DEV_ID_LEN                 48               // ���������󳤶�
#define DH_MAX_HOST_NAMELEN               64               // ����������,
#define DH_MAX_HOST_PSWLEN                32               // ���볤��
#define DH_MAX_NAME_LEN                   16               // ͨ�������ַ�������
#define DH_MAX_ETHERNET_NUM               2                // ��̫����������
#define DH_MAX_ETHERNET_NUM_EX            10               // ��չ��̫����������
#define DH_DEV_SERIALNO_LEN               48               // ���к��ַ�������
#define DH_DEV_CLASS_LEN                  16               // �豸�����ַ�������"IPC"������
#define DH_DEV_TYPE_LEN                   32               // �豸�ͺ��ַ�������"IPC-F725"������
#define DH_N_WEEKS                        7                // һ�ܵ�����    
#define DH_N_TSECT                        6                // ͨ��ʱ��θ���
#define DH_N_REC_TSECT                    6                // ¼��ʱ��θ���
#define DH_N_COL_TSECT                    2                // ��ɫʱ��θ���    
#define DH_CHAN_NAME_LEN                  32               // ͨ��������,DVR DSP��������,���32�ֽ�        
#define DH_N_ENCODE_AUX                   3                // ��չ��������    
#define DH_N_TALK                         1                // ���Խ�ͨ������
#define DH_N_COVERS                       1                // �ڵ��������    
#define DH_N_CHANNEL                      16               // ���ͨ������    
#define DH_N_ALARM_TSECT                  2                // ������ʾʱ��θ���
#define DH_MAX_ALARMOUT_NUM               16               // ��������ڸ�������
#define DH_MAX_AUDIO_IN_NUM               16               // ��Ƶ����ڸ�������
#define DH_MAX_VIDEO_IN_NUM               16               // ��Ƶ����ڸ�������
#define DH_MAX_ALARM_IN_NUM               16               // ��������ڸ�������
#define DH_MAX_DISK_NUM                   16               // Ӳ�̸�������,�ݶ�Ϊ16
#define DH_MAX_DECODER_NUM                16               // ������(485)��������    
#define DH_MAX_232FUNCS                   10               // 232���ڹ��ܸ�������
#define DH_MAX_232_NUM                    2                // 232���ڸ�������
#define DH_MAX_232_NUM_EX                 16               // ��չ�������ø�������          
#define DH_MAX_DECPRO_LIST_SIZE           100              // ������Э���б��������
#define DH_FTP_MAXDIRLEN                  240              // FTP�ļ�Ŀ¼��󳤶�
#define DH_MATRIX_MAXOUT                  16               // ���������������                                             
#define DH_TOUR_GROUP_NUM                 6                // ���������������
#define DH_MAX_DDNS_NUM                   10               // �豸֧�ֵ�ddns������������
#define DH_MAX_SERVER_TYPE_LEN            32               // ddns����������,����ַ�������
#define DH_MAX_DOMAIN_NAME_LEN            256              // ddns����,����ַ�������
#define DH_MAX_DDNS_ALIAS_LEN             32               // ddns����������,����ַ�������
#define DH_MAX_DEFAULT_DOMAIN_LEN         60               // ddnsĬ������,����ַ�������     
#define DH_MOTION_ROW                     32               // ��̬������������
#define DH_MOTION_COL                     32               // ��̬������������
#define DH_STATIC_ROW                     32               // ��̬������������
#define DH_STATIC_COL                     32               // ��̬������������
#define DH_FTP_USERNAME_LEN               64               // FTP����,�û�����󳤶�
#define DH_FTP_PASSWORD_LEN               64               // FTP����,������󳤶�
#define DH_TIME_SECTION                   2                // FTP����,ÿ��ʱ��θ���
#define DH_FTP_MAX_PATH                   240              // FTP����,�ļ�·������󳤶�
#define DH_FTP_MAX_SUB_PATH               128              // FTP����,�ļ�·������󳤶�
#define DH_INTERVIDEO_UCOM_CHANID         32               // ƽ̨��������,U��ͨͨ��ID
#define DH_INTERVIDEO_UCOM_DEVID          32               // ƽ̨��������,U��ͨ�豸ID
#define DH_INTERVIDEO_UCOM_REGPSW         16               // ƽ̨��������,U��ͨע������
#define DH_INTERVIDEO_UCOM_USERNAME       32               // ƽ̨��������,U��ͨ�û���
#define DH_INTERVIDEO_UCOM_USERPSW        32               // ƽ̨��������,U��ͨ����
#define DH_INTERVIDEO_NSS_IP              32               // ƽ̨��������,������άIP
#define DH_INTERVIDEO_NSS_SERIAL          32               // ƽ̨��������,������άserial
#define DH_INTERVIDEO_NSS_USER            32               // ƽ̨��������,������άuser
#define DH_INTERVIDEO_NSS_PWD             50               // ƽ̨��������,������άpassword
#define DH_MAX_VIDEO_COVER_NUM            16               // �ڵ�����������
#define DH_MAX_WATERMAKE_DATA             4096             // ˮӡͼƬ������󳤶�
#define DH_MAX_WATERMAKE_LETTER           128              // ˮӡ������󳤶�
#define DH_MAX_WLANDEVICE_NUM             10               // ����������������豸����
#define DH_MAX_WLANDEVICE_NUM_EX          32               // ����������������豸����
#define DH_MAX_ALARM_NAME                 64               // ��ַ����
#define DH_MAX_REGISTER_SERVER_NUM        10               // ����ע�����������
#define DH_SNIFFER_FRAMEID_NUM            6                // 6��FRAME ID ѡ��
#define DH_SNIFFER_CONTENT_NUM            4                // ÿ��FRAME��Ӧ��4��ץ������
#define DH_SNIFFER_CONTENT_NUM_EX         8                // ÿ��FRAME��Ӧ��8��ץ������
#define DH_SNIFFER_PROTOCOL_SIZE          20               // Э�����ֳ���
#define DH_MAX_PROTOCOL_NAME_LENGTH       20               
#define DH_SNIFFER_GROUP_NUM              4                // 4��ץ������
#define MAX_PATH_STOR                     240              // Զ��Ŀ¼�ĳ���
#define DH_ALARM_OCCUR_TIME_LEN           40               // �µı����ϴ�ʱ��ĳ���
#define DH_VIDEO_OSD_NAME_NUM             64               // ���ӵ����Ƴ���,Ŀǰ֧��32��Ӣ��,16������
#define DH_VIDEO_CUSTOM_OSD_NUM           8                // ֧�ֵ��Զ�����ӵ���Ŀ,������ʱ���ͨ��
#define DH_VIDEO_CUSTOM_OSD_NUM_EX        256              // ֧�ֵ��Զ�����ӵ���Ŀ,������ʱ���ͨ��
#define DH_CONTROL_AUTO_REGISTER_NUM      100              // ֧�ֶ�������ע��������ĸ���
#define DH_MMS_RECEIVER_NUM               100              // ֧�ֶ��Ž����ߵĸ���
#define DH_MMS_SMSACTIVATION_NUM          100              // ֧�ֶ��ŷ����ߵĸ���
#define DH_MMS_DIALINACTIVATION_NUM       100              // ֧�ֲ��ŷ����ߵĸ���
#define DH_MAX_ALARMOUT_NUM_EX            32               // ��������ڸ���������չ
#define DH_MAX_VIDEO_IN_NUM_EX            32               // ��Ƶ����ڸ���������չ
#define DH_MAX_ALARM_IN_NUM_EX            32               // ��������ڸ�������
#define DH_MAX_IPADDR_OR_DOMAIN_LEN       64               // IP��ַ�ַ�������
#define DH_MAX_CALLID                     32               // ���ID
#define DH_MAX_OBJECT_LIST                16               // ���ܷ����豸��⵽������ID��������    
#define DH_MAX_RULE_LIST                  16               // ���ܷ����豸�����������
#define DH_MAX_POLYGON_NUM                16               // �������󶥵����
#define DH_MAX_DETECT_LINE_NUM            20               // ����������󶥵���
#define DH_MAX_DETECT_REGION_NUM          20               // ������������󶥵���
#define DH_MAX_TRACK_LINE_NUM             20               // �����˶��켣��󶥵���
#define DH_MAX_CANDIDATE_NUM              50               // ����ʶ�����ƥ����
#define DH_MAX_PERSON_IMAGE_NUM           48               // ÿ����Ա��Ӧ���������ͼƬ��
#define DH_MAX_FENCE_LINE_NUM             2                // Χ�����������
#define MAX_SMART_VALUE_NUM               30               // ����smart��Ϣ����
#define DH_MACHINE_NAME_NUM               64               // �������Ƴ���
#define DH_INTERVIDEO_AMP_DEVICESERIAL    48               // ƽ̨��������,������ �豸���к��ַ�������
#define DH_INTERVIDEO_AMP_DEVICENAME      16               // ƽ̨��������,������ �豸�����ַ�������
#define DH_INTERVIDEO_AMP_USER            32               // ƽ̨��������,������ ע���û����ַ�������
#define DH_INTERVIDEO_AMP_PWD             32               // ƽ̨��������,������ ע�������ַ�������
#define MAX_SUBMODULE_NUM                 32               // �����ģ����Ϣ����
#define DH_MAX_CARWAY_NUM                 8                // ��ͨץ��,��󳵵���
#define DH_MAX_SNAP_SIGNAL_NUM            3                // һ�����������ץ������
#define DH_MAX_CARD_NUM                   128              // ���ŵ�������
#define DH_MAX_CARDINFO_LEN               32               // ÿ��������ַ���
#define DH_MAX_CONTROLER_NUM              64               // ���֧�ֿ�������Ŀ
#define DH_MAX_LIGHT_NUM                  32               // �����Ƶ�����
#define DH_MAX_SNMP_COMMON_LEN            64               // snmp ��д���ݳ���
#define DH_MAX_DDNS_STATE_LEN             128              // DDNS ״̬��Ϣ����
#define DH_MAX_PHONE_NO_LEN               16               // �绰���볤��
#define DH_MAX_MSGTYPE_LEN                32               // �������ͻ����Ϣ���ͳ���
#define DH_MAX_MSG_LEN                    256              // �����Ͷ���Ϣ����
#define DH_MAX_DRIVINGDIRECTION           256              // ��ʻ�����ַ�������
#define DH_MAX_GRAB_INTERVAL_NUM          4                // ����ͼƬץ�ĸ���
#define DH_MAX_FLASH_NUM                  5                // ���֧������Ƹ���
#define DH_MAX_LANE_NUM                   8                // ��Ƶ�����豸ÿ��ͨ����Ӧ����������
#define DH_MAX_ISCSI_PATH_NUM             64               // ISCSIԶ��Ŀ¼�������
#define DH_MAX_WIRELESS_CHN_NUM           256              // ����·������ŵ���
#define DH_PROTOCOL3_BASE                 100              // ����Э��汾����
#define DH_PROTOCOL3_SUPPORT              11               // ֻ֧��3��Э��
#define DH_MAX_CHANMASK                   64               // ͨ���������ֵ
#define DH_MAX_STAFF_NUM                  20               // Ũ����Ƶ������Ϣ�б��������
#define DH_MAX_CALIBRATEBOX_NUM           10               // Ũ����Ƶ������Ϣ�б궨����������
#define DH_MAX_EXCLUDEREGION_NUM          10               // Ũ����Ƶ������Ϣ���ų�����������
#define DH_MAX_POLYLINE_NUM               20               // Ũ����Ƶ������Ϣ�б������
#define DH_MAX_COLOR_NUM                  16               // �����ɫ��Ŀ
#define MAX_OBJFILTER_NUM                 16               // �������������
#define DH_MAX_SYNOPSIS_STATE_NAME        64               // ��ƵŨ��״̬�ַ�������
#define DH_MAX_SYNOPSIS_QUERY_FILE_COUNT  10               // ��ƵŨ�����ԭʼ�ļ�����·������ʱ�ļ���������
#define DH_MAX_SSID_LEN                   36               // SSID����
#define DH_MAX_APPIN_LEN                  16               // PIN�볤��
#define DH_NETINTERFACE_NAME_LEN          260              // �������Ƴ���
#define DH_NETINTERFACE_TYPE_LEN          260              // �������ͳ���
#define DH_MAX_CONNECT_STATUS_LEN         260              // ����״̬�ַ�������
#define DH_MAX_MODE_LEN                   64               // 3G֧�ֵ�����ģʽ����
#define DH_MAX_MODE_NUM                   64               // 3G֧�ֵ�����ģʽ����
#define DH_MAX_COMPRESSION_TYPES_NUM      16               // ��Ƶ�����ʽ����������
#define DH_MAX_CAPTURE_SIZE_NUM           64               // ��Ƶ�ֱ��ʸ���
#define DH_NODE_NAME_LEN                  64               // ��֯�ṹ�ڵ����Ƴ���
#define MAX_CALIBPOINTS_NUM               256              // ֧�����궨����
#define DH_MAX_ATTR_NUM                   32               // ��ʾ��Ԫ�����������
#define DH_MAX_CLOUDCONNECT_STATE_LEN     128              // ��ע������״̬��Ϣ����
#define DH_MAX_IPADDR_EX_LEN              128              // ��չIP��ַ��󳤶�
#define DH_MAX_PLATE_NUMBER_LEN           32               // �����ַ�������   
#define DH_MAX_AUTHORITY_LIST_NUM         16               // Ȩ���б�������   
#define DH_MAX_CITY_NAME_LEN              64               // ����������󳤶�
#define DH_MAX_PROVINCE_NAME_LEN          64               // ʡ��������󳤶�
#define DH_MAX_PERSON_ID_LEN              32               // ��Աid��󳤶�
#define MAX_FACE_AREA_NUM                 8                // �������������� 
#define MAX_FACE_DB_NUM                   8                // ����������ݿ����
#define MAX_EVENT_NAME                    128              // ��¼���
#define DH_MAX_ETH_NAME                   64               // ���������
#define DH_MAX_PERSON_NAME_LEN            64               // ��Ա������󳤶�
#define DH_N_SCHEDULE_TSECT               8                // ʱ���Ԫ�ظ���    
#define DH_MAX_URL_NUM                    8                // URL������
#define DH_MAX_LOWER_MITRIX_NUM           16               // �����λ������
#define DH_MAX_BURN_CHANNEL_NUM           32               // ����¼ͨ����
#define DH_MAX_NET_STRORAGE_BLOCK_NUM     64               // ���Զ�̴洢��������
#define DH_MAX_CASE_PERSON_NUM            32               // ������Ա�������
#define DH_MAX_MULTIPLAYBACK_CHANNEL_NUM  64               // ����ͨ��Ԥ���ط�ͨ����
#define DH_MAX_MULTIPLAYBACK_SPLIT_NUM    32               // ����ͨ��Ԥ���طŷָ�ģʽ��
#define DH_MAX_AUDIO_ENCODE_TYPE          64               // �������������͸���
#define MAX_LOG_PATH_LEN                  260              // ��־·������󳤶�
#define MAX_CARD_RECORD_FIELD_NUM         16               // ����¼�����������
#define DH_BATTERY_NUM_MAX                16               // ���������    
#define DH_POWER_NUM_MAX                  16               // ����Դ����        
#define DH_MAX_AUDIO_PATH                 260              // �����Ƶ�ļ�·����
#define DH_MAX_DOORNAME_LEN               128              // ����Ž����Ƴ���    
#define DH_MAX_CARDPWD_LEN                64               // ����Ž����Ƴ���    
#define NET_MAX_FISHEYE_MOUNTMODE_NUM     4                // ������۰�װģʽ����
#define NET_MAX_FISHEYE_CALIBRATEMODE_NUM 16               // ������۽���ģʽ����
#define NET_MAX_FISHEYE_EPTZCMD_NUM       64               // ������۵�����̨��������   
#define POINT_NUM_IN_PAIR                 2                // �궨����еĵ�����
#define MAX_POINT_PAIR_NUM                128              // �궨���������
#define CHANNEL_NUM_IN_POINT_GROUP        2                // �궨���е���Ƶͨ����
#define MAX_POINT_GROUP_NUM               32               // �궨�����������, ÿ����ͨ������ƴ����Ҫһ��궨��
#define MAX_LANE_INFO_NUM                 32               // ��󳵵���Ϣ��
#define MAX_LANE_DIRECTION_NUM            8                // ������������
#define DH_MAX_MONITORWALL_NUM            32               // ����ǽ�������
#define DH_MAX_OPTIONAL_URL_NUM           8                // ����url�������
#define DH_MAX_CAMERA_CHANNEL_NUM         1024             // ��������ͨ����
#define MAX_FILE_SUMMARY_NUM              32               // ����ļ�ժҪ��
#define MAX_AUDIO_ENCODE_NUM              64               // ���֧����Ƶ�������
#define MAX_MONITORWALL_NAME_LEN          64               // ����ǽ������󳤶�
#define MAX_FLASH_LIGHT_NUM               8                // ���֧�ֵı�����(�����)����
#define MAX_STROBOSCOPIC_LIGHT_NUM        8                // ���֧�ֵ�Ƶ���Ƹ���
#define MAX_MOSAIC_NUM                    8                // ���֧�ֵ�����������
#define MAX_MOSAIC_CHANNEL_NUM            256              // ֧�������˵��ӵ����ͨ������
#define MAX_FIREWARNING_INFO_NUM          4                // ����ȳ����Ż�㱨����Ϣ����
#define MAX_AXLE_NUM                      8                // ���������
#define DH_MAX_BULLET_HOLES               10               // ���ĵ����� 
#define MAX_PLATE_NUM                     64               // ÿ��ͼƬ�а���������Ƹ���
#define MAX_PREVIEW_CHANNEL_NUM           64               // ��󵼲�Ԥ����ͨ������ 
#define MAX_EVENT_RESTORE_UUID            36               // �¼��ش�uuid�����С
#define MAX_EVENT_RESTORE_CODE_NUM        8                // ����¼��ش����͸���
#define MAX_EVENT_RESOTER_CODE_TYPE       32               // �¼��ش����������С
#define MAX_SNAP_TYPE                     3                // ץͼ��������
#define MAX_MAINFORMAT_NUM                4                // ���֧����������������
#define CUSTOM_TITLE_LEN                  1024             // �Զ���������Ƴ���(���䵽1024)
#define MAX_CUSTOM_TITLE_NUM              8                // ��������Զ�������������
#define FORMAT_TYPE_LEN                   16               // ������������󳤶�
#define MAX_CHANNEL_NAME_LEN              256              // ͨ��������󳤶�
#define MAX_VIRTUALINFO_DOMAIN_LEN        64               // �������������������
#define MAX_VIRTUALINFO_TITLE_LEN         64               // ��������������ⳤ��
#define MAX_VIRTUALINFO_USERNAME_LEN      32               // ��������û�������
#define MAX_VIRTUALINFO_PASSWORD_LEN      32               // ����������볤��
#define MAX_VIRTUALINFO_PHONENUM_LEN      12               // ��������ֻ��ų���
#define MAX_VIRTUALINFO_IMEI_LEN          16               // ������ݹ����ƶ��豸��ʶ����
#define MAX_VIRTUALINFO_IMSI_LEN          16               // ������ݹ����ƶ��û�ʶ���볤��
#define MAX_VIRTUALINFO_LATITUDE_LEN      16               // ������ݾ��ȳ���
#define MAX_VIRTUALINFO_LONGITUDE_LEN     16               // �������γ�ȳ���
#define MAX_VIRTUALINFO_NUM               1024             // ������������Ϣ����
#define MAX_CALL_ID_LEN                   64               // ���ID����
#define MAX_FACE_DATA_LEN                 2048             // ����ģ��������󳤶�
#define MAX_FACE_DATA_NUM                 20               // ����ģ��������
#define MAX_FINGERPRINT_NUM               10               // ���ָ�Ƹ���
#define MAX_RINGFILE_NUM                  64               // ���������Ƶ�ļ�����
#define MAX_VIDEOIN_CONFLICT_NUM          128              // ��Ƶ���������ͻ��������
#define MAX_COURSE_LOGIC_CHANNEL          64               // ¼����������߼�ͨ����
#define MAX_COMMON_STRING_8               8                // ͨ���ַ�������8
#define MAX_COMMON_STRING_16              16               // ͨ���ַ�������16
#define MAX_COMMON_STRING_32              32               // ͨ���ַ�������32
#define MAX_COMMON_STRING_64              64               // ͨ���ַ�������64
#define MAX_MAN_LIST_COUNT                64               // ��Ա�б��������
#define MAX_COMMON_STRING_128             128              // ͨ���ַ�������128
#define MAX_STREAM_NUM                    4                // �����������
#define MAX_CELL_PHONE_NUMBER_LEN         32               // ����ֻ��ų���
#define MAX_MAIL_LEN                      64               // ������󳤶�
#define MAX_USER_NAME_LEN                 128              // ����û�������
#define MAX_PWD_LEN                       128              // ������볤��
#define MAX_SECURITY_CODE_LEN             16               // ƽ̨���͵�Ԥ���ֻ�/�����а�ȫ����󳤶�    
#define MAX_PWD_SPEC_CHARS_ARRAY_LEN      128              // ����淶�����������ַ��б���󳤶�
#define MAX_PWD_BASIC_CHARS_ARRAY_LEN     128              // ����淶��֧�ֵĻ����ַ������б���󳤶�        
#define MAX_COMMON_STRING_512             512              // ͨ���ַ�������512
#define MAX_RFIDELETAG_CARDID_LEN         16               // RFID ���ӳ��Ʊ�ǩ��Ϣ�п�����󳤶�
#define MAX_RFIDELETAG_DATE_LEN           16               // RFID ���ӳ��Ʊ�ǩ��Ϣ��ʱ����󳤶�
#define MAX_LINK_NAME_LEN                 16               // �������Ƴ���
#define MAX_SERVER_ADDRESS_LEN            64               // ������IP����
#define LINK_LAYER_VPN_NUM                64               // ��·��VPN���ø���
#define MAX_SERVER_IP_LEN                 32               // ������IP���� 
#define MAX_SCENICSPOT_POINTS_NUM         256              // �ܹ��ж��ٸ��������Ϣ
#define MAX_ACCESSSUBCONTROLLER_NUM       64               // ����Ž��ֿ�������
#define MAX_ACCESSDOOR_NUM                128              // ���������                 
#define MAX_ACCESS_READER_NUM             32               // �Ž�������������������
#define MAX_ACCESS_POINT_NUM              32               // ��Ǳ·�����ڵ����
#define MAX_CONFIG_NAME_LEN               128              // ����������Ƴ���
#define MAX_PLATE_NUMBER_LEN              64               // ����ƺ��볤��
#define MAX_MASTER_OF_CAR_LEN             32               // �������������
#define MAX_USER_TYPE_LEN                 32               // ����û����ͳ���
#define MAX_SUB_USER_TYPE_LEN			  64			   // ����û������ͳ���
#define MAX_REMARKS_LEN					  64			   // ���ע��Ϣ����
#define MAX_PARK_CHARGE_LEN               32               // ���ͣ���ѳ���
#define MAX_IN_TIME_LEN                   32               // ������볡ʱ�䳤��
#define MAX_OUT_TIME_LEN                  32               // ���������ʱ�䳤��
#define MAX_CUSTOM_LEN                    128              // ����Զ�����ʾ����
#define MAX_DEAL_NUM_LEN                  32               // ���СƱ���׺ų���
#define MAX_STORE_NO_LEN                  32               // ����ų���
#define MAX_STORE_NAME_LEN                32               // ����������
#define MAX_STORE_EMPLOYEE_ID_LEN         32               // �������Ա���ų���
#define MAX_PRODUCT_NO_LEN                32               // �����Ʒ���볤��
#define MAX_PRODUCT_NAME_LEN              32               // �����Ʒ���Ƴ���
#define MAX_PRODUCT_CATEGORY_LEN          32               // �����Ʒ��𳤶�
#define DH_MAX_FINGER_PRINT               10               // ָ��ID������󳤶�
#define MAX_SUBCHANNEL_NUM                16               // ��Ƶ��ͨ��(�ɼ���)������
#define MAX_NAME_LENGTH                   32               // �����������
#define MAX_SNAP_URL_LEN                  128              // ���ץͼ��ַ����
#define MAX_CODE_LEN                      64               // �����Ʒ��ų���
#define MAX_PERSON_INFO_NUM               4                // ���������Ϣ����
#define MAX_GOOD_INFO_NUM                 128              // �����Ʒ��Ϣ����
#define MAX_SUB_TAG_NUM                   20               // �ӱ�ǩ������
#define MAX_MANUFACTURER_LEN              32               // ����Mac��ַ���������̳���
#define MAX_MACHISTORY_SSID_LEN           24               // ������ʷSSID����
#define MAX_MACHISTORY_SSID_NUM	          5	               // ��ʷSSID��������
#define MAX_ROUTE_NUM                     16               // ���·������
#define MAX_MCU_NUM                       10               // ��󱨾�������Ƭ������

// ��ѯ����,��ӦCLIENT_QueryDevState�ӿ�
#define DH_DEVSTATE_COMM_ALARM            0x0001           // ��ѯ��ͨ����״̬(�����ⲿ����,��Ƶ��ʧ,��̬���)
#define DH_DEVSTATE_SHELTER_ALARM         0x0002           // ��ѯ�ڵ�����״̬
#define DH_DEVSTATE_RECORDING             0x0003           // ��ѯ¼��״̬
#define DH_DEVSTATE_DISK                  0x0004           // ��ѯӲ����Ϣ
#define DH_DEVSTATE_RESOURCE              0x0005           // ��ѯϵͳ��Դ״̬
#define DH_DEVSTATE_BITRATE               0x0006           // ��ѯͨ������
#define DH_DEVSTATE_CONN                  0x0007           // ��ѯ�豸����״̬
#define DH_DEVSTATE_PROTOCAL_VER          0x0008           // ��ѯ����Э��汾��,pBuf = int*
#define DH_DEVSTATE_TALK_ECTYPE           0x0009           // ��ѯ�豸֧�ֵ�����Խ���ʽ�б�,���ṹ��DHDEV_TALKFORMAT_LIST
#define DH_DEVSTATE_SD_CARD               0x000A           // ��ѯSD����Ϣ(IPC���Ʒ)
#define DH_DEVSTATE_BURNING_DEV           0x000B           // ��ѯ��¼����Ϣ
#define DH_DEVSTATE_BURNING_PROGRESS      0x000C           // ��ѯ��¼����
#define DH_DEVSTATE_PLATFORM              0x000D           // ��ѯ�豸֧�ֵĽ���ƽ̨
#define DH_DEVSTATE_CAMERA                0x000E           // ��ѯ����ͷ������Ϣ(IPC���Ʒ),pBuf = DHDEV_CAMERA_INFO *,�����ж���ṹ��
#define DH_DEVSTATE_SOFTWARE              0x000F           // ��ѯ�豸����汾��Ϣ
#define DH_DEVSTATE_LANGUAGE              0x0010           // ��ѯ�豸֧�ֵ���������
#define DH_DEVSTATE_DSP                   0x0011           // ��ѯDSP��������(��Ӧ�ṹ��DHDEV_DSP_ENCODECAP)
#define DH_DEVSTATE_OEM                   0x0012           // ��ѯOEM��Ϣ
#define DH_DEVSTATE_NET                   0x0013           // ��ѯ��������״̬��Ϣ
#define DH_DEVSTATE_TYPE                  0x0014           // ��ѯ�豸����
#define DH_DEVSTATE_SNAP                  0x0015           // ��ѯ��������(IPC���Ʒ)
#define DH_DEVSTATE_RECORD_TIME           0x0016           // ��ѯ����¼��ʱ������¼��ʱ��
#define DH_DEVSTATE_NET_RSSI              0x0017           // ��ѯ���������ź�ǿ��,���ṹ��DHDEV_WIRELESS_RSS_INFO
#define DH_DEVSTATE_BURNING_ATTACH        0x0018           // ��ѯ������¼ѡ��
#define DH_DEVSTATE_BACKUP_DEV            0x0019           // ��ѯ�����豸�б�
#define DH_DEVSTATE_BACKUP_DEV_INFO       0x001a           // ��ѯ�����豸��ϸ��Ϣ
#define DH_DEVSTATE_BACKUP_FEEDBACK       0x001b           // ���ݽ��ȷ���
#define DH_DEVSTATE_ATM_QUERY_TRADE       0x001c           // ��ѯATM��������
#define DH_DEVSTATE_SIP                   0x001d           // ��ѯsip״̬
#define DH_DEVSTATE_VICHILE_STATE         0x001e           // ��ѯ����wifi״̬
#define DH_DEVSTATE_TEST_EMAIL            0x001f           // ��ѯ�ʼ������Ƿ�ɹ�
#define DH_DEVSTATE_SMART_HARD_DISK       0x0020           // ��ѯӲ��smart��Ϣ
#define DH_DEVSTATE_TEST_SNAPPICTURE      0x0021           // ��ѯץͼ�����Ƿ�ɹ�
#define DH_DEVSTATE_STATIC_ALARM          0x0022           // ��ѯ��̬����״̬
#define DH_DEVSTATE_SUBMODULE_INFO        0x0023           // ��ѯ�豸��ģ����Ϣ
#define DH_DEVSTATE_DISKDAMAGE            0x0024           // ��ѯӲ�̻������� 
#define DH_DEVSTATE_IPC                   0x0025           // ��ѯ�豸֧�ֵ�IPC����, ���ṹ��DH_DEV_IPC_INFO
#define DH_DEVSTATE_ALARM_ARM_DISARM      0x0026           // ��ѯ����������״̬
#define DH_DEVSTATE_ACC_POWEROFF_ALARM    0x0027           // ��ѯACC�ϵ籨��״̬(����һ��DWORD, 1��ʾ�ϵ�,0��ʾͨ��)
#define DH_DEVSTATE_TEST_FTP_SERVER       0x0028           // ����FTP����������
#define DH_DEVSTATE_3GFLOW_EXCEED         0x0029           // ��ѯ3G����������ֵ״̬,(���ṹ��DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_DEVSTATE_3GFLOW_INFO           0x002a           // ��ѯ3G����������Ϣ,���ṹ��DH_DEV_3GFLOW_INFO
#define DH_DEVSTATE_VIHICLE_INFO_UPLOAD   0x002b           // �����Զ�����Ϣ�ϴ�(���ṹ��ALARM_VEHICLE_INFO_UPLOAD)
#define DH_DEVSTATE_SPEED_LIMIT           0x002c           // ��ѯ���ٱ���״̬(���ṹ��ALARM_SPEED_LIMIT)
#define DH_DEVSTATE_DSP_EX                0x002d           // ��ѯDSP��չ��������(��Ӧ�ṹ��DHDEV_DSP_ENCODECAP_EX)
#define DH_DEVSTATE_3GMODULE_INFO         0x002e           // ��ѯ3Gģ����Ϣ(��Ӧ�ṹ��DH_DEV_3GMODULE_INFO)
#define DH_DEVSTATE_MULTI_DDNS            0x002f           // ��ѯ��DDNS״̬��Ϣ(��Ӧ�ṹ��DH_DEV_MULTI_DDNS_INFO)
#define DH_DEVSTATE_CONFIG_URL            0x0030           // ��ѯ�豸����URL��Ϣ(��Ӧ�ṹ��DH_DEV_URL_INFO)
#define DH_DEVSTATE_HARDKEY               0x0031           // ��ѯHardKey״̬����Ӧ�ṹ��DHDEV_HARDKEY_STATE)
#define DH_DEVSTATE_ISCSI_PATH            0x0032           // ��ѯISCSI·���б�(��Ӧ�ṹ��DHDEV_ISCSI_PATHLIST)
#define DH_DEVSTATE_DLPREVIEW_SLIPT_CAP   0x0033           // ��ѯ�豸����Ԥ��֧�ֵķָ�ģʽ(��Ӧ�ṹ��DEVICE_LOCALPREVIEW_SLIPT_CAP)
#define DH_DEVSTATE_WIFI_ROUTE_CAP        0x0034           // ��ѯ����·��������Ϣ(��Ӧ�ṹ��DHDEV_WIFI_ROUTE_CAP)
#define DH_DEVSTATE_ONLINE                0x0035           // ��ѯ�豸������״̬(����һ��DWORD, 1��ʾ����, 0��ʾ����)
#define DH_DEVSTATE_PTZ_LOCATION          0x0036           // ��ѯ��̨״̬��Ϣ(��Ӧ�ṹ�� DH_PTZ_LOCATION_INFO)
#define DH_DEVSTATE_MONITOR_INFO          0x0037           // �����ظ�����Ϣ(��Ӧ�ṹ��DHDEV_MONITOR_INFO)
#define DH_DEVSTATE_SUBDEVICE             0x0300           // ��ѯ���豸(��Դ, ���ȵ�)״̬(��Ӧ�ṹ��CFG_DEVICESTATUS_INFO)
#define DH_DEVSTATE_RAID_INFO             0x0038           // ��ѯRAID״̬(��Ӧ�ṹ��ALARM_RAID_INFO)  
#define DH_DEVSTATE_TEST_DDNSDOMAIN       0x0039           // ����DDNS�����Ƿ����
#define DH_DEVSTATE_VIRTUALCAMERA         0x003a           // ��ѯ��������ͷ״̬(��Ӧ DHDEV_VIRTUALCAMERA_STATE_INFO)
#define DH_DEVSTATE_TRAFFICWORKSTATE      0x003b           // ��ȡ�豸������Ƶ/��Ȧģʽ״̬��(��ӦDHDEV_TRAFFICWORKSTATE_INFO)
#define DH_DEVSTATE_ALARM_CAMERA_MOVE     0x003c           // ��ȡ�������λ�����¼�״̬(��ӦALARM_CAMERA_MOVE_INFO)
#define DH_DEVSTATE_ALARM                 0x003e           // ��ȡ�ⲿ����״̬(��Ӧ NET_CLIENT_ALARM_STATE) 
#define DH_DEVSTATE_VIDEOLOST             0x003f           // ��ȡ��Ƶ��ʧ����״̬(��Ӧ NET_CLIENT_VIDEOLOST_STATE) 
#define DH_DEVSTATE_MOTIONDETECT          0x0040           // ��ȡ��̬��ⱨ��״̬(��Ӧ NET_CLIENT_MOTIONDETECT_STATE)
#define DH_DEVSTATE_DETAILEDMOTION        0x0041           // ��ȡ��ϸ�Ķ�̬��ⱨ��״̬(��Ӧ NET_CLIENT_DETAILEDMOTION_STATE)
#define DH_DEVSTATE_VEHICLE_INFO          0x0042           // ��ȡ�����������Ӳ����Ϣ(��Ӧ DHDEV_VEHICLE_INFO)
#define DH_DEVSTATE_VIDEOBLIND            0x0043           // ��ȡ��Ƶ�ڵ�����״̬(��Ӧ NET_CLIENT_VIDEOBLIND_STATE)
#define DH_DEVSTATE_3GSTATE_INFO          0x0044           // ��ѯ3Gģ�������Ϣ(��Ӧ�ṹ��DHDEV_VEHICLE_3GMODULE)
#define DH_DEVSTATE_NETINTERFACE          0x0045           // ��ѯ����ӿ���Ϣ(��Ӧ DHDEV_NETINTERFACE_INFO)
#define DH_DEVSTATE_PICINPIC_CHN          0x0046           // ��ѯ���л�ͨ����(��ӦDWORD����)
#define DH_DEVSTATE_COMPOSITE_CHN         0x0047           // ��ѯ�ں���ͨ����Ϣ(��ӦDH_COMPOSITE_CHANNEL����)
#define DH_DEVSTATE_WHOLE_RECORDING       0x0048           // ��ѯ�豸����¼��״̬(��ӦBOOL), ֻҪ��һ��ͨ����¼��,��Ϊ�豸����״̬Ϊ¼��
#define DH_DEVSTATE_WHOLE_ENCODING        0x0049           // ��ѯ�豸�������״̬(��ӦBOOL), ֻҪ��һ��ͨ���ڱ���,��Ϊ�豸����״̬Ϊ����
#define DH_DEVSTATE_DISK_RECORDE_TIME     0x004a           // ��ѯ�豸Ӳ��¼��ʱ����Ϣ(pBuf = DEV_DISK_RECORD_TIME*,�����ж���ṹ��)
#define DH_DEVSTATE_BURNER_DOOR           0x004b           // �Ƿ��ѵ�����¼��������(��Ӧ�ṹ�� NET_DEVSTATE_BURNERDOOR)
#define DH_DEVSTATE_GET_DATA_CHECK        0x004c           // ��ѯ��������У�����(��Ӧ NET_DEVSTATE_DATA_CHECK)
#define DH_DEVSTATE_ALARM_IN_CHANNEL      0x004f           // ��ѯ��������ͨ����Ϣ(��ӦNET_ALARM_IN_CHANNEL����)
#define DH_DEVSTATE_ALARM_CHN_COUNT       0x0050           // ��ѯ����ͨ����(��ӦNET_ALARM_CHANNEL_COUNT)
#define DH_DEVSTATE_PTZ_VIEW_RANGE        0x0051           // ��ѯ��̨������״̬(��Ӧ DH_OUT_PTZ_VIEW_RANGE_STATUS    )
#define DH_DEVSTATE_DEV_CHN_COUNT         0x0052           // ��ѯ�豸ͨ����Ϣ(��ӦNET_DEV_CHN_COUNT_INFO)
#define DH_DEVSTATE_RTSP_URL              0x0053           // ��ѯ�豸֧�ֵ�RTSP URL�б�,���ṹ��DEV_RTSPURL_LIST
#define DH_DEVSTATE_LIMIT_LOGIN_TIME      0x0054           // ��ѯ�豸��¼�����߳�ʱʱ��,����һ��BTYE,����λ�����ӣ� ,0��ʾ������,������������ʾ���Ƶķ�����
#define DH_DEVSTATE_GET_COMM_COUNT        0x0055           // ��ȡ������ ���ṹ��NET_GET_COMM_COUNT
#define DH_DEVSTATE_RECORDING_DETAIL      0x0056           // ��ѯ¼��״̬��ϸ��Ϣ(pBuf = NET_RECORD_STATE_DETAIL*)
#define DH_DEVSTATE_PTZ_PRESET_LIST       0x0057           // ��ȡ��ǰ��̨��Ԥ�õ��б�(��Ӧ�ṹNET_PTZ_PRESET_LIST)
#define DH_DEVSTATE_EXTERNAL_DEVICE       0x0058           // ����豸��Ϣ(pBuf = NET_EXTERNAL_DEVICE*)
#define DH_DEVSTATE_GET_UPGRADE_STATE     0x0059           // ��ȡ�豸����״̬(��Ӧ�ṹDHDEV_UPGRADE_STATE_INFO)
#define DH_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP 0x005a         // ��ȡ��ͨ��Ԥ���ָ�����( ��Ӧ�ṹ�� NET_MULTIPLAYBACK_SPLIT_CAP )
#define DH_DEVSTATE_BURN_SESSION_NUM      0x005b           // ��ȡ��¼�Ự����(pBuf = int*)
#define DH_DEVSTATE_PROTECTIVE_CAPSULE    0X005c           // ��ѯ������״̬(��Ӧ�ṹ��ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_DEVSTATE_GET_DOORWORK_MODE     0X005d           // ��ȡ��������ģʽ( ��Ӧ NET_GET_DOORWORK_MODE)
#define DH_DEVSTATE_PTZ_ZOOM_INFO         0x005e           // ��ѯ��̨��ȡ��ѧ�䱶��Ϣ(��Ӧ DH_OUT_PTZ_ZOOM_INFO )
#define DH_DEVSTATE_POWER_STATE           0x0152           // ��ѯ��Դ״̬(��Ӧ�ṹ��DH_POWER_STATUS)
#define DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE  0x153        // ��ѯ����ͨ��״̬(��Ӧ�ṹ�� NET_CLIENT_ALARM_CHANNELS_STATE)
#define DH_DEVSTATE_ALARMKEYBOARD_COUNT   0x0154           // ��ѯ���������ӵı���������(��Ӧ�ṹ��NET_ALARMKEYBOARD_COUNT)
#define DH_DEVSTATE_EXALARMCHANNELS       0x0155           // ��ѯ��չ����ģ��ͨ��ӳ���ϵ(��Ӧ�ṹ�� NET_EXALARMCHANNELS)
#define DH_DEVSTATE_GET_BYPASS            0x0156           // ��ѯͨ����·״̬(��Ӧ�ṹ�� NET_DEVSTATE_GET_BYPASS)
#define DH_DEVSTATE_ACTIVATEDDEFENCEAREA  0x0157           // ��ȡ����ķ�����Ϣ(��Ӧ�ṹ�� NET_ACTIVATEDDEFENCEAREA)
#define DH_DEVSTATE_DEV_RECORDSET         0x0158           // ��ѯ�豸��¼����Ϣ(��Ӧ NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_DOOR_STATE            0x0159           // ��ѯ�Ž�״̬(��ӦNET_DOOR_STATUS_INFO)
#define DH_DEVSTATE_ANALOGALARM_CHANNELS  0x1560           // ģ������������ͨ��ӳ���ϵ(��ӦNET_ANALOGALARM_CHANNELS)
#define DH_DEVSTATE_GET_SENSORLIST        0x1561           // ��ȡ�豸֧�ֵĴ������б�(��Ӧ NET_SENSOR_LIST)
#define DH_DEVSTATE_ALARM_CHANNELS        0x1562           // ��ѯ����������ģ��ͨ��ӳ���ϵ(��Ӧ�ṹ�� NET_ALARM_CHANNELS)
                                                           // ����豸��֧�ֲ�ѯ��չ����ģ��ͨ��,�����øù��ܲ�ѯ��չͨ�����߼�ͨ����,���������ر���ͨ��ʹ��
#define DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS  0x1563  // ��ȡ��ǰ��ϵͳ����״̬( ��Ӧ NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
#define DH_DEVSTATE_AIRCONDITION_STATE    0x1564           // ��ȡ�յ�����״̬(��Ӧ NET_GET_AIRCONDITION_STATE)
#define DH_DEVSTATE_ALARMSUBSYSTEM_STATE  0x1565           // ��ȡ��ϵͳ״̬(��ӦNET_ALARM_SUBSYSTEM_STATE)
#define DH_DEVSTATE_ALARM_FAULT_STATE     0x1566           // ��ȡ����״̬(��Ӧ NET_ALARM_FAULT_STATE_INFO)
#define DH_DEVSTATE_DEFENCE_STATE         0x1567           // ��ȡ����״̬(��Ӧ NET_DEFENCE_STATE_INFO, ����·״̬�仯�¼������ر����¼��������ź�Դ�¼���״̬����������,���ܻ���,�������豸ʹ��)
#define DH_DEVSTATE_CLUSTER_STATE         0x1568           // ��ȡ��Ⱥ״̬(��Ӧ NET_CLUSTER_STATE_INFO)
#define DH_DEVSTATE_SCADA_POINT_LIST      0x1569           // ��ȡ��λ��·����Ϣ(��Ӧ NET_SCADA_POINT_LIST_INFO)
#define DH_DEVSTATE_SCADA_INFO            0x156a           // ��ȡ����λ��Ϣ(��Ӧ NET_SCADA_INFO)
#define DH_DEVSTATE_SCADA_CAPS            0X156b           // ��ȡSCADA������(��Ӧ NET_SCADA_CAPS)
#define DH_DEVSTATE_GET_CODEID_COUNT      0x156c           // ��ȡ����ɹ���������(��Ӧ NET_GET_CODEID_COUNT)
#define DH_DEVSTATE_GET_CODEID_LIST       0x156d           // ��ѯ������Ϣ(��Ӧ NET_GET_CODEID_LIST)
#define DH_DEVSTATE_ANALOGALARM_DATA      0x156e           // ��ѯģ����ͨ������(��Ӧ NET_GET_ANALOGALARM_DATA)
#define DH_DEVSTATE_VTP_CALLSTATE         0x156f           // ��ȡ��Ƶ�绰���״̬(��Ӧ NET_GET_VTP_CALLSTATE)
#define DH_DEVSTATE_SCADA_INFO_BY_ID      0x1570           // ͨ���豸����ȡ����λ��Ϣ(��Ӧ NET_SCADA_INFO_BY_ID)
#define DH_DEVSTATE_SCADA_DEVICE_LIST     0x1571           // ��ȡ��ǰ������������ⲿ�豸ID(��Ӧ NET_SCADA_DEVICE_LIST)
#define DH_DEVSTATE_DEV_RECORDSET_EX      0x1572           // ��ѯ�豸��¼����Ϣ(������������)(��ӦNET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_ACCESS_LOCK_VER       0x1573           // ��ȡ��������汾��(��Ӧ NET_ACCESS_LOCK_VER)
#define DH_DEVSTATE_MONITORWALL_TVINFO    0x1574           // ��ȡ����ǽ��ʾ��Ϣ(��Ӧ NET_CTRL_MONITORWALL_TVINFO)
#define DH_DEVSTATE_GET_ALL_POS           0x1575           // ��ȡ�����û�����Pos�豸������Ϣ(��Ӧ NET_POS_ALL_INFO)
#define DH_DEVSTATE_GET_ROAD_LIST         0x1576           // ��ȡ���м�·�α�����Ϣ,���ױ�����Ŀר��(��Ӧ NET_ROAD_LIST_INFO)
#define DH_DEVSTATE_GET_HEAT_MAP          0x1577           // ��ȡ�ȶ�ͳ����Ϣ(��Ӧ NET_QUERY_HEAT_MAP)
#define DH_DEVSTATE_GET_WORK_STATE        0x1578           // ��ȡ���ӹ���״̬��Ϣ(��Ӧ NET_QUERY_WORK_STATE)
#define DH_DEVSTATE_GET_WIRESSLESS_STATE  0x1579           // ��ȡ�����豸״̬��Ϣ(��Ӧ NET_GET_WIRELESS_DEVICE_STATE)
#define DH_DEVSTATE_GET_REDUNDANCE_POWER_INFO  0x157a      // ��ȡ�����Դ��Ϣ(��Ӧ NET_GET_REDUNDANCE_POWER_INFO)

//////////////////////////////////////////////////////////////////////////
// �������ýṹ�� dwSize ��Ա�ĺ�
#define _setdwSize(stu) ((stu).dwSize = sizeof(stu))

//////////////////////////////////////////////////////////////////////////

#define CFG_MAX_ACCESSCONTROL_NUM				8							// ����Ž������������
#define CFG_MAX_SUMMARY_LEN						1024						// ���ӵ�JPEGͼƬ��ժҪ��Ϣ��󳤶�
#define CFG_MAX_DBKEY_NUM						64							// ���ݿ�ؼ������ֵ
#define CFG_MAX_CHANNELNAME_LEN					64							// ���ͨ�����Ƴ���
#define CFG_MAX_VIDEO_CHANNEL_NUM				256							// ���ͨ����256
#define CFG_MAX_CHANNEL_COUNT					16
#define CFG_MAX_PSTN_SERVER_NUM                 8							// ��󱨾��绰��������

//��̬��������
typedef enum tagNET_THREE_STATUS_BOOL
{
    BOOL_STATUS_FALSE  = 0 , 
    BOOL_STATUS_TRUE       ,
    BOOL_STATUS_UNKNOWN    ,  //δ֪
}NET_THREE_STATUS_BOOL;

//////////////////////////////////////////////////////////////////////////

// �յ�����ģʽ
typedef enum __EM_AIRCONDITION_MODE
{
    AIRCONDITION_MODE_UNKNOWN = 0,
    AIRCONDITION_MODE_AUTO,             // �Զ�
    AIRCONDITION_MODE_HOT,              // ����
    AIRCONDITION_MODE_COLD,             // ����
    AIRCONDITION_MODE_WET,              // ��ʪ
    AIRCONDITION_MODE_WIND,             // ͨ��
} EM_AIRCONDITION_MODE;

// �յ��ͷ�ģʽ
typedef enum __EM_AIRCONDITION_WINDMODE
{
    AIRCONDITION_WINDMODE_UNKNOWN = 0,
    AIRCONDITION_WINDMODE_STOP,          // ֹͣ
    AIRCONDITION_WINDMODE_AUTO,          // �Զ�
    AIRCONDITION_WINDMODE_HIGH,          // ����
    AIRCONDITION_WINDMODE_MIDDLE,        // ����
    AIRCONDITION_WINDMODE_LOW,           // ����
} EM_AIRCONDITION_WINDMODE;

// �յ�����״̬��Ϣ������
typedef struct tagNET_AIRCONDITION_STATE_INFO
{
    DWORD                       dwSize;
    BOOL                        bIsOnline;                    // �Ƿ�����
    BOOL                        bIsON;                        // �Ƿ���
    int                         nTemperature;                 // �յ��趨�¶�
    EM_AIRCONDITION_MODE        emAirconditionMode;           // �յ�����ģʽ
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;       // �յ��ͷ�ģʽ
    float                       fActualTemperature;           // ����ʵ���¶�
}NET_AIRCONDITION_STATE_INFO;

// ��ȡ�յ�����״̬(��ӦDH_DEVSTATE_AIRCONDITION_STATE����)
typedef struct tagNET_GET_AIRCONDITION_STATE
{
    DWORD                       dwSize;
    char                        szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
    NET_AIRCONDITION_STATE_INFO stuAirConditionState;           // �յ�����״̬��Ϣ
}NET_GET_AIRCONDITION_STATE;

// ����������ͨ����Ϣ
typedef struct tagNET_ALARM_CHANNEL_INFO 
{
    DWORD                       dwSize;
    int                         nSlot;                          // ����ַ, 0��ʾ����ͨ��, 1��ʾ�����ڵ�һ�������ϵ���չͨ��, 2��3...�Դ�����
    int                         nChannel;                       // �Ǳ��ر���ͨ������չģ���ϵ�ͨ����, ��0��ʼ
    char                        szName[DH_COMMON_STRING_128];   // ͨ������
}NET_ALARM_CHANNEL_INFO;

// ����(��Զ��)����������ͨ�����߼�ͨ����ӳ���ϵ
typedef struct tagNET_ALARM_CHANNELS 
{
    DWORD                       dwSize;
    int                         nMaxAlarmChannels;              // ���ͨ����
    int                         nRetAlarmChannels;              // ���ص�ͨ����
    NET_ALARM_CHANNEL_INFO*     pstuChannelInfo;                // ͨ����Ϣ,�û������ڴ�
}NET_ALARM_CHANNELS;

// ������ϵͳ״̬����
typedef enum __EM_ALARM_SUBSYSTEM_STATE_TYPE
{
    ALARM_SUBSYSTEM_STATE_UNKNOWN = 0,
    ALARM_SUBSYSTEM_STATE_ACTIVE,               // �Ѽ���
    ALARM_SUBSYSTEM_STATE_INACTIVE,             // δ����
    ALARM_SUBSYSTEM_STATE_UNDISTRIBUTED,        // δ����
}EM_ALARM_SUBSYSTEM_STATE_TYPE;

// ������ϵͳ״̬, CLIENT_QueryDevState��Ӧ����DH_DEVSTATE_ALARMSUBSYSTEM_STATE
typedef struct tagNET_ALARM_SUBSYSTEM_STATE
{
    DWORD          dwSize;
    int            nMaxAlarmSubSystem;                                  // ��Ч��ϵͳ����
    EM_ALARM_SUBSYSTEM_STATE_TYPE  emState[DH_MAX_ALARM_SUBSYSTEM_NUM]; // ��ϵͳ״̬��Ϣ
}NET_ALARM_SUBSYSTEM_STATE;


// ��������
typedef enum __EM_ALARM_FAULT_STATE_TYPE
{
    EM_ALARM_FAULT_STATE_ALL = 0,                // ��������
    EM_ALARM_FAULT_STATE_CONNECTFAULT,           // ���ӹ���
    EM_ALARM_FAULT_STATE_BELLFAULT,              // ���Ź���
    EM_ALARM_FAULT_STATE_KBFAULT,                // ���̹���
    EM_ALARM_FAULT_STATE_KBTAMPER,               // ���̷���
    EM_ALARM_FAULT_STATE_SENSORSHORTOUT,         // ��������·
    EM_ALARM_FAULT_STATE_SENSORTAMPER,           // ����������
}EM_ALARM_FAULT_STATE_TYPE;

// ��������״̬, �������
typedef struct tagNET_IN_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    EM_ALARM_FAULT_STATE_TYPE   emType;           // ����ѯ������
}NET_IN_ALARM_FAULT_STATE;

// ��������״̬, �������
typedef struct tagNET_OUT_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    int             nConnectFaultState;                     // 0: δ֪, 1: ����, 2:����
    int             nBell;                                  // ������Ч���� 
    int             anBellState[DH_MAX_BELL_NUM];           // ���Ź���״̬��Ϣ 0: δ֪, 1: ����, 2:����
    int             nFaultKeyboard;                         // ���̹�����Ч����
    int             anFaultKeyboard[DH_MAX_KEYBOARD_NUM];   // ���̹�����Ϣ 0: δ֪, 1: ����, 2:����
    int             nTamperKeyboard;                        // ������Ч������� 
    int             anTamperKeyboard[DH_MAX_KEYBOARD_NUM];  // ���̷�����Ϣ 0: δ֪, 1: ����, 2:����
    int             nShortOutSensor;                        // ��������Ч��·����
    int             anShortOutSensor[DH_MAX_ALARMIN];       // ��������·��Ϣ 0: δ֪, 1: ����, 2:����
    int             nTamperSensor;                          // ��������Ч�������
    int             anTamperSensor[DH_MAX_ALARMIN];         // ������������Ϣ 0: δ֪, 1: ����, 2:����
}NET_OUT_ALARM_FAULT_STATE;

// ��������״̬, CLIENT_QueryDevState��Ӧ����DH_DEVSTATE_ALARM_FAULT_STATE
typedef struct tagNET_ALARM_FAULT_STATE_INFO
{
    DWORD           dwSize;
    NET_IN_ALARM_FAULT_STATE    stuIn;           // �������
    NET_OUT_ALARM_FAULT_STATE   stuOut;          // �������
}NET_ALARM_FAULT_STATE_INFO;

// ����״̬����
typedef enum __EM_DEFENCE_STATE_TYPE
{
    EM_DEFENCE_STATE_UNKNOWN = 0,
    EM_DEFENCE_STATE_BYPASS,                     // ��·
    EM_DEFENCE_STATE_OPEN,                       // ��, ָ��������·�������
    EM_DEFENCE_STATE_CLOSE,                      // �ر�
    EM_DEFENCE_STATE_ALARMING,                   // ����, ָ��������·�������
}EM_DEFENCE_STATE_TYPE;

// ����״̬��Ϣ���������
typedef struct tagNET_IN_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    int             nDefenceNum;                 // ������Ч����, -1��ʾ��ѯ���з���
    int             anDefence[DH_MAX_ALARMIN];   // ����ѯ�ķ�����
}NET_IN_DEFENCE_STATE_INFO;

// ����״̬��Ϣ���������
typedef struct tagNET_OUT_DEFENCE_STATE_INFO
{
    DWORD           dwSize;
    int             nDefenceNum;                            // ������Ч����
    EM_DEFENCE_STATE_TYPE  anDefenceState[DH_MAX_ALARMIN];  // ����״̬��Ϣ
}NET_OUT_DEFENCE_STATE_INFO;

// ����״̬��Ϣ, CLIENT_QueryDevState��Ӧ����DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    NET_IN_DEFENCE_STATE_INFO   stuIn;                      // �������
    NET_OUT_DEFENCE_STATE_INFO  stuOut;                     // �������
}NET_DEFENCE_STATE_INFO;

// ��Ƶ�绰�������
typedef enum tagEM_NET_VTP_CALL_TYPE
{
    EM_NET_VTP_CALL_TYPE_SIP = 0,                           // SIP���
    EM_NET_VTP_CALL_TYPE_GSM,                               // GSM���
    EM_NET_VTP_CALL_TYPE_PRIVATE,                           // ˽��Э����
}EM_NET_VTP_CALL_TYPE;

// ��Ƶ�绰���״̬����
typedef enum tagEM_NET_VTP_CALL_STATE_TYPE
{
    EM_NET_VTP_CALL_STATE_UNKNOWN = 0,
    EM_NET_VTP_CALL_STATE_IDLE,                              // ��ʼ״̬
    EM_NET_VTP_CALL_STATE_CALLING,                           // ���к��״̬(�Է�δ��Ӧ)
    EM_NET_VTP_CALL_STATE_CALLED,                            // ���к��״̬
    EM_NET_VTP_CALL_STATE_RINGING,                           // ���л���״̬(�Է���Ӧ, ��û�н���)
    EM_NET_VTP_CALL_STATE_CONNECTING,                        // ͨ����״̬
    EM_NET_VTP_CALL_STATE_CONNECTING2,                       // ͨ����2״̬(ͨ��ý�������ͨ����״̬)
    EM_NET_VTP_CALL_STATE_DISCONNECT,                        // ͨ���Ҷ�״̬
}EM_NET_VTP_CALL_STATE_TYPE;

// ��ȡ��Ƶ�绰���״̬ (��Ӧ DH_DEVSTATE_VTP_CALLSTATE)
typedef struct tagNET_GET_VTP_CALLSTATE 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // ����ѯ�ĺ������, �������
    char                        szCallID[DH_COMMON_STRING_128]; // ����ѯ�ĶԽ�Ψһ��ʶ, �������
    const char*                 szTargetID;                     // ��ת�����豸ID, ΪNULL��ʾ��ת��, �������
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // ���״̬
}NET_GET_VTP_CALLSTATE;

// ��ѯ����,��ӦCLIENT_QueryRemotDevState�ӿ�
#define DH_DEVSTATE_ALARM_REMOTE          0x1000           // ��ȡԶ���豸�ⲿ����(��Ӧ ALARM_REMOTE_ALARM_INFO)
#define DH_DEVSTATE_ALARM_FRONTDISCONNECT 0x1001           // ��ȡǰ��IPC��������(��Ӧ�ṹ��ALARM_FRONTDISCONNET_INFO)

// ��������,��ӦCLIENT_GetDevConfig��CLIENT_SetDevConfig�ӿ�
#define DH_DEV_DEVICECFG                  0x0001           // �豸��������
#define DH_DEV_NETCFG                     0x0002           // ��������
#define DH_DEV_CHANNELCFG                 0x0003           // ͼ��ͨ������
#define DH_DEV_PREVIEWCFG                 0x0004           // Ԥ����������
#define DH_DEV_RECORDCFG                  0x0005           // ¼������
#define DH_DEV_COMMCFG                    0x0006           // ������������
#define DH_DEV_ALARMCFG                   0x0007           // ������������
#define DH_DEV_TIMECFG                    0x0008           // DVRʱ������
#define DH_DEV_TALKCFG                    0x0009           // �Խ���������
#define DH_DEV_AUTOMTCFG                  0x000A           // �Զ�ά������        
#define DH_DEV_VEDIO_MARTIX               0x000B           // ����������Ʋ�������    
#define DH_DEV_MULTI_DDNS                 0x000C           // ��ddns����������
#define DH_DEV_SNAP_CFG                   0x000D           // ץͼ�������
#define DH_DEV_WEB_URL_CFG                0x000E           // HTTP·������
#define DH_DEV_FTP_PROTO_CFG              0x000F           // FTP�ϴ�����
#define DH_DEV_INTERVIDEO_CFG             0x0010           // ƽ̨��������,��ʱchannel��������ƽ̨����,
                                                           // channel=4�� �������������أ�channel=10������������ά��channel=11������U��ͨ��channel=51������������
#define DH_DEV_VIDEO_COVER                0x0011           // �����ڵ�����
#define DH_DEV_TRANS_STRATEGY             0x0012           // �����������,��������\����������
#define DH_DEV_DOWNLOAD_STRATEGY          0x0013           // ¼�����ز�������,��������\��ͨ����
#define DH_DEV_WATERMAKE_CFG              0x0014           // ͼ��ˮӡ����
#define DH_DEV_WLAN_CFG                   0x0015           // ������������
#define DH_DEV_WLAN_DEVICE_CFG            0x0016           // ���������豸����
#define DH_DEV_REGISTER_CFG               0x0017           // ����ע���������
#define DH_DEV_CAMERA_CFG                 0x0018           // ����ͷ��������
#define DH_DEV_INFRARED_CFG               0x0019           // ���ⱨ������
#define DH_DEV_SNIFFER_CFG                0x001A           // Snifferץ������
#define DH_DEV_MAIL_CFG                   0x001B           // �ʼ�����
#define DH_DEV_DNS_CFG                    0x001C           // DNS����������
#define DH_DEV_NTP_CFG                    0x001D           // NTP����
#define DH_DEV_AUDIO_DETECT_CFG           0x001E           // ��Ƶ�������
#define DH_DEV_STORAGE_STATION_CFG        0x001F           // �洢λ������
#define DH_DEV_PTZ_OPT_CFG                0x0020           // ��̨��������(�Ѿ��ϳ�,��ʹ��CLIENT_GetPtzOptAttr��ȡ��̨��������)
#define DH_DEV_DST_CFG                    0x0021           // ����ʱ����
#define DH_DEV_ALARM_CENTER_CFG           0x0022           // ������������
#define DH_DEV_VIDEO_OSD_CFG              0x0023           // ��ƵOSD��������
#define DH_DEV_CDMAGPRS_CFG               0x0024           // CDMA\GPRS��������
#define DH_DEV_IPFILTER_CFG               0x0025           // IP��������
#define DH_DEV_TALK_ENCODE_CFG            0x0026           // ����Խ���������
#define DH_DEV_RECORD_PACKET_CFG          0X0027           // ¼������������
#define DH_DEV_MMS_CFG                    0X0028           // ����MMS���� 
#define DH_DEV_SMSACTIVATION_CFG          0X0029           // ���ż���������������
#define DH_DEV_DIALINACTIVATION_CFG       0X002A           // ���ż���������������
#define DH_DEV_SNIFFER_CFG_EX             0x0030           // ����ץ������
#define DH_DEV_DOWNLOAD_RATE_CFG          0x0031           // �����ٶ�����
#define DH_DEV_PANORAMA_SWITCH_CFG        0x0032           // ȫ���л���������
#define DH_DEV_LOST_FOCUS_CFG             0x0033           // ʧȥ���㱨������
#define DH_DEV_ALARM_DECODE_CFG           0x0034           // ��������������
#define DH_DEV_VIDEOOUT_CFG               0x0035           // ��Ƶ�����������
#define DH_DEV_POINT_CFG                  0x0036           // Ԥ�Ƶ�ʹ������
#define DH_DEV_IP_COLLISION_CFG           0x0037           // Ip��ͻ��ⱨ������
#define DH_DEV_OSD_ENABLE_CFG             0x0038           // OSD����ʹ������
#define DH_DEV_LOCALALARM_CFG             0x0039           // ���ر�������(�ṹ��DH_ALARMIN_CFG_EX)
#define DH_DEV_NETALARM_CFG               0x003A           // ���籨������(�ṹ��DH_ALARMIN_CFG_EX)
#define DH_DEV_MOTIONALARM_CFG            0x003B           // ���챨������(�ṹ��DH_MOTION_DETECT_CFG_EX)
#define DH_DEV_VIDEOLOSTALARM_CFG         0x003C           // ��Ƶ��ʧ��������(�ṹ��DH_VIDEO_LOST_CFG_EX)
#define DH_DEV_BLINDALARM_CFG             0x003D           // ��Ƶ�ڵ���������(�ṹ��DH_BLIND_CFG_EX)
#define DH_DEV_DISKALARM_CFG              0x003E           // Ӳ�̱�������(�ṹ��DH_DISK_ALARM_CFG_EX)
#define DH_DEV_NETBROKENALARM_CFG         0x003F           // �����жϱ�������(�ṹ��DH_NETBROKEN_ALARM_CFG_EX)
#define DH_DEV_ENCODER_CFG                0x0040           // ����ͨ����ǰ�˱�������Ϣ�����DVRʹ��,�ṹ��DEV_ENCODER_CFG��
#define DH_DEV_TV_ADJUST_CFG              0x0041           // TV�������ã�channel����TV��(0��ʼ),���ͽṹ�壩
#define DH_DEV_ABOUT_VEHICLE_CFG          0x0042           // �����������,��������ʹ��
#define DH_DEV_ATM_OVERLAY_ABILITY        0x0043           // ��ȡatm����֧��������Ϣ
#define DH_DEV_ATM_OVERLAY_CFG            0x0044           // atm��������,��atm����
#define DH_DEV_DECODER_TOUR_CFG           0x0045           // ������������Ѳ����
#define DH_DEV_SIP_CFG                    0x0046           // SIP����
#define DH_DEV_VICHILE_WIFI_AP_CFG        0x0047           // wifi ap����
#define DH_DEV_STATICALARM_CFG            0x0048           // ��̬�������� 
#define DH_DEV_DECODE_POLICY_CFG          0x0049           // �豸�Ľ����������(�ṹ��DHDEV_DECODEPOLICY_CFG,channelΪ����ͨ��0��ʼ) 
#define DH_DEV_MACHINE_CFG                0x004A           // ������ص�����(�ṹ��DHDEV_MACHINE_CFG)
#define DH_DEV_MAC_COLLISION_CFG          0x004B           // MAC��ͻ�������(�ṹ�� ALARM_MAC_COLLISION_CFG)
#define DH_DEV_RTSP_CFG                   0x004C           // RTSP����(��Ӧ�ṹ��DHDEV_RTSP_CFG)
#define DH_DEV_232_COM_CARD_CFG           0x004E           // 232���ڿ����ź��¼�����(��Ӧ�ṹ��COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_485_COM_CARD_CFG           0x004F           // 485���ڿ����ź��¼�����(��Ӧ�ṹ��COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_FTP_PROTO_CFG_EX           0x0050           // FTP�ϴ���չ����(��Ӧ�ṹ��DHDEV_FTP_PROTO_CFG_EX)
#define DH_DEV_SYSLOG_REMOTE_SERVER       0x0051           // SYSLOG Զ�̷���������(��Ӧ�ṹ��DHDEV_SYSLOG_REMOTE_SERVER)
#define DH_DEV_COMMCFG_EX                 0x0052           // ��չ������������(��Ӧ�ṹ��DHDEV_COMM_CFG_EX)            
#define DH_DEV_NETCARD_CFG                0x0053           // ������Ϣ����(��Ӧ�ṹ��DHDEV_NETCARD_CFG)
#define DH_DEV_BACKUP_VIDEO_FORMAT        0x0054           // ��Ƶ���ݸ�ʽ����(��Ӧ�ṹ��DHDEV_BACKUP_VIDEO_FORMAT)
#define DH_DEV_STREAM_ENCRYPT_CFG         0x0055           // ������������(��Ӧ�ṹ��DHEDV_STREAM_ENCRYPT)
#define DH_DEV_IPFILTER_CFG_EX            0x0056           // IP����������չ(��Ӧ�ṹ��DHDEV_IPIFILTER_CFG_EX)
#define DH_DEV_CUSTOM_CFG                 0x0057           // �û��Զ�������(��Ӧ�ṹ��DHDEV_CUSTOM_CFG)
#define DH_DEV_WLAN_DEVICE_CFG_EX         0x0058           // ���������豸��չ����(��Ӧ�ṹ��DHDEV_WLAN_DEVICE_LIST_EX)
#define DH_DEV_ACC_POWEROFF_CFG           0x0059           // ACC�����¼�����(��Ӧ�ṹ��DHDEV_ACC_POWEROFF_CFG)
#define DH_DEV_EXPLOSION_PROOF_CFG        0x005a           // �����б����¼�����(��Ӧ�ṹ��DHDEV_EXPLOSION_PROOF_CFG)
#define DH_DEV_NETCFG_EX                  0x005b           // ������չ����(��Ӧ�ṹ��DHDEV_NET_CFG_EX)
#define DH_DEV_LIGHTCONTROL_CFG           0x005c           // �ƹ��������(��Ӧ�ṹ��DHDEV_LIGHTCONTROL_CFG)
#define DH_DEV_3GFLOW_CFG                 0x005d           // 3G������Ϣ����(��Ӧ�ṹ��DHDEV_3GFLOW_INFO_CFG)
#define DH_DEV_IPV6_CFG                   0x005e           // IPv6����(��Ӧ�ṹ��DHDEV_IPV6_CFG)
#define DH_DEV_SNMP_CFG                   0X005f           // Snmp����(��Ӧ�ṹ��DHDEV_NET_SNMP_CFG), ������ɺ���Ҫ�����豸
#define DH_DEV_SNAP_CONTROL_CFG           0x0060           // ץͼ��������(��Ӧ�ṹ��DHDEV_SNAP_CONTROL_CFG)
#define DH_DEV_GPS_MODE_CFG               0X0061           // GPS��λģʽ����(��Ӧ�ṹ��DHDEV_GPS_MODE_CFG)
#define DH_DEV_SNAP_UPLOAD_CFG            0X0062           // ͼƬ�ϴ�������Ϣ(��Ӧ�ṹ�� DHDEV_SNAP_UPLOAD_CFG)
#define DH_DEV_SPEED_LIMIT_CFG            0x0063           // ����������Ϣ(��Ӧ�ṹ��DHDEV_SPEED_LIMIT_CFG)
#define DH_DEV_ISCSI_CFG                  0x0064           // iSCSI����(��Ӧ�ṹ��DHDEV_ISCSI_CFG), ������ɺ���Ҫ�����豸
#define DH_DEV_WIRELESS_ROUTING_CFG       0x0065           // ����·������(��Ӧ�ṹ��DHDEV_WIRELESS_ROUTING_CFG)
#define DH_DEV_ENCLOSURE_CFG              0x0066           // ����Χ������(��Ӧ�ṹ��DHDEV_ENCLOSURE_CFG)
#define DH_DEV_ENCLOSURE_VERSION_CFG      0x0067           // ����Χ���汾������(��Ӧ�ṹ��DHDEV_ENCLOSURE_VERSION_CFG)
#define DH_DEV_RIAD_EVENT_CFG             0x0068           // Raid�¼�����(��Ӧ�ṹ��DHDEV_RAID_EVENT_CFG)
#define DH_DEV_FIRE_ALARM_CFG             0x0069           // �𾯱�������(��Ӧ�ṹ��DHDEV_FIRE_ALARM_CFG)
#define DH_DEV_LOCALALARM_NAME_CFG        0x006a           // �������Ʊ�������(��ӦName1&&name2&&name3...��ʽ�ַ���)
#define DH_DEV_URGENCY_RECORD_CFG         0x0070           // ��洢����(��Ӧ�ṹ��DHDEV_URGENCY_RECORD_CFG)
#define DH_DEV_ELEVATOR_ATTRI_CFG         0x0071           // �������в�������(��Ӧ�ṹ��DHDEV_ELEVATOR_ATTRI_CFG)
#define DH_DEV_ATM_OVERLAY_CFG_EX         0x0072           // atm��������,��atm����,֧�ִ���32ͨ�����豸(��Ӧ�ṹ��DHDEV_ATM_OVERLAY_CONFIG_EX)
#define DH_DEV_MACFILTER_CFG              0x0073           // MAC��������(��Ӧ�ṹ��DHDEV_MACFILTER_CFG)
#define DH_DEV_MACIPFILTER_CFG            0x0074           // MAC,IP����(Ҫ��ip,mac��һһ��Ӧ��)����(��Ӧ�ṹ��DHDEV_MACIPFILTER_CFG)
#define DH_DEV_STREAM_ENCRYPT_TIME_CFG    0x0075           // ��������(���ܼƻ�)����(��Ӧ�ṹ��DHEDV_STREAM_ENCRYPT)
#define DH_DEV_LIMIT_BIT_RATE_CFG         0x0076           // ����������(��Ӧ�ṹ�� DHDEV_LIMIT_BIT_RATE) 
#define DH_DEV_SNAP_CFG_EX                0x0077           // ץͼ���������չ(��Ӧ�ṹ�� DHDEV_SNAP_CFG_EX)
#define DH_DEV_DECODER_URL_CFG            0x0078           // ������url����(��Ӧ�ṹ��DHDEV_DECODER_URL_CFG)
#define DH_DEV_TOUR_ENABLE_CFG            0x0079           // ��Ѳʹ������(��Ӧ�ṹ��DHDEV_TOUR_ENABLE_CFG)
#define DH_DEV_VICHILE_WIFI_AP_CFG_EX     0x007a           // wifi ap������չ(��Ӧ�ṹ��DHDEV_VEHICLE_WIFI_AP_CFG_EX)
#define DH_DEV_ENCODER_CFG_EX             0x007b           // ����ͨ����ǰ�˱�������Ϣ��չ,(��Ӧ�ṹ�� DEV_ENCODER_CFG_EX)

// ���漸�����������ǵļ���������
#define DH_DEV_ITC_HWS000_RA_CFG          0x007c             // ���������״�Ƕ�����(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_HS_CFG          0x007d             // �������ǳ��ٴ���ֵ����(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_LS_CFG          0x007e             // ��������Ƿ�ٴ���ֵ����(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_FL_CFG          0x007f             // ���������������������(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_OC_CFG          0x0080             // �������ǳ����ܼ�������(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_LC_CFG          0x0081             // ��������Ƿ���ܼ�������(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_AC_CFG          0x0082             // ��������Υ���ܼ�������(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_FC_CFG          0x0083             // ���������������˸��������(��Ӧһ��intֵ)
#define DH_DEV_ITC_HWS000_ALL_CFG         0x0084             // �������ǲ�ѯ����ȫ������ֵ����(��ӦDEV_ITC_HWS000_ALL_CFG)
#define DH_DEV_ITC_HWS000_CLEAR_COUNT_CFG 0x0085             // ������������4�ּ�������(OC,LC,AC,FC ��Ӧһ��intֵ)
#define DH_DEV_USER_END_CFG               1000
#define DH_DEV_ITC_HWS000_CFG_ITEM_NUM    8                     // �������ǵ���������Ŀ
// ������������������
typedef struct tagDEV_ITC_HWS000_ALL_CFG
{
    DWORD dwSize;
    int nValue[DH_DEV_ITC_HWS000_CFG_ITEM_NUM]; // �������ֵ
                                                // ������0��ʼ �������״�Ƕȣ����ٴ���ֵ��Ƿ�ٴ���ֵ����������ȣ������ܼ�����Ƿ���ܼ�����Υ���ܼ������������˸����
}DEV_ITC_HWS000_ALL_CFG;

// ��������,��ӦCLIENT_StartListen�ӿ�
#define DH_COMM_ALARM                     0x1100           // ���汨��(�����ⲿ����,��Ƶ��ʧ,��̬���)
#define DH_SHELTER_ALARM                  0x1101           // ��Ƶ�ڵ�����
#define DH_DISK_FULL_ALARM                0x1102           // Ӳ��������
#define DH_DISK_ERROR_ALARM               0x1103           // Ӳ�̹��ϱ���
#define DH_SOUND_DETECT_ALARM             0x1104           // ��Ƶ��ⱨ��
#define DH_ALARM_DECODER_ALARM            0x1105           // ��������������

// ��չ��������,��ӦCLIENT_StartListenEx�ӿ�
#define DH_ALARM_ALARM_EX                 0x2101           // �ⲿ�����������ֽ������豸����ͨ��������ͬ��ÿ���ֽڱ�ʾһ������ͨ���ı���״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_MOTION_ALARM_EX                0x2102           // ��̬��ⱨ���������ֽ������豸��Ƶͨ��������ͬ��ÿ���ֽڱ�ʾһ����Ƶͨ���Ķ�̬��ⱨ��״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_VIDEOLOST_ALARM_EX             0x2103           // ��Ƶ��ʧ�����������ֽ������豸��Ƶͨ��������ͬ��ÿ���ֽڱ�ʾһ����Ƶͨ������Ƶ��ʧ����״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_SHELTER_ALARM_EX               0x2104           // ��Ƶ�ڵ������������ֽ������豸��Ƶͨ��������ͬ��ÿ���ֽڱ�ʾһ����Ƶͨ�����ڵ�(����)����״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_SOUND_DETECT_ALARM_EX          0x2105           // ��Ƶ��ⱨ��������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ����Ƶͨ������Ƶ��ⱨ��״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_DISKFULL_ALARM_EX              0x2106           // Ӳ��������������Ϊ1���ֽڣ�1Ϊ��Ӳ����������0Ϊ�ޱ�����
#define DH_DISKERROR_ALARM_EX             0x2107           // ��Ӳ�̱���������Ϊ32���ֽڣ�ÿ���ֽڱ�ʾһ��Ӳ�̵Ĺ��ϱ���״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_ENCODER_ALARM_EX               0x210A           // ����������������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ��ͨ��������״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_URGENCY_ALARM_EX               0x210B           // �����������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ��ͨ��������״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_WIRELESS_ALARM_EX              0x210C           // ���߱���������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ��ͨ��������״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_NEW_SOUND_DETECT_ALARM_EX      0x210D           // ����Ƶ��ⱨ��,������Ϣ�Ľṹ���DH_NEW_SOUND_ALARM_STATE��
#define DH_ALARM_DECODER_ALARM_EX         0x210E           // ����������������������Ϣ�Ľṹ��� ALARM_DECODER_ALARM
#define DH_DECODER_DECODE_ABILITY         0x210F           // ��������������������������Ϊһ���ֽڣ�0������������ 1����ʾ��������������
#define DH_FDDI_DECODER_ABILITY           0x2110           // ���˱�����״̬������������Ϣ�Ľṹ��� ALARM_FDDI_ALARM
#define DH_PANORAMA_SWITCH_ALARM_EX       0x2111           // �л���������������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ��ͨ��������״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_LOSTFOCUS_ALARM_EX             0x2112           // ʧȥ���㱨��������Ϊ16���ֽڣ�ÿ���ֽڱ�ʾһ��ͨ��������״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_OEMSTATE_EX                    0x2113           // oem��ͣ״̬������Ϊ 1 BYTE��
#define DH_DSP_ALARM_EX                   0x2114           // DSP������������Ϣ�Ľṹ��� DSP_ALARM
#define DH_ATMPOS_BROKEN_EX               0x2115           // atm��pos���Ͽ�����, ����Ϊ 1 BYTE��0�����ӶϿ� 1����������
#define DH_RECORD_CHANGED_EX              0x2116           // ¼��״̬�仯������������ϢΪ ALARM_RECORDING_CHANGED ����
#define DH_CONFIG_CHANGED_EX              0x2117           // ���÷����仯���������� ��
#define DH_DEVICE_REBOOT_EX               0x2118           // �豸����������� ��
#define DH_WINGDING_ALARM_EX              0x2119           // ��Ȧ/���������ϱ���(��Ӧ�ṹ�� ALARM_WINGDING_INFO)
#define DH_TRAF_CONGESTION_ALARM_EX       0x211A           // ��ͨ��������(���������쳣ֹͣ�����Ŷ�)(��Ӧ�ṹ�� ALARM_TRAF_CONGESTION_INFO)
#define DH_TRAF_EXCEPTION_ALARM_EX        0x211B           // ��ͨ�쳣����(��ͨ��������0���쳣����)(��Ӧ�ṹ�� ALARM_TRAF_EXCEPTION_INFO)
#define DH_EQUIPMENT_FILL_ALARM_EX        0x211C           // �����豸���ϱ���(��Ӧ�ṹ�� ALARM_EQUIPMENT_FILL_INFO)
#define DH_ALARM_ARM_DISARM_STATE         0x211D           // ����������״̬(��Ӧ�ṹ�� ALARM_EQUIPMENT_FILL_INFO)
#define DH_ALARM_ACC_POWEROFF             0x211E           // ACC�ϵ籨��������Ϊ DWORD 0��ACCͨ�� 1��ACC�ϵ� 
#define DH_ALARM_3GFLOW_EXCEED            0x211F           // 3G����������ֵ����(��Ӧ�ṹ�� DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_ALARM_SPEED_LIMIT              0x2120           // ���ٱ���(��Ӧ�ṹ�� ALARM_SPEED_LIMIT)
#define DH_ALARM_VEHICLE_INFO_UPLOAD      0x2121           // �����Զ�����Ϣ�ϴ� (��Ӧ�ṹ�� ALARM_VEHICLE_INFO_UPLOAD)
#define DH_STATIC_ALARM_EX                0x2122           // ��̬��ⱨ���������ֽ������豸��Ƶͨ��������ͬ��ÿ���ֽڱ�ʾһ����Ƶͨ���ľ�̬��ⱨ��״̬��1Ϊ�б�����0Ϊ�ޱ�����
#define DH_PTZ_LOCATION_EX                0x2123           // ��̨��λ��Ϣ(��Ӧ�ṹ�� DH_PTZ_LOCATION_INFO)
#define DH_ALARM_CARD_RECORD_UPLOAD       0x2124           // ����¼����Ϣ�ϴ�(��Ӧ�ṹ�� ALARM_CARD_RECORD_INFO_UPLOAD)
#define DH_ALARM_ATM_INFO_UPLOAD          0x2125           // ATM������Ϣ�ϴ�(��Ӧ�ṹ�� ALARM_ATM_INFO_UPLOAD)
#define DH_ALARM_ENCLOSURE                0x2126           // ����Χ������(��Ӧ�ṹ��ALARM_ENCLOSURE_INFO)
#define DH_ALARM_SIP_STATE                0x2127           // SIP״̬����(��Ӧ�ṹ�� ALARM_SIP_STATE)
#define DH_ALARM_RAID_STATE               0x2128           // RAID�쳣����(��Ӧ�ṹ�� ALARM_RAID_INFO)
#define DH_ALARM_CROSSING_SPEED_LIMIT     0x2129           // ·�����ٱ���(��Ӧ�ṹ�� ALARM_SPEED_LIMIT)
#define DH_ALARM_OVER_LOADING             0x212A           // ���ر���(��Ӧ�ṹ��ALARM_OVER_LOADING)
#define DH_ALARM_HARD_BRAKING             0x212B           // ��ɲ������(��Ӧ������ALARM_HARD_BRAKING)
#define DH_ALARM_SMOKE_SENSOR             0x212C           // �̸б���(��Ӧ�ṹ��ALARM_SMOKE_SENSOR)
#define DH_ALARM_TRAFFIC_LIGHT_FAULT      0x212D           // ��ͨ�ƹ��ϱ���(��Ӧ�ṹ��ALARM_TRAFFIC_LIGHT_FAULT) 
#define DH_ALARM_TRAFFIC_FLUX_STAT        0x212E           // ��ͨ����ͳ�Ʊ���(��Ӧ�ṹ��ALARM_TRAFFIC_FLUX_LANE_INFO)
#define DH_ALARM_CAMERA_MOVE              0x212F           // �������λ�����¼�(��Ӧ�ṹ��ALARM_CAMERA_MOVE_INFO)
#define DH_ALARM_DETAILEDMOTION           0x2130           // ��ϸ���챨���ϱ���Ϣ(��Ӧ�ṹ��ALARM_DETAILEDMOTION_CHNL_INFO)
#define DH_ALARM_STORAGE_FAILURE          0x2131           // �洢�쳣����(��Ӧ�ṹ�� ALARM_STORAGE_FAILURE ����)
#define DH_ALARM_FRONTDISCONNECT          0x2132           // ǰ��IPC��������(��Ӧ�ṹ��ALARM_FRONTDISCONNET_INFO)
#define DH_ALARM_ALARM_EX_REMOTE          0x2133           // Զ���ⲿ����(��Ӧ�ṹ�� ALARM_REMOTE_ALARM_INFO)
#define DH_ALARM_BATTERYLOWPOWER          0x2134           // ��ص����ͱ���(��Ӧ�ṹ��ALARM_BATTERYLOWPOWER_INFO)
#define DH_ALARM_TEMPERATURE              0x2135           // �¶ȹ��߱���(��Ӧ�ṹ�� ALARM_TEMPERATURE_INFO)
#define DH_ALARM_TIREDDRIVE               0x2136           // ƣ�ͼ�ʻ����(��Ӧ�ṹ��ALARM_TIREDDRIVE_INFO)
#define DH_ALARM_LOST_RECORD              0x2137           // ��¼���¼�����(��Ӧ�ṹ��ALARM_LOST_RECORD)
#define DH_ALARM_HIGH_CPU                 0x2138           // CPUռ���ʹ����¼�����(��Ӧ�ṹ�� ALARM_HIGH_CPU)
#define DH_ALARM_LOST_NETPACKET           0x2139           // ���緢�����ݶ����¼�����(��Ӧ�ṹ�� ALARM_LOST_NETPACKET)
#define DH_ALARM_HIGH_MEMORY              0x213A           // �ڴ�ռ���ʹ����¼�����(��Ӧ�ṹ��ALARM_HIGH_MEMORY)
#define DH_LONG_TIME_NO_OPERATION         0x213B           // WEB�û���ʱ���޲����¼�������չ��Ϣ��
#define DH_BLACKLIST_SNAP                 0x213C           // ����������ץ���¼�(��Ӧ�ṹ��DH_BLACKLIST_SNAP_INFO)         
#define DH_ALARM_DISK                     0x213E           // Ӳ�̱���(��Ӧ ALARM_DISK_INFO ����)
#define DH_ALARM_FILE_SYSTEM              0x213F           // �ļ�ϵͳ����(��ӦALARM_FILE_SYSTEM_INFO����)
#define DH_ALARM_IVS                      0x2140           // ���ܱ����¼�(��Ӧ�ṹ��ALARM_IVS_INFO)
#define DH_ALARM_GOODS_WEIGHT_UPLOAD      0x2141           // ������Ϣ�ϱ�(��ӦALARM_GOODS_WEIGHT_UPLOAD_INFO)
#define DH_ALARM_GOODS_WEIGHT             0x2142           // ������Ϣ����(��ӦALARM_GOODS_WEIGHT_INFO)
#define DH_GPS_STATUS                     0x2143           // GPS��λ��Ϣ(��Ӧ NET_GPS_STATUS_INFO)
#define DH_ALARM_DISKBURNED_FULL          0x2144           // Ӳ�̿�¼������(��Ӧ ALARM_DISKBURNED_FULL_INFO)
#define DH_ALARM_STORAGE_LOW_SPACE        0x2145           // �洢���������¼�(��ӦALARM_STORAGE_LOW_SPACE_INFO)
#define DH_ALARM_DISK_FLUX                0x2160           // Ӳ�������쳣�¼�(��Ӧ ALARM_DISK_FLUX)
#define DH_ALARM_NET_FLUX                 0x2161           // ���������쳣�¼�(��Ӧ ALARM_NET_FLUX)
#define DH_ALARM_FAN_SPEED                0x2162           // ����ת���쳣�¼�(��Ӧ ALARM_FAN_SPEED)
#define DH_ALARM_STORAGE_FAILURE_EX       0x2163           // �洢���󱨾�(��Ӧ�ṹ��ALARM_STORAGE_FAILURE_EX)
#define DH_ALARM_RECORD_FAILED            0x2164           // ¼���쳣����(��Ӧ�ṹ��ALARM_RECORD_FAILED_INFO)
#define DH_ALARM_STORAGE_BREAK_DOWN       0x2165           // �洢�����¼�(��Ӧ�ṹ�� ALARM_STORAGE_BREAK_DOWN_INFO)
#define DH_ALARM_VIDEO_ININVALID          0x2166           // ��Ƶ����ͨ��ʧЧ�¼����������õ���Ƶ����ͨ������,�����豸����������ALARM_VIDEO_ININVALID_INFO
#define DH_ALARM_VEHICLE_TURNOVER         0x2167           // �����෭�����¼�(��Ӧ�ṹ��ALARM_VEHICEL_TURNOVER_EVENT_INFO)
#define DH_ALARM_VEHICLE_COLLISION        0x2168           // ����ײ�������¼�(��Ӧ�ṹ��ALARM_VEHICEL_COLLISION_EVENT_INFO)
#define DH_ALARM_VEHICLE_CONFIRM          0x2169           // �����ϴ���Ϣ�¼�(��Ӧ�ṹ��ALARM_VEHICEL_CONFIRM_INFO)
#define DH_ALARM_VEHICLE_LARGE_ANGLE      0x2170           // ��������ͷ��Ƕ�Ťת�¼�(��Ӧ�ṹ��ALARM_VEHICEL_LARGE_ANGLE)
#define DH_ALARM_TALKING_INVITE           0x2171           // �豸����Է�����Խ��¼�(��Ӧ�ṹ��ALARM_TALKING_INVITE_INFO)
#define DH_ALARM_ALARM_EX2                0x2175           // ���ر����¼�(��Ӧ�ṹ�� ALARM_ALARM_INFO_EX2,��DH_ALARM_ALARM_EX����)
#define DH_ALARM_VIDEO_TIMING             0x2176           // ��Ƶ��ʱ����¼�(��Ӧ�ṹ��ALARM_VIDEO_TIMING)
#define DH_ALARM_COMM_PORT                0x2177           // �����¼�(��Ӧ�ṹ��ALARM_COMM_PORT_EVENT_INFO)
#define DH_ALARM_AUDIO_ANOMALY            0x2178           // ��Ƶ�쳣�¼�(��Ӧ�ṹ��ALARM_AUDIO_ANOMALY)
#define DH_ALARM_AUDIO_MUTATION           0x2179           // ��ǿͻ���¼�(��Ӧ�ṹ��ALARM_AUDIO_MUTATION)
#define DH_EVENT_TYREINFO                 0x2180           // ��̥��Ϣ�ϱ��¼�(��Ӧ�ṹ��EVENT_TYRE_INFO)
#define DH_ALARM_POWER_ABNORMAL           0X2181           // �����Դ�쳣����(��Ӧ�ṹ��ALARM_POWER_ABNORMAL_INFO)
#define DH_EVENT_REGISTER_OFF             0x2182           // �����豸���������¼�(��Ӧ�ṹ�� EVENT_REGISTER_OFF_INFO)
#define DH_ALARM_NO_DISK                  0x2183           // ��Ӳ�̱���(��Ӧ�ṹ��ALARM_NO_DISK_INFO)
#define DH_ALARM_FALLING                  0x2184           // �����¼�����(��Ӧ�ṹ��ALARM_FALLING_INFO)
#define DH_ALARM_PROTECTIVE_CAPSULE       0x2185           // �������¼�(��Ӧ�ṹ��ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_ALARM_NO_RESPONSE              0x2186           // ���δӦ�𾯱�(��Ӧ�ṹ��ALARM_NO_RESPONSE_INFO)
#define DH_ALARM_CONFIG_ENABLE_CHANGE     0x2187           // ����ʹ�ܸı��ϱ��¼�(��Ӧ�ṹ�� ALARM_CONFIG_ENABLE_CHANGE_INFO)
#define DH_EVENT_CROSSLINE_DETECTION      0x2188           // �������¼�( ��Ӧ�ṹ�� ALARM_EVENT_CROSSLINE_INFO )
#define DH_EVENT_CROSSREGION_DETECTION    0x2189           // �������¼�( ��Ӧ�ṹ�� ALARM_EVENT_CROSSREGION_INFO )
#define DH_EVENT_LEFT_DETECTION           0x218a           // ��Ʒ�����¼�( ��Ӧ�ṹ�� ALARM_EVENT_LEFT_INFO )
#define DH_EVENT_FACE_DETECTION           0x218b           // ��������¼�( ��Ӧ�ṹ�� ALARM_EVENT_FACE_INFO ) 
#define DH_ALARM_IPC                      0x218c           // IPC����,IPCͨ��DVR��NVR�ϱ��ı��ر���(��Ӧ�ṹ�� ALARM_IPC_INFO)
#define DH_EVENT_TAKENAWAYDETECTION       0x218d           // ��Ʒ�����¼�(��Ӧ�ṹ�� ALARM_TAKENAWAY_DETECTION_INFO)
#define DH_EVENT_VIDEOABNORMALDETECTION   0x218e           // ��Ƶ�쳣�¼�(��Ӧ�ṹ�� ALARM_VIDEOABNORMAL_DETECTION_INFO)
#define DH_EVENT_MOTIONDETECT             0x218f           // ��Ƶ�ƶ�����¼�(��Ӧ�ṹ�� ALARM_MOTIONDETECT_INFO)
#define DH_ALARM_PIR                      0x2190           // PIR����(��ӦBYTE*, pBuf����dwBufLen)
#define DH_ALARM_STORAGE_HOT_PLUG         0x2191           // �洢�Ȳ���¼�(��Ӧ�ṹ�� ALARM_STORAGE_HOT_PLUG_INFO)
#define DH_ALARM_FLOW_RATE                0x2192           // ����ʹ������¼�(��Ӧ�ṹ�� ALARM_FLOW_RATE_INFO)
#define DH_ALARM_MOVEDETECTION            0x2193           // �ƶ��¼�(��ӦALARM_MOVE_DETECTION_INFO)
#define DH_ALARM_WANDERDETECTION          0x2194           // �ǻ��¼�(��ӦALARM_WANDERDETECTION_INFO)
#define DH_ALARM_CROSSFENCEDETECTION      0x2195           // ��ԽΧ���¼�(��ӦALARM_CROSSFENCEDETECTION_INFO)
#define DH_ALARM_PARKINGDETECTION         0x2196           // �Ƿ�ͣ���¼�(��ӦALARM_PARKINGDETECTION_INFO)
#define DH_ALARM_RIOTERDETECTION          0x2197           // ��Ա�ۼ��¼�(��ӦALARM_RIOTERDETECTION_INFO)
#define DH_ALARM_STORAGE_NOT_EXIST        0x3167           // �洢�鲻�����¼�(��Ӧ�ṹ�� ALARM_STORAGE_NOT_EXIST_INFO)
#define DH_ALARM_NET_ABORT                0x3169           // ��������¼�(��Ӧ�ṹ�� ALARM_NETABORT_INFO)
#define DH_ALARM_IP_CONFLICT              0x3170           // IP��ͻ�¼�(��Ӧ�ṹ�� ALARM_IP_CONFLICT_INFO)
#define DH_ALARM_MAC_CONFLICT             0x3171           // MAC��ͻ�¼�(��Ӧ�ṹ�� ALARM_MAC_CONFLICT_INFO)
#define DH_ALARM_POWERFAULT               0x3172           // ��Դ�����¼�(��Ӧ�ṹ��ALARM_POWERFAULT_INFO)
#define DH_ALARM_CHASSISINTRUDED          0x3173           // ��������(����)�����¼�(��Ӧ�ṹ��ALARM_CHASSISINTRUDED_INFO)
#define DH_ALARM_ALARMEXTENDED            0x3174           // ������չ�����¼�(��Ӧ�ṹ�� ALARM_ALARMEXTENDED_INFO)
#define DH_ALARM_ARMMODE_CHANGE_EVENT     0x3175           // ������״̬�仯�¼�(��Ӧ�ṹ��ALARM_ARMMODE_CHANGE_INFO)
#define DH_ALARM_BYPASSMODE_CHANGE_EVENT  0x3176           // ��·״̬�仯�¼�(��Ӧ�ṹ��ALARM_BYPASSMODE_CHANGE_INFO)
#define DH_ALARM_ACCESS_CTL_NOT_CLOSE     0x3177           // �Ž�δ���¼�(��Ӧ�ṹ��ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
#define DH_ALARM_ACCESS_CTL_BREAK_IN      0x3178           // �����¼�(��Ӧ�ṹ��ALARM_ACCESS_CTL_BREAK_IN_INFO)
#define DH_ALARM_ACCESS_CTL_REPEAT_ENTER  0x3179           // ���������¼�(��Ӧ�ṹ��ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
#define DH_ALARM_ACCESS_CTL_DURESS        0x3180           // в�ȿ�ˢ���¼�(��Ӧ�ṹ��ALARM_ACCESS_CTL_DURESS_INFO)
#define DH_ALARM_ACCESS_CTL_EVENT         0x3181           // �Ž��¼�(��Ӧ�ṹ�� ALARM_ACCESS_CTL_EVENT_INFO)
#define DH_URGENCY_ALARM_EX2              0x3182           // �����EX2(��DH_URGENCY_ALARM_EX������,��Ӧ�ṹ��ALARM_URGENCY_ALARM_EX2, ��Ϊ�����Ľ��¼�, һ�㴦���������ⲿͨѶ�����������
#define DH_ALARM_INPUT_SOURCE_SIGNAL      0x3183           // ��������Դ�ź��¼�(ֻҪ������ͻ�������¼�, ���۷�����ǰ��ģʽ,�޷�����, ��Ӧ ALARM_INPUT_SOURCE_SIGNAL_INFO )
#define DH_ALARM_ANALOGALARM_EVENT        0x3184           // ģ������������ͨ���¼�(��Ӧ�ṹ��ALARM_ANALOGALARM_EVENT_INFO)
#define DH_ALARM_ACCESS_CTL_STATUS        0x3185           // �Ž�״̬�¼�(��Ӧ�ṹ��ALARM_ACCESS_CTL_STATUS_INFO)
#define DH_ALARM_ACCESS_SNAP              0x3186           // �Ž�ץͼ�¼�(��Ӧ�ṹ��ALARM_ACCESS_SNAP_INFO)
#define DH_ALARM_ALARMCLEAR               0x3187           // �����¼�(��Ӧ�ṹ��ALARM_ALARMCLEAR_INFO)
#define DH_ALARM_CIDEVENT                 0x3188           // CID�¼�(��Ӧ�ṹ�� ALARM_CIDEVENT_INFO)
#define DH_ALARM_TALKING_HANGUP           0x3189           // �豸�����Ҷ϶Խ��¼�(��Ӧ�ṹ��ALARM_TALKING_HANGUP_INFO)
#define DH_ALARM_BANKCARDINSERT           0x318a           // ���п��忨�¼�(��Ӧ�ṹ��ALARM_BANKCARDINSERT_INFO)
#define DH_ALARM_RCEMERGENCY_CALL         0x318b           // ���б����¼�(��Ӧ�ṹ�� ALARM_RCEMERGENCY_CALL_INFO)
#define DH_ALARM_OPENDOORGROUP            0x318c           // ������Ͽ����¼�(��Ӧ�ṹ��ALARM_OPEN_DOOR_GROUP_INFO)
#define DH_ALARM_FINGER_PRINT             0x318d           // ��ȡָ���¼�(��Ӧ�ṹ��ALARM_CAPTURE_FINGER_PRINT_INFO)
#define DH_ALARM_CARD_RECORD              0x318e           // ����¼���¼�(��Ӧ�ṹ�� ALARM_CARD_RECORD_INFO)
#define DH_ALARM_SUBSYSTEM_STATE_CHANGE   0x318f           // ��ϵͳ״̬�ı��¼�(��Ӧ�ṹ��ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
#define DH_ALARM_BATTERYPOWER_EVENT       0x3190           // ��ص�����ʱ֪ͨ�¼�(��Ӧ�ṹ��ALARM_BATTERYPOWER_INFO)
#define DH_ALARM_BELLSTATUS_EVENT         0x3191           // ����״̬�¼�(��Ӧ�ṹ��ALARM_BELLSTATUS_INFO)
#define DH_ALARM_DEFENCE_STATE_CHANGE_EVENT 0x3192         // ����״̬�仯�¼�(��Ӧ�ṹ��ALARM_DEFENCE_STATUS_CHANGE_INFO), 
                                                           // ��������,�Ͳ��������仯�¼�����·״̬�仯�¼��е�״̬���岻ͬ,
                                                           // ��״̬ͨ��CLIENT_QueryDevState()�ӿڵ�DH_DEVSTATE_DEFENCE_STATE�����ȡ
#define DH_ALARM_TICKET_STATISTIC         0x3193           // ��Ʊͳ����Ϣ�¼�(��Ӧ�ṹ�� ALARM_TICKET_STATISTIC)
#define DH_ALARM_LOGIN_FAILIUR            0x3194           // ��½ʧ���¼�(��Ӧ�ṹ��ALARM_LOGIN_FAILIUR_INFO)
#define DH_ALARM_MODULE_LOST              0x3195           // ��չģ������¼�(��Ӧ�ṹ�� ALARM_MODULE_LOST_INFO)
#define DH_ALARM_PSTN_BREAK_LINE          0x3196           // PSTN�����¼�(��Ӧ�ṹ��ALARM_PSTN_BREAK_LINE_INFO)
#define DH_ALARM_ANALOG_PULSE             0x3197           // ģ���������¼�(˲ʱ���¼�), �ض�����������ʱ�Ŵ���(��Ӧ�ṹ��ALARM_ANALOGPULSE_INFO)
#define DH_ALARM_MISSION_CONFIRM          0x3198           // ����ȷ���¼�(��Ӧ�ṹ�� ALARM_MISSION_CONFIRM_INFO)
#define DH_ALARM_DEVICE_MSG_NOTIFY        0x3199           // �豸��ƽ̨��֪ͨ���¼�(��Ӧ�ṹ�� ALARM_DEVICE_MSG_NOTIFY_INFO)
#define DH_ALARM_VEHICLE_STANDING_OVER_TIME 0x319A         // ͣ����ʱ����(��Ӧ�ṹ�� ALARM_VEHICLE_STANDING_OVER_TIME_INFO)
#define DH_ALARM_ENCLOSURE_ALARM          0x319B           // ����Χ���¼�(��Ӧ�ṹ�� ALARM_ENCLOSURE_ALARM_INFO)
#define DH_ALARM_GUARD_DETECT             0x319C           // ��ͤ����¼�,���¼���ͤ�е�һ����ʱ�ϱ�start�¼�,��ͤ���һ�����뿪ʱ�ϱ�stop �¼�(��Ӧ�ṹ��ALARM_GUARD_DETECT_INFO)
#define DH_ALARM_GUARD_INFO_UPDATE        0x319D           // ��ͤ��Ϣ�����¼�,ֻҪ��ͤ����Ա������ϱ�(��Ӧ�ṹ��ALARM_GUARD_UPDATE_INFO)  
#define DH_ALARM_NODE_ACTIVE              0x319E           // �ڵ㼤���¼�(��Ӧ�ṹ��ALARM_NODE_ACTIVE_INFO)
#define DH_ALARM_VIDEO_STATIC             0x319F           // ��Ƶ��̬����¼�(��Ӧ�ṹ�� ALARM_VIDEO_STATIC_INFO)
#define DH_ALARM_REGISTER_REONLINE        0x31a0           // ����ע���豸���µ�½�¼�(��Ӧ�ṹ��ALARM_REGISTER_REONLINE_INFO)
#define DH_ALARM_ISCSI_STATUS             0x31a1           // ISCSI�澯�¼�(��Ӧ�ṹ�� ALARM_ISCSI_STATUS_INFO)
#define DH_ALARM_SCADA_DEV_ALARM          0x31a2           // ���ɼ��豸�����¼�(��Ӧ�ṹ�� ALARM_SCADA_DEV_INFO)
#define DH_ALARM_AUXILIARY_DEV_STATE      0x31a3           // �����豸״̬(��Ӧ�ṹ��ALARM_AUXILIARY_DEV_STATE)
#define DH_ALARM_PARKING_CARD             0x31a4           // ͣ��ˢ���¼�(��Ӧ�ṹ��ALARM_PARKING_CARD)
#define DH_ALARM_PROFILE_ALARM_TRANSMIT   0x31a5           // ���������¼�(��Ӧ�ṹ��ALARM_PROFILE_ALARM_TRANSMIT_INFO)
#define DH_ALARM_VEHICLE_ACC              0x31a6           // ����ACC�����¼�(��Ӧ�ṹ�� ALARM_VEHICLE_ACC_INFO)
#define DH_ALARM_TRAFFIC_SUSPICIOUSCAR    0x31a7           // ���ɳ����ϱ��¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
#define DH_ALARM_ACCESS_LOCK_STATUS       0x31a8           // ����״̬�¼�(��Ӧ�ṹ�� ALARM_ACCESS_LOCK_STATUS_INFO)
#define DH_ALARM_FINACE_SCHEME            0x31a9           // ��ƾ����¼�(��Ӧ�ṹ�� ALARM_FINACE_SCHEME_INFO)
#define DH_ALARM_HEATIMG_TEMPER           0x31aa           // �ȳ�����µ��¶��쳣�����¼�(��Ӧ�ṹ�� ALARM_HEATIMG_TEMPER_INFO)
#define DH_ALARM_TALKING_IGNORE_INVITE    0x31ab           // �豸ȡ���Խ������¼�(��Ӧ�ṹ��ALARM_TALKING_IGNORE_INVITE_INFO)
#define DH_ALARM_BUS_SHARP_TURN           0x31ac           // ������ת�¼�(��Ӧ�ṹ��ALARM_BUS_SHARP_TURN_INFO)
#define DH_ALARM_BUS_SCRAM                0x31ad           // ������ͣ�¼�(��Ӧ�ṹ��ALARM_BUS_SCRAM_INFO)
#define DH_ALARM_BUS_SHARP_ACCELERATE     0x31ae           // �����������¼�(��Ӧ�ṹ��ALARM_BUS_SHARP_ACCELERATE_INFO)
#define DH_ALARM_BUS_SHARP_DECELERATE     0x31af           // �����������¼�(��Ӧ�ṹ��ALARM_BUS_SHARP_DECELERATE_INFO)
#define DH_ALARM_ACCESS_CARD_OPERATE      0x31b0           // �Ž������ݲ����¼�(��Ӧ�ṹ��ALARM_ACCESS_CARD_OPERATE_INFO)
#define DH_ALARM_POLICE_CHECK             0x31b1           // ��Աǩ���¼�(��Ӧ�ṹ��ALARM_POLICE_CHECK_INFO)
#define DH_ALARM_NET                      0x31b2           // ���籨���¼�(��Ӧ�ṹ�� ALARM_NET_INFO)
#define DH_ALARM_NEW_FILE                 0X31b3           // ���ļ��¼�(��Ӧ�ṹ��ALARM_NEW_FILE_INFO)
#define DH_ALARM_FIREWARNING              0x31b5           // �ȳ����Ż���¼� (��Ӧ�ṹ�� ALARM_FIREWARNING_INFO)
#define DH_ALARM_RECORD_LOSS              0x31b6           // ¼��ʧ�¼�,ָӲ����õ������,������ɾ��ԭ������(��Ӧ�ṹ��ALARM_RECORD_LOSS_INFO)
#define DH_ALARM_VIDEO_FRAME_LOSS         0x31b7           // ��Ƶ��֡�¼�,�������粻�û����������������Ķ�֡(��Ӧ�ṹ��ALARM_VIDEO_FRAME_LOSS_INFO)
#define DH_ALARM_RECORD_VOLUME_FAILURE    0x31b8           // �ɱ���¼��Ĵ��̾����쳣,�����¼���쳣(��Ӧ�ṹ�� ALARM_RECORD_VOLUME_FAILURE_INFO)
#define DH_EVENT_SNAP_UPLOAD              0X31b9           // ͼ�ϴ�����¼�(��Ӧ�ṹ��EVENT_SNAP_UPLOAD_INFO)
#define DH_ALARM_AUDIO_DETECT             0x31ba           // ��Ƶ����¼�(��Ӧ�ṹ�� ALARM_AUDIO_DETECT )
#define DH_ALARM_UPLOADPIC_FAILCOUNT      0x31bb           // �ϴ�����ʧ�����ݸ�������Ӧ�ṹ��ALARM_UPLOADPIC_FAILCOUNT_INFO��
#define DH_ALARM_POS_MANAGE               0x31bc           // POS�����¼��¼�(��Ӧ�ṹ�� ALARM_POS_MANAGE_INFO )
#define DH_ALARM_REMOTE_CTRL_STATUS       0x31bd           // ����ң����״̬�¼�(��Ӧ�ṹ�� ALARM_REMOTE_CTRL_STATUS )
#define DH_ALARM_PASSENGER_CARD_CHECK     0x31be           // ����, �˿�ˢ���¼�(��Ӧ�ṹ�� ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_SOUND                    0x31bf           // �����¼�(��Ӧ�ṹ�� ALARM_SOUND )
#define DH_ALARM_LOCK_BREAK               0x31c0           // �����¼�(��Ӧ�ṹ�� ALARM_LOCK_BREAK_INFO )
#define DH_ALARM_HUMAN_INSIDE             0x31c1           // ���������¼�(��Ӧ�ṹ��ALARM_HUMAN_INSIDE_INFO)
#define DH_ALARM_HUMAN_TUMBLE_INSIDE      0x31c2           // ��������ˤ���¼�(��Ӧ�ṹ��ALARM_HUMAN_TUMBLE_INSIDE_INFO)
#define DH_ALARM_DISABLE_LOCKIN           0x31c3           // �������Ű�ť�����¼�(��ӦALARM_DISABLE_LOCKIN_INFO)
#define DH_ALARM_DISABLE_LOCKOUT          0x31c4           // �������Ű�ť�����¼�(��Ӧ�ṹ��ALARM_DISABLE_LOCKOUT_INFO)
#define DH_ALARM_UPLOAD_PIC_FAILED        0x31c5           // Υ�������ϴ�ʧ���¼�(��Ӧ�ṹ�� ALARM_UPLOAD_PIC_FAILED_INFO )
#define DH_ALARM_FLOW_METER               0x31c6           // ˮ����ͳ����Ϣ�ϱ��¼�(��Ӧ�ṹ�� ALARM_FLOW_METER_INFO)
#define DH_ALARM_WIFI_SEARCH              0x31c7           // ��ȡ����Χ������WIFI�豸�ϱ��¼�(��Ӧ�ṹ�� ALARM_WIFI_SEARCH_INFO)
#define DH_ALARM_WIRELESSDEV_LOWPOWER     0X31C8           // ��ȡ�����豸�͵����ϱ��¼�(��Ӧ�ṹ��ALARM_WIRELESSDEV_LOWPOWER_INFO)
#define DH_ALARM_PTZ_DIAGNOSES            0x31c9           // ��̨����¼�(��Ӧ�ṹ��ALARM_PTZ_DIAGNOSES_INFO)
#define DH_ALARM_FLASH_LIGHT_FAULT        0x31ca           // ������(�����)�����¼� (��Ӧ�ṹ�� ALARM_FLASH_LIGHT_FAULT_INFO)
#define DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT   0x31cb        // Ƶ���Ʊ����¼� (��Ӧ�ṹ�� ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO)
#define DH_ALARM_HUMAM_NUMBER_STATISTIC   0x31cc           // ������/������ͳ���¼� (��Ӧ�ṹ�� ALARM_HUMAN_NUMBER_STATISTIC_INFO)
#define DH_ALARM_VIDEOUNFOCUS             0x31ce           // ��Ƶ�齹����(��Ӧ�ṹ�� ALARM_VIDEOUNFOCUS_INFO)
#define DH_ALARM_BUF_DROP_FRAME           0x31cd           // ¼�񻺳�����֡�¼�(��Ӧ�ṹ�� ALARM_BUF_DROP_FRAME_INFO)
#define DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL 0x31cf        // ˫���豸�����뱸��֮��汾��Ϣ��һ���쳣�¼� (��Ӧ�ṹ�� ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO)
#define DH_ALARM_DCSSWITCH                 0x31d0          // �����л��¼� ��Ⱥ�л����� (��Ӧ�ṹ�� ALARM_DCSSWITCH_INFO)
#define DH_ALARM_RADAR_CONNECT_STATE       0x31d1          // �״�״̬�¼�(��Ӧ�ṹ�� ALARM_RADAR_CONNECT_STATE_INFO)
#define DH_ALARM_DEFENCE_ARMMODE_CHANGE    0X31d2          // ����������״̬�ı��¼�(��Ӧ�ṹ�� ALARM_DEFENCE_ARMMODECHANGE_INFO)
#define DH_ALARM_SUBSYSTEM_ARMMODE_CHANGE  0X31d3          // ��ϵͳ������״̬�ı��¼�(��Ӧ�ṹ�� ALARM_SUBSYSTEM_ARMMODECHANGE_INFO)
#define DH_ALARM_RFID_INFO                 0X31d4          // �����߼����Ϣ�¼�(��Ӧ�ṹ�� ALARM_RFID_INFO)
#define DH_ALARM_SMOKE_DETECTION           0X31d5          // �������¼�(��Ӧ�ṹ�� ALARM_SMOKE_DETECTION_INFO)
#define DH_ALARM_BETWEENRULE_TEMP_DIFF     0x31d6          // �ȳ��������²��쳣����(��Ӧ�ṹ�� ALARM_BETWEENRULE_DIFFTEMPER_INFO)
#define DH_ALARM_TRAFFIC_PIC_ANALYSE       0X31d7          // ͼƬ���η����¼�(��Ӧ ALARM_PIC_ANALYSE_INFO)
#define DH_ALARM_HOTSPOT_WARNING           0X31d8          // �ȳ����ȵ��쳣����(��Ӧ�ṹ�� ALARM_HOTSPOT_WARNING_INFO)
#define DH_ALARM_COLDSPOT_WARNING          0X31d9          // �ȳ�������쳣����(��Ӧ�ṹ�� ALARM_COLDSPOT_WARNING_INFO)
#define DH_ALARM_FIREWARNING_INFO          0X31da          // �ȳ�����鱨����Ϣ�ϱ�(��Ӧ�ṹ�� ALARM_FIREWARNING_INFO_DETAIL)
#define DH_ALARM_FACE_OVERHEATING          0x31db          // �ȳ������巢��Ԥ��(��Ӧ�ṹ�� ALARM_FACE_OVERHEATING_INFO)
#define DH_ALARM_SENSOR_ABNORMAL           0X31dc          // ̽�����쳣����(��Ӧ�ṹ�� ALARM_SENSOR_ABNORMAL_INFO)
#define DH_ALARM_PATIENTDETECTION          0x31de          // ��ز��˻״̬�����¼�(��Ӧ�ṹ�� ALARM_PATIENTDETECTION_INFO)
#define DH_ALARM_RADAR_HIGH_SPEED          0x31df          // �״��ⳬ�ٱ����¼� ����¥��ר�� (��Ӧ�ṹ�� ALARM_RADAR_HIGH_SPEED_INFO)
#define DH_ALARM_POLLING_ALARM             0x31e0          // �豸Ѳ�챨���¼� ����¥��ר�� (��Ӧ�ṹ�� ALARM_POLLING_ALARM_INFO)
#define DH_ALARM_ITC_HWS000                0x31e1          // ���������豸�¼��뱨��(��Ӧ�ṹ�� ALARM_ITC_HWS000)
#define DH_ALARM_TRAFFICSTROBESTATE        0x31e2          // ��բ��״̬�¼�(��Ӧ�ṹ�� ALARM_TRAFFICSTROBESTATE_INFO)
#define DH_ALARM_TELEPHONE_CHECK           0X31e3          // �ֻ������ϱ��¼�(��Ӧ�ṹ�� ALARM_TELEPHONE_CHECK_INFO)
#define DH_ALARM_PASTE_DETECTION           0x31e4          // �����¼�(��Ӧ�ṹ�� ALARM_PASTE_DETECTION_INFO )
#define DH_ALARM_SHOOTINGSCORERECOGNITION  0x31e5          // �������¼�(��Ӧ�ṹ�� ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO)
#define DH_ALARM_SWIPEOVERTIME             0X31e6          // ��ʱδˢ���¼�(��Ӧ�ṹ�� ALARM_SWIPE_OVERTIME_INFO)
#define DH_ALARM_DRIVING_WITHOUTCARD       0X31e7          // �޿���ʻ�¼�(��Ӧ�ṹ�� ALARM_DRIVING_WITHOUTCARD_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION 0x31e8  //������¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO ) 
#define DH_ALARM_FIGHTDETECTION            0x31e9          // ��Ź�¼�(��Ӧ�ṹ�� NET_ALARM_FIGHTDETECTION)
#define DH_ALARM_OIL_4G_OVERFLOW           0x31ea          // ��ɽ����4G����������ֵ�ı����¼�(��Ӧ�ṹ�� NET_ALARM_OIL_4G_OVERFLOW_INFO)
#define DH_ALARM_ACCESSIDENTIFY            0X31eb          // VTO����ʶ���¼�(��Ӧ�ṹ�� NET_ALARM_ACCESSIDENTIFY)
#define DH_ALARM_POWER_SWITCHER_ALARM      0x31ec          // �����Դ����״̬�쳣�����¼�(��Ӧ�ṹ�� DEV_ALRAM_POWERSWITCHER_INFO)
#define DH_ALARM_SCENNE_CHANGE_ALARM       0x31ed          // ��������¼�(��Ӧ�ṹ�� ALARM_PIC_SCENECHANGE_INFO)ԭ����VideoAbnormalDetection��SceneChange���¼���������������Ϊ�����¼�����
#define DH_ALARM_WIFI_VIRTUALINFO_SEARCH   0x31ef          // WIFI��������ϱ��¼�(��Ӧ�ṹ�� ALARM_WIFI_VIRTUALINFO_SEARCH_INFO)
#define DH_ALARM_TRAFFIC_OVERSPEED         0x31f0          // �����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_OVERSPEED_INFO)
#define DH_ALARM_TRAFFIC_UNDERSPEED        0x31f1          // Ƿ���¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_UNDERSPEED_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRAIN        0x31f2          // ��ͨ�����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_PEDESTRAIN_INFO)
#define DH_ALARM_TRAFFIC_JAM               0x31f3          // ��ͨӵ���¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_JAM)
#define DH_ALARM_TRAFFIC_PARKING           0x31f4          // Υ��ͣ���¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_PARKING_INFO)
#define DH_ALARM_TRAFFIC_THROW             0x31f5          // ��ͨ������Ʒ�¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_THROW_INFO)
#define DH_ALARM_TRAFFIC_RETROGRADE        0x31f6          // �����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_RETROGRADE_INFO)
#define DH_ALARM_VTSTATE_UPDATE            0x31f7          // VTS״̬�ϱ�(��Ӧ�ṹ�� ALARM_VTSTATE_UPDATE_INFO)
#define DH_ALARM_CALL_NO_ANSWERED          0x31f8          // ֱ������£�����޴�Ӧ�¼�(��Ӧ�ṹ�� NET_ALARM_CALL_NO_ANSWERED_INFO)
#define DH_ALARM_USER_LOCK_EVENT           0x31f9          // �û����������¼�
#define DH_ALARM_RETROGRADE_DETECTION      0x31fa          // ��Ա�����¼�(��Ӧ�ṹ�� ALARM_RETROGRADE_DETECTION_INFO)
#define DH_ALARM_AIO_APP_CONFIG_EVENT      0x31fb          // AIO�����¼�(��Ӧ�ṹ�� ALARM_AIO_APP_CONFIG_EVENT)
#define DH_ALARM_RAID_STATE_EX             0x31fc          // RAID�쳣����(��Ӧ�ṹ�� ALARM_RAID_INFO_EX)
#define DH_ALARM_STORAGE_IPC_FAILURE       0x31fd          // IPC�Ĵ洢���ʹ����¼�(IPC SD���쳣)(��Ӧ�ṹ�� ALARM_STORAGE_IPC_FAILURE_INFO)
#define DH_ALARM_DEVICE_STAY               0x31fe          // ��ֹ����,����豸������ָ��ʱ����û�б仯��������ֹ������Ϣ(��Ӧ�Ľṹ�� ALARM_DEVICE_STAY_INFO)
#define DH_ALARM_SUB_WAY_DOOR_STATE        0x31ff          // ����������״̬(��Ӧ�ṹ�� ALARM_SUB_WAY_DOOR_STATE_INFO)
#define DH_ALARM_SUB_WAY_PECE_SWITCH       0x3200          // ����PECE����״̬(��Ӧ�ṹ�� ALARM_SUB_WAY_PECE_SWITCH_INFO)
#define DH_ALARM_SUB_WAY_FIRE_ALARM        0x3201          // �������¼�(��Ӧ�ṹ�� ALARM_SUB_WAY_FIRE_ALARM_INFO)
#define DH_ALARM_SUB_WAY_EMER_HANDLE       0x3202          // �����˿ͽ��ֱ�����(��Ӧ�ṹ�� ALARM_SUB_WAY_EMER_HANDLE_INFO)
#define DH_ALARM_SUB_WAY_CAB_COVER         0x3203          // ����˾���Ҹǰ�״̬(��Ӧ�ṹ�� ALARM_SUB_WAY_CAB_COVER_INFO)
#define DH_ALARM_SUB_WAY_DERA_OBST         0x3204          // ������⵽�ϰ�����ѹ�(��Ӧ�ṹ�� ALARM_SUB_WAY_DERA_OBST_INFO)
#define DH_ALARM_SUB_WAY_PECU_CALL         0x3205          // �������ұ�����״̬(��Ӧ�ṹ�� ALARM_SUB_WAY_PECU_CALL_INFO)
#define DH_ALARM_BOX                       0x3206          // �������ӱ����¼� (��Ӧ�ṹ�� ALARM_BOX_INFO)
#define DH_ALARM_DOOR_CLOSEDMANUALLY       0x3207          // ��Ϊ�����¼�(��Ӧ�ṹ�� ALARM_DOOR_CLOSEDMANUALLY_INFO)
#define DH_ALARM_DOOR_NOTCLOSED_LONGTIME   0x3208          // �ų���ʱ��δ�ر����¼�(��Ӧ�ṹ�� ALARM_DOOR_NOTCLOSED_LONGTIME_INFO)
#define DH_ALARM_UNDER_VOLTAGE             0X3209          // ��ѹ����9V, ��ԴǷѹ����, ��Ƶ���Ժ�ɫOSDͼ�������ʽ���� (��Ӧ�ṹ�� ALARM_UNDER_VOLTAGE_INFO ) 
#define DH_ALARM_OVER_VOLTAGE              0x320a          // ��ѹ����19V, ��Դ��ѹ����, ��Ƶ���Ժ�ɫOSDͼ�������ʽ���� (��Ӧ�ṹ�� ALARM_OVER_VOLTAGE_INFO ) 
#define DH_ALARM_CUT_LINE                  0x320b          // ��ϱ���(��Ӧ�ṹ��ALARM_CUT_LINE_INFO)
#define DH_ALARM_VIDEOMOTION_EVENT         0x320c          // �����¼�(��Ӧ�ṹ�� ALARM_VIDEOMOTION_EVENT_INFO)
#define DH_ALARM_WIDE_VIEW_REGION_EVENT    0x320d          // WideViewRegions�¼�(��Ӧ�ṹ�� ALARM_WIDE_VIEW_REGION_EVENT_INFO) ������Ŀ�����¼���Aƽ̨�����¼�������������¼�ת����Bƽ̨
#define DH_ALARM_FIBRE_OPTIC_ABORT         0x320e          // ���˱���(��Ӧ�ṹ�� ALARM_FIBRE_OPTIC_ABORT)
#define DH_ALARM_TAIL_DETECTION            0x320f          // β���¼�(��Ӧ�ṹ�� ALARM_TAIL_DETECTION_INFO)
#define DH_ALARM_BITRATES_OVERLIMIT        0x3210          // �����������ͨ�������񱨾�(��Ӧ�ṹ�� ALARM_BITRATES_OVERLIMIT_INFO)
#define DH_ALARM_RECORD_CHANGED_EX         0x3211          // ¼��״̬�仯����(��Ӧ�ṹ�� ALARM_RECORD_CHANGED_INFO_EX)
#define DH_ALARM_HIGH_DECIBEL              0x3212          // ����߷ֱ���ⱨ��(��Ӧ�ṹ�� ALARM_HIGH_DECIBEL_INFO)
#define DH_ALARM_SHAKE_DETECTION           0x3213          // ҡ�μ�ⱨ��(��Ӧ�ṹ�� ALARM_SHAKE_DETECTION_INFO)
#define DH_ALARM_TUMBLE_DETECTION          0x3214          // ���ر����¼�(��Ӧ�ṹ�� ALARM_TUMBLE_DETECTION_INFO)
#define DH_ALARM_ACCESS_CTL_MALICIOUS      0x3215          // ���⿪���¼�(��Ӧ�ṹ�� ALARM_ACCESS_CTL_MALICIOUS)
#define DH_ALARM_ACCESS_CTL_USERID_REGISTER 0x3216         // �û���ע���¼�(��Ӧ�ṹ�� ALARM_ACCESS_CTL_USERID_REGISTER)
#define DH_ALARM_ACCESS_CTL_REVERSELOCK    0X3217          // ����״̬��Ϣ�仯�¼�(��Ӧ�ṹ�� ALARM_ACCESS_CTL_REVERSELOCK)
#define DH_ALARM_ACCESS_CTL_USERID_DELETE  0X3218          // ɾ���û��¼�(��Ӧ�ṹ�� ALARM_ACCESS_CTL_USERID_DELETE)
#define DH_ALARM_ACCESS_DOOR_BELL          0x3219          // �����¼�(��Ӧ�ṹ�� ALARM_ACCESS_DOOR_BELL_INFO)
#define DH_ALARM_ACCESS_FACTORY_RESET      0x321a          // �����ָ�����(��Ӧ�ṹ�� ALARM_ACCESS_FACTORY_RESET)
#define DH_ALARM_POLICE_RECORD_PROGRESS    0x321b          // MPT¼����NVR�Ľ����¼�(��Ӧ�ṹ�� ALARM_POLICE_RECORD_PROGRESS_INFO)
#define DH_ALARM_POLICE_PLUGIN             0x321c          // MPT����γ��豸�¼�(��Ӧ�ṹ�� ALARM_POLICE_PLUGIN_INFO)
#define DH_ALARM_GPS_NOT_ALIGNED           0x321d          // GPSδ��λ����(��Ӧ�ṹ�� ALARM_GPS_NOT_ALIGNED_INFO)
#define DH_ALARM_WIRELESS_NOT_CONNECTED    0x321e          // ����δ���ӱ���(����wifi��3G/4G)(��Ӧ�ṹ�� ALARM_WIRELESS_NOT_CONNECTED_INFO)
#define DH_ALARM_CABINET                   0x321f          // �ƹ��豸���͵���Ʒ��ŵ�����Ϣʵʱ�ϱ��¼�(��Ӧ�ṹ�� ALARM_CABINET_INFO)
#define DH_SWITCH_SCREEN                   0x3220          // �л���Ļ�¼�
#define DH_ALARM_NEAR_DISTANCE_DETECTION   0x3221            // ������Ӵ�����(��Ӧ�ṹ��ALARM_NEAR_DISTANCE_INFO)
#define DH_ALARM_MAN_STAND_DETECTION       0x3222            // �����Ӿ�վ������(��Ӧ�ṹ��ALARM_MAN_STAND_INFO)
#define DH_ALARM_MAN_NUM_DETECTION         0x3223            // �����Ӿ�����������ͳ�Ʊ���(��Ӧ�ṹ��ALARM_MAN_NUM_INFO)
#define DH_MCS_GENERAL_CAPACITY_LOW        0x3224            // ΢�Ƴ��������¼�(��Ӧ�ṹ��ALARM_MCS_GENERAL_CAPACITY_LOW_INFO)
#define DH_MCS_DATA_NODE_OFFLINE           0x3225            // ΢�ƴ洢�ڵ������¼�(��Ӧ�ṹ��ALARM_MCS_DATA_NODE_OFFLINE_INFO)
#define DH_MCS_DISK_OFFLINE                0x3226            // ΢�ƴ��������¼�(��Ӧ�ṹ��ALARM_MCS_DISK_OFFLINE_INFO)
#define DH_MCS_DISK_SLOW                   0x3227            // ΢�ƴ��̱����¼�(��Ӧ�ṹ��ALARM_MCS_DISK_SLOW_INFO)
#define DH_MCS_DISK_BROKEN                 0x3228            // ΢�ƴ������¼�(��Ӧ�ṹ��ALARM_MCS_DISK_BROKEN_INFO)
#define DH_MCS_DISK_UNKNOW_ERROR           0x3229            // ΢�ƴ���δ֪�����¼�(��Ӧ�ṹ��ALARM_MCS_DISK_UNKNOW_ERROR_INFO)
#define DH_MCS_METADATA_SERVER_ABNORMAL    0x322a            // ΢��Ԫ���ݷ������쳣�¼�(��Ӧ�ṹ��ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO)
#define DH_MCS_CATALOG_SERVER_ABNORMAL     0x322b            // ΢��Ŀ¼�������쳣�¼�(��Ӧ�ṹ��ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO)
#define DH_MCS_GENERAL_CAPACITY_RESUME     0x322c            // ΢�Ƴ��������ָ��¼�(��Ӧ�ṹ��ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO)
#define DH_MCS_DATA_NODE_ONLINE            0x322d            // ΢�ƴ洢�ڵ������¼�(��Ӧ�ṹ��ALARM_MCS_DATA_NODE_ONLINE_INFO)
#define DH_MCS_DISK_ONLINE                 0x322e            // ΢�ƴ��������¼�(��Ӧ�ṹ��ALARM_MCS_DISK_ONLINE_INFO)
#define DH_MCS_METADATA_SLAVE_ONLINE       0x322f            // ΢��Ԫ���ݱ��������¼�(��Ӧ�ṹ��ALARM_MCS_METADATA_SLAVE_ONLINE_INFO)
#define DH_MCS_CATALOG_SERVER_ONLINE       0x3230            // ΢��Ŀ¼�����������¼�(��Ӧ�ṹ��ALARM_MCS_CATALOG_SERVER_ONLINE_INFO)
#define DH_ALARM_OFFLINE_LOGSYNC           0x3231            // ͬ��������־�¼�(��Ӧ�ṹ�� ALARM_OFFLINE_LOGSYNC_INFO)
#define DH_ALARM_UPGRADE_STATE             0X3232            // �豸����״̬�¼�(��Ӧ�ṹ�� ALARM_UPGRADE_STATE)
#define DH_ALARM_LABELINFO                 0x3233            // IPC����(2017.4),RFID��ǩ��Ϣ�ɼ��¼�(��Ӧ�ṹ�� ALARM_LABELINFO)
#define DH_ALARM_TIRED_PHYSIOLOGICAL       0x3234            // ����ƣ���¼�(��Ӧ�ṹ�� ALARM_TIRED_PHYSIOLOGICAL)
#define DH_ALARM_CALLING_WHEN_DRIVING      0x3235            // ������绰�¼�(��Ӧ�ṹ�� ALARM_CALLING_WHEN_DRIVING)
#define DH_ALARM_TRAFFIC_DRIVER_SMOKING    0x3236            // ���������¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_DRIVER_SMOKING)
#define DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD 0x3237            // ������ͷ�����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_DRIVER_LOWER_HEAD)
#define DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND     0x3238       // ����������α����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_DRIVER_LOOK_AROUND)
#define DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST      0x3239       // ������ڱ����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_DRIVER_LEAVE_POST)
#define DH_ALARM_TRAFFIC_DRIVER_YAWN            0x323a       // �������Ƿ�����¼�(��Ӧ�ṹ�� ALARM_TRAFFIC_DRIVER_YAWN)
#define DH_ALARM_AUTO_INSPECTION                0x323b       // �豸�Լ��¼�(��Ӧ�ṹ�� ALARM_AUTO_INSPECTION) 
#define DH_ALARM_TRAFFIC_VEHICLE_POSITION       0x323c       // ����λ���¼�(��Ӧ�Ľṹ�� ALARM_TRAFFIC_VEHICLE_POSITION)
#define DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP  0x323d       // ������֤����ץͼ��Ϣ�¼�(��Ӧ�ṹ�� ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO) 
#define DH_ALARM_VIDEOBLIND                0x323e            // ��Ƶ�ڵ��¼�(��Ӧ�ṹ��ALARM_VIDEO_BLIND_INFO)
#define DH_ALARM_DRIVER_NOTCONFIRM         0x323f            // ˾��δ��ȷ�ϰ�ť�����¼�(��Ӧ�ṹ��ALARM_DRIVER_NOTCONFIRM_INFO)
#define DH_ALARM_FACEINFO_COLLECT          0x3240            // ������Ϣ¼���¼�(��ӦALARM_FACEINFO_COLLECT_INFO)
#define DH_ALARM_HIGH_SPEED	               0x3241			 // �������ٱ����¼�(��ӦALARM_HIGH_SPEED_INFO)
#define DH_ALARM_VIDEO_LOSS                0x3242			 // ��Ƶ��ʧ�¼�(��Ӧ ALARM_VIDEO_LOSS_INFO)
#define DH_ALARM_MPTBASE_CONNECT           0x3243			 // �豸���������״̬�¼�(��Ӧ�ṹ��ALARM_MPTBASE_CONNECT) 
#define DH_ALARM_LATEST_SHUTDOWN           0x3244			 // �豸�ϴιػ�״̬�¼�(��Ӧ�ṹ�� ALARM_LATEST_SHUTDOWN)

#define DH_ALARM_ROBOT_COLLISION	        0x3245			// ��������ײ�¼�(��Ӧ�ṹ�� ALARM_ROBOT_COLLISION)
#define DH_ALARM_ROBOT_FALLENDOWN		    0x3246			// �����˵����¼�(��Ӧ�ṹ�� ALARM_ROBOT_FALLENDOWN)
#define DH_ALARM_ROBOT_UNRECOGNIZED2DCODE   0x3247			// �����˶�λ��ʶ��ʧ���¼�(��Ӧ�ṹ�� ALARM_ROBOT_UNRECOGNIZED2DCODE) 
#define DH_ALARM_ROBOT_WRONG2DCODE	        0x3248			// �����˴����λ���¼�(��Ӧ�Ľṹ�� ALARM_ROBOT_WRONG2DCODE)
#define DH_ALARM_ROBOT_ROADBLOCKED	        0x3249		    // ������·���¼�(��Ӧ�ṹ�� ALARM_ROBOT_ROADBLOCKED) 
#define DH_ALARM_ROBOT_FAULT				0x324a			// �����˹����¼�(��Ӧ�ṹ�� ALARM_ROBOT_FAULT)
#define DH_ALARM_ROBOT_OVERLOAD			    0x324b			// �����˳����¼�(��Ӧ�ṹ�� ALARM_ROBOT_OVERLOAD)
#define DH_ALARM_ROBOT_YAWEXCEPTION		    0x324c			// ����������ƫ���¼�(��Ӧ ALARM_ROBOT_YAWEXCEPTION)

#define DH_ALARM_VIDEO_TALK_PATH		    0x324d			 // �Խ�·���¼�(��Ӧ�ṹ�� ALARM_VIDEO_TALK_PATH_INFO)

#define DH_ALARM_ROBOT_LOADTIMEOUT		    0x324e			// ����������ƫ���¼�(��Ӧ ALARM_ROBOT_LOADTIMEOUT )
#define DH_ALARM_ROBOT_UNLOADTIMEOUT		0x324f			// �����������쳣�¼�(��Ӧ ALARM_ROBOT_UNLOADTIMEOUT)
#define DH_ALARM_ROBOT_MAPUPDATE		    0x3250			// ������ж���쳣�¼�(��Ӧ ALARM_ROBOT_MAPUPDATE)

// �¼�����
#define DH_CONFIG_RESULT_EVENT_EX           0x3000           // �޸����õķ����룻���ؽṹ��DEV_SET_RESULT
#define DH_REBOOT_EVENT_EX                  0x3001           // �豸�����¼������δ������������,��ǰ�޸ĵ����ò���������Ч
#define DH_AUTO_TALK_START_EX               0x3002           // �豸�������뿪ʼ����Խ�
#define DH_AUTO_TALK_STOP_EX                0x3003           // �豸����ֹͣ����Խ�
#define DH_CONFIG_CHANGE_EX                 0x3004           // �豸���÷����ı�
#define DH_IPSEARCH_EVENT_EX                0x3005           // IP�����¼�, �����ַ�����ʽ����:DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay&&DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay &&��
#define DH_AUTO_RECONNECT_FAILD             0x3006           // �Զ�����ʧ���¼�
#define DH_REALPLAY_FAILD_EVENT             0x3007           // ����ʧ���¼�,���ؽṹ��DEV_PLAY_RESULT
#define DH_PLAYBACK_FAILD_EVENT             0x3008           // �ط�ʧ���¼�,���ؽṹ��DEV_PLAY_RESULT   
#define DH_IVS_TRAFFIC_REALFLOWINFO         0x3009           // ��ͨʵʱ������Ϣ�¼�ALARM_IVS_TRAFFIC_REALFLOW_INFO
#define DH_DEVICE_ABORT_EVENT               0x300a           // �ͻ��˱��߳�, ��Ӧ�ṹ�� DEV_CLIENT_ABORT_INFO
#define DH_TALK_FAILD_EVENT                 0x300b           // ��������Խ�ʧ��, ��Ӧ�ṹ�� DEV_TALK_RESULT
#define DH_START_LISTEN_FINISH_EVENT        0x300c           // �����¼��ӿ�����첽֪ͨ�¼�, ��ϢΪNULL
#define DH_YUEQINGLIGHTING_STATE_EVENT      0x300d             // ƽ̨ͳ�Ƶƹ⿪�ص�ʱ���¼�, ��Ӧ�Ľṹ�� DEV_YUEQINGLIGHTING_STATE_INFO
#define DH_ALARM_VIOLATE_NO_FLY_TIME        0x300e           // Υ�������¼�, ��Ӧ�ṹ�� ALARM_VIOLATE_NO_FLY_TIME_INFO              
#define DH_ALARM_BOX_ALARM			        0x300f		    // ������ͨ���Ĵ��������¼� (��Ӧ�ṹ�� ALARM_BOX_ALARM_INFO )


// �����ϴ����ܵı�������,��ӦCLIENT_StartService�ӿڡ�NEW_ALARM_UPLOAD�ṹ��.
#define DH_UPLOAD_ALARM                     0x4000           // �ⲿ����            
#define DH_UPLOAD_MOTION_ALARM              0x4001           // ��̬��ⱨ��
#define DH_UPLOAD_VIDEOLOST_ALARM           0x4002           // ��Ƶ��ʧ����
#define DH_UPLOAD_SHELTER_ALARM             0x4003           // ��Ƶ�ڵ�����
#define DH_UPLOAD_SOUND_DETECT_ALARM        0x4004           // ��Ƶ��ⱨ��
#define DH_UPLOAD_DISKFULL_ALARM            0x4005           // Ӳ��������
#define DH_UPLOAD_DISKERROR_ALARM           0x4006           // ��Ӳ�̱���
#define DH_UPLOAD_ENCODER_ALARM             0x4007           // ����������
#define DH_UPLOAD_DECODER_ALARM             0x400B           // ��������������
#define DH_UPLOAD_EVENT                     0x400C           // ��ʱ�ϴ���
#define DH_UPLOAD_IVS                       0x400D           // ���ܱ���, ��Ӧ�ṹ��ALARM_UPLOAD_IVS_INFO
#define DH_UPLOAD_SMOKESENSOR_ALARM         0x400E           // �̸б���, ��Ӧ�ṹ��ALARM_UPLOAD_SMOKESENSOR_INFO
#define DH_UPLOAD_ALARM_EX                  0x400F           // �ⲿ������չ,��Ӧ�ṹ�� ALARM_UPLOAD_ALARMEX_INFO 
#define DH_UPLOAD_REMOTE_LOGIN_FAILD_ALARM  0x4010           // Զ�̵�¼ʧ�ܱ���, ��Ӧ�ṹ�� ALARM_UPLOAD_LOGIN_FAILED_INFO
#define DH_UPLOAD_CUSTOM                    0x4011           // ��չ�ֶ��ɿͻ��Զ���,pParam:��չ����ָ��,dwParamLen:��չ���ݳ���
#define DH_UPLOAD_FRONTDISCONNECT_ALARM     0x4012           // ǰ�˶�������, ��Ӧ�ṹ�� NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_IPC                 0x4013           // IPC�ⲿ����, ��Ӧ�ṹ�� NEW_ALARM_UPLOAD
#define DH_UPLOAD_NET_ALARM                 0x4014           // ���籨������(���紥��,�����豸�������뱨�����ź�), ��Ӧ�ṹ�� NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_RAID                0x4015           // Raid�쳣�¼�, ��Ӧ�ṹ�� NEW_ALARM_UPLOAD
#define DH_UPLOAD_SCENE_CHANGE              0X4016           // �������, ��Ӧ�ṹ�� NEW_ALARM_UPLOAD

// ����Bus״̬��Ӧ�¼��ϱ�(CLIENT_AttachBusState)
#define DH_ALARM_BUS_DRIVER_CHECK         0X0001           // ˾��ǩ���¼�(��Ӧ�ṹ�� ALARM_BUS_DRIVER_CHECK_INFO)
#define DH_ALARM_BUS_IMPORT_SITE          0x0002           // ��վ�¼�(��Ӧ�ṹ�� ALARM_BUS_IMPORT_SITE_INFO)
#define DH_ALARM_BUS_EXPORT_SITE          0x0003           // ��վ�¼�(��Ӧ�ṹ�� ALARM_BUS_EXPORT_SITE_INFO)
#define DH_ALARM_BUS_ABNORMAL             0x0004           // �����쳣�¼�(��Ӧ�ṹ�� ALARM_BUS_ABNORMAL_INFO)
#define DH_ALARM_BUS_DOOR_OPEN            0x0005           // ���Ŵ��¼�(��Ӧ�ṹ�� ALARM_VEHICLE_DOOR_OPEN_INFO)
#define DH_ALARM_BUS_CUR_MILEAGE          0x0006           // ��ǰ����¼�(��Ӧ�ṹ�� ALARM_BUS_CUR_MILEAGE_INFO)
#define DH_ALARM_BUS_CUR_OIL              0x0007           // ��ǰ�ͺ�����¼�(��Ӧ�ṹ�� ALARM_BUS_CUR_OIL_INFO)
#define DH_ALARM_BUS_LOW_OIL              0x0008           // �����������¼�(��Ӧ�ṹ�� ALARM_BUS_LOW_OIL_INFO)
#define DH_ALARM_BUS_PASSENGER_CARD_CHECK 0x0009           // �˿�ˢ���¼�(��Ӧ�ṹ�� ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_BUS_VEHICLE_STANDING_OVER_TIME 0x000a     // ͣ����ʱ�¼�(��Ӧ�ṹ�� ALARM_VEHICLE_STANDING_OVER_TIME_INFO )
#define DH_ALARM_BUS_DRIVE_AFTER_WORK     0x000b           // �ǹ���ʱ���¼�(��Ӧ�ṹ�� ALARM_DVRIVE_AFTER_WORK )
#define DH_ALARM_BUS_PAD_SHUTDOWN         0x000c           // PAD�ػ��¼�, DVR�ϱ�PadShutdown��Ϣ, PAD�յ����Զ���ʱ�ػ�(��Ӧ�ṹ�� ALARM_BUS_PAD_SHUTDOWN_INFO)
#define DH_ALARM_BUS_TIRED_DRIVE_CHECK    0x000d           // ƣ�ͼ�ʻ�¼�(��Ӧ�ṹ�� ALARM_TIRED_DRIVE_CHECK_INFO )
#define DH_ALARM_BUS_STEAL_OIL            0x000e           // ͵���¼�(��Ӧ�ṹ�� ALARM_BUS_STEAL_OIL_INFO)

// �첽�ӿڻص�����
#define RESPONSE_DECODER_CTRL_TV          0x00000001       // ��ӦCLIENT_CtrlDecTVScreen�ӿ�
#define RESPONSE_DECODER_SWITCH_TV        0x00000002       // ��ӦCLIENT_SwitchDecTVEncoder�ӿ�
#define RESPONSE_DECODER_PLAYBACK         0x00000003       // ��ӦCLIENT_DecTVPlayback�ӿ�
#define RESPONSE_EXCHANGE_DATA            0X00000004       // ��ӦCLIENT_ExchangeData�ӿ�
#define RESPONSE_ASYN_QUERY_RECORDFILE    0X00000005       // ��ӦCLIENT_StartQueryRecordFile�ӿ�

// CLIENT_FileTransmit�ӿڴ����ļ�����
#define DH_DEV_UPGRADEFILETRANS_START     0x0000           // ��ʼ�����ļ��ϴ�(��Ӧ�ṹ�� DHDEV_UPGRADE_FILE_INFO)
#define DH_DEV_UPGRADEFILETRANS_SEND      0x0001           // ���������ļ�  
#define DH_DEV_UPGRADEFILETRANS_STOP      0x0002           // ֹͣ���������ļ�
#define DH_DEV_BLACKWHITETRANS_START      0x0003           // ��ʼ���ͺڰ�����(��Ӧ�ṹ�� DHDEV_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITETRANS_SEND       0x0004           // ���ͺڰ�����
#define DH_DEV_BLACKWHITETRANS_STOP       0x0005           // ֹͣ���ͺڰ����� 
#define DH_DEV_BLACKWHITE_LOAD            0x0006           // ���غڰ�����(��Ӧ�ṹ��DHDEV_LOAD_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITE_LOAD_STOP       0x0007           // ֹͣ���غڰ�����
#define DH_DEV_FILETRANS_STOP             0x002B           // ֹͣ�ļ��ϴ�
#define DH_DEV_FILETRANS_BURN             0x002C           // ��¼�ļ��ϴ�

// �ֱ����б�,������ֱ�����������롢�����
#define DH_CAPTURE_SIZE_D1                0x00000001
#define DH_CAPTURE_SIZE_HD1               0x00000002
#define DH_CAPTURE_SIZE_BCIF              0x00000004
#define DH_CAPTURE_SIZE_CIF               0x00000008
#define DH_CAPTURE_SIZE_QCIF              0x00000010    
#define DH_CAPTURE_SIZE_VGA               0x00000020    
#define DH_CAPTURE_SIZE_QVGA              0x00000040
#define DH_CAPTURE_SIZE_SVCD              0x00000080
#define DH_CAPTURE_SIZE_QQVGA             0x00000100
#define DH_CAPTURE_SIZE_SVGA              0x00000200
#define DH_CAPTURE_SIZE_XVGA              0x00000400
#define DH_CAPTURE_SIZE_WXGA              0x00000800
#define DH_CAPTURE_SIZE_SXGA              0x00001000
#define DH_CAPTURE_SIZE_WSXGA             0x00002000   
#define DH_CAPTURE_SIZE_UXGA              0x00004000
#define DH_CAPTURE_SIZE_WUXGA             0x00008000
#define DH_CAPTURE_SIZE_LFT               0x00010000
#define DH_CAPTURE_SIZE_720               0x00020000
#define DH_CAPTURE_SIZE_1080              0x00040000
#define DH_CAPTURE_SIZE_1_3M              0x00080000
#define DH_CAPTURE_SIZE_2M                0x00100000
#define DH_CAPTURE_SIZE_5M                0x00200000
#define DH_CAPTURE_SIZE_3M                0x00400000                
#define DH_CAPTURE_SIZE_5_0M              0x00800000
#define DH_CPTRUTE_SIZE_1_2M              0x01000000    
#define DH_CPTRUTE_SIZE_1408_1024         0x02000000    
#define DH_CPTRUTE_SIZE_8M                0x04000000    
#define DH_CPTRUTE_SIZE_2560_1920         0x08000000
#define DH_CAPTURE_SIZE_960H              0x10000000
#define DH_CAPTURE_SIZE_960_720           0x20000000

// ����ģʽ�б�,���������ģʽ��������롢�����
#define DH_CAPTURE_COMP_DIVX_MPEG4        0x00000001
#define DH_CAPTURE_COMP_MS_MPEG4          0x00000002
#define DH_CAPTURE_COMP_MPEG2             0x00000004
#define DH_CAPTURE_COMP_MPEG1             0x00000008
#define DH_CAPTURE_COMP_H263              0x00000010
#define DH_CAPTURE_COMP_MJPG              0x00000020
#define DH_CAPTURE_COMP_FCC_MPEG4         0x00000040
#define DH_CAPTURE_COMP_H264              0x00000080
#define DH_CAPTURE_COMP_H265              0x00000100
#define DH_CAPTURE_COMP_SVAC              0x00000200

// ������������,�����뱨������������������롢�����
#define DH_ALARM_UPLOAD                   0x00000001
#define DH_ALARM_RECORD                   0x00000002
#define DH_ALARM_PTZ                      0x00000004
#define DH_ALARM_MAIL                     0x00000008
#define DH_ALARM_TOUR                     0x00000010
#define DH_ALARM_TIP                      0x00000020
#define DH_ALARM_OUT                      0x00000040
#define DH_ALARM_FTP_UL                   0x00000080
#define DH_ALARM_BEEP                     0x00000100
#define DH_ALARM_VOICE                    0x00000200
#define DH_ALARM_SNAP                     0x00000400

// "�ָ�Ĭ������"����,�ɽ����롢�����, �ӿ�CLIENT_ControlDevice����DH_CTRL_RESTOREDEFAULT
#define DH_RESTORE_COMMON                 0x00000001       // ��ͨ����
#define DH_RESTORE_CODING                 0x00000002       // ��������
#define DH_RESTORE_VIDEO                  0x00000004       // ¼������
#define DH_RESTORE_COMM                   0x00000008       // ��������
#define DH_RESTORE_NETWORK                0x00000010       // ��������
#define DH_RESTORE_ALARM                  0x00000020       // ��������
#define DH_RESTORE_VIDEODETECT            0x00000040       // ��Ƶ���
#define DH_RESTORE_PTZ                    0x00000080       // ��̨����
#define DH_RESTORE_OUTPUTMODE             0x00000100       // ���ģʽ
#define DH_RESTORE_CHANNELNAME            0x00000200       // ͨ������
#define DH_RESTORE_VIDEOINOPTIONS         0x00000400       // ����ͷ����
#define DH_RESTORE_CPS                    0x00000800       // ���ܽ�ͨ
#define DH_RESTORE_INTELLIGENT            0x00001000       // ��Ƶ����
#define DH_RESTORE_REMOTEDEVICE           0x00002000       // Զ���豸����
#define DH_RESTORE_DECODERVIDEOOUT        0x00004000       // ������Ѳ
#define DH_RESTORE_LINKMODE               0x00008000       // ����ģʽ
#define DH_RESTORE_COMPOSITE              0x00010000       // �ں���    
#define DH_RESTORE_ALL                    0x80000000       // ȫ������

// ��̨�����б�--���ĸ��ֽ�����
#define PTZ_DIRECTION                     0x00000001       // ����
#define PTZ_ZOOM                          0x00000002       // �䱶
#define PTZ_FOCUS                         0x00000004       // �۽�
#define PTZ_IRIS                          0x00000008       // ��Ȧ
#define PTZ_ALARM                         0x00000010       // ��������
#define PTZ_LIGHT                         0x00000020       // �ƹ�
#define PTZ_SETPRESET                     0x00000040       // ����Ԥ�õ�
#define PTZ_CLEARPRESET                   0x00000080       // ���Ԥ�õ�
#define PTZ_GOTOPRESET                    0x00000100       // ת��Ԥ�õ�
#define PTZ_AUTOPANON                     0x00000200       // ˮƽ��ʼ
#define PTZ_AUTOPANOFF                    0x00000400       // ˮƽ����
#define PTZ_SETLIMIT                      0x00000800       // ���ñ߽�
#define PTZ_AUTOSCANON                    0x00001000       // �Զ�ɨ�迪ʼ
#define PTZ_AUTOSCANOFF                   0x00002000       // �Զ�ɨ�迪ֹͣ
#define PTZ_ADDTOUR                       0x00004000       // ����Ѳ����
#define PTZ_DELETETOUR                    0x00008000       // ɾ��Ѳ����
#define PTZ_STARTTOUR                     0x00010000       // ��ʼѲ��
#define PTZ_STOPTOUR                      0x00020000       // ����Ѳ��
#define PTZ_CLEARTOUR                     0x00040000       // ɾ��Ѳ��
#define PTZ_SETPATTERN                    0x00080000       // ����ģʽ
#define PTZ_STARTPATTERN                  0x00100000       // ��ʼģʽ
#define PTZ_STOPPATTERN                   0x00200000       // ֹͣģʽ
#define PTZ_CLEARPATTERN                  0x00400000       // ���ģʽ
#define PTZ_POSITION                      0x00800000       // ���ٶ�λ
#define PTZ_AUX                           0x01000000       // ��������
#define PTZ_MENU                          0x02000000       // ����˵�
#define PTZ_EXIT                          0x04000000       // �˳�����˵�
#define PTZ_ENTER                         0x08000000       // ȷ��
#define PTZ_ESC                           0x10000000       // ȡ��
#define PTZ_MENUUPDOWN                    0x20000000       // �˵����²���
#define PTZ_MENULEFTRIGHT                 0x40000000       // �˵����Ҳ���
#define PTZ_OPT_NUM                       0x80000000       // �����ĸ���

// ���ĸ��ֽ�����
#define PTZ_DEV                           0x00000001       // ��̨����
#define PTZ_MATRIX                        0x00000002       // �������

// ץͼ��Ƶ��������
#define CODETYPE_MPEG4                    0
#define CODETYPE_H264                     1
#define CODETYPE_JPG                      2

// ���������б�
#define DH_CAPTURE_BRC_CBR                0
#define DH_CAPTURE_BRC_VBR                1
//#define DH_CAPTURE_BRC_MBR              2

// ֡�������붨��
#define FRAME_TYPE_MOTION                       0x00000001       // ����֡

// ���ܷ����¼�����
#define EVENT_IVS_ALL                           0x00000001        // ���������¼�
#define EVENT_IVS_CROSSLINEDETECTION            0x00000002        // �������¼�(��Ӧ DEV_EVENT_CROSSLINE_INFO)
#define EVENT_IVS_CROSSREGIONDETECTION          0x00000003        // �������¼�(��Ӧ DEV_EVENT_CROSSREGION_INFO)
#define EVENT_IVS_PASTEDETECTION                0x00000004        // �����¼�(��Ӧ DEV_EVENT_PASTE_INFO)
#define EVENT_IVS_LEFTDETECTION                 0x00000005        // ��Ʒ�����¼�(��Ӧ DEV_EVENT_LEFT_INFO)
#define EVENT_IVS_STAYDETECTION                 0x00000006        // ͣ���¼�(��Ӧ DEV_EVENT_STAY_INFO)
#define EVENT_IVS_WANDERDETECTION               0x00000007        // �ǻ��¼�(��Ӧ DEV_EVENT_WANDER_INFO)
#define EVENT_IVS_PRESERVATION                  0x00000008        // ��Ʒ��ȫ�¼�(��Ӧ DEV_EVENT_PRESERVATION_INFO)
#define EVENT_IVS_MOVEDETECTION                 0x00000009        // �ƶ��¼�(��Ӧ DEV_EVENT_MOVE_INFO)
#define EVENT_IVS_TAILDETECTION                 0x0000000A        // β���¼�(��Ӧ DEV_EVENT_TAIL_INFO)
#define EVENT_IVS_RIOTERDETECTION               0x0000000B        // �����¼�(��Ӧ DEV_EVENT_RIOTERL_INFO)
#define EVENT_IVS_FIREDETECTION                 0x0000000C        // ���¼�(��Ӧ DEV_EVENT_FIRE_INFO)
#define EVENT_IVS_SMOKEDETECTION                0x0000000D        // �������¼�(��Ӧ DEV_EVENT_SMOKE_INFO)
#define EVENT_IVS_FIGHTDETECTION                0x0000000E        // ��Ź�¼�(��Ӧ DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_FLOWSTAT                      0x0000000F        // ����ͳ���¼�(��Ӧ DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_NUMBERSTAT                    0x00000010        // ����ͳ���¼�(��Ӧ DEV_EVENT_NUMBERSTAT_INFO)
#define EVENT_IVS_CAMERACOVERDDETECTION         0x00000011        // ����ͷ�����¼�(����)
#define EVENT_IVS_CAMERAMOVEDDETECTION          0x00000012        // ����ͷ�ƶ��¼�(����)
#define EVENT_IVS_VIDEOABNORMALDETECTION        0x00000013        // ��Ƶ�쳣�¼�(��Ӧ DEV_EVENT_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_VIDEOBADDETECTION             0x00000014        // ��Ƶ���¼�(����)
#define EVENT_IVS_TRAFFICCONTROL                0x00000015        // ��ͨ�����¼�(��Ӧ DEV_EVENT_TRAFFICCONTROL_INFO)
#define EVENT_IVS_TRAFFICACCIDENT               0x00000016        // ��ͨ�¹��¼�(��Ӧ DEV_EVENT_TRAFFICACCIDENT_INFO)
#define EVENT_IVS_TRAFFICJUNCTION               0x00000017        // ��ͨ·���¼�----�Ϲ���(��Ӧ DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_TRAFFICGATE                   0x00000018        // ��ͨ�����¼�----�Ϲ���(��Ӧ DEV_EVENT_TRAFFICGATE_INFO)
#define EVENT_TRAFFICSNAPSHOT                   0x00000019        // ��ͨץ���¼�(��Ӧ DEV_EVENT_TRAFFICSNAPSHOT_INFO)
#define EVENT_IVS_FACEDETECT                    0x0000001A        // ��������¼� (��Ӧ DEV_EVENT_FACEDETECT_INFO)
#define EVENT_IVS_TRAFFICJAM                    0x0000001B        // ��ͨӵ���¼�(��Ӧ DEV_EVENT_TRAFFICJAM_INFO)
#define EVENT_IVS_TRAFFIC_RUNREDLIGHT           0x00000100        // ��ͨΥ��-������¼�(��Ӧ DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_OVERLINE              0x00000101        // ��ͨΥ��-ѹ�������¼�(��Ӧ DEV_EVENT_TRAFFIC_OVERLINE_INFO)
#define EVENT_IVS_TRAFFIC_RETROGRADE            0x00000102        // ��ͨΥ��-�����¼�(��Ӧ DEV_EVENT_TRAFFIC_RETROGRADE_INFO)
#define EVENT_IVS_TRAFFIC_TURNLEFT              0x00000103        // ��ͨΥ��-Υ����ת(��Ӧ DEV_EVENT_TRAFFIC_TURNLEFT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHT             0x00000104        // ��ͨΥ��-Υ����ת(��Ӧ DEV_EVENT_TRAFFIC_TURNRIGHT_INFO)
#define EVENT_IVS_TRAFFIC_UTURN                 0x00000105        // ��ͨΥ��-Υ�µ�ͷ(��Ӧ DEV_EVENT_TRAFFIC_UTURN_INFO)
#define EVENT_IVS_TRAFFIC_OVERSPEED             0x00000106        // ��ͨΥ��-����(��Ӧ DEV_EVENT_TRAFFIC_OVERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_UNDERSPEED            0x00000107        // ��ͨΥ��-����(��Ӧ DEV_EVENT_TRAFFIC_UNDERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_PARKING               0x00000108        // ��ͨΥ��-Υ��ͣ��(��Ӧ DEV_EVENT_TRAFFIC_PARKING_INFO)
#define EVENT_IVS_TRAFFIC_WRONGROUTE            0x00000109        // ��ͨΥ��-����������ʻ(��Ӧ DEV_EVENT_TRAFFIC_WRONGROUTE_INFO)
#define EVENT_IVS_TRAFFIC_CROSSLANE             0x0000010A        // ��ͨΥ��-Υ�±��(��Ӧ DEV_EVENT_TRAFFIC_CROSSLANE_INFO)
#define EVENT_IVS_TRAFFIC_OVERYELLOWLINE        0x0000010B        // ��ͨΥ��-ѹ���� (��Ӧ DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO)
#define EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER     0x0000010C        // ��ͨΥ��-·����ʻ�¼�(��Ӧ DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO)   
#define EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE     0x0000010E        // ��ͨΥ��-���Ƴ�ռ���¼�(��Ӧ DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY    0x0000010F        // ��ͨΥ��-���������������¼�(��Ӧ DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO)
#define EVENT_IVS_CROSSFENCEDETECTION           0x0000011F        // ��ԽΧ���¼�(��Ӧ DEV_EVENT_CROSSFENCEDETECTION_INFO)
#define EVENT_IVS_ELECTROSPARKDETECTION         0X00000110        // ����¼�(��Ӧ DEV_EVENT_ELECTROSPARK_INFO)
#define EVENT_IVS_TRAFFIC_NOPASSING             0x00000111        // ��ͨΥ��-��ֹͨ���¼�(��Ӧ DEV_EVENT_TRAFFIC_NOPASSING_INFO)
#define EVENT_IVS_ABNORMALRUNDETECTION          0x00000112        // �쳣�����¼�(��Ӧ DEV_EVENT_ABNORMALRUNDETECTION_INFO)
#define EVENT_IVS_RETROGRADEDETECTION           0x00000113        // ��Ա�����¼�(��Ӧ DEV_EVENT_RETROGRADEDETECTION_INFO)
#define EVENT_IVS_INREGIONDETECTION             0x00000114        // �����ڼ���¼�(��Ӧ DEV_EVENT_INREGIONDETECTION_INFO)
#define EVENT_IVS_TAKENAWAYDETECTION            0x00000115        // ��Ʒ�����¼�(��Ӧ DEV_EVENT_TAKENAWAYDETECTION_INFO)
#define EVENT_IVS_PARKINGDETECTION              0x00000116        // �Ƿ�ͣ���¼�(��Ӧ DEV_EVENT_PARKINGDETECTION_INFO)
#define EVENT_IVS_FACERECOGNITION               0x00000117        // ����ʶ���¼�(��Ӧ DEV_EVENT_FACERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_MANUALSNAP            0x00000118        // ��ͨ�ֶ�ץ���¼�(��Ӧ DEV_EVENT_TRAFFIC_MANUALSNAP_INFO)
#define EVENT_IVS_TRAFFIC_FLOWSTATE             0x00000119        // ��ͨ����ͳ���¼�(��Ӧ DEV_EVENT_TRAFFIC_FLOW_STATE)
#define EVENT_IVS_TRAFFIC_STAY                  0x0000011A        // ��ͨ�����¼�(��Ӧ DEV_EVENT_TRAFFIC_STAY_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINROUTE        0x0000011B        // �г�ռ���¼�(��Ӧ DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO)
#define EVENT_ALARM_MOTIONDETECT                0x0000011C        // ��Ƶ�ƶ�����¼�(��Ӧ DEV_EVENT_ALARM_INFO)
#define EVENT_ALARM_LOCALALARM                  0x0000011D        // �ⲿ�����¼�(��Ӧ DEV_EVENT_ALARM_INFO)
#define EVENT_IVS_PRISONERRISEDETECTION         0x0000011E        // �������������¼�(��Ӧ DEV_EVENT_PRISONERRISEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_TOLLGATE              0x00000120        // ��ͨΥ��-�����¼�----�¹���(��Ӧ DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_DENSITYDETECTION              0x00000121        // ��Ա�ܼ��ȼ��(��Ӧ DEV_EVENT_DENSITYDETECTION_INFO)
#define EVENT_IVS_VIDEODIAGNOSIS                0x00000122        // ��Ƶ��Ͻ���¼�(��Ӧ NET_VIDEODIAGNOSIS_COMMON_INFO �� NET_REAL_DIAGNOSIS_RESULT)
#define EVENT_IVS_QUEUEDETECTION                0x00000123        // �ŶӼ�ⱨ���¼�(��Ӧ DEV_EVENT_QUEUEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE     0x00000124        // ռ�ù��������¼�(��Ӧ DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO)
#define EVENT_IVS_TRAFFIC_BACKING               0x00000125        // Υ�µ����¼�(��Ӧ DEV_EVENT_IVS_TRAFFIC_BACKING_INFO)
#define EVENT_IVS_AUDIO_ABNORMALDETECTION       0x00000126        // �����쳣���(��Ӧ DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT        0x00000127        // ��ͨΥ��-���Ƶ��¼�(��Ӧ DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO)
#define EVENT_IVS_CLIMBDETECTION                0x00000128        // �ʸ߼���¼�(��Ӧ DEV_EVENT_IVS_CLIMB_INFO)
#define EVENT_IVS_LEAVEDETECTION                0x00000129        // ��ڼ���¼�(��Ӧ DEV_EVENT_IVS_LEAVE_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX    0x0000012A        // ��������ץ���¼�(��Ӧ DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING   0x0000012B        // ��λ�г��¼�(��Ӧ DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING 0x0000012C        // ��λ�޳��¼�(��Ӧ DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO)    
#define EVENT_IVS_TRAFFIC_PEDESTRAIN            0x0000012D        // ��ͨ�����¼�(��Ӧ DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO)
#define EVENT_IVS_TRAFFIC_THROW                 0x0000012E        // ��ͨ������Ʒ�¼�(��Ӧ DEV_EVENT_TRAFFIC_THROW_INFO)
#define EVENT_IVS_TRAFFIC_IDLE                  0x0000012F        // ��ͨ�����¼�(��Ӧ DEV_EVENT_TRAFFIC_IDLE_INFO)
#define EVENT_ALARM_VEHICLEACC                  0x00000130        // ����ACC�ϵ籨���¼�(��Ӧ DEV_EVENT_ALARM_VEHICLEACC_INFO)
#define EVENT_ALARM_VEHICLE_TURNOVER            0x00000131        // �����෭�����¼�(��Ӧ DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_COLLISION           0x00000132        // ����ײ�������¼�(��Ӧ DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_LARGE_ANGLE         0x00000133        // ��������ͷ��Ƕ�Ťת�¼�
#define EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE  0x00000134        // ��λѹ���¼�(��Ӧ DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO)
#define EVENT_IVS_MULTISCENESWITCH              0x00000135        // �ೡ���л��¼�(��Ӧ DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO)
#define EVENT_IVS_TRAFFIC_RESTRICTED_PLATE      0X00000136        // ���޳����¼�(��Ӧ DEV_EVENT_TRAFFIC_RESTRICTED_PLATE)
#define EVENT_IVS_TRAFFIC_OVERSTOPLINE          0X00000137        // ѹֹͣ���¼�(��Ӧ DEV_EVENT_TRAFFIC_OVERSTOPLINE)
#define EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT      0x00000138        // ��ͨδϵ��ȫ���¼�(��Ӧ DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT)
#define EVENT_IVS_TRAFFIC_DRIVER_SMOKING        0x00000139        // ��ʻԱ�����¼�(��Ӧ DEV_EVENT_TRAFFIC_DRIVER_SMOKING)
#define EVENT_IVS_TRAFFIC_DRIVER_CALLING        0x0000013A        // ��ʻԱ��绰�¼�(��Ӧ DEV_EVENT_TRAFFIC_DRIVER_CALLING)
#define EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT 0x0000013B        // ���˴�����¼�(��Ӧ DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_PASSNOTINORDER        0x0000013C        // δ���涨����ͨ��(��Ӧ DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO)
#define EVENT_IVS_OBJECT_DETECTION              0x00000141        // ������������¼�
#define EVENT_ALARM_ANALOGALARM                 0x00000150        // ģ��������ͨ���ı����¼�(��ӦDEV_EVENT_ALARM_ANALOGALRM_INFO)
#define EVENT_IVS_CROSSLINEDETECTION_EX         0x00000151        // ��������չ�¼�
#define EVENT_ALARM_COMMON                      0x00000152        // ��ͨ¼��
#define EVENT_ALARM_VIDEOBLIND                  0x00000153        // ��Ƶ�ڵ��¼�(��Ӧ DEV_EVENT_ALARM_VIDEOBLIND)
#define EVENT_ALARM_VIDEOLOSS                   0x00000154        // ��Ƶ��ʧ�¼�
#define EVENT_IVS_GETOUTBEDDETECTION            0x00000155        // �������´��¼�(��Ӧ DEV_EVENT_GETOUTBED_INFO)
#define EVENT_IVS_PATROLDETECTION               0x00000156        // Ѳ�߼���¼�(��Ӧ DEV_EVENT_PATROL_INFO)
#define EVENT_IVS_ONDUTYDETECTION               0x00000157        // վ�ڼ���¼�(��Ӧ DEV_EVENT_ONDUTY_INFO)
#define EVENT_IVS_NOANSWERCALL                  0x00000158        // �ſڻ����δ��Ӧ�¼�
#define EVENT_IVS_STORAGENOTEXIST               0x00000159        // �洢�鲻�����¼�
#define EVENT_IVS_STORAGELOWSPACE               0x0000015A        // Ӳ�̿ռ�ͱ����¼�
#define EVENT_IVS_STORAGEFAILURE                0x0000015B        // �洢�����¼�
#define EVENT_IVS_PROFILEALARMTRANSMIT          0x0000015C        // ���������¼�
#define EVENT_IVS_VIDEOSTATIC                   0x0000015D        // ��Ƶ��̬����¼�(��Ӧ DEV_EVENT_ALARM_VIDEOSTATIC_INFO)
#define EVENT_IVS_VIDEOTIMING                   0x0000015E        // ��Ƶ��ʱ����¼�(��Ӧ DEV_EVENT_ALARM_VIDEOTIMING_INFO)
#define EVENT_IVS_HEATMAP                       0x0000015F        // �ȶ�ͼ(��Ӧ CFG_IVS_HEATMAP_INFO)
#define EVENT_IVS_CITIZENIDCARD                 0x00000160        // ���֤��Ϣ��ȡ�¼�(��Ӧ DEV_EVENT_ALARM_CITIZENIDCARD_INFO)
#define EVENT_IVS_PICINFO                       0x00000161        // ͼƬ��Ϣ�¼�(��Ӧ DEV_EVENT_ALARM_PIC_INFO)
#define EVENT_IVS_NETPLAYCHECK                  0x00000162        // �����Ǽ��¼�(��Ӧ DEV_EVENT_ALARM_NETPLAYCHECK_INFO)
#define EVENT_IVS_TRAFFIC_JAM_FORBID_INTO       0x00000163        // ����ӵ�½����¼�(��Ӧ DEV_EVENT_ALARM_JAMFORBIDINTO_INFO)
#define EVENT_IVS_SNAPBYTIME                    0x00000164        // ��ʱץͼ�¼�(��ӦDEV_EVENT_SNAPBYTIME)
#define EVENT_IVS_PTZ_PRESET                    0x00000165        // ��̨ת����Ԥ�õ��¼�(��Ӧ DEV_EVENT_ALARM_PTZ_PRESET_INFO)
#define EVENT_IVS_RFID_INFO                     0x00000166        // �����߼����Ϣ�¼�(��Ӧ DEV_EVENT_ALARM_RFID_INFO)
#define EVENT_IVS_STANDUPDETECTION              0X00000167        // ����������¼� 
#define EVENT_IVS_QSYTRAFFICCARWEIGHT           0x00000168        // ��ͨ���ڳ����¼�(��Ӧ DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO)
#define EVENT_IVS_TRAFFIC_COMPAREPLATE          0x00000169        // ����ǰ���ƺϳ��¼�(��ӦDEV_EVENT_TRAFFIC_COMPAREPLATE_INFO)
#define EVENT_IVS_SHOOTINGSCORERECOGNITION      0x0000016A        // �������¼�(��Ӧ DEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO,CFG_IVS_SHOOTINGSCORERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_FCC                   0x0000016B        // ����վ��ǹ����ǹ�¼�(��Ӧ DEV_EVENT_TRAFFIC_FCC_INFO)
#define EVENT_IVS_TRAFFIC_TRANSFINITE           0x0000016C        // Υ�³���ץͼ�ϱ��¼�,���˿Ƽ��γ�(��Ӧ DEV_EVENT_TRAFFIC_TRANSFINITE_INFO)
#define EVENT_IVS_SCENE_CHANGE                  0x0000016D        // ��������¼�(��Ӧ DEV_ALRAM_SCENECHANGE_INFO,CFG_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_LETRACK                       0x0000016E        // �򵥸����¼�(��δ�о����¼�)
#define EVENT_IVS_OBJECT_ACTION                 0x0000016F        // �������¼�(��δ�о����¼�)
#define EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP       0x00000170        // Ԥ����ץ��ͼƬ�¼�(��Ӧ DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO)
#define EVENT_ALARM_EQSTATE                     0x00000171        // ���ܲ�������״̬�ϱ�(��δ�о����¼�)
#define EVENT_IVS_ALARM_IPC                     0x00000172        // DVR/NVR�豸�ϵ�IPC����(��δ�о����¼�)
#define EVENT_IVS_POS_RECORD                    0x00000173        // POS¼���ѯ�¼�(��δ�о����¼�)
#define EVENT_IVS_NEAR_DISTANCE_DETECTION       0x00000174        // ������Ӵ��¼�(��Ӧ DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_PERSON       0x00000175        // ������������¼�(��Ӧ DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_NONMOTOR     0x00000176        // �ǻ�������������¼�(��Ӧ DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO)
#define EVENT_IVS_TUMBLE_DETECTION              0x00000177        // ���ر����¼�(��Ӧ DEV_EVENT_TUMBLE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_ALL                   0x000001FF        // ������traffic��ͷ���¼�,Ŀǰָ����
                                                                  // EVENT_IVS_TRAFFICCONTROL -> EVENT_TRAFFICSNAPSHOT
                                                                  // EVENT_IVS_TRAFFIC_RUNREDLIGHT -> EVENT_IVS_TRAFFIC_UNDERSPEED
#define EVENT_IVS_VIDEOANALYSE                  0x00000200      // �������ܷ����¼� 
#define EVENT_IVS_LINKSD                        0x00000201      // LinkSD�¼�(��Ӧ DEV_EVENT_LINK_SD)
#define EVENT_IVS_VEHICLEANALYSE                0x00000202      // ��������������(��ӦDEV_EVENT_VEHICLEANALYSE)
#define EVENT_IVS_FLOWRATE                      0x00000203      // ����ʹ������¼�(��Ӧ DEV_EVENT_FLOWRATE_INFO)
#define EVENT_IVS_ACCESS_CTL                    0x00000204      // �Ž��¼� (��Ӧ DEV_EVENT_ACCESS_CTL_INFO)
#define EVENT_IVS_SNAPMANUAL                    0x00000205      // SnapManual�¼�(��Ӧ DEV_EVENT_SNAPMANUAL)
#define EVENT_IVS_TRAFFIC_ELETAGINFO            0x00000206      // RFID���ӳ��Ʊ�ǩ�¼�(��Ӧ DEV_EVENT_TRAFFIC_ELETAGINFO_INFO)
#define EVENT_IVS_TRAFFIC_TIREDPHYSIOLOGICAL    0x00000207      // ����ƣ�ͼ�ʻ�¼�(��ӦDEV_EVENT_TIREDPHYSIOLOGICAL_INFO)
#define EVENT_IVS_TRAFFIC_BUSSHARPTURN          0x00000208      // ������ת�����¼�(��ӦDEV_EVENT_BUSSHARPTURN_INFO)
#define EVENT_IVS_CITIZEN_PICTURE_COMPARE       0x00000209      // ��֤�ȶ��¼�(��Ӧ DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO)
#define EVENT_IVS_TRAFFIC_TIREDLOWERHEAD        0x0000020A      // ������ͷ�����¼�(��ӦDEV_EVENT_TIREDLOWERHEAD_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND      0x0000020B      // ����������α����¼�(��ӦDEV_EVENT_DRIVERLOOKAROUND_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST       0x0000020C      // ������ڱ����¼�(��ӦDEV_EVENT_DRIVERLEAVEPOST_INFO)
#define EVENT_IVS_MAN_STAND_DETECTION           0x0000020D      // �����Ӿ�վ���¼�(��ӦDEV_EVENT_MANSTAND_DETECTION_INFO)
#define EVENT_IVS_MAN_NUM_DETECTION             0x0000020E      // �����Ӿ�����������ͳ���¼�(��ӦDEV_EVENT_MANNUM_DETECTION_INFO)
#define EVENT_IVS_STEREO_NUMBERSTAT             0x0000020F      // ������ͳ���¼�(��δ�о����¼�)
#define EVENT_IVS_TRAFFIC_DRIVERYAWN            0x00000210      // �������Ƿ�¼�(��ӦDEV_EVENT_DRIVERYAWN_INFO)
#define EVENT_IVS_NUMBERSTAT_PLAN               0x00000211      // ������ͳ�Ƽƻ�(��δ�о����¼�,���ʹ��,��Ӧ�������ýṹ�� CFG_NUMBERSTAT_INFO)
#define EVENT_IVS_HEATMAP_PLAN                  0x00000212      // �ȶ�ͼ�ƻ�(��δ�о����¼�,���ʹ��,��Ӧ�������ýṹ�� CFG_IVS_HEATMAP_INFO)
#define EVENT_IVS_CALLNOANSWERED                0x00000213      // ����޴�Ӧ�¼�
#define EVENT_IVS_IGNOREINVITE                  0x00000214      // ���������¼�
#define EVENT_IVS_HUMANTRAIT                    0x00000215      // ���������¼�(��Ӧ DEV_EVENT_HUMANTRAIT_INFO)
#define EVENT_ALARM_LE_HEADDETECTION            0x00000216      // �ֳ���ͷ����¼�,ֻ���ڶ����ֻ�����
#define EVENT_IVS_FACEANALYSIS                  0x00000217      // ���������¼� (��δ�о����¼�)
#define EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT 0x00000218      // ��ת������ֱ���¼�(��Ӧ DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN      0x00000219      // ����Сת�¼�(��Ӧ DEV_EVENT_BIGBENDSMALLTURN_INFO)
#define EVENT_IVS_ROAD_CONSTRUCTION             0x0000021A      // ��·ʩ������¼�(��ӦDEV_EVENT_ROAD_CONSTRUCTION_INFO)
#define EVENT_IVS_ROAD_BLOCK                    0x0000021B      // ·�ϼ���¼�(��ӦDEV_EVENT_ROAD_BLOCK_INFO)
#define EVENT_IVS_TRAFFIC_QUEUEJUMP             0x0000021C      // ���������¼�(��Ӧ DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO)
#define EVENT_IVS_VEHICLE_SUSPICIOUSCAR         0x0000021D      // ���ɳ����¼�(��Ӧ DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT  0x0000021E    // ��ת������ֱ���¼�(��Ӧ DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE    0x0000021F    // ��ת������ֱ������(��Ӧ DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO)
#define EVENT_IVS_INSTALL_CARDREADER            0x00000220      // ��װ�������¼�(��Ӧ DEV_EVENT_INSTALL_CARDREADER_INFO)
#define EVENT_ALARM_YALE_DROPBOX_BADTOKEN       0X00000221      // Yale tokenʧЧ�¼���ֻ���ڶ����ֻ�����

//�豸�洢������,�豸���������
#define STOR_POINT_READ_WRITE                   0x00001001      // ��д��,ԭ��Ϊ"ReadWrite*","ReadWrite*",�����д��, �м��"*"����Ϊ��,����Ϊһ������
#define STOR_POINT_READ_ONLY                    0x00001002      // ֻ����
#define STOR_POINT_REDUNDANT                    0x00001003      // ������,��"ReadWirte"��һ�����ั��
#define STOR_POINT_BACKUP                       0x00001004      // ������,����д����ֹͣ,����ѭ������
#define STOR_POINT_DRAW_FRAME                   0x00001005      // ��ʷ��֡��,ʵʱ¼����ָ��ʱ���,��֡��д�����
#define STOR_POINT_NAS_FTP                      0x00001006      // Զ������洢��(Э������FTP),���ܻ��ж��
#define STOR_POINT_NAS_NFS                      0x00001007      // Զ������洢��(Э������NFS),���ܻ��ж��
#define STOR_POINT_NAS_SMB                      0x00001008      // Զ������洢��(Э������SMB),���ܻ��ж��
#define STOR_POINT_NAS_ISCSI                    0x00001009      // Զ������洢��(Э������ISCSI),���ܻ��ж��
#define STOR_POINT_NAS_CLOUD                    0x0000100A      // Զ������洢��(Э������Cloud),���ܻ��ж��

//����ͳ���¼�ʹ�ú�
#define FLOWSTAT_ADDR_NAME                      16                //�����еص�����

//��Խӿ�CLIENT_OperateTrafficList�����ַ������ȶ���
#define DH_TARFFIC_NAME_LEN                     16                
#define DH_CREATE_TIME_LEN                      32
#define DH_AUTHORITY_NUM                        16

// �������ʹ���,��ӦCLIENT_GetLastError�ӿڵķ���ֵ
#define _EC(x)                                  (0x80000000|x)
#define NET_NOERROR                             0                 // û�д���
#define NET_ERROR                               -1                // δ֪����
#define NET_SYSTEM_ERROR                        _EC(1)            // Windowsϵͳ����
#define NET_NETWORK_ERROR                       _EC(2)            // �������,��������Ϊ���糬ʱ
#define NET_DEV_VER_NOMATCH                     _EC(3)            // �豸Э�鲻ƥ��
#define NET_INVALID_HANDLE                      _EC(4)            // �����Ч
#define NET_OPEN_CHANNEL_ERROR                  _EC(5)            // ��ͨ��ʧ��
#define NET_CLOSE_CHANNEL_ERROR                 _EC(6)            // �ر�ͨ��ʧ��
#define NET_ILLEGAL_PARAM                       _EC(7)            // �û��������Ϸ�
#define NET_SDK_INIT_ERROR                      _EC(8)            // SDK��ʼ������
#define NET_SDK_UNINIT_ERROR                    _EC(9)            // SDK�������
#define NET_RENDER_OPEN_ERROR                   _EC(10)           // ����render��Դ����
#define NET_DEC_OPEN_ERROR                      _EC(11)           // �򿪽�������
#define NET_DEC_CLOSE_ERROR                     _EC(12)           // �رս�������
#define NET_MULTIPLAY_NOCHANNEL                 _EC(13)           // �໭��Ԥ���м�⵽ͨ����Ϊ0
#define NET_TALK_INIT_ERROR                     _EC(14)           // ¼����ʼ��ʧ��
#define NET_TALK_NOT_INIT                       _EC(15)           // ¼���δ����ʼ��
#define NET_TALK_SENDDATA_ERROR                 _EC(16)           // ������Ƶ���ݳ���
#define NET_REAL_ALREADY_SAVING                 _EC(17)           // ʵʱ�����Ѿ����ڱ���״̬
#define NET_NOT_SAVING                          _EC(18)           // δ����ʵʱ����
#define NET_OPEN_FILE_ERROR                     _EC(19)           // ���ļ�����
#define NET_PTZ_SET_TIMER_ERROR                 _EC(20)           // ����̨���ƶ�ʱ��ʧ��
#define NET_RETURN_DATA_ERROR                   _EC(21)           // �Է������ݵ�У�����
#define NET_INSUFFICIENT_BUFFER                 _EC(22)           // û���㹻�Ļ���
#define NET_NOT_SUPPORTED                       _EC(23)           // ��ǰSDKδ֧�ָù���
#define NET_NO_RECORD_FOUND                     _EC(24)           // ��ѯ����¼��
#define NET_NOT_AUTHORIZED                      _EC(25)           // �޲���Ȩ��
#define NET_NOT_NOW                             _EC(26)           // ��ʱ�޷�ִ��
#define NET_NO_TALK_CHANNEL                     _EC(27)           // δ���ֶԽ�ͨ��
#define NET_NO_AUDIO                            _EC(28)           // δ������Ƶ
#define NET_NO_INIT                             _EC(29)           // ����SDKδ����ʼ��
#define NET_DOWNLOAD_END                        _EC(30)           // �����ѽ���
#define NET_EMPTY_LIST                          _EC(31)           // ��ѯ���Ϊ��
#define NET_ERROR_GETCFG_SYSATTR                _EC(32)           // ��ȡϵͳ��������ʧ��
#define NET_ERROR_GETCFG_SERIAL                 _EC(33)           // ��ȡ���к�ʧ��
#define NET_ERROR_GETCFG_GENERAL                _EC(34)           // ��ȡ��������ʧ��
#define NET_ERROR_GETCFG_DSPCAP                 _EC(35)           // ��ȡDSP��������ʧ��
#define NET_ERROR_GETCFG_NETCFG                 _EC(36)           // ��ȡ��������ʧ��
#define NET_ERROR_GETCFG_CHANNAME               _EC(37)           // ��ȡͨ������ʧ��
#define NET_ERROR_GETCFG_VIDEO                  _EC(38)           // ��ȡ��Ƶ����ʧ��
#define NET_ERROR_GETCFG_RECORD                 _EC(39)           // ��ȡ¼������ʧ��
#define NET_ERROR_GETCFG_PRONAME                _EC(40)           // ��ȡ������Э������ʧ��
#define NET_ERROR_GETCFG_FUNCNAME               _EC(41)           // ��ȡ232���ڹ�������ʧ��
#define NET_ERROR_GETCFG_485DECODER             _EC(42)           // ��ȡ����������ʧ��
#define NET_ERROR_GETCFG_232COM                 _EC(43)           // ��ȡ232��������ʧ��
#define NET_ERROR_GETCFG_ALARMIN                _EC(44)           // ��ȡ�ⲿ������������ʧ��
#define NET_ERROR_GETCFG_ALARMDET               _EC(45)           // ��ȡ��̬��ⱨ��ʧ��
#define NET_ERROR_GETCFG_SYSTIME                _EC(46)           // ��ȡ�豸ʱ��ʧ��
#define NET_ERROR_GETCFG_PREVIEW                _EC(47)           // ��ȡԤ������ʧ��
#define NET_ERROR_GETCFG_AUTOMT                 _EC(48)           // ��ȡ�Զ�ά������ʧ��
#define NET_ERROR_GETCFG_VIDEOMTRX              _EC(49)           // ��ȡ��Ƶ��������ʧ��
#define NET_ERROR_GETCFG_COVER                  _EC(50)           // ��ȡ�����ڵ�����ʧ��
#define NET_ERROR_GETCFG_WATERMAKE              _EC(51)           // ��ȡͼ��ˮӡ����ʧ��
#define NET_ERROR_GETCFG_MULTICAST              _EC(52)           // ��ȡ����ʧ��λ�ã��鲥�˿ڰ�ͨ������
#define NET_ERROR_SETCFG_GENERAL                _EC(55)           // �޸ĳ�������ʧ��
#define NET_ERROR_SETCFG_NETCFG                 _EC(56)           // �޸���������ʧ��
#define NET_ERROR_SETCFG_CHANNAME               _EC(57)           // �޸�ͨ������ʧ��
#define NET_ERROR_SETCFG_VIDEO                  _EC(58)           // �޸���Ƶ����ʧ��
#define NET_ERROR_SETCFG_RECORD                 _EC(59)           // �޸�¼������ʧ��
#define NET_ERROR_SETCFG_485DECODER             _EC(60)           // �޸Ľ���������ʧ��
#define NET_ERROR_SETCFG_232COM                 _EC(61)           // �޸�232��������ʧ��
#define NET_ERROR_SETCFG_ALARMIN                _EC(62)           // �޸��ⲿ���뱨������ʧ��
#define NET_ERROR_SETCFG_ALARMDET               _EC(63)           // �޸Ķ�̬��ⱨ������ʧ��
#define NET_ERROR_SETCFG_SYSTIME                _EC(64)           // �޸��豸ʱ��ʧ��
#define NET_ERROR_SETCFG_PREVIEW                _EC(65)           // �޸�Ԥ������ʧ��
#define NET_ERROR_SETCFG_AUTOMT                 _EC(66)           // �޸��Զ�ά������ʧ��
#define NET_ERROR_SETCFG_VIDEOMTRX              _EC(67)           // �޸���Ƶ��������ʧ��
#define NET_ERROR_SETCFG_COVER                  _EC(68)           // �޸������ڵ�����ʧ��
#define NET_ERROR_SETCFG_WATERMAKE              _EC(69)           // �޸�ͼ��ˮӡ����ʧ��
#define NET_ERROR_SETCFG_WLAN                   _EC(70)           // �޸�����������Ϣʧ��
#define NET_ERROR_SETCFG_WLANDEV                _EC(71)           // ѡ�����������豸ʧ��
#define NET_ERROR_SETCFG_REGISTER               _EC(72)           // �޸�����ע���������ʧ��
#define NET_ERROR_SETCFG_CAMERA                 _EC(73)           // �޸�����ͷ��������ʧ��
#define NET_ERROR_SETCFG_INFRARED               _EC(74)           // �޸ĺ��ⱨ������ʧ��
#define NET_ERROR_SETCFG_SOUNDALARM             _EC(75)           // �޸���Ƶ��������ʧ��
#define NET_ERROR_SETCFG_STORAGE                _EC(76)           // �޸Ĵ洢λ������ʧ��
#define NET_AUDIOENCODE_NOTINIT                 _EC(77)           // ��Ƶ����ӿ�û�гɹ���ʼ��
#define NET_DATA_TOOLONGH                       _EC(78)           // ���ݹ���
#define NET_UNSUPPORTED                         _EC(79)           // �豸��֧�ָò���
#define NET_DEVICE_BUSY                         _EC(80)           // �豸��Դ����
#define NET_SERVER_STARTED                      _EC(81)           // �������Ѿ���
#define NET_SERVER_STOPPED                      _EC(82)           // ��������δ�ɹ���
#define NET_LISTER_INCORRECT_SERIAL             _EC(83)           // �������к�����
#define NET_QUERY_DISKINFO_FAILED               _EC(84)           // ��ȡӲ����Ϣʧ��
#define NET_ERROR_GETCFG_SESSION                _EC(85)           // ��ȡ����Session��Ϣ
#define NET_USER_FLASEPWD_TRYTIME               _EC(86)           // ����������󳬹����ƴ���
#define NET_LOGIN_ERROR_PASSWORD                _EC(100)          // ���벻��ȷ
#define NET_LOGIN_ERROR_USER                    _EC(101)          // �ʻ�������
#define NET_LOGIN_ERROR_TIMEOUT                 _EC(102)          // �ȴ���¼���س�ʱ
#define NET_LOGIN_ERROR_RELOGGIN                _EC(103)          // �ʺ��ѵ�¼
#define NET_LOGIN_ERROR_LOCKED                  _EC(104)          // �ʺ��ѱ�����
#define NET_LOGIN_ERROR_BLACKLIST               _EC(105)          // �ʺ��ѱ���Ϊ������
#define NET_LOGIN_ERROR_BUSY                    _EC(106)          // ��Դ����,ϵͳæ
#define NET_LOGIN_ERROR_CONNECT                 _EC(107)          // ��¼�豸��ʱ,�������粢����
#define NET_LOGIN_ERROR_NETWORK                 _EC(108)          // ��������ʧ��
#define NET_LOGIN_ERROR_SUBCONNECT              _EC(109)          // ��¼�豸�ɹ�,���޷�������Ƶͨ��,��������״��
#define NET_LOGIN_ERROR_MAXCONNECT              _EC(110)          // �������������
#define NET_LOGIN_ERROR_PROTOCOL3_ONLY          _EC(111)          // ֻ֧��3��Э��
#define NET_LOGIN_ERROR_UKEY_LOST               _EC(112)          // δ����U�ܻ�U����Ϣ����
#define NET_LOGIN_ERROR_NO_AUTHORIZED           _EC(113)          // �ͻ���IP��ַû�е�¼Ȩ��
#define NET_LOGIN_ERROR_USER_OR_PASSOWRD        _EC(117)          // �˺Ż��������  
#define NET_RENDER_SOUND_ON_ERROR               _EC(120)          // Render�����Ƶ����
#define NET_RENDER_SOUND_OFF_ERROR              _EC(121)          // Render��ر���Ƶ����
#define NET_RENDER_SET_VOLUME_ERROR             _EC(122)          // Render�������������
#define NET_RENDER_ADJUST_ERROR                 _EC(123)          // Render�����û����������
#define NET_RENDER_PAUSE_ERROR                  _EC(124)          // Render����ͣ���ų���
#define NET_RENDER_SNAP_ERROR                   _EC(125)          // Render��ץͼ����
#define NET_RENDER_STEP_ERROR                   _EC(126)          // Render�ⲽ������
#define NET_RENDER_FRAMERATE_ERROR              _EC(127)          // Render������֡�ʳ���
#define NET_RENDER_DISPLAYREGION_ERROR          _EC(128)          // Render��������ʾ�������
#define NET_RENDER_GETOSDTIME_ERROR             _EC(129)          // Render���ȡ��ǰ����ʱ�����
#define NET_GROUP_EXIST                         _EC(140)          // �����Ѵ���
#define NET_GROUP_NOEXIST                       _EC(141)          // ����������
#define NET_GROUP_RIGHTOVER                     _EC(142)          // ���Ȩ�޳���Ȩ���б�Χ
#define NET_GROUP_HAVEUSER                      _EC(143)          // �������û�,����ɾ��
#define NET_GROUP_RIGHTUSE                      _EC(144)          // ���ĳ��Ȩ�ޱ��û�ʹ��,���ܳ���
#define NET_GROUP_SAMENAME                      _EC(145)          // ������ͬ���������ظ�
#define NET_USER_EXIST                          _EC(146)          // �û��Ѵ���
#define NET_USER_NOEXIST                        _EC(147)          // �û�������
#define NET_USER_RIGHTOVER                      _EC(148)          // �û�Ȩ�޳�����Ȩ��
#define NET_USER_PWD                            _EC(149)          // �����ʺ�,�������޸�����
#define NET_USER_FLASEPWD                       _EC(150)          // ���벻��ȷ
#define NET_USER_NOMATCHING                     _EC(151)          // ���벻ƥ��
#define NET_USER_INUSE                          _EC(152)          // �˺�����ʹ����
#define NET_ERROR_GETCFG_ETHERNET               _EC(300)          // ��ȡ��������ʧ��
#define NET_ERROR_GETCFG_WLAN                   _EC(301)          // ��ȡ����������Ϣʧ��
#define NET_ERROR_GETCFG_WLANDEV                _EC(302)          // ��ȡ���������豸ʧ��
#define NET_ERROR_GETCFG_REGISTER               _EC(303)          // ��ȡ����ע�����ʧ��
#define NET_ERROR_GETCFG_CAMERA                 _EC(304)          // ��ȡ����ͷ����ʧ��
#define NET_ERROR_GETCFG_INFRARED               _EC(305)          // ��ȡ���ⱨ������ʧ��
#define NET_ERROR_GETCFG_SOUNDALARM             _EC(306)          // ��ȡ��Ƶ��������ʧ��
#define NET_ERROR_GETCFG_STORAGE                _EC(307)          // ��ȡ�洢λ������ʧ��
#define NET_ERROR_GETCFG_MAIL                   _EC(308)          // ��ȡ�ʼ�����ʧ��
#define NET_CONFIG_DEVBUSY                      _EC(309)          // ��ʱ�޷�����
#define NET_CONFIG_DATAILLEGAL                  _EC(310)          // �������ݲ��Ϸ�
#define NET_ERROR_GETCFG_DST                    _EC(311)          // ��ȡ����ʱ����ʧ��
#define NET_ERROR_SETCFG_DST                    _EC(312)          // ��������ʱ����ʧ��
#define NET_ERROR_GETCFG_VIDEO_OSD              _EC(313)          // ��ȡ��ƵOSD��������ʧ��
#define NET_ERROR_SETCFG_VIDEO_OSD              _EC(314)          // ������ƵOSD��������ʧ��
#define NET_ERROR_GETCFG_GPRSCDMA               _EC(315)          // ��ȡCDMA\GPRS��������ʧ��
#define NET_ERROR_SETCFG_GPRSCDMA               _EC(316)          // ����CDMA\GPRS��������ʧ��
#define NET_ERROR_GETCFG_IPFILTER               _EC(317)          // ��ȡIP��������ʧ��
#define NET_ERROR_SETCFG_IPFILTER               _EC(318)          // ����IP��������ʧ��
#define NET_ERROR_GETCFG_TALKENCODE             _EC(319)          // ��ȡ����Խ���������ʧ��
#define NET_ERROR_SETCFG_TALKENCODE             _EC(320)          // ��������Խ���������ʧ��
#define NET_ERROR_GETCFG_RECORDLEN              _EC(321)          // ��ȡ¼������������ʧ��
#define NET_ERROR_SETCFG_RECORDLEN              _EC(322)          // ����¼������������ʧ��
#define NET_DONT_SUPPORT_SUBAREA                _EC(323)          // ��֧������Ӳ�̷���
#define NET_ERROR_GET_AUTOREGSERVER             _EC(324)          // ��ȡ�豸������ע���������Ϣʧ��
#define NET_ERROR_CONTROL_AUTOREGISTER          _EC(325)          // ����ע���ض���ע�����
#define NET_ERROR_DISCONNECT_AUTOREGISTER       _EC(326)          // �Ͽ�����ע�����������
#define NET_ERROR_GETCFG_MMS                    _EC(327)          // ��ȡmms����ʧ��
#define NET_ERROR_SETCFG_MMS                    _EC(328)          // ����mms����ʧ��
#define NET_ERROR_GETCFG_SMSACTIVATION          _EC(329)          // ��ȡ���ż���������������ʧ��
#define NET_ERROR_SETCFG_SMSACTIVATION          _EC(330)          // ���ö��ż���������������ʧ��
#define NET_ERROR_GETCFG_DIALINACTIVATION       _EC(331)          // ��ȡ���ż���������������ʧ��
#define NET_ERROR_SETCFG_DIALINACTIVATION       _EC(332)          // ���ò��ż���������������ʧ��
#define NET_ERROR_GETCFG_VIDEOOUT               _EC(333)          // ��ѯ��Ƶ�����������ʧ��
#define NET_ERROR_SETCFG_VIDEOOUT               _EC(334)          // ������Ƶ�����������ʧ��
#define NET_ERROR_GETCFG_OSDENABLE              _EC(335)          // ��ȡosd����ʹ������ʧ��
#define NET_ERROR_SETCFG_OSDENABLE              _EC(336)          // ����osd����ʹ������ʧ��
#define NET_ERROR_SETCFG_ENCODERINFO            _EC(337)          // ��������ͨ��ǰ�˱����������ʧ��
#define NET_ERROR_GETCFG_TVADJUST               _EC(338)          // ��ȡTV��������ʧ��
#define NET_ERROR_SETCFG_TVADJUST               _EC(339)          // ����TV��������ʧ��
#define NET_ERROR_CONNECT_FAILED                _EC(340)          // ����������ʧ��
#define NET_ERROR_SETCFG_BURNFILE               _EC(341)          // �����¼�ļ��ϴ�ʧ��
#define NET_ERROR_SNIFFER_GETCFG                _EC(342)          // ��ȡץ��������Ϣʧ��
#define NET_ERROR_SNIFFER_SETCFG                _EC(343)          // ����ץ��������Ϣʧ��
#define NET_ERROR_DOWNLOADRATE_GETCFG           _EC(344)          // ��ѯ����������Ϣʧ��
#define NET_ERROR_DOWNLOADRATE_SETCFG           _EC(345)          // ��������������Ϣʧ��
#define NET_ERROR_SEARCH_TRANSCOM               _EC(346)          // ��ѯ���ڲ���ʧ��
#define NET_ERROR_GETCFG_POINT                  _EC(347)          // ��ȡԤ�Ƶ���Ϣ����
#define NET_ERROR_SETCFG_POINT                  _EC(348)          // ����Ԥ�Ƶ���Ϣ����
#define NET_SDK_LOGOUT_ERROR                    _EC(349)          // SDKû�������ǳ��豸
#define NET_ERROR_GET_VEHICLE_CFG               _EC(350)          // ��ȡ��������ʧ��
#define NET_ERROR_SET_VEHICLE_CFG               _EC(351)          // ���ó�������ʧ��
#define NET_ERROR_GET_ATM_OVERLAY_CFG           _EC(352)          // ��ȡatm��������ʧ��
#define NET_ERROR_SET_ATM_OVERLAY_CFG           _EC(353)          // ����atm��������ʧ��
#define NET_ERROR_GET_ATM_OVERLAY_ABILITY       _EC(354)          // ��ȡatm��������ʧ��
#define NET_ERROR_GET_DECODER_TOUR_CFG          _EC(355)          // ��ȡ������������Ѳ����ʧ��
#define NET_ERROR_SET_DECODER_TOUR_CFG          _EC(356)          // ���ý�����������Ѳ����ʧ��
#define NET_ERROR_CTRL_DECODER_TOUR             _EC(357)          // ���ƽ�����������Ѳʧ��
#define NET_GROUP_OVERSUPPORTNUM                _EC(358)          // �����豸֧������û�����Ŀ
#define NET_USER_OVERSUPPORTNUM                 _EC(359)          // �����豸֧������û���Ŀ
#define NET_ERROR_GET_SIP_CFG                   _EC(368)          // ��ȡSIP����ʧ��
#define NET_ERROR_SET_SIP_CFG                   _EC(369)          // ����SIP����ʧ��
#define NET_ERROR_GET_SIP_ABILITY               _EC(370)          // ��ȡSIP����ʧ��
#define NET_ERROR_GET_WIFI_AP_CFG               _EC(371)          // ��ȡWIFI ap����ʧ��
#define NET_ERROR_SET_WIFI_AP_CFG               _EC(372)          // ����WIFI ap����ʧ��
#define NET_ERROR_GET_DECODE_POLICY             _EC(373)          // ��ȡ�����������ʧ��
#define NET_ERROR_SET_DECODE_POLICY             _EC(374)          // ���ý����������ʧ��
#define NET_ERROR_TALK_REJECT                   _EC(375)          // �ܾ��Խ�
#define NET_ERROR_TALK_OPENED                   _EC(376)          // �Խ��������ͻ��˴�
#define NET_ERROR_TALK_RESOURCE_CONFLICIT       _EC(377)          // ��Դ��ͻ
#define NET_ERROR_TALK_UNSUPPORTED_ENCODE       _EC(378)          // ��֧�ֵ���������ʽ
#define NET_ERROR_TALK_RIGHTLESS                _EC(379)          // ��Ȩ��
#define NET_ERROR_TALK_FAILED                   _EC(380)          // ����Խ�ʧ��
#define NET_ERROR_GET_MACHINE_CFG               _EC(381)          // ��ȡ�����������ʧ��
#define NET_ERROR_SET_MACHINE_CFG               _EC(382)          // ���û����������ʧ��
#define NET_ERROR_GET_DATA_FAILED               _EC(383)          // �豸�޷���ȡ��ǰ��������
#define NET_ERROR_MAC_VALIDATE_FAILED           _EC(384)          // MAC��ַ��֤ʧ�� 
#define NET_ERROR_GET_INSTANCE                  _EC(385)          // ��ȡ������ʵ��ʧ��
#define NET_ERROR_JSON_REQUEST                  _EC(386)          // ���ɵ�jason�ַ�������
#define NET_ERROR_JSON_RESPONSE                 _EC(387)          // ��Ӧ��jason�ַ�������
#define NET_ERROR_VERSION_HIGHER                _EC(388)          // Э��汾���ڵ�ǰʹ�õİ汾
#define NET_SPARE_NO_CAPACITY                   _EC(389)          // �ȱ�����ʧ��, ��������
#define NET_ERROR_SOURCE_IN_USE                 _EC(390)          // ��ʾԴ���������ռ��
#define NET_ERROR_REAVE                         _EC(391)          // �߼��û���ռ�ͼ��û���Դ
#define NET_ERROR_NETFORBID                     _EC(392)          // ��ֹ���� 
#define NET_ERROR_GETCFG_MACFILTER              _EC(393)          // ��ȡMAC��������ʧ��
#define NET_ERROR_SETCFG_MACFILTER              _EC(394)          // ����MAC��������ʧ��
#define NET_ERROR_GETCFG_IPMACFILTER            _EC(395)          // ��ȡIP/MAC��������ʧ��
#define NET_ERROR_SETCFG_IPMACFILTER            _EC(396)          // ����IP/MAC��������ʧ��
#define NET_ERROR_OPERATION_OVERTIME            _EC(397)          // ��ǰ������ʱ 
#define NET_ERROR_SENIOR_VALIDATE_FAILED        _EC(398)          // �߼�У��ʧ�� 
#define NET_ERROR_DEVICE_ID_NOT_EXIST           _EC(399)          // �豸ID������
#define NET_ERROR_UNSUPPORTED                   _EC(400)          // ��֧�ֵ�ǰ����
#define NET_ERROR_PROXY_DLLLOAD                 _EC(401)          // ��������ʧ��
#define NET_ERROR_PROXY_ILLEGAL_PARAM           _EC(402)          // �����û��������Ϸ�
#define NET_ERROR_PROXY_INVALID_HANDLE          _EC(403)          // ��������Ч
#define NET_ERROR_PROXY_LOGIN_DEVICE_ERROR      _EC(404)          // �������ǰ���豸ʧ��
#define NET_ERROR_PROXY_START_SERVER_ERROR      _EC(405)          // ��������ʧ��
#define NET_ERROR_SPEAK_FAILED                  _EC(406)          // ���󺰻�ʧ��
#define NET_ERROR_NOT_SUPPORT_F6                _EC(407)          // �豸��֧�ִ�F6�ӿڵ���
#define NET_ERROR_CD_UNREADY                    _EC(408)          // ����δ����
#define NET_ERROR_DIR_NOT_EXIST                 _EC(409)          // Ŀ¼������
#define NET_ERROR_UNSUPPORTED_SPLIT_MODE        _EC(410)          // �豸��֧�ֵķָ�ģʽ
#define NET_ERROR_OPEN_WND_PARAM                _EC(411)          // �����������Ϸ�
#define NET_ERROR_LIMITED_WND_COUNT             _EC(412)          // ����������������
#define NET_ERROR_UNMATCHED_REQUEST             _EC(413)          // ���������뵱ǰģʽ��ƥ��
#define NET_RENDER_ENABLELARGEPICADJUSTMENT_ERROR   _EC(414)      // Render�����ø���ͼ���ڲ��������Գ���
#define NET_ERROR_UPGRADE_FAILED                _EC(415)          // �豸����ʧ��
#define NET_ERROR_NO_TARGET_DEVICE              _EC(416)          // �Ҳ���Ŀ���豸
#define NET_ERROR_NO_VERIFY_DEVICE              _EC(417)          // �Ҳ�����֤�豸
#define NET_ERROR_CASCADE_RIGHTLESS             _EC(418)          // �޼���Ȩ��
#define NET_ERROR_LOW_PRIORITY                  _EC(419)          // �����ȼ�
#define NET_ERROR_REMOTE_REQUEST_TIMEOUT        _EC(420)          // Զ���豸����ʱ
#define NET_ERROR_LIMITED_INPUT_SOURCE          _EC(421)          // ����Դ�������·������
#define NET_ERROR_SET_LOG_PRINT_INFO            _EC(422)          // ������־��ӡʧ��
#define NET_ERROR_PARAM_DWSIZE_ERROR            _EC(423)          // ��ε�dwsize�ֶγ���
#define NET_ERROR_LIMITED_MONITORWALL_COUNT     _EC(424)          // ����ǽ������������
#define NET_ERROR_PART_PROCESS_FAILED           _EC(425)          // ���ֹ���ִ��ʧ��
#define NET_ERROR_TARGET_NOT_SUPPORT            _EC(426)          // �ù��ܲ�֧��ת��
#define NET_ERROR_VISITE_FILE                   _EC(510)          // �����ļ�ʧ��
#define NET_ERROR_DEVICE_STATUS_BUSY            _EC(511)          // �豸æ
#define NET_USER_PWD_NOT_AUTHORIZED             _EC(512)          // �޸�������Ȩ��
#define NET_USER_PWD_NOT_STRONG                 _EC(513)          // ����ǿ�Ȳ���
#define NET_ERROR_NO_SUCH_CONFIG                _EC(514)          // û�ж�Ӧ������
#define NET_ERROR_AUDIO_RECORD_FAILED           _EC(515)          // ¼��ʧ��
#define NET_ERROR_SEND_DATA_FAILED              _EC(516)          // ���ݷ���ʧ��
#define NET_ERROR_OBSOLESCENT_INTERFACE         _EC(517)          // �����ӿ�
#define NET_ERROR_INSUFFICIENT_INTERAL_BUF      _EC(518)          // �ڲ����岻��
#define NET_ERROR_NEED_ENCRYPTION_PASSWORD      _EC(519)          // �޸��豸ipʱ,��ҪУ������
#define NET_ERROR_NOSUPPORT_RECORD              _EC(520)          // �豸��֧�ִ˼�¼��
#define NET_ERROR_SERIALIZE_ERROR               _EC(1010)         // �������л�����
#define NET_ERROR_DESERIALIZE_ERROR             _EC(1011)         // ���ݷ����л�����
#define NET_ERROR_LOWRATEWPAN_ID_EXISTED        _EC(1012)         // ������ID�Ѵ���
#define NET_ERROR_LOWRATEWPAN_ID_LIMIT          _EC(1013)         // ����ID�����ѳ���
#define NET_ERROR_LOWRATEWPAN_ID_ABNORMAL       _EC(1014)         // �����쳣���
#define NET_ERROR_ENCRYPT                       _EC(1015)         // ��������ʧ��
#define NET_ERROR_PWD_ILLEGAL                   _EC(1016)         // �����벻�Ϲ淶
#define NET_ERROR_DEVICE_ALREADY_INIT           _EC(1017)         // �豸�Ѿ���ʼ��
#define NET_ERROR_SECURITY_CODE                 _EC(1018)         // ��ȫ�����
#define NET_ERROR_SECURITY_CODE_TIMEOUT         _EC(1019)         // ��ȫ�볬����Ч��
#define NET_ERROR_GET_PWD_SPECI                 _EC(1020)         // ��ȡ����淶ʧ��
#define NET_ERROR_NO_AUTHORITY_OF_OPERATION     _EC(1021)         // ��Ȩ�޽��иò���
#define NET_ERROR_DECRYPT                       _EC(1022)         // ��������ʧ��
#define NET_ERROR_2D_CODE                       _EC(1023)         // 2D codeУ��ʧ��
#define NET_ERROR_INVALID_REQUEST               _EC(1024)         // �Ƿ���RPC����
#define	NET_ERROR_PWD_RESET_DISABLE			    _EC(1025)		  // �������ù����ѹر�
#define NET_ERROR_PLAY_PRIVATE_DATA             _EC(1026)         // ��ʾ˽�����ݣ����������ʧ��
#define NET_ERROR_ROBOT_OPERATE_FAILED          _EC(1027)         // �����˲���ʧ��
/************************************************************************
 ** ö�ٶ���
 ***********************************************************************/

//��ȡ������Ϣ���� CLIENT_QueryNetStat  �ӿ�ʹ��
typedef enum tagEM_NET_QUERY_TYPE
{
    NET_APP_DATA_STAT ,     // ��ȡЭ��ջͳ������,(����ṹ��NET_IN_NETAPP_NET_DATA_STAT,����ṹ��NET_OUT_NETAPP_NET_DATA_STAT)
    NET_APP_LINK_STAT ,     // ��ȡ������·״̬,(����ṹ��NET_IN_NETAPP_LINK_STATUS,����ṹ��NET_OUT_NETAPP_LINK_STATUS)
}EM_NET_QUERY_TYPE;

// ץͼ���� CLIENT_CapturePictureEx �ӿ�ʹ��
typedef enum tagNET_CAPTURE_FORMATS
{
    NET_CAPTURE_BMP,
    NET_CAPTURE_JPEG,       // 100%������JPEG
    NET_CAPTURE_JPEG_70,    // 70%������JPEG
    NET_CAPTURE_JPEG_50,
    NET_CAPTURE_JPEG_30,
}NET_CAPTURE_FORMATS;

// �豸����
typedef enum tagNET_DEVICE_TYPE 
{
    NET_PRODUCT_NONE = 0,
    NET_DVR_NONREALTIME_MACE,     // ��ʵʱMACE
    NET_DVR_NONREALTIME,          // ��ʵʱ
    NET_NVS_MPEG1,                // ������Ƶ������
    NET_DVR_MPEG1_2,              // MPEG1��·¼���
    NET_DVR_MPEG1_8,              // MPEG1��·¼���
    NET_DVR_MPEG4_8,              // MPEG4��·¼���
    NET_DVR_MPEG4_16,             // MPEG4ʮ��·¼���
    NET_DVR_MPEG4_SX2,            // LBϵ��¼���
    NET_DVR_MEPG4_ST2,            // GBϵ��¼���
    NET_DVR_MEPG4_SH2,            // HBϵ��¼���               10
    NET_DVR_MPEG4_GBE,            // GBEϵ��¼���
    NET_DVR_MPEG4_NVSII,          // II��������Ƶ������
    NET_DVR_STD_NEW,              // �±�׼����Э��
    NET_DVR_DDNS,                 // DDNS������
    NET_DVR_ATM,                  // ATM��
    NET_NB_SERIAL,                // ������ʵʱNBϵ�л���
    NET_LN_SERIAL,                // LNϵ�в�Ʒ
    NET_BAV_SERIAL,               // BAVϵ�в�Ʒ
    NET_SDIP_SERIAL,              // SDIPϵ�в�Ʒ
    NET_IPC_SERIAL,               // IPCϵ�в�Ʒ                20
    NET_NVS_B,                    // NVS Bϵ��
    NET_NVS_C,                    // NVS Hϵ��
    NET_NVS_S,                    // NVS Sϵ��
    NET_NVS_E,                    // NVS Eϵ��
    NET_DVR_NEW_PROTOCOL,         // ��QueryDevState�в�ѯ�豸����,���ַ�����ʽ
    NET_NVD_SERIAL,               // ������
    NET_DVR_N5,                   // N5
    NET_DVR_MIX_DVR,              // ���DVR
    NET_SVR_SERIAL,               // SVRϵ��
    NET_SVR_BS,                   // SVR-BS                     30
    NET_NVR_SERIAL,               // NVRϵ��
    NET_DVR_N51,                  // N51
    NET_ITSE_SERIAL,              // ITSE ���ܷ�����
    NET_ITC_SERIAL,               // ���ܽ�ͨ����豸
    NET_HWS_SERIAL,               // �״������HWS
    NET_PVR_SERIAL,               // ��Яʽ����Ƶ¼���
    NET_IVS_SERIAL,               // IVS��������Ƶ������ϵ�У�
    NET_IVS_B,                    // ͨ��������Ƶ��������
    NET_IVS_F,                    // ����ʶ�������
    NET_IVS_V,                    // ��Ƶ������Ϸ�����         40
    NET_MATRIX_SERIAL,            // ����
    NET_DVR_N52,                  // N52
    NET_DVR_N56,                  // N56
    NET_ESS_SERIAL,               // ESS
    NET_IVS_PC,                   // ����ͳ�Ʒ�����
    NET_PC_NVR,                   // pc-nvr
    NET_DSCON,                    // ����������
    NET_EVS,                      // ������Ƶ�洢������
    NET_EIVS,                     // Ƕ��ʽ���ܷ�����Ƶϵͳ
    NET_DVR_N6,                   // DVR-N6                     50
    NET_UDS,                      // ���ܽ�����
    NET_AF6016,                   // ���б�������
    NET_AS5008,                   // ��Ƶ���籨������
    NET_AH2008,                   // ���籨������
    NET_A_SERIAL,                 // ��������ϵ��
    NET_BSC_SERIAL,               // �Ž�ϵ�в�Ʒ
    NET_NVS_SERIAL,               // NVSϵ�в�Ʒ
    NET_VTO_SERIAL,               // VTOϵ�в�Ʒ
    NET_VTNC_SERIAL,              // VTNCϵ�в�Ʒ
    NET_TPC_SERIAL,               // TPCϵ�в�Ʒ, ���ȳ����豸  60
    NET_ASM_SERIAL,               // �����м��豸
    NET_VTS_SERIAL,               // �����
    NET_ARC2016C,                 // ��������ARC2016C
    NET_ASA,                      // ���ڻ�
	NET_VTT_SERIAL,				  // ��ҵ�Խ��ն�
	NET_VTA_SERIAL,				  // ������
	NET_VTNS_SERIAL,			  // SIP������
	NET_VTH_SERIAL,				  // ���ڻ�
}NET_DEVICE_TYPE ;

// ��������
typedef enum __LANGUAGE_TYPE
{
    DH_LANGUAGE_ENGLISH,                // Ӣ��    
    DH_LANGUAGE_CHINESE_SIMPLIFIED,     // ��������    
    DH_LANGUAGE_CHINESE_TRADITIONAL,    // ��������    
    DH_LANGUAGE_ITALIAN,                // �������    
    DH_LANGUAGE_SPANISH,                // ��������
    DH_LANGUAGE_JAPANESE,               // ���İ�    
    DH_LANGUAGE_RUSSIAN,                // ���İ�        
    DH_LANGUAGE_FRENCH,                 // ���İ�        
    DH_LANGUAGE_GERMAN,                 // ���İ�        
    DH_LANGUAGE_PORTUGUESE,             // ��������    
    DH_LANGUAGE_TURKEY,                 // ��������    
    DH_LANGUAGE_POLISH,                 // ������    
    DH_LANGUAGE_ROMANIAN,               // ��������    
    DH_LANGUAGE_HUNGARIAN,              // ��������    
    DH_LANGUAGE_FINNISH,                // ������    
    DH_LANGUAGE_ESTONIAN,               // ��ɳ������    
    DH_LANGUAGE_KOREAN,                 // ����    
    DH_LANGUAGE_FARSI,                  // ��˹��     
    DH_LANGUAGE_DANSK,                  // ������
    DH_LANGUAGE_CZECHISH,               // �ݿ���
    DH_LANGUAGE_BULGARIA,               // ����������
    DH_LANGUAGE_SLOVAKIAN,              // ˹�工����
    DH_LANGUAGE_SLOVENIA,               // ˹����������
    DH_LANGUAGE_CROATIAN,               // ���޵�����
    DH_LANGUAGE_DUTCH,                  // ������
    DH_LANGUAGE_GREEK,                  // ϣ����
    DH_LANGUAGE_UKRAINIAN,              // �ڿ�����
    DH_LANGUAGE_SWEDISH,                // �����
    DH_LANGUAGE_SERBIAN,                // ����ά����
    DH_LANGUAGE_VIETNAMESE,             // Խ����
    DH_LANGUAGE_LITHUANIAN,             // ��������
    DH_LANGUAGE_FILIPINO,               // ���ɱ���
    DH_LANGUAGE_ARABIC,                 // ��������
    DH_LANGUAGE_CATALAN,                // ��̩��������
    DH_LANGUAGE_LATVIAN,                // ����ά����
    DH_LANGUAGE_THAI,                   // ̩��
    DH_LANGUAGE_HEBREW,                 // ϣ������
    DH_LANGUAGE_Bosnian,                // ��˹������
} DH_LANGUAGE_TYPE;

// ��������
typedef enum __EM_UPGRADE_TYPE
{
    DH_UPGRADE_BIOS_TYPE = 1,           // BIOS����
    DH_UPGRADE_WEB_TYPE,                // WEB����
    DH_UPGRADE_BOOT_YPE,                // BOOT����
    DH_UPGRADE_CHARACTER_TYPE,          // ���ֿ�
    DH_UPGRADE_LOGO_TYPE,               // LOGO
    DH_UPGRADE_EXE_TYPE,                // EXE,���粥������
    DH_UPGRADE_DEVCONSTINFO_TYPE,       // �豸������Ϣ����(�磺Ӳ��ID,MAC,���к�)
    DH_UPGRADE_PERIPHERAL_TYPE,         // ��������Ƭ(�糵��287оƬ)
    DH_UPGRADE_GEOINFO_TYPE,            // ������Ϣ��λоƬ
    DH_UPGRADE_MENU,                    // �˵����豸���������ͼƬ��
    DH_UPGRADE_ROUTE,                   // ��·�ļ����繫����·��
    DH_UPGRADE_ROUTE_STATE_AUTO,        // ��վ��Ƶ������·���׵ı�վ��Ƶ��
    DH_UPGRADE_SCREEN,                  // ���������繫����������
} EM_UPGRADE_TYPE;

// ¼������(��ʱ����̬��⡢����)
typedef enum __REC_TYPE
{
    DH_REC_TYPE_TIM = 0,
    DH_REC_TYPE_MTD,
    DH_REC_TYPE_ALM,
    DH_REC_TYPE_NUM,
} REC_TYPE;

// �������� 
typedef enum __GPRSCDMA_NETWORK_TYPE
{
    DH_TYPE_AUTOSEL = 0,                        // �Զ�ѡ��
    DH_TYPE_TD_SCDMA,                           // TD-SCDMA���� 
    DH_TYPE_WCDMA,                              // WCDMA����
    DH_TYPE_CDMA_1x,                            // CDMA 1.x����
    DH_TYPE_EDGE,                               // GPRS����
    DH_TYPE_EVDO,                               // EVDO����
    DH_TYPE_WIFI,                               // ����
} EM_GPRSCDMA_NETWORK_TYPE;

// �ӿ�����,��ӦCLIENT_SetSubconnCallBack�ӿ�
typedef enum __EM_INTERFACE_TYPE
{
    DH_INTERFACE_OTHER = 0x00000000,            // δ֪�ӿ�
    DH_INTERFACE_REALPLAY,                      // ʵʱ���ӽӿ�
    DH_INTERFACE_PREVIEW,                       // �໭��Ԥ���ӿ�
    DH_INTERFACE_PLAYBACK,                      // �طŽӿ�
    DH_INTERFACE_DOWNLOAD,                      // ���ؽӿ�
    DH_INTERFACE_REALLOADPIC,                   // ��������ͼƬ�ӿ�
} EM_INTERFACE_TYPE;

// ��Ƶ���ӶϿ��¼�����
typedef enum _EM_REALPLAY_DISCONNECT_EVENT_TYPE
{
    DISCONNECT_EVENT_REAVE,                     // ��ʾ�߼��û���ռ�ͼ��û���Դ
    DISCONNECT_EVENT_NETFORBID,                 // ��ֹ����
    DISCONNECT_EVENT_SUBCONNECT,                // ��̬�����ӶϿ�
}EM_REALPLAY_DISCONNECT_EVENT_TYPE;

// �¼��ļ����ļ���ǩ����
typedef enum __EM_EVENT_FILETAG
{
    DH_ATMBEFOREPASTE = 1,                      // ATM����ǰ
    DH_ATMAFTERPASTE,                           // ATM������
}EM_EVENT_FILETAG;

// IPC����
typedef enum __EM_IPC_TYPE
{
    DH_IPC_PRIVATE,                                 // ˽��
    DH_IPC_AEBELL,                                  // ���籴��
    DH_IPC_PANASONIC,                               // ����
    DH_IPC_SONY,                                    // ����
    DH_IPC_DYNACOLOR,                               // Dynacolor
    DH_IPC_TCWS = 5,                                // �������
    DH_IPC_SAMSUNG,                                 // ����
    DH_IPC_YOKO,                                    // YOKO
    DH_IPC_AXIS,                                    // ��Ѷ��
    DH_IPC_SANYO,                                   // ����       
    DH_IPC_BOSH = 10,                               // Bosch
    DH_IPC_PECLO,                                   // Peclo
    DH_IPC_PROVIDEO,                                // Provideo
    DH_IPC_ACTI,                                    // ACTi
    DH_IPC_VIVOTEK,                                 // Vivotek
    DH_IPC_ARECONT = 15,                            // Arecont
    DH_IPC_PRIVATEEH,                               // PrivateEH    
    DH_IPC_IMATEK,                                  // IMatek
    DH_IPC_SHANY,                                   // Shany
    DH_IPC_VIDEOTREC,                               // ����ӯ��
    DH_IPC_URA = 20,                                // Ura
    DH_IPC_BITICINO,                                // Bticino 
    DH_IPC_ONVIF,                                   // OnvifЭ������
    DH_IPC_SHEPHERD,                                // �Ӱ�
    DH_IPC_YAAN,                                    // �ǰ�
    DH_IPC_AIRPOINT = 25,                           // Airpop
    DH_IPC_TYCO,                                    // TYCO
    DH_IPC_XUNMEI,                                  // Ѷ��
    DH_IPC_HIKVISION,                               // ����
    DH_IPC_LG,                                      // LG
    DH_IPC_AOQIMAN = 30,                            // ������
    DH_IPC_BAOKANG,                                 // ����    
    DH_IPC_WATCHNET,                                // Watchnet
    DH_IPC_XVISION,                                 // Xvision
    DH_IPC_FUSITSU,                                 // ��ʿͨ
    DH_IPC_CANON = 35,                              // Canon
    DH_IPC_GE,                                      // GE
    DH_IPC_Basler,                                  // ��˹��
    DH_IPC_Patro,                                   // ������
    DH_IPC_CPKNC,                                   // CPPLUS Kϵ��
    DH_IPC_CPRNC = 40,                              // CPPLUS Rϵ��
    DH_IPC_CPUNC,                                   // CPPLUS Uϵ��
    DH_IPC_CPPLUS,                                  // CPPLUS IPC
    DH_IPC_XunmeiS,                                 // Ѷ��s,ʵ��Э��ΪOnvif
    DH_IPC_GDDW,                                    // �㶫����
    DH_IPC_PSIA = 45,                               // PSIA
    DH_IPC_GB2818,                                  // GB2818    
    DH_IPC_GDYX,                                    // GDYX
    DH_IPC_OTHER,                                   // ���û��Զ���
    DH_IPC_CPUNR,                                   // CPPLUS NVR
    DH_IPC_CPUAR = 50,                              // CPPLUS DVR
    DH_IPC_AIRLIVE,                                 // Airlive    
    DH_IPC_NPE,                                     // NPE    
    DH_IPC_AXVIEW,                                  // AXVIEW
    DH_IPC_DFWL,                                    // ��������
    DH_IPC_HYUNDAI = 56,                            // HYUNDAI DVR
    DH_IPC_APHD,                                    // ���ջ���
    DH_IPC_WELLTRANS ,                              // ΢��
    DH_IPC_CDJF,                                    // �ɶ��ѷ�
    DH_IPC_JVC = 60,                                // JVC
    DH_IPC_INFINOVA,                                // Ӣ����
    DH_IPC_ADT,                                     // ADT
    DH_IPC_SIVIDI,                                  // ���ϴ���
    DH_IPC_CPUNP,                                   // CPPLUS ���
    DH_IPC_HX = 65,                                 // ����
    DH_IPC_TJGS,                                    // ������
    DH_IPC_MULTICAST = 79,                          // �鲥
    DH_IPC_RVI = 84,                                // RVi
}EM_IPC_TYPE;

// H264 ���뼶��
typedef enum __EM_H264_PROFILE_RANK
{
    DH_PROFILE_BASELINE = 1,                       // �ṩI/P֡,��֧��progressive(����ɨ��)��CAVLC
    DH_PROFILE_MAIN,                               // �ṩI/P/B֡,֧��progressiv��interlaced,�ṩCAVLC��CABAC
    DH_PROFILE_EXTENDED,                           // �ṩI/P/B/SP/SI֡,��֧��progressive(����ɨ��)��CAVLC
    DH_PROFILE_HIGH,                               // ��FRExt,Main_Profile������������8x8 intra prediction(8x8 ֡��Ԥ��), custom 
                                                   // quant(�Զ�������), lossless video coding(������Ƶ����), �����yuv��ʽ
}EM_H264_PROFILE_RANK;

typedef enum __EM_DISK_TYPE
{
    DH_DISK_READ_WRITE,                         // ��д������
    DH_DISK_READ_ONLY,                          // ֻ��������
    DH_DISK_BACKUP,                             // ������������ý��������
    DH_DISK_REDUNDANT,                          // ����������
    DH_DISK_SNAPSHOT,                           // ����������
}EM_DISK_TYPE;

// ���������㷨����ģʽ
typedef enum  __EM_ENCRYPT_ALOG_WORKMODE
{
    ENCRYPT_ALOG_WORKMODE_ECB,                  // ECBģʽ
    ENCRYPT_ALOG_WORKMODE_CBC,                  // CBCģʽ
    ENCRYPT_ALOG_WORKMODE_CFB,                  // CFBģʽ
    ENCRYPT_ALOG_WORKMODE_OFB,                  // OFBģʽ
}EM_ENCRYPT_ALOG_WORKMODE;

typedef enum __EM_MOBILE_PPP_STATE
{
    MOBILE_PPP_UP = 0,                          // �����Ѿ�����
    MOBILE_PPP_DOWN,                            // ppp���ӶϿ�        
    MOBILE_PPP_CONNECTING,                      // ���ڴ�������        
    MOBILE_PPP_CLOSEING,                        // ���ڹر�PPP����
} EM_MOBILE_PPP_STATE;

typedef enum __EM_3GMOBILE_STATE
{
    MOBILE_MODULE_OFF,                          // ��ʾ3g����ģ��ر�           
    MOBILE_MODULE_STARTING,                     // ��ʾ3g����ģ��������    
    MOBILE_MODULE_WORKING,                      // ��ʾ3g����ģ�����ڹ�����
}EM_3GMOBILE_STATE;

typedef enum tagEM_LOGIN_SPAC_CAP_TYPE
{
    EM_LOGIN_SPEC_CAP_TCP               = 0,    // TCP��½, Ĭ�Ϸ�ʽ
    EM_LOGIN_SPEC_CAP_ANY               = 1,    // ��������½
    EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2,    // ����ע��ĵ���
    EM_LOGIN_SPEC_CAP_MULTICAST         = 3,    // �鲥��½
    EM_LOGIN_SPEC_CAP_UDP               = 4,    // UDP��ʽ�µĵ���
    EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6,    // ֻ���������µĵ���
    EM_LOGIN_SPEC_CAP_SSL               = 7,    // SSL���ܷ�ʽ��½

    EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9,    // ��¼���ܺ�Զ���豸
    EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10,   // ��¼�豸����ȡ���ò���
    EM_LOGIN_SPEC_CAP_U_LOGIN           = 11,   // ��U���豸�ĵ���
    EM_LOGIN_SPEC_CAP_LDAP              = 12,   // LDAP��ʽ��¼
    EM_LOGIN_SPEC_CAP_AD                = 13,   // AD��ActiveDirectory����¼��ʽ
    EM_LOGIN_SPEC_CAP_RADIUS            = 14,   // Radius ��¼��ʽ 
    EM_LOGIN_SPEC_CAP_SOCKET_5          = 15,   // Socks5��½��ʽ
    EM_LOGIN_SPEC_CAP_CLOUD             = 16,   // �Ƶ�½��ʽ
    EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17,   // ���μ�Ȩ��½��ʽ
    EM_LOGIN_SPEC_CAP_TS                = 18,   // TS�����ͻ��˵�½��ʽ
    EM_LOGIN_SPEC_CAP_P2P               = 19,   // ΪP2P��½��ʽ
    EM_LOGIN_SPEC_CAP_MOBILE            = 20,   // �ֻ��ͻ��˵�½
    EM_LOGIN_SPEC_CAP_INVALID                   // ��Ч�ĵ�½��ʽ
}EM_LOGIN_SPAC_CAP_TYPE;

/////////////////////////////////�������/////////////////////////////////

// Ԥ������,��ӦCLIENT_RealPlayEx�ӿ�
typedef enum _RealPlayType
{
    DH_RType_Realplay = 0,                      // ʵʱԤ��
    DH_RType_Multiplay,                         // �໭��Ԥ��
    DH_RType_Realplay_0,                        // ʵʱ����-������,��ͬ��DH_RType_Realplay
    DH_RType_Realplay_1,                        // ʵʱ����-������1
    DH_RType_Realplay_2,                        // ʵʱ����-������2
    DH_RType_Realplay_3,                        // ʵʱ����-������3    
    DH_RType_Multiplay_1,                       // �໭��Ԥ����1����
    DH_RType_Multiplay_4,                       // �໭��Ԥ����4����
    DH_RType_Multiplay_8,                       // �໭��Ԥ����8����
    DH_RType_Multiplay_9,                       // �໭��Ԥ����9����
    DH_RType_Multiplay_16,                      // �໭��Ԥ����16����
    DH_RType_Multiplay_6,                       // �໭��Ԥ����6����
    DH_RType_Multiplay_12,                      // �໭��Ԥ����12����
    DH_RType_Multiplay_25,                      // �໭��Ԥ����25����
    DH_RType_Multiplay_36,                      // �໭��Ԥ����36����
    DH_RType_Realplay_Test = 255,               // �����������
} DH_RealPlayType;

/////////////////////////////////��̨���/////////////////////////////////

// ͨ����̨��������
typedef enum _PTZ_ControlType
{

    DH_PTZ_UP_CONTROL = 0,                      // ��
    DH_PTZ_DOWN_CONTROL,                        // ��
    DH_PTZ_LEFT_CONTROL,                        // ��
    DH_PTZ_RIGHT_CONTROL,                       // ��
    DH_PTZ_ZOOM_ADD_CONTROL,                    // �䱶+
    DH_PTZ_ZOOM_DEC_CONTROL,                    // �䱶-
    DH_PTZ_FOCUS_ADD_CONTROL,                   // ����+
    DH_PTZ_FOCUS_DEC_CONTROL,                   // ����-
    DH_PTZ_APERTURE_ADD_CONTROL,                // ��Ȧ+
    DH_PTZ_APERTURE_DEC_CONTROL,                // ��Ȧ-
    DH_PTZ_POINT_MOVE_CONTROL,                  // ת��Ԥ�õ�
    DH_PTZ_POINT_SET_CONTROL,                   // ����
    DH_PTZ_POINT_DEL_CONTROL,                   // ɾ��
    DH_PTZ_POINT_LOOP_CONTROL,                  // ���Ѳ��
    DH_PTZ_LAMP_CONTROL                         // �ƹ���ˢ
} DH_PTZ_ControlType;

// ��̨������չ����
typedef enum _EXTPTZ_ControlType
{
    DH_EXTPTZ_LEFTTOP = 0x20,                   // ����
    DH_EXTPTZ_RIGHTTOP,                         // ����
    DH_EXTPTZ_LEFTDOWN,                         // ����
    DH_EXTPTZ_RIGHTDOWN,                        // ����
    DH_EXTPTZ_ADDTOLOOP,                        // ����Ԥ�õ㵽Ѳ�� Ѳ����· Ԥ�õ�ֵ
    DH_EXTPTZ_DELFROMLOOP,                      // ɾ��Ѳ����Ԥ�õ� Ѳ����· Ԥ�õ�ֵ
    DH_EXTPTZ_CLOSELOOP,                        // ���Ѳ�� Ѳ����·
    DH_EXTPTZ_STARTPANCRUISE,                   // ��ʼˮƽ��ת
    DH_EXTPTZ_STOPPANCRUISE,                    // ֹͣˮƽ��ת
    DH_EXTPTZ_SETLEFTBORDER,                    // ������߽�
    DH_EXTPTZ_SETRIGHTBORDER,                   // �����ұ߽�
    DH_EXTPTZ_STARTLINESCAN,                    // ��ʼ��ɨ
    DH_EXTPTZ_CLOSELINESCAN,                    // ֹͣ��ɨ
    DH_EXTPTZ_SETMODESTART,                     // ����ģʽ��ʼ    ģʽ��·
    DH_EXTPTZ_SETMODESTOP,                      // ����ģʽ����    ģʽ��·
    DH_EXTPTZ_RUNMODE,                          // ����ģʽ    ģʽ��·
    DH_EXTPTZ_STOPMODE,                         // ֹͣģʽ    ģʽ��·
    DH_EXTPTZ_DELETEMODE,                       // ���ģʽ    ģʽ��·
    DH_EXTPTZ_REVERSECOMM,                      // ��ת����
    DH_EXTPTZ_FASTGOTO,                         // ���ٶ�λ ˮƽ����(8192) ��ֱ����(8192) �䱶(4)
    DH_EXTPTZ_AUXIOPEN,                         // �������ؿ� ������(param4��Ӧ PTZ_CONTROL_AUXILIARY,param1��param2��param3��Ч,dwStop����ΪFALSE)
    DH_EXTPTZ_AUXICLOSE,                        // �������ع� ������(param4��Ӧ PTZ_CONTROL_AUXILIARY,param1��param2��param3��Ч,dwStop����ΪFALSE)
    DH_EXTPTZ_OPENMENU = 0x36,                  // ������˵�
    DH_EXTPTZ_CLOSEMENU,                        // �رղ˵�
    DH_EXTPTZ_MENUOK,                           // �˵�ȷ��
    DH_EXTPTZ_MENUCANCEL,                       // �˵�ȡ��
    DH_EXTPTZ_MENUUP,                           // �˵���
    DH_EXTPTZ_MENUDOWN,                         // �˵���
    DH_EXTPTZ_MENULEFT,                         // �˵���
    DH_EXTPTZ_MENURIGHT,                        // �˵���
    DH_EXTPTZ_ALARMHANDLE = 0x40,               // ����������̨ parm1����������ͨ����parm2��������������1-Ԥ�õ�2-��ɨ3-Ѳ����parm3������ֵ,��Ԥ�õ��
    DH_EXTPTZ_MATRIXSWITCH = 0x41,              // �����л� parm1����������(��Ƶ�����)��parm2����Ƶ����ţ�parm3�������
    DH_EXTPTZ_LIGHTCONTROL,                     // �ƹ������
    DH_EXTPTZ_EXACTGOTO,                        // ��ά��ȷ��λ parm1��ˮƽ�Ƕ�(0~3600)��parm2����ֱ����(0~900)��parm3���䱶(1~128)
    DH_EXTPTZ_RESETZERO,                        // ��ά��λ������λ
    DH_EXTPTZ_MOVE_ABSOLUTELY,                  // �����ƶ���������,param4��Ӧ�ṹ PTZ_CONTROL_ABSOLUTELY
    DH_EXTPTZ_MOVE_CONTINUOUSLY,                // �����ƶ���������,param4��Ӧ�ṹ PTZ_CONTROL_CONTINUOUSLY
    DH_EXTPTZ_GOTOPRESET,                       // ��̨��������,��һ���ٶ�ת��Ԥ��λ��,parm4��Ӧ�ṹPTZ_CONTROL_GOTOPRESET
    DH_EXTPTZ_SET_VIEW_RANGE = 0x49,            // ���ÿ�����(param4��Ӧ�ṹ PTZ_VIEW_RANGE_INFO)
    DH_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A,          // ���Ծ۽�(param4��Ӧ�ṹPTZ_FOCUS_ABSOLUTELY)
    DH_EXTPTZ_HORSECTORSCAN = 0x4B,             // ˮƽ��ɨ(param4��ӦPTZ_CONTROL_SECTORSCAN,param1��param2��param3��Ч)
    DH_EXTPTZ_VERSECTORSCAN = 0x4C,             // ��ֱ��ɨ(param4��ӦPTZ_CONTROL_SECTORSCAN,param1��param2��param3��Ч)
    DH_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D,         // �趨���Խ��ࡢ�۽�ֵ,param1Ϊ����,��Χ:[0,255],param2Ϊ�۽�,��Χ:[0,255],param3��param4��Ч
    DH_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E,          // �������۵�����̨,param4��Ӧ�ṹ PTZ_CONTROL_SET_FISHEYE_EPTZ  
    DH_EXTPTZ_SET_TRACK_START = 0x4F,           // �������ʼ����(param4��Ӧ�ṹ��Ϊ PTZ_CONTROL_SET_TRACK_CONTROL,dwStop��FALSE, param1��param2��param3��Ч)
    DH_EXTPTZ_SET_TRACK_STOP = 0x50,            // �����ֹͣ����(param4��Ӧ�ṹ��Ϊ PTZ_CONTROL_SET_TRACK_CONTROL,dwStop��FALSE,param1��param2��param3��Ч)
    DH_EXTPTZ_RESTART = 0x51,                   // ��̨��������(param1��param2��param3 param4 ����Ч,dwStop����ΪFALSE)
	DH_EXTPTZ_INTELLI_TRACKMOVE = 0x52,         // ��̨�����ƶ�,ǹ������ר��,param4��Ӧ�ṹ PTZ_CONTROL_INTELLI_TRACKMOVE
    DH_EXTPTZ_SET_FOCUS_REGION = 0x53,          // ��������۽�����(param4��Ӧ�ṹ��ΪPTZ_CONTROL_SET_FOCUS_REGION,dwStop��FALSE,param1��param2��param3��Ч)
    DH_EXTPTZ_PAUSELINESCAN = 0x54,             // ��ͣ��ɨ(param1��param2��param3param4����Ч��dwStop����ΪFALSE)

    DH_EXTPTZ_UP_TELE = 0x70,                   // �� + TELE param1=�ٶ�(1-8),��ͬ
    DH_EXTPTZ_DOWN_TELE,                        // �� + TELE
    DH_EXTPTZ_LEFT_TELE,                        // �� + TELE
    DH_EXTPTZ_RIGHT_TELE,                       // �� + TELE
    DH_EXTPTZ_LEFTUP_TELE,                      // ���� + TELE
    DH_EXTPTZ_LEFTDOWN_TELE,                    // ���� + TELE
    DH_EXTPTZ_TIGHTUP_TELE,                     // ���� + TELE
    DH_EXTPTZ_RIGHTDOWN_TELE,                   // ���� + TELE
    DH_EXTPTZ_UP_WIDE,                          // �� + WIDE param1=�ٶ�(1-8),��ͬ
    DH_EXTPTZ_DOWN_WIDE,                        // �� + WIDE
    DH_EXTPTZ_LEFT_WIDE,                        // �� + WIDE
    DH_EXTPTZ_RIGHT_WIDE,                       // �� + WIDE
    DH_EXTPTZ_LEFTUP_WIDE,                      // ���� + WIDE
    DH_EXTPTZ_LEFTDOWN_WIDE,                    // ���� + WIDE
    DH_EXTPTZ_TIGHTUP_WIDE,                     // ���� + WIDE
    DH_EXTPTZ_RIGHTDOWN_WIDE,                   // ���� + WIDE
	DH_EXTPTZ_GOTOPRESETSNAP = 0x80,            // ת��Ԥ�õ㲢ץͼ
    DH_EXTPTZ_DIRECTIONCALIBRATION = 0x82,      // У׼��̨����˫����У׼��
    DH_EXTPTZ_SINGLEDIRECTIONCALIBRATION = 0x83, // У׼��̨���򣨵�����У׼��,param4��Ӧ�ṹ NET_IN_CALIBRATE_SINGLEDIRECTION
    
    DH_EXTPTZ_TOTAL,                            // �������ֵ
} DH_EXTPTZ_ControlType;

// ���۵�����̨��������
typedef enum tagNET_FISHEYE_EPTZ_CMD
{
    NET_FISHEYE_EPTZ_CMD_UNKOWN,                    // δ֪����
	NET_FISHEYE_EPTZ_CMD_ZOOMIN,                    // �Ŵ�,dwParam1��ʾ����,��Χ1��8
	NET_FISHEYE_EPTZ_CMD_ZOOMOUT,                   // ��С,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_UP,                        // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_DOWN,                      // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_LEFT,                      // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_RIGHT,                     // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_ROTATECLOCK,               // �Զ�˳ʱ����ת,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_ROTATEANTICLOCK,           // �Զ���ʱ����ת,dwParam1��ʾ����,��Χ1��8
    NET_FISHEYE_EPTZ_CMD_STOP,                      // ��ֹ�Զ���ת����
    NET_FISHEYE_EPTZ_CMD_TAPVIEW,                   // ��ʾָ��λ��,���㼴��,dwParam1��ʾeptz��������̨���Ľ��������,�������ڽ������ͼ���еĺ�����,ȡֵ���������������ͼ��Ŀ�
    // dwParam2��ʾeptz��������̨���Ľ���������,�������ڽ������ͼ���е�������,ȡֵ���������������ͼ��ĸ�
    NET_FISHEYE_EPTZ_CMD_SHOEREGION,                // ��ѡ�Ŵ�,wParam1��ʾ��ѡ�������ĵ�ĺ�����,
    // dwParam2��ʾ��ѡ�������ĵ��������,dwParam3��ʾ��ѡ���εĿ�
    // dwParam4��ʾ��ѡ���εĸ�
}NET_FISHEYE_EPTZ_CMD;

// �������������
typedef enum tagNET_TRACK_CONTROL_CMD
{
    NET_TRACK_CONTROL_CMD_UP,                       // �����ƶ�,dwParam1��ʾ����,��Χ1��8 
    NET_TRACK_CONTROL_CMD_DOWN,                     // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_TRACK_CONTROL_CMD_LEFT,                     // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_TRACK_CONTROL_CMD_RIGHT,                    // �����ƶ�,dwParam1��ʾ����,��Χ1��8
    NET_TRACK_CONTROL_CMD_SETPRESET,                // ����Ԥ�õ�,dwParam1��ʾԤ�õ�ֵ
    NET_TRACK_CONTROL_CMD_CLEARPRESET,              // ���Ԥ�õ�,dwParam1��ʾԤ�õ�ֵ
    NET_TRACK_CONTROL_CMD_GOTOPRESET,               // ת��Ԥ�õ�,dwParam1��ʾԤ�õ�ֵ
} NET_TRACK_CONTROL_CMD;

// ���۽���ģʽ
typedef enum tagNET_CALIBRATE_MODE
{
    NET_FISHEYE_CALIBRATE_MODE_UNKOWN,                      // δ֪ģʽ 
    NET_FISHEYE_CALIBRATE_MODE_ORIGIAL,                     // ԭʼͼ��ģʽ
    NET_FISHEYE_CALIBRATE_MODE_CONFIG,                      // ����ģ
    NET_FISHEYE_CALIBRATE_MODE_PANORAMA,                    // ȫ��ģʽ
    NET_FISHEYE_CALIBRATE_MODE_DOUBLEPANORAMA,              // ˫ȫ��ģʽ
    NET_FISHEYE_CALIBRATE_MODE_ORIGIALPLUSTHREEEPTZREGION,  // 1+3ģʽ��һ��ԭʼ����ͼ���3��EPtzͼ��
    NET_FISHEYE_CALIBRATE_MODE_SINGLE,                      // ������EPtzģʽ��ֻ��һ��EPtz���棩
    NET_FISHEYE_CALIBRATE_MODE_FOUREPTZREGION,              // 4����ģʽ��4��EPtz���ƻ��棩
    NET_FISHEYE_CALIBRATE_MODE_NORMAL,                      // ��ͨģʽ
}NET_FISHEYE_CALIBRATE_MODE;

typedef enum tagNET_FISHEYE_TYPE
{
    NET_FISHEYE_UNKOWN =0   ,               //δ֪
    NET_FISHEYE_CHIP        ,               //��֧���豸�����۽���
    NET_FISHEYE_PLUGIN      ,               //��֧�ֿؼ����۽���
    NET_FISHEYE_CHIP_PLUGIN ,               //���߶�֧��
}NET_FISHEYE_TYPE;

// ���۰�װģʽ
typedef enum tagNET_FISHEYE_MOUNT_MODE
{
    NET_FISHEYE_MOUNT_MODE_UNKOWN,                          // δ֪ģʽ                  
    NET_FISHEYE_MOUNT_MODE_CEIL,                            // ��װģʽ 
    NET_FISHEYE_MOUNT_MODE_WALL,                            // ��װģʽ  
    NET_FISHEYE_MOUNT_MODE_FLOOR,                           // ��װģʽ  
}NET_FISHEYE_MOUNT_MODE;
/////////////////////////////////��־���/////////////////////////////////

// ��־��ѯ����
typedef enum _DH_LOG_QUERY_TYPE
{
    DHLOG_ALL = 0,                              // ������־
    DHLOG_SYSTEM,                               // ϵͳ��־
    DHLOG_CONFIG,                               // ������־
    DHLOG_STORAGE,                              // �洢���
    DHLOG_ALARM,                                // ������־
    DHLOG_RECORD,                               // ¼�����
    DHLOG_ACCOUNT,                              // �ʺ����
    DHLOG_CLEAR,                                // �����־
    DHLOG_PLAYBACK,                             // �ط����
    DHLOG_MANAGER                               // ǰ�˹����������
} DH_LOG_QUERY_TYPE;

// ��־����
typedef enum _DH_LOG_TYPE
{
    DH_LOG_REBOOT = 0x0000,                     // �豸����
    DH_LOG_SHUT,                                // �豸�ػ�
    DH_LOG_REPORTSTOP,
    DH_LOG_REPORTSTART,
    DH_LOG_UPGRADE = 0x0004,                    // �豸����
    DH_LOG_SYSTIME_UPDATE = 0x0005,             // ϵͳʱ�����
    DH_LOG_GPS_TIME_UPDATE = 0x0006,            // GPSʱ�����
    DH_LOG_AUDIO_TALKBACK,                      // ����Խ�, true������,false����ر�    
    DH_LOG_COMM_ADAPTER,                        // ͸������, true������,false����ر�    
    DH_LOG_NET_TIMING,                          // ����Уʱ
    DH_LOG_CONFSAVE = 0x0100,                   // ��������
    DH_LOG_CONFLOAD,                            // ��ȡ����
    DH_LOG_FSERROR = 0x0200,                    // �ļ�ϵͳ����
    DH_LOG_HDD_WERR,                            // Ӳ��д����
    DH_LOG_HDD_RERR,                            // Ӳ�̶�����
    DH_LOG_HDD_TYPE,                            // ����Ӳ������
    DH_LOG_HDD_FORMAT,                          // ��ʽ��Ӳ��
    DH_LOG_HDD_NOSPACE,                         // ��ǰ�����̿ռ䲻��
    DH_LOG_HDD_TYPE_RW,                         // ����Ӳ������Ϊ��д��
    DH_LOG_HDD_TYPE_RO,                         // ����Ӳ������Ϊֻ����    
    DH_LOG_HDD_TYPE_RE,                         // ����Ӳ������Ϊ������
    DH_LOG_HDD_TYPE_SS,                         // ����Ӳ������Ϊ������
    DH_LOG_HDD_NONE,                            // ��Ӳ�̼�¼
    DH_LOG_HDD_NOWORKHDD,                       // �޹�����(û�ж�д��)
    DH_LOG_HDD_TYPE_BK,                         // ����Ӳ������Ϊ������
    DH_LOG_HDD_TYPE_REVERSE,                    // ����Ӳ������Ϊ�������
    DH_LOG_HDD_START_INFO = 0x20e ,             // ��¼����ʱ��Ӳ����Ϣ
    DH_LOG_HDD_WORKING_DISK,                    // ��¼���̺�Ĺ����̺�
    DH_LOG_HDD_OTHER_ERROR,                     // ��¼Ӳ����������
    DH_LOG_HDD_SLIGHT_ERR,                      // Ӳ�̴�����΢����
    DH_LOG_HDD_SERIOUS_ERR,                     // Ӳ�̴�����������
    DH_LOG_HDD_NOSPACE_END,                     // ��ǰ�����̿ռ䲻�㱨������
    DH_LOG_HDD_TYPE_RAID_CONTROL,               // Raid����
    DH_LOG_HDD_TEMPERATURE_HIGH,                // �¶ȹ���
    DH_LOG_HDD_TEMPERATURE_LOW,                 // �¶ȹ���
    DH_LOG_HDD_ESATA_REMOVE,                    // �Ƴ�eSATA
    DH_LOG_ALM_IN = 0x0300,                     // �ⲿ���뱨����ʼ
    DH_LOG_NETALM_IN,                           // ���籨������
    DH_LOG_ALM_END = 0x0302,                    // �ⲿ���뱨��ֹͣ
    DH_LOG_LOSS_IN,                             // ��Ƶ��ʧ������ʼ
    DH_LOG_LOSS_END,                            // ��Ƶ��ʧ��������
    DH_LOG_MOTION_IN,                           // ��̬��ⱨ����ʼ
    DH_LOG_MOTION_END,                          // ��̬��ⱨ������
    DH_LOG_ALM_BOSHI,                           // ��������������
    DH_LOG_NET_ABORT = 0x0308,                  // ����Ͽ�
    DH_LOG_NET_ABORT_RESUME,                    // ����ָ�
    DH_LOG_CODER_BREAKDOWN,                     // ����������
    DH_LOG_CODER_BREAKDOWN_RESUME,              // ���������ϻָ�
    DH_LOG_BLIND_IN,                            // ��Ƶ�ڵ�
    DH_LOG_BLIND_END,                           // ��Ƶ�ڵ��ָ�
    DH_LOG_ALM_TEMP_HIGH,                       // �¶ȹ���
    DH_LOG_ALM_VOLTAGE_LOW,                     // ��ѹ����
    DH_LOG_ALM_BATTERY_LOW,                     // �����������
    DH_LOG_ALM_ACC_BREAK,                       // ACC�ϵ�
    DH_LOG_ALM_ACC_RES,
    DH_LOG_GPS_SIGNAL_LOST,                     // GPS���ź�
    DH_LOG_GPS_SIGNAL_RESUME,                   // GPS�źŻָ�
    DH_LOG_3G_SIGNAL_LOST,                      // 3G���ź�
    DH_LOG_3G_SIGNAL_RESUME,                    // 3G�źŻָ�
    DH_LOG_ALM_IPC_IN,                          // IPC�ⲿ����
    DH_LOG_ALM_IPC_END,                         // IPC�ⲿ�����ָ�
    DH_LOG_ALM_DIS_IN,                          // ��������
    DH_LOG_ALM_DIS_END,                         // ���������ָ�
    DH_LOG_ALM_UPS_IN, 				            // UPS�澯
    DH_LOG_ALM_UPS_END, 				        // UPS�澯�ָ�
    DH_LOG_ALM_NAS_IN,				            // NAS�������쳣����
    DH_LOG_ALM_NAS_END,				            // NAS�������쳣�����ָ�
    DH_LOG_ALM_REDUNDANT_POWER_IN,              // �����Դ�澯
    DH_LOG_ALM_REDUNDANT_POWER_END,             // �����Դ�澯�ָ�
    DH_LOG_ALM_RECORD_FAILED_IN,				// ¼��ʧ�ܸ澯
    DH_LOG_ALM_RECORD_FAILED_END,			    // ¼��ʧ�ܸ澯�ָ�
    DH_LOG_ALM_VGEXCEPT_IN,				        // �洢���쳣����
    DH_LOG_ALM_VGEXCEPT_END,				    // �洢���쳣�����ָ�	
    DH_LOG_ALM_FANSPEED_IN,			            // ���ȱ�����ʼ
    DH_LOG_ALM_FANSPEED_END,			        // ���ȱ�������
    DH_LOG_ALM_DROP_FRAME_IN,			        // ��֡������ʼ
    DH_LOG_ALM_DROP_FRAME_END,			        // ��֡��������
    DH_LOG_ALM_DISK_STATE_CHECK,		        // ����Ԥ��Ѳ�챨���¼���־����
    DH_LOG_ALARM_COAXIAL_SMOKE,		            // ͬ���̸б����¼�
    DH_LOG_ALARM_COAXIAL_TEMP_HIGH,	            // ͬ���¶ȱ����¼�
    DH_LOG_ALARM_COAXIAL_ALM_IN,		        // ͬ���ⲿ�����¼�
    DH_LOG_INFRAREDALM_IN = 0x03a0,             // ���߱�����ʼ
    DH_LOG_INFRAREDALM_END,                     // ���߱�������
    DH_LOG_IPCONFLICT,                          // IP��ͻ
    DH_LOG_IPCONFLICT_RESUME,                   // IP�ָ�
    DH_LOG_SDPLUG_IN,                           // SD������(DH_LOG_ITEM�е�reservedֵΪ3��ʾU�̲���)
    DH_LOG_SDPLUG_OUT,                          // SD���γ�(DH_LOG_ITEM�е�reservedֵΪ3��ʾU�̰γ�)
    DH_LOG_NET_PORT_BIND_FAILED,                // ����˿ڰ�ʧ��
    DH_LOG_HDD_BEEP_RESET,                      // Ӳ�̴��󱨾���������
    DH_LOG_MAC_CONFLICT,                        // MAC��ͻ
    DH_LOG_MAC_CONFLICT_RESUME,                 // MAC��ͻ�ָ�
    DH_LOG_ALARM_OUT,                           // �������״̬
    DH_LOG_ALM_RAID_STAT_EVENT,                 // RAID״̬�仯�¼� 
    DH_LOG_ABLAZE_ON,                           // �𾯱���,�̸л��¶�
    DH_LOG_ABLAZE_OFF,                          // �𾯱��� �ָ�
    DH_LOG_INTELLI_ALARM_PLUSE,                 // ���������ͱ���
    DH_LOG_INTELLI_ALARM_IN,                    // ���ܱ�����ʼ
    DH_LOG_INTELLI_ALARM_END,                   // ���ܱ�������
    DH_LOG_3G_SIGNAL_SCAN,                      // 3G�źż��
    DH_LOG_GPS_SIGNAL_SCAN,                     // GPS�źż��
    DH_LOG_AUTOMATIC_RECORD = 0x0400,           // �Զ�¼��
    DH_LOG_MANUAL_RECORD = 0x0401,              // �ֶ�¼��
    DH_LOG_CLOSED_RECORD,                       // ֹͣ¼��
    DH_LOG_LOGIN = 0x0500,                      // ��¼
    DH_LOG_LOGOUT,                              // ע��
    DH_LOG_ADD_USER,                            // ����û�
    DH_LOG_DELETE_USER,                         // ɾ���û�
    DH_LOG_MODIFY_USER,                         // �޸��û�
    DH_LOG_ADD_GROUP,                           // ����û���
    DH_LOG_DELETE_GROUP,                        // ɾ���û���
    DH_LOG_MODIFY_GROUP,                        // �޸��û���
    DH_LOG_NET_LOGIN = 0x0508,                  // �����û���¼
    DH_LOG_MODIFY_PASSWORD,                     // �޸�����
    DH_LOG_CLEAR = 0x0600,                      // �����־
    DH_LOG_SEARCHLOG,                           // ��ѯ��־
    DH_LOG_SEARCH = 0x0700,                     // ¼���ѯ
    DH_LOG_DOWNLOAD,                            // ¼������
    DH_LOG_PLAYBACK,                            // ¼��ط�
    DH_LOG_BACKUP,                              // ����¼���ļ�
    DH_LOG_BACKUPERROR,                         // ����¼���ļ�ʧ��
    DH_LOG_BACK_UPRT,                           // ʵʱ����,�����̿�¼
    DH_LOG_BACKUPCLONE,                         // ���̸��ơ�
    DH_LOG_DISK_CHANGED,                        // �ֶ�����
    DH_LOG_IMAGEPLAYBACK,                       // ͼƬ�ط�
    DH_LOG_LOCKFILE,                            // ����¼��
    DH_LOG_UNLOCKFILE,                          // ����¼��
    DH_LOG_ATMPOS,                              // ATM���ŵ��������־
    DH_PLAY_PAUSE,                              // ��ͣ�ط�
    DH_PLAY_START,                              // ����
    LOG_PLAY_STOP,                              // ֹͣ�ط�
    LOG_PLAY_BACK,                              // ����
    LOG_PLAY_FAST,                              // ���
    LOG_PLAY_SLOW,                              // ����
    LOG_SMART_SEARCH,                           // ���ܼ���
    LOG_RECORD_SNAP,                            // ¼��ץͼ
    LOG_ADD_TAG,                                // ��ӱ�ǩ
    LOG_DEL_TAG,                                // ɾ����ǩ
    LOG_USB_IN,                                 // ����USB�豸
    LOG_USB_OUT,                                // USB�豸�Ͽ�����
    LOG_BACKUP_FILE,                            // �ļ�����
    LOG_BACKUP_LOG,                             // ��־����
    LOG_BACKUP_CONFIG,                          // ���ñ���

    DH_LOG_TIME_UPDATE  = 0x0800,               // ʱ��ͬ��
    DH_LOG_REMOTE_STATE = 0x0850,               // Զ����־ 
    DH_LOG_USER_DEFINE = 0x0900,
    DH_LOG_TYPE_NR = 10,
} DH_LOG_TYPE;

// ��չ��־����,��ӦCLIENT_QueryLogEx�ӿ�,����(int nType = 1������reserved = &nType)
typedef enum _DH_NEWLOG_TYPE
{
    DH_NEWLOG_REBOOT = 0x0000,                     // �豸����
    DH_NEWLOG_SHUT,                                // �豸�ػ�
    DH_NEWLOG_REPORTSTOP,
    DH_NEWLOG_REPORTSTART,
    DH_NEWLOG_UPGRADE = 0x0004,                    // �豸����
    DH_NEWLOG_SYSTIME_UPDATE = 0x0005,             // ϵͳʱ�����
    DH_NEWLOG_GPS_TIME_UPDATE = 0x0006,            // GPSʱ�����

    DH_NEWLOG_AUDIO_TALKBACK,                      // ����Խ�, true������,false����ر�    
    DH_NEWLOG_COMM_ADAPTER,                        // ͸������, true������,false����ر�    
    DH_NEWLOG_NET_TIMING,                          // ����Уʱ

    DH_NEWLOG_CONFSAVE = 0x0100,                   // ��������
    DH_NEWLOG_CONFLOAD,                            // ��ȡ����
    DH_NEWLOG_FSERROR = 0x0200,                    // �ļ�ϵͳ����
    DH_NEWLOG_HDD_WERR,                            // Ӳ��д����
    DH_NEWLOG_HDD_RERR,                            // Ӳ�̶�����
    DH_NEWLOG_HDD_TYPE,                            // ����Ӳ������
    DH_NEWLOG_HDD_FORMAT,                          // ��ʽ��Ӳ��
    DH_NEWLOG_HDD_NOSPACE,                         // ��ǰ�����̿ռ䲻��
    DH_NEWLOG_HDD_TYPE_RW,                         // ����Ӳ������Ϊ��д��
    DH_NEWLOG_HDD_TYPE_RO,                         // ����Ӳ������Ϊֻ����    
    DH_NEWLOG_HDD_TYPE_RE,                         // ����Ӳ������Ϊ������
    DH_NEWLOG_HDD_TYPE_SS,                         // ����Ӳ������Ϊ������
    DH_NEWLOG_HDD_NONE,                            // ��Ӳ�̼�¼��־
    DH_NEWLOG_HDD_NOWORKHDD,                       // �޹�����(û�ж�д��)
    DH_NEWLOG_HDD_TYPE_BK,                         // ����Ӳ������Ϊ������
    DH_NEWLOG_HDD_TYPE_REVERSE,                    // ����Ӳ������Ϊ�������
    DH_NEWLOG_HDD_START_INFO = 0x20e,              // ��¼����ʱ��Ӳ����Ϣ
    DH_NEWLOG_HDD_WORKING_DISK,                    // ��¼���̺�Ĺ����̺�
    DH_NEWLOG_HDD_OTHER_ERROR,                     // ��¼Ӳ����������
    DH_NEWLOG_HDD_SLIGHT_ERR,                      // Ӳ�̴�����΢����
    DH_NEWLOG_HDD_SERIOUS_ERR,                     // Ӳ�̴�����������
    DH_NEWLOG_HDD_NOSPACE_END,                     // ��ǰ�����̿ռ䲻�㱨������

    DH_NEWLOG_HDD_TYPE_RAID_CONTROL,               // Raid����
    DH_NEWLOG_HDD_TEMPERATURE_HIGH,                // �¶ȹ���
    DH_NEWLOG_HDD_TEMPERATURE_LOW,                 // �¶ȹ���
    DH_NEWLOG_HDD_ESATA_REMOVE,                    // �Ƴ�eSATA

    DH_NEWLOG_ALM_IN = 0x0300,                     // �ⲿ���뱨����ʼ
    DH_NEWLOG_NETALM_IN,                           // ���籨��
    DH_NEWLOG_ALM_END = 0x0302,                    // �ⲿ���뱨��ֹͣ
    DH_NEWLOG_LOSS_IN,                             // ��Ƶ��ʧ������ʼ
    DH_NEWLOG_LOSS_END,                            // ��Ƶ��ʧ��������
    DH_NEWLOG_MOTION_IN,                           // ��̬��ⱨ����ʼ
    DH_NEWLOG_MOTION_END,                          // ��̬��ⱨ������
    DH_NEWLOG_ALM_BOSHI,                           // ��������������
    DH_NEWLOG_NET_ABORT = 0x0308,                  // ����Ͽ�
    DH_NEWLOG_NET_ABORT_RESUME,                    // ����ָ�
    DH_NEWLOG_CODER_BREAKDOWN,                     // ����������
    DH_NEWLOG_CODER_BREAKDOWN_RESUME,              // ���������ϻָ�
    DH_NEWLOG_BLIND_IN,                            // ��Ƶ�ڵ�
    DH_NEWLOG_BLIND_END,                           // ��Ƶ�ڵ��ָ�
    DH_NEWLOG_ALM_TEMP_HIGH,                       // �¶ȹ���
    DH_NEWLOG_ALM_VOLTAGE_LOW,                     // ��ѹ����
    DH_NEWLOG_ALM_BATTERY_LOW,                     // �����������
    DH_NEWLOG_ALM_ACC_BREAK,                       // ACC�ϵ�
    DH_NEWLOG_ALM_ACC_RES,
    DH_NEWLOG_GPS_SIGNAL_LOST,                     // GPS���ź�
    DH_NEWLOG_GPS_SIGNAL_RESUME,                   // GPS�źŻָ�
    DH_NEWLOG_3G_SIGNAL_LOST,                      // 3G���ź�
    DH_NEWLOG_3G_SIGNAL_RESUME,                    // 3G�źŻָ�

    DH_NEWLOG_ALM_IPC_IN,                          // IPC�ⲿ����
    DH_NEWLOG_ALM_IPC_END,                         // IPC�ⲿ�����ָ�
    DH_NEWLOG_ALM_DIS_IN,                          // ��������
    DH_NEWLOG_ALM_DIS_END,                         // ���������ָ�

    DH_NEWLOG_INFRAREDALM_IN = 0x03a0,             // ���߱�����ʼ
    DH_NEWLOG_INFRAREDALM_END,                     // ���߱�������
    DH_NEWLOG_IPCONFLICT,                          // IP��ͻ
    DH_NEWLOG_IPCONFLICT_RESUME,                   // IP�ָ�
    DH_NEWLOG_SDPLUG_IN,                           // SD������
    DH_NEWLOG_SDPLUG_OUT,                          // SD���γ�
    DH_NEWLOG_NET_PORT_BIND_FAILED,                // ����˿ڰ�ʧ��
    DH_NEWLOG_HDD_BEEP_RESET,                      // Ӳ�̴��󱨾���������
    DH_NEWLOG_MAC_CONFLICT,                        // MAC��ͻ
    DH_NEWLOG_MAC_CONFLICT_RESUME,                 // MAC��ͻ�ָ�
    DH_NEWLOG_ALARM_OUT,                           // �������״̬
    DH_NEWLOG_ALM_RAID_STAT_EVENT,                 // RAID״̬�仯�¼� 
    DH_NEWLOG_ABLAZE_ON,                           // �𾯱���,�̸л��¶�
    DH_NEWLOG_ABLAZE_OFF,                          // �𾯱��� �ָ�
    DH_NEWLOG_INTELLI_ALARM_PLUSE,                 // ���������ͱ���
    DH_NEWLOG_INTELLI_ALARM_IN,                    // ���ܱ�����ʼ
    DH_NEWLOG_INTELLI_ALARM_END,                   // ���ܱ�������
    DH_NEWLOG_3G_SIGNAL_SCAN,                      // 3G�źż��
    DH_NEWLOG_GPS_SIGNAL_SCAN,                     // GPS�źż��
    DH_NEWLOG_AUTOMATIC_RECORD = 0x0400,           // �Զ�¼��
    DH_NEWLOG_MANUAL_RECORD,                       // �ֶ�¼��
    DH_NEWLOG_CLOSED_RECORD,                       // ֹͣ¼��
    DH_NEWLOG_LOGIN = 0x0500,                      // ��¼
    DH_NEWLOG_LOGOUT,                              // ע��
    DH_NEWLOG_ADD_USER,                            // ����û�
    DH_NEWLOG_DELETE_USER,                         // ɾ���û�
    DH_NEWLOG_MODIFY_USER,                         // �޸��û�
    DH_NEWLOG_ADD_GROUP,                           // ����û���
    DH_NEWLOG_DELETE_GROUP,                        // ɾ���û���
    DH_NEWLOG_MODIFY_GROUP,                        // �޸��û���
    DH_NEWLOG_NET_LOGIN = 0x0508,                  // �����û���¼
    DH_NEWLOG_CLEAR = 0x0600,                      // �����־
    DH_NEWLOG_SEARCHLOG,                           // ��ѯ��־
    DH_NEWLOG_SEARCH = 0x0700,                     // ¼���ѯ
    DH_NEWLOG_DOWNLOAD,                            // ¼������
    DH_NEWLOG_PLAYBACK,                            // ¼��ط�
    DH_NEWLOG_BACKUP,                              // ����¼���ļ�
    DH_NEWLOG_BACKUPERROR,                         // ����¼���ļ�ʧ��

    DH_NEWLOG_BACK_UPRT,                           // ʵʱ����,�����̿�¼
    DH_NEWLOG_BACKUPCLONE,                         // ���̸��ơ�
    DH_NEWLOG_DISK_CHANGED,                        // �ֶ�����
    DH_NEWLOG_IMAGEPLAYBACK,                       // ͼƬ�ط�
    DH_NEWLOG_LOCKFILE,                            // ����¼��
    DH_NEWLOG_UNLOCKFILE,                          // ����¼��
    DH_NEWLOG_ATMPOS,                              // ATM���ŵ��������־

    DH_NEWLOG_TIME_UPDATE  = 0x0800,               // ʱ�����
    DH_NEWLOG_REMOTE_STATE = 0x0850,               // Զ����־ 

    DH_NEWLOG_USER_DEFINE = 0x0900,
    DH_NEWLOG_TYPE_NR = 10,        
} DH_NEWLOG_TYPE;

///////////////////////////////����Խ����///////////////////////////////

// �����������
typedef enum __TALK_CODING_TYPE 
{
    DH_TALK_DEFAULT = 0,                        // ��ͷPCM
    DH_TALK_PCM = 1,                            // ��ͷPCM
    DH_TALK_G711a,                              // G711a
    DH_TALK_AMR,                                // AMR
    DH_TALK_G711u,                              // G711u
    DH_TALK_G726,                               // G726
    DH_TALK_G723_53,                            // G723_53
    DH_TALK_G723_63,                            // G723_63
    DH_TALK_AAC,                                // AAC
    DH_TALK_OGG,                                // OGG
    DH_TALK_G729 = 10,                          // G729
    DH_TALK_MPEG2,                               // MPEG2
    DH_TALK_MPEG2_Layer2,                        // MPEG2-Layer2
    DH_TALK_G722_1,                             // G.722.1
    DH_TALK_ADPCM = 21,                         // ADPCM
    DH_TALK_MP3   = 22,                            // MP3
    
} DH_TALK_CODING_TYPE;

// ¼���ļ�����
typedef enum __NET_RECORD_TYPE
{
    NET_RECORD_TYPE_ALL,                        // ����¼��
    NET_RECORD_TYPE_NORMAL,                     // ��ͨ¼��
    NET_RECORD_TYPE_ALARM,                      // �ⲿ����¼��
    NET_RECORD_TYPE_MOTION,                     // ���챨��¼��
}NET_RECORD_TYPE;

// �Խ���ʽ
typedef enum __EM_USEDEV_MODE
{
    DH_TALK_CLIENT_MODE,                        // ���ÿͻ��˷�ʽ��������Խ�
    DH_TALK_SERVER_MODE,                        // ���÷�������ʽ��������Խ�
    DH_TALK_ENCODE_TYPE,                        // ��������Խ������ʽ(��ӦDHDEV_TALKDECODE_INFO)
    DH_ALARM_LISTEN_MODE,                       // ���ñ������ķ�ʽ
    DH_CONFIG_AUTHORITY_MODE,                   // ����ͨ��Ȩ�޽������ù���
    DH_TALK_TALK_CHANNEL,                       // ���öԽ�ͨ��(0~MaxChannel-1)
    DH_RECORD_STREAM_TYPE,                      // ���ô���ѯ����ʱ��طŵ�¼����������(0-��������,1-������,2-������)  
    DH_TALK_SPEAK_PARAM,                        // ��������Խ���������,��Ӧ�ṹ�� NET_SPEAK_PARAM
    DH_RECORD_TYPE,                             // ���ð�ʱ��¼��طż����ص�¼���ļ�����(���NET_RECORD_TYPE)
    DH_TALK_MODE3,                              // ���������豸������Խ�����, ��Ӧ�ṹ�� NET_TALK_EX
    DH_PLAYBACK_REALTIME_MODE ,                 // ����ʵʱ�طŹ���(0-�ر�,1����)
    DH_TALK_TRANSFER_MODE,                      // ��������Խ��Ƿ�Ϊת��ģʽ, ��Ӧ�ṹ�� NET_TALK_TRANSFER_PARAM
    DH_TALK_VT_PARAM,                           // ����VT�Խ�����, ��Ӧ�ṹ�� NET_VT_TALK_PARAM
    DH_TARGET_DEV_ID,                           // ����Ŀ���豸��ʾ��, ���Բ�ѯ��ϵͳ����(��0-ת��ϵͳ������Ϣ)
} EM_USEDEV_MODE;


typedef enum __EM_TALK_DATA_TYPE
{ 
    NET_TALK_DATA_LOCAL_AUDIO = 0,              // ����¼���ɼ�����Ƶ����
    NET_TALK_DATA_RECV_AUDIO,                   // �յ����豸����������Ƶ����
    NET_TALK_DATA_RESPOND,                      // �Խ������Ӧ����
    NET_TALK_DATA_RECV_VIDEO,                   // �յ����豸����������Ƶ����
}EM_TALK_DATA_TYPE;

typedef struct tagNET_TALK_VIDEO_FORMAT
{
    DWORD               dwSize;
    DWORD               dwCompression;          // ��Ƶѹ����ʽ
    int                 nFrequency;             // ��Ƶ����Ƶ��
}NET_TALK_VIDEO_FORMAT;
// �����豸������Խ�����,��ӦCLIENT_SetDeviceMode()��DH_TALK_MODE3����
typedef struct tagNET_TALK_EX
{
    DWORD               dwSize;
    int                 nChannel;                               // ͨ����
    int                 nAudioPort;                             // ��Ƶ���������˿�
    int                 nWaitTime;                              // �ȴ�ʱ��, ��λms,Ϊ0��ʹ��Ĭ��ֵ
    HWND                hVideoWnd;                              // ���ӶԽ���Ƶ��ʾ����
    NET_TALK_VIDEO_FORMAT stuVideoFmt;                          // ��Ƶ�����ʽ
    char                szMulticastAddr[DH_MAX_IPADDR_LEN_EX];  // �鲥��ַ
    WORD                wMulticastLocalPort;                    // �鲥���ض˿�
    WORD                wMulticastRemotePort;                   // �鲥Զ�̶˿�
}NET_TALK_EX;

// AMR��������
typedef enum __EM_ARM_ENCODE_MODE
{
    DH_TALK_AMR_AMR475 = 1,                     // AMR475����
    DH_TALK_AMR_AMR515,                         // AMR515����
    DH_TALK_AMR_AMR59,                          // AMR59����
    DH_TALK_AMR_AMR67,                          // AMR67����
    DH_TALK_AMR_AMR74,                          // AMR74����
    DH_TALK_AMR_AMR795,                         // AMR795����
    DH_TALK_AMR_AMR102,                         // AMR102����
    DH_TALK_AMR_AMR122,                         // AMR122����
} EM_ARM_ENCODE_MODE;

typedef struct __NET_SPEAK_PARAM
{
    DWORD           dwSize;                     // �ṹ���С
    int             nMode;                      // 0���Խ���Ĭ��ģʽ��,1���������Ӻ����л����Խ�Ҫ��������
    int             nSpeakerChannel;            // ������ͨ����,����ʱ��Ч
    BOOL            bEnableWait;                // ����Խ�ʱ�Ƿ�ȴ��豸����Ӧ,Ĭ�ϲ��ȴ�.TRUE:�ȴ�;FALSE:���ȴ�
                                                // ��ʱʱ����CLIENT_SetNetworkParam����,��ӦNET_PARAM��nWaittime�ֶ�
} NET_SPEAK_PARAM;

// �Ƿ�������Խ���ת��ģʽ
typedef struct tagNET_TALK_TRANSFER_PARAM
{
    DWORD           dwSize;
    BOOL            bTransfer;                  // �Ƿ�������Խ�ת��ģʽ, TRUE: ����ת��, FALSE: �ر�ת��
}NET_TALK_TRANSFER_PARAM;

/////////////////////////////////�������/////////////////////////////////

// ��������,��ӦCLIENT_ControlDevice�ӿ�
typedef enum _CtrlType
{
    DH_CTRL_REBOOT = 0,                            // �����豸    
    DH_CTRL_SHUTDOWN,                              // �ر��豸
    DH_CTRL_DISK,                                  // Ӳ�̹���
    DH_KEYBOARD_POWER = 3,                         // �������
    DH_KEYBOARD_ENTER,
    DH_KEYBOARD_ESC,
    DH_KEYBOARD_UP,
    DH_KEYBOARD_DOWN,
    DH_KEYBOARD_LEFT,
    DH_KEYBOARD_RIGHT,
    DH_KEYBOARD_BTN0,
    DH_KEYBOARD_BTN1,
    DH_KEYBOARD_BTN2,
    DH_KEYBOARD_BTN3,
    DH_KEYBOARD_BTN4,
    DH_KEYBOARD_BTN5,
    DH_KEYBOARD_BTN6,
    DH_KEYBOARD_BTN7,
    DH_KEYBOARD_BTN8,
    DH_KEYBOARD_BTN9,
    DH_KEYBOARD_BTN10,
    DH_KEYBOARD_BTN11,
    DH_KEYBOARD_BTN12,
    DH_KEYBOARD_BTN13,
    DH_KEYBOARD_BTN14,
    DH_KEYBOARD_BTN15,
    DH_KEYBOARD_BTN16,
    DH_KEYBOARD_SPLIT,
    DH_KEYBOARD_ONE,
    DH_KEYBOARD_NINE,
    DH_KEYBOARD_ADDR,
    DH_KEYBOARD_INFO,
    DH_KEYBOARD_REC,
    DH_KEYBOARD_FN1,
    DH_KEYBOARD_FN2,
    DH_KEYBOARD_PLAY,
    DH_KEYBOARD_STOP,
    DH_KEYBOARD_SLOW,
    DH_KEYBOARD_FAST,
    DH_KEYBOARD_PREW,
    DH_KEYBOARD_NEXT,
    DH_KEYBOARD_JMPDOWN,
    DH_KEYBOARD_JMPUP,
    DH_KEYBOARD_10PLUS,
    DH_KEYBOARD_SHIFT,
    DH_KEYBOARD_BACK,               
    DH_KEYBOARD_LOGIN ,                            // ��������̹���
    DH_KEYBOARD_CHNNEL ,                           // �л���Ƶͨ��
    DH_TRIGGER_ALARM_IN = 100,                     // ������������
    DH_TRIGGER_ALARM_OUT,                          // �����������
    DH_CTRL_MATRIX,                                // �������
    DH_CTRL_SDCARD,                                // SD������(IPC��Ʒ)����ͬӲ�̿���
    DH_BURNING_START,                              // ��¼������,��ʼ��¼
    DH_BURNING_STOP,                               // ��¼������,������¼
    DH_BURNING_ADDPWD,                             // ��¼������,��������(��'\0'Ϊ��β���ַ���,��󳤶�8λ)
    DH_BURNING_ADDHEAD,                            // ��¼������,����Ƭͷ(��'\0'Ϊ��β���ַ���,��󳤶�1024�ֽ�,֧�ַ���,�зָ��'\n')
    DH_BURNING_ADDSIGN,                            // ��¼������,���Ӵ�㵽��¼��Ϣ(������)
    DH_BURNING_ADDCURSTOMINFO,                     // ��¼������,�Զ������(��'\0'Ϊ��β���ַ���,��󳤶�1024�ֽ�,֧�ַ���,�зָ��'\n')
    DH_CTRL_RESTOREDEFAULT,                        // �ָ��豸��Ĭ������
    DH_CTRL_CAPTURE_START,                         // �����豸ץͼ
    DH_CTRL_CLEARLOG,                              // �����־
    DH_TRIGGER_ALARM_WIRELESS = 200,               // �������߱���(IPC��Ʒ)
    DH_MARK_IMPORTANT_RECORD,                      // ��ʶ��Ҫ¼���ļ�
    DH_CTRL_DISK_SUBAREA,                          // ����Ӳ�̷���    
    DH_BURNING_ATTACH,                             // ��¼������,������¼.
    DH_BURNING_PAUSE,                              // ��¼��ͣ
    DH_BURNING_CONTINUE,                           // ��¼����
    DH_BURNING_POSTPONE,                           // ��¼˳��
    DH_CTRL_OEMCTRL,                               // ��ͣ����
    DH_BACKUP_START,                               // �豸���ݿ�ʼ
    DH_BACKUP_STOP,                                // �豸����ֹͣ
    DH_VIHICLE_WIFI_ADD,                           // �����ֶ�����WIFI����
    DH_VIHICLE_WIFI_DEC,                           // �����ֶ�ɾ��WIFI����
    DH_BUZZER_START,                               // ���������ƿ�ʼ
    DH_BUZZER_STOP,                                // ���������ƽ���
    DH_REJECT_USER,                                // �޳��û�
    DH_SHIELD_USER,                                // �����û�
    DH_RAINBRUSH,                                  // ���ܽ�ͨ, ��ˢ���� 
    DH_MANUAL_SNAP,                                // ���ܽ�ͨ, �ֶ�ץ�� (��Ӧ�ṹ��MANUAL_SNAP_PARAMETER)
    DH_MANUAL_NTP_TIMEADJUST,                      // �ֶ�NTPУʱ
    DH_NAVIGATION_SMS,                             // ������Ϣ�Ͷ���Ϣ
    DH_CTRL_ROUTE_CROSSING,                        // ·�ߵ�λ��Ϣ
    DH_BACKUP_FORMAT,                              // ��ʽ�������豸
    DH_DEVICE_LOCALPREVIEW_SLIPT,                  // �����豸�˱���Ԥ���ָ�(��Ӧ�ṹ��DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)    
    DH_CTRL_INIT_RAID,                             // RAID��ʼ��
    DH_CTRL_RAID,                                  // RAID����
    DH_CTRL_SAPREDISK,                             // �ȱ��̲���
    DH_WIFI_CONNECT,                               // �ֶ�����WIFI����(��Ӧ�ṹ��WIFI_CONNECT)
    DH_WIFI_DISCONNECT,                            // �ֶ��Ͽ�WIFI����(��Ӧ�ṹ��WIFI_CONNECT)
    DH_CTRL_ARMED,                                 // ����������
    DH_CTRL_IP_MODIFY,                             // �޸�ǰ��IP(��Ӧ�ṹ��DHCTRL_IPMODIFY_PARAM)                     
    DH_CTRL_WIFI_BY_WPS,                           // wps����wifi(��Ӧ�ṹ��DHCTRL_CONNECT_WIFI_BYWPS)
    DH_CTRL_FORMAT_PATITION,                       // ��ʽ������(��Ӧ�ṹ��DH_FORMAT_PATITION)
    DH_CTRL_EJECT_STORAGE,                         // �ֶ�ж���豸(��Ӧ�ṹ��DH_EJECT_STORAGE_DEVICE)
    DH_CTRL_LOAD_STORAGE,                          // �ֶ�װ���豸(��Ӧ�ṹ��DH_LOAD_STORAGE_DEVICE)
    DH_CTRL_CLOSE_BURNER,                          // �رտ�¼��������(��Ӧ�ṹ�� NET_CTRL_BURNERDOOR) һ����Ҫ��6��
    DH_CTRL_EJECT_BURNER,                          // ������¼��������(��Ӧ�ṹ�� NET_CTRL_BURNERDOOR) һ����Ҫ��4��
    DH_CTRL_CLEAR_ALARM,                           // ����(��Ӧ�ṹ�� NET_CTRL_CLEAR_ALARM)
    DH_CTRL_MONITORWALL_TVINFO,                    // ����ǽ��Ϣ��ʾ(��Ӧ�ṹ�� NET_CTRL_MONITORWALL_TVINFO)
    DH_CTRL_START_VIDEO_ANALYSE,                   // ��ʼ��Ƶ���ܷ���(��Ӧ�ṹ�� NET_CTRL_START_VIDEO_ANALYSE)
    DH_CTRL_STOP_VIDEO_ANALYSE,                    // ֹͣ��Ƶ���ܷ���(��Ӧ�ṹ�� NET_CTRL_STOP_VIDEO_ANALYSE)
    DH_CTRL_UPGRADE_DEVICE,                        // �������豸����,���豸���������������,����Ҫ���������ļ�
    DH_CTRL_MULTIPLAYBACK_CHANNALES,               // �л���ͨ��Ԥ���طŵ�ͨ��(��Ӧ�ṹ�� NET_CTRL_MULTIPLAYBACK_CHANNALES)
    DH_CTRL_SEQPOWER_OPEN,                         // ��Դʱ�����򿪿����������(��Ӧ NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_CLOSE,                        // ��Դʱ�����رտ����������(��Ӧ NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_OPEN_ALL,                     // ��Դʱ�����򿪿������������(��Ӧ NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_CLOSE_ALL,                    // ��Դʱ�����رտ������������(��Ӧ NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_PROJECTOR_RISE,                        // ͶӰ������(��Ӧ NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_PROJECTOR_FALL,                        // ͶӰ���½�(��Ӧ NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_PROJECTOR_STOP,                        // ͶӰ��ֹͣ(��Ӧ NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_INFRARED_KEY,                          // ���ⰴ��(��Ӧ NET_CTRL_INFRARED_KEY_PARAM)
    DH_CTRL_START_PLAYAUDIO,                       // �豸��ʼ������Ƶ�ļ�(��Ӧ�ṹ�� NET_CTRL_START_PLAYAUDIO)
    DH_CTRL_STOP_PLAYAUDIO,                        // �豸ֹͣ������Ƶ�ļ�
    DH_CTRL_START_ALARMBELL,                       // �����(��Ӧ�ṹ�� NET_CTRL_ALARMBELL)
    DH_CTRL_STOP_ALARMBELL,                        // �رվ���(��Ӧ�ṹ�� NET_CTRL_ALARMBELL)
    DH_CTRL_ACCESS_OPEN,                           // �Ž�����-����(��Ӧ�ṹ�� NET_CTRL_ACCESS_OPEN)
    DH_CTRL_SET_BYPASS,                            // ������·����(��Ӧ�ṹ�� NET_CTRL_SET_BYPASS)
    DH_CTRL_RECORDSET_INSERT,                      // ��Ӽ�¼,��ü�¼�����(��ӦNET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATE,                      // ����ĳ��¼����ŵļ�¼(��ӦNET_CTRL_RECORDSET_PARAM)
    DH_CTRL_RECORDSET_REMOVE,                      // ���ݼ�¼�����ɾ��ĳ��¼(��ӦNET_CTRL_RECORDSET_PARAM)
    DH_CTRL_RECORDSET_CLEAR,                       // ������м�¼����Ϣ(��ӦNET_CTRL_RECORDSET_PARAM)
    DH_CTRL_ACCESS_CLOSE,                          // �Ž�����-����(��Ӧ�ṹ�� NET_CTRL_ACCESS_CLOSE)
    DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET,            // ������ϵͳ��������(��Ӧ�ṹ��NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
    DH_CTRL_FORBID_OPEN_STROBE,                    // ��ֹ�豸�˿�բ(��Ӧ�ṹ�� NET_CTRL_FORBID_OPEN_STROBE)
    DH_CTRL_OPEN_STROBE,                           // �����բ(��Ӧ�ṹ�� NET_CTRL_OPEN_STROBE)
    DH_CTRL_TALKING_REFUSE,                        // �Խ��ܾ�����(��Ӧ�ṹ�� NET_CTRL_TALKING_REFUSE)
    DH_CTRL_ARMED_EX,                              // ����������(��Ӧ�ṹ�� CTRL_ARM_DISARM_PARAM_EX), ��CTRL_ARM_DISARM_PARAM ����,���������
    DH_CTRL_REMOTE_TALK,                           // Զ�̶Խ�����(��Ӧ�ṹ��NET_CTRL_REMOTETALK_PARAM)
    DH_CTRL_NET_KEYBOARD = 400,                    // ������̿���(��Ӧ�ṹ�� DHCTRL_NET_KEYBOARD)
    DH_CTRL_AIRCONDITION_OPEN,                     // �򿪿յ�(��Ӧ�ṹ�� NET_CTRL_OPEN_AIRCONDITION)
    DH_CTRL_AIRCONDITION_CLOSE,                    // �رտյ�(��Ӧ�ṹ�� NET_CTRL_CLOSE_AIRCONDITION)
    DH_CTRL_AIRCONDITION_SET_TEMPERATURE,          // �趨�յ��¶�(��Ӧ�ṹ�� NET_CTRL_SET_TEMPERATURE)
    DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE,       // ���ڿյ��¶�(��Ӧ�ṹ�� NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETMODE,                  // ���ÿյ�����ģʽ(��Ӧ�ṹ�� NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETWINDMODE,              // ���ÿյ��ͷ�ģʽ(��Ӧ�ṹ�� NET_CTRL_AIRCONDITION_SETMODE)
    DH_CTRL_RESTOREDEFAULT_EX ,                    // �ָ��豸��Ĭ��������Э��(��Ӧ�ṹ��NET_CTRL_RESTORE_DEFAULT)
                                                   // �ָ���������ʹ�ø�ö��,����ӿ�ʧ��,
                                                   // ��CLIENT_GetLastError����NET_UNSUPPORTED,�ٳ���ʹ��DH_CTRL_RESTOREDEFAULT�ָ�����
    DH_CTRL_NOTIFY_EVENT,                          // ���豸�����¼�(��Ӧ�ṹ�� NET_NOTIFY_EVENT_DATA)
    DH_CTRL_SILENT_ALARM_SET,                      // ������������
    DH_CTRL_START_PLAYAUDIOEX,                     // �豸��ʼ�����(��Ӧ�ṹ�� NET_CTRL_START_PLAYAUDIOEX)
    DH_CTRL_STOP_PLAYAUDIOEX,                      // �豸ֹͣ�����
    DH_CTRL_CLOSE_STROBE,                          // �رյ�բ(��Ӧ�ṹ�� NET_CTRL_CLOSE_STROBE)
    DH_CTRL_SET_ORDER_STATE,                       // ���ó�λԤ��״̬(��Ӧ�ṹ�� NET_CTRL_SET_ORDER_STATE)
    DH_CTRL_RECORDSET_INSERTEX,                    // ���ָ�Ƽ�¼,��ü�¼�����(��ӦNET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATEEX,                    // ����ָ�Ƽ�¼����ŵļ�¼(��ӦNET_CTRL_RECORDSET_PARAM)
    DH_CTRL_CAPTURE_FINGER_PRINT,                  // ָ�Ʋɼ�(��Ӧ�ṹ�� NET_CTRL_CAPTURE_FINGER_PRINT)
    DH_CTRL_ECK_LED_SET,                           // ͣ��������ڿ�����LED����(��Ӧ�ṹ�� NET_CTRL_ECK_LED_SET_PARAM)
    DH_CTRL_ECK_IC_CARD_IMPORT,                    // ����ͣ��ϵͳ����ڻ�IC����Ϣ����(��Ӧ�ṹ�� NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
    DH_CTRL_ECK_SYNC_IC_CARD,                      // ����ͣ��ϵͳ����ڻ�IC����Ϣͬ��ָ��,�յ���ָ���,�豸ɾ��ԭ��IC����Ϣ(��Ӧ�ṹ�� NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
    DH_CTRL_LOWRATEWPAN_REMOVE,                    // ɾ��ָ�������豸(��Ӧ�ṹ�� NET_CTRL_LOWRATEWPAN_REMOVE)
    DH_CTRL_LOWRATEWPAN_MODIFY,                    // �޸������豸��Ϣ(��Ӧ�ṹ�� NET_CTRL_LOWRATEWPAN_MODIFY)
	DH_CTRL_ECK_SET_PARK_INFO,                     // ����ͣ��ϵͳ����ڻ����ó�λ��Ϣ(��Ӧ�ṹ�� NET_CTRL_ECK_SET_PARK_INFO_PARAM)
    DH_CTRL_VTP_DISCONNECT,                        // �Ҷ���Ƶ�绰(��Ӧ�ṹ�� NET_CTRL_VTP_DISCONNECT)
    DH_CTRL_UPDATE_FILES,                          // Զ��Ͷ�Ŷ�ý���ļ�����(��Ӧ�ṹ�� NET_CTRL_UPDATE_FILES)
    DH_CTRL_MATRIX_SAVE_SWITCH,                    // ��������λ���������ϵ(��Ӧ�ṹ�� NET_CTRL_MATRIX_SAVE_SWITCH)
    DH_CTRL_MATRIX_RESTORE_SWITCH,                 // �ָ�����λ���������ϵ(��Ӧ�ṹ�� NET_CTRL_MATRIX_RESTORE_SWITCH)
    DH_CTRL_VTP_DIVERTACK,                         // ���ת����Ӧ(��Ӧ�ṹ�� NET_CTRL_VTP_DIVERTACK)	
    DH_CTRL_RAINBRUSH_MOVEONCE,                    // ��ˢ����ˢһ��,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ�ṹ�� NET_CTRL_RAINBRUSH_MOVEONCE)
    DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY,            // ��ˢ����ѭ��ˢ,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ�ṹ�� NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    DH_CTRL_RAINBRUSH_STOPMOVE,                    // ��ˢֹͣˢ,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ�ṹ�� NET_CTRL_RAINBRUSH_STOPMOVE)
    DH_CTRL_ALARM_ACK,                             // �����¼�ȷ��(��Ӧ�ṹ�� NET_CTRL_ALARM_ACK)
                                                   // DH_CTRL_ALARM_ACK �ò��������ڱ����ص��ӿ��е���
    DH_CTRL_RECORDSET_IMPORT,                      // ���������¼����Ϣ(��ӦNET_CTRL_RECORDSET_PARAM)
    DH_CTRL_DELIVERY_FILE,                         // ����Ƶ�����Ͷ����Ƶ��ͼƬ�ļ�, ¥��Խ�ʹ�ã�ͬһʱ��Ͷ��(��ӦNET_CTRL_DELIVERY_FILE)
	DH_CTRL_FORCE_BREAKING,                        // ǿ�Ʋ���Υ������(��Ӧ NET_CTRL_FORCE_BREAKING)
	DH_CTRL_RESTORE_EXCEPT,						   // �ָ���ָ�����������������ΪĬ�ϡ�
	DH_CTRL_SET_PARK_INFO,						   // ����ͣ����Ϣ��ƽ̨���ø�������������ڵ�������ʾ(��Ӧ�ṹ�� NET_CTRL_SET_PARK_INFO)
	DH_CTRL_CLEAR_SECTION_STAT,					   // �����ǰʱ���������ͳ����Ϣ, ���´�0��ʼ����(��Ӧ�ṹ��NET_CTRL_CLEAR_SECTION_STAT_INFO)
    DH_CTRL_DELIVERY_FILE_BYCAR,                   // ����Ƶ�����Ͷ����Ƶ��ͼƬ�ļ�, ����ʹ�ã���浥��ʱ��Ͷ��(��ӦNET_CTRL_DELIVERY_FILE_BYCAR)
                                                   // ��������ֻ�� CLIENT_ControlDeviceEx ����Ч
    DH_CTRL_THERMO_GRAPHY_ENSHUTTER = 0x10000,     // �����ȳ����������/����, pInBuf= NET_IN_THERMO_EN_SHUTTER*, pOutBuf= NET_OUT_THERMO_EN_SHUTTER * 
    DH_CTRL_RADIOMETRY_SETOSDMARK,                 // ���ò������osdΪ����, pInBuf= NET_IN_RADIOMETRY_SETOSDMARK*, pOutBuf= NET_OUT_RADIOMETRY_SETOSDMARK *    
    DH_CTRL_AUDIO_REC_START_NAME,                  // ������Ƶ¼��õ�¼����, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_AUDIO_REC_STOP_NAME,                   // �ر���Ƶ¼������ļ�����, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_SNAP_MNG_SNAP_SHOT,                    // ��ʱץͼ(�����ֶ�ץͼ), pInBuf = NET_IN_SNAP_MNG_SHOT *, pOutBuf = NET_OUT_SNAP_MNG_SHOT *
    DH_CTRL_LOG_STOP,                              // ǿ��ͬ���������ݵ����ݿⲢ�ر����ݿ�, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_LOG_RESUME,                            // �ָ����ݿ�, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_POS_ADD,                               // ����һ��Pos�豸, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_POS_REMOVE,                            // ɾ��һ��Pos�豸, pInBuf = NET_IN_POS_REMOVE *, pOutBuf = NET_OUT_POS_REMOVE *
    DH_CTRL_POS_REMOVE_MULTI,                      // ����ɾ��Pos�豸, pInBuf = NET_IN_POS_REMOVE_MULTI *, pOutBuf = NET_OUT_POS_REMOVE_MULTI *
    DH_CTRL_POS_MODIFY,                            // �޸�һ��Pos�豸, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_SET_SOUND_ALARM,                       // ������������, pInBuf = NET_IN_SOUND_ALARM *, pOutBuf = NET_OUT_SOUND_ALARM *
	DH_CTRL_AUDIO_MATRIX_SILENCE,				   // ��Ƶ��֤һ���������(��ӦpInBuf = NET_IN_AUDIO_MATRIX_SILENCE, pOutBuf =  NET_OUT_AUDIO_MATRIX_SILENCE)
    DH_CTRL_MANUAL_UPLOAD_PICTURE,                 // �����ֶ��ϴ�, pInBuf = NET_IN_MANUAL_UPLOAD_PICTURE *, pOutBUf = NET_OUT_MANUAL_UPLOAD_PICTURE *
    DH_CTRL_REBOOT_NET_DECODING_DEV,               // ������������豸, pInBuf = NET_IN_REBOOT_NET_DECODING_DEV *, pOutBuf = NET_OUT_REBOOT_NET_DECODING_DEV *
	DH_CTRL_SET_IC_SENDER,						   // ParkingControl ���÷����豸, pInBuf = NET_IN_SET_IC_SENDER *, pOutBuf = NET_OUT_SET_IC_SENDER * 
    DH_CTRL_SET_MEDIAKIND,                         // ���ü����������,�����Ƶ,����Ƶ,����Ƶ pInBuf = NET_IN_SET_MEDIAKIND *, pOutBuf = NET_OUT_SET_MEDIAKIND *
                                                   // ��Ϲ����б�������ʹ��, EN_ENCODE_CHN,2-����֧������Ƶ�ֿ���ȡ
	DH_CTRL_LOWRATEWPAN_ADD,                       // ���������豸��Ϣ(��Ӧ�ṹ�� pInBuf = NET_CTRL_LOWRATEWPAN_ADD *, pOutBUf = NULL)
	DH_CTRL_LOWRATEWPAN_REMOVEALL,                 // ɾ�����е������豸��Ϣ(��Ӧ�ṹ�� pInBuf = NET_CTRL_LOWRATEWPAN_REMOVEALL *, pOutBUf = NULL)
	DH_CTRL_SET_DOOR_WORK_MODE,                    // ������������ģʽ(��Ӧ�ṹ�� pInBuf = NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE *, pOutBUf = NULL)	
    DH_CTRL_TEST_MAIL,                             // �����ʼ� pInBuf = NET_IN_TEST_MAIL *, pOutBUf = NET_OUT_TEST_MAIL *
    DH_CTRL_CONTROL_SMART_SWITCH,                  // �������ܿ��� pInBuf = NET_IN_CONTROL_SMART_SWITCH *, pOutBUf = NET_OUT_CONTROL_SMART_SWITCH *
	DH_CTRL_LOWRATEWPAN_SETWORKMODE,          	   // ����̽�����Ĺ���ģʽ(��Ӧ�ṹ��pInBuf = NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE *, pOutBUf = NULL)
} CtrlType;

// ��������λ���������ϵ����(��Ӧ����DH_CTRL_MATRIX_SAVE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_SAVE_SWITCH 
{
    DWORD           dwSize;
    const char*     pszName;                        // ����λ���������ϵ����
} NET_CTRL_MATRIX_SAVE_SWITCH;

// �ָ�����λ���������ϵ����(��Ӧ����DH_CTRL_MATRIX_RESTORE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_RESTORE_SWITCH
{
    DWORD           dwSize;
    const char*     pszName;                        // ����λ���������ϵ����
} NET_CTRL_MATRIX_RESTORE_SWITCH;

// �ָ�Ĭ��������Э���������
typedef struct tagNET_CTRL_RESTORE_DEFAULT
{
    DWORD               dwSize;
    const char*         szCfgNames;                     // ����������'&&'Ϊ���,�������μ�dhconfigsdk.h��CLIENT_GetNewDevConfig��CLIENT_SetNewDevConfig�ӿڵ���������
}NET_CTRL_RESTORE_DEFAULT;

// �ָ����Ĭ�������������
typedef struct tagNET_CTRL_RESTORE_EXCEPT
{
	DWORD			dwSize;
	char		 	szCfgName[DH_MAX_STRING_LEN];				// �������ƣ��������μ�dhconfigsdk.h��CLIENT_GetNewDevConfig��CLIENT_SetNewDevConfig�ӿڵ���������
}NET_CTRL_RESTORE_EXCEPT;

// �򿪿յ�����(��Ӧ����DH_CTRL_AIRCONDITION_OPEN)
typedef struct tagNET_CTRL_OPEN_AIRCONDITION
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
} NET_CTRL_OPEN_AIRCONDITION;

// �رտյ�����(��Ӧ����DH_CTRL_AIRCONDITION_CLOSE)
typedef struct tagNET_CTRL_CLOSE_AIRCONDITION
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
} NET_CTRL_CLOSE_AIRCONDITION;

// ���ÿյ��¶Ȳ���(��Ӧ����DH_CTRL_AIRCONDITION_SET_TEMPERATURE)
typedef struct tagNET_CTRL_SET_TEMPERATURE
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
    int                 nTemperature;                   // �¶�ֵ(��λ�����϶�)
} NET_CTRL_SET_TEMPERATURE;

// ���ڿյ��¶Ȳ���(��Ӧ����DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE)
typedef struct tagNET_CTRL_ADJUST_TEMPERATURE
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
    int                 nTemperatureScale;              // ���õ�ֵ, ��-1��ʾ�¶��µ�һ��(��λ�����϶�)
} NET_CTRL_ADJUST_TEMPERATURE;

// ���ÿյ�����ģʽ����(��Ӧ����DH_CTRL_AIRCONDITION_SETMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETMODE
{
    DWORD                   dwSize;
    char                    szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
    EM_AIRCONDITION_MODE    emAirconditionMode;             // �յ�����ģʽ
    int                     nTemperature;                   // ���õ�ֵ(��λ�����϶�)
} NET_CTRL_AIRCONDITION_SETMODE;

// ���ÿյ��ͷ�ģʽ����(��Ӧ����DH_CTRL_AIRCONDITION_SETWINDMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETWINDMODE
{
    DWORD                       dwSize;
    char                        szDeviceID[DH_MAX_DEV_ID_LEN];  // �豸Ωһ��ʶ��
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // �յ��ͷ�ģʽ
} NET_CTRL_AIRCONDITION_SETWINDMODE;

// IO��������,��ӦCLIENT_QueryIOControlState�ӿ�
typedef enum _IOTYPE
{
    DH_ALARMINPUT = 1,                             // ���Ʊ�������,��Ӧ�ṹ��ΪALARM_CONTROL
    DH_ALARMOUTPUT = 2,                            // ���Ʊ����������Ӧ�ṹ��ΪALARM_CONTROL
    DH_DECODER_ALARMOUT = 3,                       // ���Ʊ����������������Ӧ�ṹ��ΪDECODER_ALARM_CONTROL
    DH_WIRELESS_ALARMOUT = 5,                      // �������߱����������Ӧ�ṹ��ΪALARM_CONTROL
    DH_ALARM_TRIGGER_MODE = 7,                     // ����������ʽ���ֶ�,�Զ�,�رգ�,ʹ��TRIGGER_MODE_CONTROL�ṹ��
} DH_IOTYPE;

/////////////////////////////////�������/////////////////////////////////

// �ֱ���ö��,��DH_DSP_ENCODECAPʹ��
typedef enum _CAPTURE_SIZE
{
    CAPTURE_SIZE_D1,                               // 704*576(PAL)  704*480(NTSC)
    CAPTURE_SIZE_HD1,                              // 352*576(PAL)  352*480(NTSC)
    CAPTURE_SIZE_BCIF,                             // 704*288(PAL)  704*240(NTSC)
    CAPTURE_SIZE_CIF,                              // 352*288(PAL)  352*240(NTSC)
    CAPTURE_SIZE_QCIF,                             // 176*144(PAL)  176*120(NTSC)
    CAPTURE_SIZE_VGA,                              // 640*480
    CAPTURE_SIZE_QVGA,                             // 320*240
    CAPTURE_SIZE_SVCD,                             // 480*480
    CAPTURE_SIZE_QQVGA,                            // 160*128
    CAPTURE_SIZE_SVGA,                             // 800*592
    CAPTURE_SIZE_XVGA,                             // 1024*768
    CAPTURE_SIZE_WXGA,                             // 1280*800
    CAPTURE_SIZE_SXGA,                             // 1280*1024  
    CAPTURE_SIZE_WSXGA,                            // 1600*1024  
    CAPTURE_SIZE_UXGA,                             // 1600*1200
    CAPTURE_SIZE_WUXGA,                            // 1920*1200
    CAPTURE_SIZE_LTF,                              // 240*192
    CAPTURE_SIZE_720,                              // 1280*720
    CAPTURE_SIZE_1080,                             // 1920*1080
    CAPTURE_SIZE_1_3M,                             // 1280*960
    CAPTURE_SIZE_2M,                               // 1872*1408
    CAPTURE_SIZE_5M,                               // 3744*1408
    CAPTURE_SIZE_3M,                               // 2048*1536
    CAPTURE_SIZE_5_0M,                             // 2432*2050
    CPTRUTE_SIZE_1_2M,                             // 1216*1024
    CPTRUTE_SIZE_1408_1024,                        // 1408*1024
    CPTRUTE_SIZE_8M,                               // 3296*2472
    CPTRUTE_SIZE_2560_1920,                        // 2560*1920(5M)
    CAPTURE_SIZE_960H,                             // 960*576(PAL) 960*480(NTSC)
    CAPTURE_SIZE_960_720,                          // 960*720
    CAPTURE_SIZE_NHD,                              // 640*360
    CAPTURE_SIZE_QNHD,                             // 320*180
    CAPTURE_SIZE_QQNHD,                            // 160*90
    CAPTURE_SIZE_960_540,                          // 960*540
    CAPTURE_SIZE_640_352,                          // 640*352
    CAPTURE_SIZE_640_400,                          // 640*400
    CAPTURE_SIZE_320_192,                          // 320*192    
    CAPTURE_SIZE_320_176,                          // 320*176
    CAPTURE_SIZE_NR=255  
} CAPTURE_SIZE;

// �����ļ�����,��CLIENT_ExportConfigFile�ӿ�ʹ��
typedef enum __DH_CONFIG_FILE_TYPE
{
    DH_CONFIGFILE_ALL = 0,                         // ȫ�������ļ�
    DH_CONFIGFILE_LOCAL,                           // ���������ļ�
    DH_CONFIGFILE_NETWORK,                         // ���������ļ�
    DH_CONFIGFILE_USER,                            // �û������ļ�
} DH_CONFIG_FILE_TYPE;

// NTP
typedef enum __DH_TIME_ZONE_TYPE
{
    DH_TIME_ZONE_0,                                // {0, 0*3600,"GMT+00:00"}
    DH_TIME_ZONE_1,                                // {1, 1*3600,"GMT+01:00"}
    DH_TIME_ZONE_2,                                // {2, 2*3600,"GMT+02:00"}
    DH_TIME_ZONE_3,                                // {3, 3*3600,"GMT+03:00"}
    DH_TIME_ZONE_4,                                // {4, 3*3600+1800,"GMT+03:30"}
    DH_TIME_ZONE_5,                                // {5, 4*3600,"GMT+04:00"}
    DH_TIME_ZONE_6,                                // {6, 4*3600+1800,"GMT+04:30"}
    DH_TIME_ZONE_7,                                // {7, 5*3600,"GMT+05:00"}
    DH_TIME_ZONE_8,                                // {8, 5*3600+1800,"GMT+05:30"}
    DH_TIME_ZONE_9,                                // {9, 5*3600+1800+900,"GMT+05:45"}
    DH_TIME_ZONE_10,                               // {10, 6*3600,"GMT+06:00"}
    DH_TIME_ZONE_11,                               // {11, 6*3600+1800,"GMT+06:30"}
    DH_TIME_ZONE_12,                               // {12, 7*3600,"GMT+07:00"}
    DH_TIME_ZONE_13,                               // {13, 8*3600,"GMT+08:00"}
    DH_TIME_ZONE_14,                               // {14, 9*3600,"GMT+09:00"}
    DH_TIME_ZONE_15,                               // {15, 9*3600+1800,"GMT+09:30"}
    DH_TIME_ZONE_16,                               // {16, 10*3600,"GMT+10:00"}
    DH_TIME_ZONE_17,                               // {17, 11*3600,"GMT+11:00"}
    DH_TIME_ZONE_18,                               // {18, 12*3600,"GMT+12:00"}
    DH_TIME_ZONE_19,                               // {19, 13*3600,"GMT+13:00"}
    DH_TIME_ZONE_20,                               // {20, -1*3600,"GMT-01:00"}
    DH_TIME_ZONE_21,                               // {21, -2*3600,"GMT-02:00"}
    DH_TIME_ZONE_22,                               // {22, -3*3600,"GMT-03:00"}
    DH_TIME_ZONE_23,                               // {23, -3*3600-1800,"GMT-03:30"}
    DH_TIME_ZONE_24,                               // {24, -4*3600,"GMT-04:00"}
    DH_TIME_ZONE_25,                               // {25, -5*3600,"GMT-05:00"}
    DH_TIME_ZONE_26,                               // {26, -6*3600,"GMT-06:00"}
    DH_TIME_ZONE_27,                               // {27, -7*3600,"GMT-07:00"}
    DH_TIME_ZONE_28,                               // {28, -8*3600,"GMT-08:00"}
    DH_TIME_ZONE_29,                               // {29, -9*3600,"GMT-09:00"}
    DH_TIME_ZONE_30,                               // {30, -10*3600,"GMT-10:00"}
    DH_TIME_ZONE_31,                               // {31, -11*3600,"GMT-11:00"}
    DH_TIME_ZONE_32,                               // {32, -12*3600,"GMT-12:00"}
} DH_TIME_ZONE_TYPE;

typedef enum _SNAP_TYPE
{
    SNAP_TYP_TIMING = 0,
    SNAP_TYP_ALARM,
    SNAP_TYP_NUM,
} SNAP_TYPE;

typedef enum _CONNECT_STATE
{
    CONNECT_STATE_UNCONNECT  = 0,	// δ������
    CONNECT_STATE_CONNECTING,		// ��������
    CONNECT_STATE_CONNECTED,		// ������
	CONNECT_STATE_EMPTY,			// ͨ��δ���ã�����Ϣ
	CONNECT_STATE_CHANGED,			// ���ӵ��豸��Ϣ�иĶ�
    CONNECT_STATE_ERROR = 255,		// δ֪�豸״̬
} CONNECT_STATE;

// ץ��ģʽ
typedef enum tagDH_TRAFFIC_SNAP_MODE
{    
    DH_TRAFFIC_SNAP_MODE_COIL = 1,                       // ��Ȧץ��
    DH_TRAFFIC_SNAP_MODE_COIL_PICANALYSIS,               // ��Ȧץ��, ͼƬ����
    DH_TRAFFIC_SNAP_MODE_STREAM,                         // ��Ƶץ��
    DH_TRAFFIC_SNAP_MODE_STREAM_IDENTIFY,                // ��Ƶץ��, ����ʶ��
} DH_TRAFFIC_SNAP_MODE;

// ��λ������
typedef enum 
{
    NET_CARPORTLIGHT_TYPE_RED,                           // ���
    NET_CARPORTLIGHT_TYPE_GREEN,                         // �̵�
}NET_CARPORTLIGHT_TYPE;

// ��λ�����Ʒ�ʽ
typedef enum
{
    NET_CARPORTLIGHT_MODE_OFF,                           // �� 
    NET_CARPORTLIGHT_MODE_ON,                            // ��
    NET_CARPORTLIGHT_MODE_GLINT,                         // ��˸
}NET_CARPORTLIGHT_MODE;

/////////////////////////////////���ܽ�ͨ���/////////////////////////////////
//�ڰ�������������
typedef enum _EM_OPERATE_TYPE
{
    NET_TRAFFIC_LIST_INSERT,                             // ���Ӽ�¼����
    NET_TRAFFIC_LIST_UPDATE,                             // ���¼�¼����
    NET_TRAFFIC_LIST_REMOVE,                             // ɾ����¼����
    NET_TRAFFIC_LIST_MAX,
}EM_RECORD_OPERATE_TYPE ;

//��������
typedef enum _EM_NET_PLATE_TYPE
{
    NET_PLATE_TYPE_UNKNOWN,
    NET_PLATE_TYPE_NORMAL,                              // "Normal" ���ƺ���
    NET_PLATE_TYPE_YELLOW,                              // "Yellow" ����
    NET_PLATE_TYPE_DOUBLEYELLOW,                        // "DoubleYellow" ˫���β��
    NET_PLATE_TYPE_POLICE,                              // "Police" ����
    NET_PLATE_TYPE_ARMED,                               // "Armed" �侯��
    NET_PLATE_TYPE_MILITARY,                            // "Military" ���Ӻ���
    NET_PLATE_TYPE_DOUBLEMILITARY,                      // "DoubleMilitary" ����˫��
    NET_PLATE_TYPE_SAR,                                 // "SAR" �۰���������    
    NET_PLATE_TYPE_TRAINNING,                           // "Trainning" ����������
    NET_PLATE_TYPE_PERSONAL,                            // "Personal" ���Ժ���
    NET_PLATE_TYPE_AGRI,                                // "Agri" ũ����
    NET_PLATE_TYPE_EMBASSY,                             // "Embassy" ʹ�ݺ���
    NET_PLATE_TYPE_MOTO,                                // "Moto" Ħ�г�����
    NET_PLATE_TYPE_TRACTOR,                             // "Tractor" ����������
    NET_PLATE_TYPE_OFFICIALCAR,                         // "OfficialCar " ����
    NET_PLATE_TYPE_PERSONALCAR,                         // "PersonalCar" ˽�ҳ�
    NET_PLATE_TYPE_WARCAR,                              // "WarCar"  ����
    NET_PLATE_TYPE_OTHER,                               // "Other" ��������
	NET_PLATE_TYPE_CIVILAVIATION,                       // "Civilaviation" �񺽺���
	NET_PLATE_TYPE_BLACK,                               // "Black" ����
	NET_PLATE_TYPE_PURENEWENERGYMICROCAR,               // "PureNewEnergyMicroCar" ���綯����ԴС��
	NET_PLATE_TYPE_MIXEDNEWENERGYMICROCAR,              // "MixedNewEnergyMicroCar" �������ԴС��
	NET_PLATE_TYPE_PURENEWENERGYLARGECAR,               // "PureNewEnergyLargeCar" ���綯����Դ��
	NET_PLATE_TYPE_MIXEDNEWENERGYLARGECAR,              // "MixedNewEnergyLargeCar" �������Դ��
}EM_NET_PLATE_TYPE;


//������ɫ
typedef enum _EM_NET_PLATE_COLOR_TYPE
{
    NET_PLATE_COLOR_OTHER,                              // ������ɫ
    NET_PLATE_COLOR_BLUE,                               // ��ɫ "Blue"
    NET_PLATE_COLOR_YELLOW,                             // ��ɫ "Yellow"    
    NET_PLATE_COLOR_WHITE,                              // ��ɫ "White"
    NET_PLATE_COLOR_BLACK,                              // ��ɫ "Black"
    NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT,           // �Ƶ׺��� "YellowbottomBlackText"
    NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT,             // ���װ��� "BluebottomWhiteText" 
    NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT,            // �ڵװ��� "BlackBottomWhiteText"
	NET_PLATE_COLOR_SHADOW_GREEN,						// ������ "ShadowGreen"
	NET_PLATE_COLOR_YELLOW_GREEN,						// ����˫ƴ "YellowGreen"
}EM_NET_PLATE_COLOR_TYPE;

//��������
typedef enum _EM_NET_VEHICLE_TYPE
{
    NET_VEHICLE_TYPE_UNKNOW,                            // δ֪����
    NET_VEHICLE_TYPE_MOTOR,                             // "Motor" ������           
    NET_VEHICLE_TYPE_NON_MOTOR,                         // "Non-Motor"�ǻ�����        
    NET_VEHICLE_TYPE_BUS,                               // "Bus"������        
    NET_VEHICLE_TYPE_BICYCLE,                           // "Bicycle" ���г�        
    NET_VEHICLE_TYPE_MOTORCYCLE,                        // "Motorcycle"Ħ�г�        
    NET_VEHICLE_TYPE_UNLICENSEDMOTOR,                   // "UnlicensedMotor": ���ƻ�����
    NET_VEHICLE_TYPE_LARGECAR,                          // "LargeCar"  ��������
    NET_VEHICLE_TYPE_MICROCAR,                          // "MicroCar" С������
    NET_VEHICLE_TYPE_EMBASSYCAR,                        // "EmbassyCar" ʹ������
    NET_VEHICLE_TYPE_MARGINALCAR,                       // "MarginalCar" �������
    NET_VEHICLE_TYPE_AREAOUTCAR,                        // "AreaoutCar" ��������
    NET_VEHICLE_TYPE_FOREIGNCAR,                        // "ForeignCar" �⼮����
    NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE,            // "DualTriWheelMotorcycle"��������Ħ�г�
    NET_VEHICLE_TYPE_LIGHTMOTORCYCLE,                   // "LightMotorcycle" ���Ħ�г�
    NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE,                 // "EmbassyMotorcycle "ʹ��Ħ�г�
    NET_VEHICLE_TYPE_MARGINALMOTORCYCLE,                // "MarginalMotorcycle "���Ħ�г�
    NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE,                 // "AreaoutMotorcycle "����Ħ�г�
    NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE,                 // "ForeignMotorcycle "�⼮Ħ�г�
    NET_VEHICLE_TYPE_FARMTRANSMITCAR,                   // "FarmTransmitCar" ũ�����䳵
    NET_VEHICLE_TYPE_TRACTOR,                           // "Tractor" ������
    NET_VEHICLE_TYPE_TRAILER,                           // "Trailer"  �ҳ�
    NET_VEHICLE_TYPE_COACHCAR,                          // "CoachCar"��������
    NET_VEHICLE_TYPE_COACHMOTORCYCLE,                   // "CoachMotorcycle "����Ħ�г�
    NET_VEHICLE_TYPE_TRIALCAR,                          // "TrialCar" ��������
    NET_VEHICLE_TYPE_TRIALMOTORCYCLE,                   // "TrialMotorcycle "����Ħ�г�
    NET_VEHICLE_TYPE_TEMPORARYENTRYCAR,                 // "TemporaryEntryCar"��ʱ�뾳����
    NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE,          // "TemporaryEntryMotorcycle"��ʱ�뾳Ħ�г�
    NET_VEHICLE_TYPE_TEMPORARYSTEERCAR,                 // "TemporarySteerCar"��ʱ��ʻ��
    NET_VEHICLE_TYPE_PASSENGERCAR,                      // "PassengerCar" �ͳ�
    NET_VEHICLE_TYPE_LARGETRUCK,                        // "LargeTruck" �����
    NET_VEHICLE_TYPE_MIDTRUCK,                          // "MidTruck" �л���
    NET_VEHICLE_TYPE_SALOONCAR,                         // "SaloonCar" �γ�
    NET_VEHICLE_TYPE_MICROBUS,                          // "Microbus"�����
    NET_VEHICLE_TYPE_MICROTRUCK,                        // "MicroTruck"С����
    NET_VEHICLE_TYPE_TRICYCLE,                          // "Tricycle"���ֳ�
    NET_VEHICLE_TYPE_PASSERBY,                          // "Passerby" ����
}EM_NET_VEHICLE_TYPE;


//������ɫ
typedef enum _EM_NET_VEHICLE_COLOR_TYPE
{
    NET_VEHICLE_COLOR_OTHER,                            //������ɫ    
    NET_VEHICLE_COLOR_WHITE,                            //��ɫ	"White"
    NET_VEHICLE_COLOR_BLACK,                            //��ɫ	"Black"
    NET_VEHICLE_COLOR_RED,                              //��ɫ	"Red"
    NET_VEHICLE_COLOR_YELLOW,                           //��ɫ	"Yellow"
    NET_VEHICLE_COLOR_GRAY,                             //��ɫ	"Gray"
    NET_VEHICLE_COLOR_BLUE,                             //��ɫ	"Blue"
    NET_VEHICLE_COLOR_GREEN,                            //��ɫ	"Green"
    NET_VEHICLE_COLOR_PINK,                             //�ۺ�ɫ "Pink"
    NET_VEHICLE_COLOR_PURPLE,                           //��ɫ	"Purple"
    NET_VEHICLE_COLOR_BROWN,                            //��ɫ	"Brown"
}EM_NET_VEHICLE_COLOR_TYPE;

//��������
typedef enum _EM_NET_TRAFFIC_CAR_CONTROL_TYPE
{
    NET_CAR_CONTROL_OTHER,
    NET_CAR_CONTROL_OVERDUE_NO_CHECK,                   // ����δ��	"OverdueNoCheck"
    NET_CAR_CONTROL_BRIGANDAGE_CAR,                     // ��������	"BrigandageCar"
    NET_CAR_CONTROL_BREAKING,                           // Υ��		"Breaking"
    NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE,                // ��������  "CausetroubleEscape"
}EM_NET_TRAFFIC_CAR_CONTROL_TYPE;

typedef enum _EM_NET_AUTHORITY_TYPE
{
    NET_AUTHORITY_UNKNOW,
    NET_AUTHORITY_OPEN_GATE,                            //��բȨ��
}EM_NET_AUTHORITY_TYPE;

typedef enum _EM_NET_RECORD_TYPE
{
    NET_RECORD_UNKNOWN,

    NET_RECORD_TRAFFICREDLIST,                          // ��ͨ�������˻���¼
                                                        // ��ѯ������Ӧ FIND_RECORD_TRAFFICREDLIST_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_TRAFFIC_LIST_RECORD �ṹ��
    NET_RECORD_TRAFFICBLACKLIST,                        // ��ͨ�������˺ż�¼
                                                        // ��ѯ������Ӧ FIND_RECORD_TRAFFICREDLIST_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_TRAFFIC_LIST_RECORD �ṹ��
    NET_RECORD_BURN_CASE,                               // ��¼������¼
                                                        // ��ѯ������Ӧ FIND_RECORD_BURN_CASE_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_BURN_CASE_INFO �ṹ��
    NET_RECORD_ACCESSCTLCARD,                           // �Ž���
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESSCTLCARD_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORDSET_ACCESS_CTL_CARD �ṹ��
    NET_RECORD_ACCESSCTLPWD,                            // �Ž�����
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESSCTLPWD_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORDSET_ACCESS_CTL_PWD
    NET_RECORD_ACCESSCTLCARDREC,                        // �Ž������¼������ͬʱ�����ź�ʱ��β�ѯ,������NET_RECORD_ACCESSCTLCARDREC_EX��ѯ��
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESSCTLCARDREC_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORDSET_ACCESS_CTL_CARDREC �ṹ��
    NET_RECORD_ACCESSCTLHOLIDAY,                        // ���ռ�¼��
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORDSET_HOLIDAY �ṹ��
    NET_RECORD_TRAFFICFLOW_STATE,                       // ��ѯ��ͨ������¼
                                                        // ��ѯ������Ӧ FIND_RECORD_TRAFFICFLOW_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_TRAFFIC_FLOW_STATE �ṹ��
    NET_RECORD_VIDEOTALKLOG,                            // ͨ����¼
                                                        // ��ѯ������Ӧ FIND_RECORD_VIDEO_TALK_LOG_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_VIDEO_TALK_LOG �ṹ��
    NET_RECORD_REGISTERUSERSTATE,                       // ״̬��¼
                                                        // ��ѯ������Ӧ FIND_RECORD_REGISTER_USER_STATE_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_REGISTER_USER_STATE �ṹ��
    NET_RECORD_VIDEOTALKCONTACT,                        // ��ϵ�˼�¼
                                                        // ��ѯ������Ӧ FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_VIDEO_TALK_CONTACT �ṹ��

	NET_RECORD_ANNOUNCEMENT,							//�����¼
                                                        //��ѯ������Ӧ FIND_RECORD_ANNOUNCEMENT_CONDITION �ṹ��
                                                        //��¼��Ϣ��Ӧ NET_RECORD_ANNOUNCEMENT_INFO �ṹ��
														
														
	NET_RECORD_ALARMRECORD,							    //������¼
                                                        //��ѯ������Ӧ FIND_RECORD_ALARMRECORD_CONDITION �ṹ��
                                                        //��¼��Ϣ��Ӧ NET_RECORD_ALARMRECORD_INFO �ṹ��
														

    NET_RECORD_COMMODITYNOTICE,                         // �·���Ʒ��¼
                                                        // ��ѯ������Ӧ FIND_RECORD_COMMODITY_NOTICE_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_COMMODITY_NOTICE �ṹ��
                                                        
    NET_RECORD_HEALTHCARENOTICE,                        // ������Ϣ��¼
                                                        // ��ѯ������Ӧ FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_HEALTH_CARE_NOTICE �ṹ��

    NET_RECORD_ACCESSCTLCARDREC_EX,                     // �Ž������¼(��ѡ�񲿷�������ѯ,�������NET_RECORD_ACCESSCTLCARDREC)
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORDSET_ACCESS_CTL_CARDREC �ṹ��

    NET_RECORD_GPS_LOCATION,                            // GPSλ����Ϣ��¼, ֻʵ��import��clear
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_GPS_LOCATION_INFO �ṹ��

	NET_RECORD_RESIDENT,                                // ���ⷿ�⻧��Ϣ
														// ��ѯ������Ӧ FIND_RECORD_RESIDENT_CONDTION�ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_RESIDENT_INFO �ṹ��

	NET_RECORD_SENSORRECORD,                            // ��������ݼ�¼
														// ��ѯ������Ӧ FIND_RECORD_SENSORRECORD_CONDITION �ṹ��
														// ��¼��Ϣ��Ӧ NET_RECORD_SENSOR_RECORD �ṹ��
	
	NET_RECORD_ACCESSQRCODE,							//���Ŷ�ά���¼��
														//��¼��Ϣ��Ӧ NET_RECORD_ACCESSQRCODE_INFO�ṹ��
														
	NET_RECORD_ELECTRONICSTAG,							// ���ӳ��Ʋ�ѯ
														// ��ѯ������ӦFIND_RECORD_ELECTRONICSTAG_CONDITION �ṹ��
                                                        // ��¼��Ϣ��ӦNET_RECORD_ELECTRONICSTAG_INFO �ṹ��

    NET_RECORD_ACCESS_BLUETOOTH,						// �������ż�¼��
                                                        // ��ѯ������Ӧ FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION �ṹ��
                                                        // ��¼��Ϣ��Ӧ NET_RECORD_ACCESS_BLUETOOTH_INFO �ṹ��
}EM_NET_RECORD_TYPE;

// ʱ������
typedef enum
{
    NET_TIME_TYPE_ABSLUTE,                                  // ����ʱ��
    NET_TIME_TYPE_RELATIVE,                                 // ���ʱ��,�������Ƶ�ļ�ͷ֡Ϊʱ�����,ͷ֡��Ӧ��UTC(0000-00-00 00:00:00)
}EM_TIME_TYPE;

// ��ɫ����
typedef enum
{
    NET_COLOR_TYPE_RED,                                     // ��ɫ
    NET_COLOR_TYPE_YELLOW,                                  // ��ɫ
    NET_COLOR_TYPE_GREEN,                                   // ��ɫ
    NET_COLOR_TYPE_CYAN,                                    // ��ɫ
    NET_COLOR_TYPE_BLUE,                                    // ��ɫ
    NET_COLOR_TYPE_PURPLE,                                  // ��ɫ
    NET_COLOR_TYPE_BLACK,                                   // ��ɫ
    NET_COLOR_TYPE_WHITE,                                   // ��ɫ
    NET_COLOR_TYPE_MAX,
}EM_COLOR_TYPE;

/////////////////////////////////����ʶ�����/////////////////////////////////
// ��Ա����
typedef enum 
{
    PERSON_TYPE_UNKNOWN,
    PERSON_TYPE_NORMAL,                                     // ��ͨ��Ա
    PERSON_TYPE_SUSPICION,                                  // ������Ա
	PERSON_TYPE_THIEF,                                      // С͵
	PERSON_TYPE_VIP,                                        // ��Ҫ��Ա
	PERSON_TYPE_FATECHECK,                                  // �����Ա
	PERSON_TYPE_STAFF,                                      // ������Ա
}EM_PERSON_TYPE;

// ֤������
typedef enum
{
    CERTIFICATE_TYPE_UNKNOWN,
    CERTIFICATE_TYPE_IC,                                    // ���֤
    CERTIFICATE_TYPE_PASSPORT,                              // ���� 
}EM_CERTIFICATE_TYPE;

// ����ʶ�����ݿ����
typedef enum
{
    NET_FACERECONGNITIONDB_UNKOWN, 
    NET_FACERECONGNITIONDB_ADD,                         // �����Ա��Ϣ����������,�����Ա�Ѿ�����,ͼƬ���ݺ�ԭ�������ݺϲ�
    NET_FACERECONGNITIONDB_DELETE,                      // ɾ����Ա��Ϣ����������
    NET_FACERECONGNITIONDB_MODIFY,                      // �޸���Ա��Ϣ����������,��Ա��UID��ʶ���� 
    NET_FACERECONGNITIONDB_DELETE_BY_UID,               // ͨ��UIDɾ����Ա��Ϣ����������
}EM_OPERATE_FACERECONGNITIONDB_TYPE;

// �����Ա�ģʽ
typedef enum 
{
    NET_FACE_COMPARE_MODE_UNKOWN,
    NET_FACE_COMPARE_MODE_NORMAL,                       // ����
    NET_FACE_COMPARE_MODE_AREA,                         // ָ�����������������
    NET_FACE_COMPARE_MODE_AUTO,                         // ����ģʽ,�㷨��������������������Զ�ѡȡ��� 
}EM_FACE_COMPARE_MODE;

// ��������
typedef enum
{
    NET_FACE_AREA_TYPE_UNKOWN,
    NET_FACE_AREA_TYPE_EYEBROW,                         // üë
    NET_FACE_AREA_TYPE_EYE,                             // �۾�
    NET_FACE_AREA_TYPE_NOSE,                            // ����
    NET_FACE_AREA_TYPE_MOUTH,                           // ���
    NET_FACE_AREA_TYPE_CHEEK,                           // ����
}EM_FACE_AREA_TYPE;

// ������������
typedef enum
{
    NET_FACE_DB_TYPE_UNKOWN,
    NET_FACE_DB_TYPE_HISTORY,                           // ��ʷ���ݿ�,��ŵ��Ǽ�����������Ϣ,һ��û�а���������Ӧ��Ա��Ϣ
    NET_FACE_DB_TYPE_BLACKLIST,                         // ���������ݿ�
    NET_FACE_DB_TYPE_WHITELIST,                         // ���������ݿ�,����
    NET_FACE_DB_TYPE_ALARM  ,                           // ������
}EM_FACE_DB_TYPE;

// ����ʶ���¼�����
typedef enum 
{
    NET_FACERECOGNITION_ALARM_TYPE_UNKOWN,
    NET_FACERECOGNITION_ALARM_TYPE_ALL,                // �ڰ�����
    NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST,          // ������
    NET_FACERECOGNITION_ALARM_TYPE_WHITELIST,          // ������
}EM_FACERECOGNITION_ALARM_TYPE;

// ����ʶ����������
typedef enum
{
    EM_FACERECOGNITION_FACE_TYPE_UNKOWN,
    EM_FACERECOGNITION_FACE_TYPE_ALL,                  // ��������   
    EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS,          // ʶ��ɹ�
    EM_FACERECOGNITION_FACE_TYPE_REC_FAIL,             // ʶ��ʧ��
}EM_FACERECOGNITION_FACE_TYPE;

// ֡����ö��ֵ  
typedef enum __EM_FRAME_TYPE
{
    EM_FRAME_UNKOWN,                                   // δ֪���� 
    EM_FRAME_TYPE_MOTION,                              // ����֡,��Ӧ֡��Ϣ�ṹ�� NET_MOTION_FRAM_INFO
}EM_FRAME_TYPE;

/////////////////////////////////��̭����/////////////////////////////////

// ��������,Ŀǰʹ�ø�ö�ٵĽӿ�����̭,�벻Ҫʹ��
typedef enum _CFG_INDEX
{
    CFG_GENERAL = 0,                                    // ��ͨ
    CFG_COMM,                                           // ����
    CFG_NET,                                            // ����
    CFG_RECORD,                                         // ¼��
    CFG_CAPTURE,                                        // ͼ������
    CFG_PTZ,                                            // ��̨
    CFG_DETECT,                                         // ��̬���
    CFG_ALARM,                                          // ����
    CFG_DISPLAY,                                        // ��ʾ
    CFG_RESERVED,                                       // ����,ʹ��������
    CFG_TITLE = 10,                                     // ͨ������
    CFG_MAIL = 11,                                      // �ʼ�����
    CFG_EXCAPTURE = 12,                                 // Ԥ��ͼ������
    CFG_PPPOE = 13,                                     // pppoe����
    CFG_DDNS = 14,                                      // DDNS����
    CFG_SNIFFER    = 15,                                // ������Ӳ�������
    CFG_DSPINFO    = 16,                                // ����������Ϣ
    CFG_COLOR = 126,                                    // ��ɫ������Ϣ
    CFG_ALL,                                            // ����
} CFG_INDEX;

/************************************************************************
 ** �ṹ�嶨��
 ***********************************************************************/

//��ʾ���������ԭ��ʾ���ڵ�����
typedef struct
{
    double                dleft;                  //��ʾ���������ԭ��ʾ���ڵ������� 
    double                dright;                 //��ʾ���������ԭ��ʾ���ڵ�������
    double                dtop;                   //��ʾ���������ԭ��ʾ���ڵ�������
    double                dbottom;                //��ʾ���������ԭ��ʾ���ڵ�������
} DH_DISPLAYRREGION;
// ʱ��
typedef struct 
{
    DWORD                dwYear;                  // ��
    DWORD                dwMonth;                 // ��
    DWORD                dwDay;                   // ��
    DWORD                dwHour;                  // ʱ
    DWORD                dwMinute;                // ��
    DWORD                dwSecond;                // ��
} NET_TIME,*LPNET_TIME;

typedef struct 
{
    DWORD                dwYear;                  // ��
    DWORD                dwMonth;                 // ��
    DWORD                dwDay;                   // ��
    DWORD                dwHour;                  // ʱ
    DWORD                dwMinute;                // ��
    DWORD                dwSecond;                // ��
    DWORD                dwMillisecond;           // ����
    DWORD                dwReserved[2];           // �����ֶ�
} NET_TIME_EX,*LPNET_TIME_EX;

// ��־��Ϣ���ʱ�䶨��
typedef struct _DHDEVTIME
{
    DWORD                second:6;                // ��    1-60        
    DWORD                minute:6;                // ��    1-60        
    DWORD                hour:5;                  // ʱ    1-24        
    DWORD                day:5;                   // ��    1-31        
    DWORD                month:4;                 // ��    1-12        
    DWORD                year:6;                  // ��    2000-2063    
} DHDEVTIME, *LPDHDEVTIME;

typedef struct tagRANGE
{
    float               fMax;                               // ���ֵ
    float               fMin;                               // ��Сֵ
    BOOL                abStep;                             // �Ƿ����ò���
    float               fStep;                              // ����
    BOOL                abDefault;                          // �Ƿ�����Ĭ��ֵ
    float               fDefault;                           // Ĭ��ֵ
    char reserved[16];
} RANGE;
// �ص�����(�첽�ӿ�)
typedef struct __NET_CALLBACK_DATA 
{
    int                  nResultCode;            // �����룻0���ɹ�
    char                 *pBuf;                  // ��������, ���������û����ٵ�,�ӽӿ��βδ��룬��СΪnRetLen
    int                  nRetLen;                // ���ճ���
    LLONG                lOperateHandle;         // �������
    void*                userdata;               // ������Ӧ�û�����
    char                 reserved[16];
} NET_CALLBACK_DATA, *LPNET_CALLBACK_DATA;

///////////////////////////////������ض���///////////////////////////////

// �ص���Ƶ����֡��֡�����ṹ��
typedef struct _tagVideoFrameParam
{
    BYTE                 encode;                 // ��������
    BYTE                 frametype;              // I = 0, P = 1, B = 2...
    BYTE                 format;                 // PAL - 0, NTSC - 1
    BYTE                 size;                   // CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
                                                 // SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15, LFT - 16, 720 - 17, 1080 - 18 ,1_3M-19
												 // 2M-20, 5M-21;��size=255ʱ����Ա����width,height ��Ч
    DWORD                fourcc;                 // �����H264��������Ϊ0������ֵΪ*( DWORD*)"DIVX"����0x58564944
    WORD				 width;					 // ����λ�����أ���size=255ʱ��Ч
	WORD				 height;				 // �ߣ���λ�����أ���size=255ʱ��Ч
    NET_TIME             struTime;               // ʱ����Ϣ
} tagVideoFrameParam;

// �ص���Ƶ����֡��֡�����ṹ��
typedef struct _tagCBPCMDataParam
{
    BYTE                channels;                // ������
    BYTE                samples;                 // ���� 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
    BYTE                depth;                   // ������� ȡֵ8����16�ȡ�ֱ�ӱ�ʾ
    BYTE                param1;                  // 0 - ָʾ�޷���,1-ָʾ�з���
    DWORD               reserved;                // ����
} tagCBPCMDataParam;

// ͨ��������Ļ���ӵ����ݽṹ
typedef struct _DH_CHANNEL_OSDSTRING
{
    BOOL                bEnable;                            // ʹ��
    DWORD               dwPosition[MAX_STRING_LINE_LEN];    //�����ַ���λ�á���1-9������ʾ,��С����λ�ö�Ӧ
                                                            // 7����    8��        9����
                                                            // 4��      5��        6��
                                                            // 1����    2��        3����
    char                szStrings[MAX_STRING_LINE_LEN][MAX_PER_STRING_LEN];    // ��������ַ�,ÿ�����20���ֽ�
} DH_CHANNEL_OSDSTRING;

//�ص�YUV���ݵĲ����ṹ��
typedef struct _tagCBYUVDataParam
{
    long                nWidth;                 // ͼ��Ŀ�
    long                nHeight;                // ͼ��ĸ�
    NET_TIME            stNetTime;              // �����е�ʱ��
    DWORD               reserved[2];            // ����
} tagCBYUVDataParam;

///////////////////////////////�ط���ض���///////////////////////////////
// ¼���ѯ����
typedef enum tagEmQueryRecordType
{
    EM_RECORD_TYPE_ALL              = 0,            // ����¼��
    EM_RECORD_TYPE_ALARM            = 1,            // �ⲿ����¼��
    EM_RECORD_TYPE_MOTION_DETECT    = 2,            // ��̬��ⱨ��¼��
    EM_RECORD_TYPE_ALARM_ALL        = 3,            // ���б���¼��
    EM_RECORD_TYPE_CARD             = 4,            // ���Ų�ѯ
    EM_RECORD_TYPE_CONDITION        = 5,            // ��������ѯ
    EM_RECORD_TYPE_JOIN             = 6,            // ��ϲ�ѯ
    EM_RECORD_TYPE_CARD_PICTURE     = 8,            // �����Ų�ѯͼƬ,HB-U��NVS��ʹ��
    EM_RECORD_TYPE_PICTURE          = 9,            // ��ѯͼƬ,HB-U��NVS��ʹ��
    EM_RECORD_TYPE_FIELD            = 10,           // ���ֶβ�ѯ
    EM_RECORD_TYPE_INTELLI_VIDEO   = 11,           // ����¼���ѯ
    EM_RECORD_TYPE_NET_DATA         = 15,           // ��ѯ��������,�������ɵ�ʹ��
    EM_RECORD_TYPE_TRANS_DATA       = 16,           // ��ѯ͸����������¼��
    EM_RECORD_TYPE_IMPORTANT        = 17,           // ��ѯ��Ҫ¼��
    EM_RECORD_TYPE_TALK_DATA        = 18,           // ��ѯ¼���ļ�
    EM_RECORD_TYPE_POS				= 19,			// POS¼��

    EM_RECORD_TYPE_INVALID          = 256,          // ��Ч�Ĳ�ѯ����
    
}EM_QUERY_RECORD_TYPE;

// ¼���ļ���Ϣ
typedef struct
{
    unsigned int        ch;                         // ͨ����
    char                filename[124];              // �ļ���
    unsigned int        framenum;                   // �ļ���֡��
    unsigned int        size;                       // �ļ�����, ��λΪKbyte
    NET_TIME            starttime;                  // ��ʼʱ��
    NET_TIME            endtime;                    // ����ʱ��
    unsigned int        driveno;                    // ���̺�(��������¼��ͱ���¼�������,0��127��ʾ����¼��,����64��ʾ����1,128��ʾ����¼��)
    unsigned int        startcluster;               // ��ʼ�غ�
    BYTE                nRecordFileType;            // ¼���ļ�����  0����ͨ¼��1������¼��2���ƶ���⣻3������¼��4��ͼƬ, 5: ����¼��, 19: POS¼��, 255:����¼��
    BYTE                bImportantRecID;            // 0:��ͨ¼�� 1:��Ҫ¼��
    BYTE                bHint;                      // �ļ���λ����(nRecordFileType==4<ͼƬ>ʱ,bImportantRecID<<8 +bHint ,���ͼƬ��λ���� )
    BYTE                bRecType;                   // 0-������¼�� 1-����1��¼�� 2-������2 3-������3¼��
} NET_RECORDFILE_INFO, *LPNET_RECORDFILE_INFO;

// Ũ��¼���ļ���Ϣ
typedef struct tagNET_SynopsisFileInfo
{
    DWORD               dwSize;                     // �ýṹ���С
    char                szFileName[MAX_PATH];       // �ļ���,����C:\a.dav
    NET_TIME            stuStartTime;               // ��ʼʱ��
    NET_TIME            stuEndTime;                 // ����ʱ��
    unsigned int        nTaskID;                    // �ڷ�������ı�ʾ,���ļ���2ѡ1ʹ��
    BYTE                bFileType;                  // 1-��ƵŨ��¼���ļ�,2-��ƵŨ��Դ�ļ�
    BYTE                byMode;                     // ����ģʽ: 0-���ļ�����, 1-��ʱ������, 2-���ļ�ƫ������
    BYTE                bReserved[2];
    unsigned int        nFileLength;                // �ļ���С,��λ:KB
    unsigned int        nStartFileOffset;           // ��ʼ�ļ�ƫ��, ��λ: KB
    unsigned int        nEndFileOffset;             // �����ļ�ƫ��, ��λ: KB
    int                 nChannel;                   // ͨ����, NVR�ط�ר��(û��TaskID), ��Ũ����������Ч
    int                 nCluster;                   // �غ�, NVR�ط�ר��(û��TaskID), ��Ũ����������Ч
}NET_SYNOPSISFILE_INFO, *LPNET_SYNOPSISFILE_INFO;

// �ط����ݻص�����ԭ��
// pBuffer: ���ݻ��������ڴ���SDK�ڲ������ͷ�
// dwDataType: 0-¼���ļ�ԭʼ����,1-��˽����������
typedef int (CALLBACK *fDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

typedef struct __NET_MULTI_PLAYBACK_PARAM 
{
    DWORD                      dwSize; 
    int                        nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM]; // Ԥ��ͨ����
    int                        nChannelNum;                             // Ԥ��ͨ���� 
    int                        nType;                                   // �ط��ļ�����,0����ͨ¼��1������¼��2���ƶ���⣻3������¼��4��ͼƬ
    NET_TIME                   stStartTime;                             // �طſ�ʼʱ��
    NET_TIME                   stEndTime;                               // �طŽ���ʱ��
    int                        nFPS;                                    // ֡��,1~25
    int                        nBitRate;                                // ����ֵ,192~1024
    char                       szResolution[DH_MAX_CAPTURE_SIZE_NUM];   // �ֱ���,"D1"��"HD1"��"2CIF"��"CIF"��"QCIF"   
    int                        nWaitTime;                               // ��ʱ�ȴ�ʱ�� 
    HWND                       hWnd;                                    // ��Ƶ���Ŵ��ھ��
    fDataCallBack              fDownLoadDataCallBack;                   // ��Ƶ���ݻص�
    LDWORD                     dwDataUser;                              // 
}NET_MULTI_PLAYBACK_PARAM;

// ĳ�µĸ����Ƿ����¼���״̬��Ϣ
typedef struct
{
    BYTE        flag[32];           //ĳ���ڵĸ����Ƿ����¼���״̬����,0��ʾû��,1��ʾ�С�
    BYTE        Reserved[64];       //����
}NET_RECORD_STATUS, *LPNET_RECORD_STATUS;

// �첽��ѯ����ص�����ԭ��,
// nError = 0 ��ʾ��ѯ�ɹ�;
// nError = 1 ��ʾ�ڴ�����ʧ��;
// nError = 2 ��ʾ��ʱ, ����ʱʱ����δ����ָ��ʱ��ε����, pFileinfos,nFileNum�����Ѳ鵽��¼���б�;
// nError = 3 ��ʾ�豸��������У�鲻ͨ��;
// nError = 4 ���Ͳ�ѯ����ʧ��
typedef void (CALLBACK *fQueryRecordFileCallBack)(LLONG lQueryHandle, LPNET_RECORDFILE_INFO pFileinfos, int nFileNum, int nError, void *pReserved, LDWORD dwUser);

// CLIENT_StartQueryRecordFile�ӿ��������
typedef struct tagNET_IN_START_QUERY_RECORDFILE
{ 
    DWORD               dwSize;                            // �ṹ���С, �����߱����ʼ�����ֶ�
    int                 nChannelId;                        // ����ѯͨ����, ��0��ʼ
    int                 nRecordFileType;                   // ����ѯ¼������, ��� EM_QUERY_RECORD_TYPE ����
    int                 nStreamType;                       // ��ѯ��������,0-��������,1-������,2-������
    NET_TIME            stStartTime;                       // ��ѯ��ʼʱ��
    NET_TIME            stEndTime;                         // ��ѯ����ʱ��
    char*               pchCardid;                         // ������Ϣ���������տ��Ų�ѯʱ��Ч�����û������ڴ�
														   // ���nRecordFileType = 4��5��10,�ڴ��С������256�ֽ�
														   // ���nRecordFileType = 8,�ڴ��С������20�ֽ�
    int                 nWaitTime;                         // ��ʱ�ȴ�ʱ��,��λms 
    fQueryRecordFileCallBack cbFunc;                       // ��ѯ����ص����� 
    LDWORD              dwUser;                            // �û���Ϣ
	BOOL				bByTime;						   // �Ƿ����ʱ���ѯ
}NET_IN_START_QUERY_RECORDFILE;

typedef struct tagNET_OUT_START_QUERY_RECORDFILE
{
    DWORD                dwSize;                           // �ṹ���С
    LLONG                lQueryHandle;                     // ���ؾ��    
}NET_OUT_START_QUERY_RECORDFILE;

// �طŽ��Ȼص�����ԭ��
// dwDownLoadSize == -1 ��ʾ�û��طŻ������ؽ������
// dwDownLoadSize ==- 2 ��ʾ�û�û�лطŻ������ز���Ȩ��
typedef void (CALLBACK *fDownLoadPosCallBack)(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, LDWORD dwUser);

// ¼��ط������Ϣ
typedef struct tagNET_IN_PLAY_BACK_BY_TIME_INFO
{
    NET_TIME            stStartTime;                       // ��ʼʱ��
    NET_TIME            stStopTime;                        // ����ʱ��
    HWND                hWnd;                              // ���Ŵ���, ��ΪNULL
    fDownLoadPosCallBack cbDownLoadPos;                    // ���Ȼص�
    LDWORD              dwPosUser;                         // ���Ȼص��û���Ϣ
    fDataCallBack       fDownLoadDataCallBack;             // ���ݻص�
    LDWORD              dwDataUser;                        // ���ݻص��û���Ϣ
    int                 nPlayDirection;                    // ���ŷ���, 0:����; 1:����;
    int                 nWaittime;                         // �ӿڳ�ʱʱ��, Ŀǰ����ʹ��
    BYTE                bReserved[1024];                   // Ԥ���ֽ�
}NET_IN_PLAY_BACK_BY_TIME_INFO;

// ¼��طų�����Ϣ
typedef struct tagNET_OUT_PLAY_BACK_BY_TIME_INFO
{
    BYTE                bReserved[1024];                   // Ԥ���ֽ�
}NET_OUT_PLAY_BACK_BY_TIME_INFO;

// ¼��ط��ٶ�
typedef enum tagEM_PLAY_BACK_SPEED
{
	EM_PLAY_BACK_SPEED_SLOW_16 = -4,               // 1/16������
	EM_PLAY_BACK_SPEED_SLOW_8,                     // 1/8������
	EM_PLAY_BACK_SPEED_SLOW_4,                     // 1/4������
	EM_PLAY_BACK_SPEED_SLOW_2,                     // 1/2������
	EM_PLAY_BACK_SPEED_NORMAL = 0,                 // �����ٶ�
	EM_PLAY_BACK_SPEED_FAST_2,                     // 2�����
	EM_PLAY_BACK_SPEED_FAST_4,                     // 4�����
	EM_PLAY_BACK_SPEED_FAST_8,                     // 8�����
	EM_PLAY_BACK_SPEED_FAST_16,                    // 16�����
}EM_PLAY_BACK_SPEED;

typedef struct
{
    unsigned short      left;                        // 0~8192
    unsigned short      right;                       // 0~8192
    unsigned short      top;                         // 0~8192
    unsigned short      bottom;                      // 0~8192
} MotionDetectRect;

// ���ܻط���Ϣ
typedef struct 
{
    MotionDetectRect    motion_rect;               // ����֡��������
    NET_TIME            stime;                     // �طŵĿ�ʼʱ��
    NET_TIME            etime;                     // �طŵĽ���ʱ��
    BYTE                bStart;                    // ��ʼֹͣ����: 1,��ʼ,2:ֹͣ
    BYTE                reserved[116];
} IntelligentSearchPlay, *LPIntelligentSearchPlay;

// ����¼��ʱ��
typedef struct  
{
    int                 nChnCount;                  // ͨ����Ŀ
    NET_TIME            stuFurthestTime[16];        // ����¼��ʱ��,��ЧֵΪǰ��0 �� (nChnCount-1)��.���ĳͨ��û��¼��Ļ�,����¼��ʱ��ȫΪ0
    DWORD               dwFurthestTimeAllSize;      // ��ͨ����������16ʱ,ʹ�á���ʾ����pStuFurthestTimeAll����ڴ��С��
    NET_TIME*           pStuFurthestTimeAll;        // ��ͨ����������16ʱ,ʹ�á��˲����ڴ���Ҫ�û�����,�����СΪ(ͨ������*sizeof(NET_TIME))��
    BYTE                bReserved[376];             // �����ֶ�
} NET_FURTHEST_RECORD_TIME;

// CLIENT_FindFramInfo �ӿ��������
typedef struct __NET_IN_FIND_FRAMEINFO_PRAM
{
    DWORD                 dwSize;                   // �ṹ���С 
    BOOL                  abFileName;               // �ļ����Ƿ���Ϊ��Ч�Ĳ�ѯ����,���ļ�����Ч,��������ļ���Ϣ��stRecordInfo��
    char                  szFileName[MAX_PATH];     // �ļ���
    NET_RECORDFILE_INFO   stuRecordInfo;            // �ļ���Ϣ
    DWORD                 dwFramTypeMask;           // ֡��������,�����֡�������붨�塱
}NET_IN_FIND_FRAMEINFO_PRAM;

// CLIENT_FindFramInfo �ӿ��������
typedef struct __NET_OUT_FIND_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // �ṹ���С 
    LLONG                 lFindHandle;          // �ļ����Ҿ��
}NET_OUT_FIND_FRAMEINFO_PRAM;

// ����֡��Ϣ
typedef struct __NET_MOTION_FRAME_INFO
{
    DWORD                 dwSize;               // �ṹ���С
    NET_TIME              stuTime;              // ��ǰ֡,ʱ��� 
    int                   nMotionRow;           // ��̬������������
    int                   nMotionCol;           // ��̬������������
    BYTE                  byRegion[DH_MOTION_ROW][DH_MOTION_COL];// �������,���32*32������
}NET_MOTION_FRAME_INFO;

// �ļ�֡��Ϣ
typedef struct __NET_FILE_FRAME_INFO
{
    DWORD                 dwSize;               // �ṹ���С
    int                   nChannelId;           // ͨ����
    NET_TIME              stuStartTime;         // ��ʼʱ��
    NET_TIME              stuEndTime;           // ����ʱ��
    WORD                  wRecType;             // 0-������¼�� 1-����1��¼�� 2-������2 3-������3¼��
    WORD                  wFameType;            // ֡����,���EM_FRAME_TYPE
    void*                 pFramInfo;            // ��Ӧ����֡��Ϣ,�ռ����û�����,���������ڴ��СΪsizeof(NET_MOTION_FRAME_INFO)
}NET_FILE_FRAME_INFO;

// CLIENT_FindNextFramInfo �ӿ��������
typedef struct __NET_IN_FINDNEXT_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // �ṹ���С  
    int                   nFramCount;           // ����ѯ֡����,0,��ʾ��ѯ���ϲ�ѯ����������֡��Ϣ
}NET_IN_FINDNEXT_FRAMEINFO_PRAM;

// CLIENT_FindNextFramInfo �ӿ��������
typedef struct __NET_OUT_FINDNEXT_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // �ṹ���С 
    NET_FILE_FRAME_INFO*  pFramInfos;           // ֡��Ϣ,���û�����ռ�,�ռ��СΪ sizeof(NET_FILE_FRAM_INFO) * nMaxFramCount
    int                   nMaxFramCount;        // �û������֡��Ϣ����
    int                   nRetFramCount;        // ʵ�ʷ��ص�֡��Ϣ����
}NET_OUT_FINDNEXT_FRAMEINFO_PRAM;

#define	MAX_LABEL_ARRAY		1024

// ��ǩ����
typedef struct tagNET_FILE_STREAM_TAG_INFO
{
	DWORD				dwSize;									// �ṹ���С
	NET_TIME			stuTime;								// ��ǩʱ��
	char				szContext[DH_COMMON_STRING_64];			// ��ǩ���ݣ����ı���ʹ��utf8����
	char				szUserName[DH_COMMON_STRING_32];		// �û��������ı���ʹ��utf8���룬EVS��������
	char				szChannelName[DH_COMMON_STRING_64];		// ͨ�����ƣ����ı���ʹ��utf8���룬EVS��������
} NET_FILE_STREAM_TAG_INFO;

// �ļ�����
typedef enum tagNET_FILE_STREAM_TYPE
{
	NET_FILE_STREAM_TYPE_UNKNOWN = 0,				// δ֪
	NET_FILE_STREAM_TYPE_NORMAL,					// ��ͨ
	NET_FILE_STREAM_TYPE_ALARM,						// ����
	NET_FILE_STREAM_TYPE_DETECTION,					// ����
} NET_FILE_STREAM_TYPE;

// ��ѯ���ı�ǩ��Ϣ
typedef struct tagNET_FILE_STREAM_TAG_INFO_EX
{
	DWORD					dwSize;	
	NET_TIME				stuTime;									// ��ǩ��������Ƶ��ʱ�䣬��ȷ����
	int						nMillisecond;								// ����
	int						nSequence;									// ��Ƶ���к�
	char					szContext[DH_COMMON_STRING_64];				// ��ǩ���ݣ����ı���ʹ��utf8����
	NET_TIME				stuStartTime;								// ¼���ļ���ʼʱ��
	NET_TIME				stuEndTime;									// ¼���ļ�����ʱ��
	NET_FILE_STREAM_TYPE	emType;										// �ļ�����
	char					szUserName[DH_COMMON_STRING_32];			// �û��������ı���ʹ��utf8���룬EVS��������
	char					szChannelName[DH_COMMON_STRING_64];			// ͨ�����ƣ����ı���ʹ��utf8���룬EVS��������
} NET_FILE_STREAM_TAG_INFO_EX;


// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags �ӿ��������
typedef struct tagNET_IN_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;								// �ṹ���С 
	int							nArrayCount;						// ��ǩ�������
	NET_FILE_STREAM_TAG_INFO*	pstuTagInfo;						// ��ǩ���飬�������ݹ�ϵΪ"��", �û������ڴ�,��СΪsizeof(NET_FILE_STREAM_TAG_INFO)*nArrayCount						
} NET_IN_FILE_STREAM_TAGS_INFO;

// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags �ӿ��������
typedef struct tagNET_OUT_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;					// �ṹ���С 
} NET_OUT_FILE_STREAM_TAGS_INFO;


// CLIENT_FileStreamGetTags �ӿ��������
typedef struct tagNET_IN_FILE_STREAM_GET_TAGS_INFO
{
	DWORD					dwSize;					// �ṹ���С 
} NET_IN_FILE_STREAM_GET_TAGS_INFO;

// CLIENT_FileStreamGetTags / CLIENT_FileStreamfilterTags �ӿ��������
typedef struct tagNET_OUT_FILE_STREAM_GET_TAGS_INFO
{
	DWORD							dwSize;								// �ṹ���С 
	int								nMaxNumber;							// ��ǩ����������
	int								nRetTagsNumber;						// ��ǩ����ʵ�ʷ��صĸ���
	NET_FILE_STREAM_TAG_INFO_EX*	pstuTagInfo;						// ��ǩ����
} NET_OUT_FILE_STREAM_GET_TAGS_INFO;


// CLIENT_FileStreamFilterTags �ӿ��������
typedef struct tagNET_IN_FILE_STREAM_FILTER_TAGS_INFO
{
	DWORD						dwSize;									// �ṹ���С 
	char						szContext[DH_COMMON_STRING_64];			// ��ǩ���ݣ����ı���ʹ��utf8����
	char						szUserName[DH_COMMON_STRING_32];		// �û��������ı���ʹ��utf8���룬EVS��������
	char						szChannelName[DH_COMMON_STRING_64];		// ͨ�����ƣ����ı���ʹ��utf8���룬EVS��������			
} NET_IN_FILE_STREAM_FILTER_TAGS_INFO;

// CLIENT_FileStreamfilterTags �ӿ��������
// typedef struct tagNET_OUT_FILE_STREAM_FILTER_TAGS_INFO
// {
// 	DWORD							dwSize;								// �ṹ���С 
// 	NET_FILE_STREAM_TAG_INFO_EX		stuTagInfo[MAX_LABEL_ARRAY];		// ��ǩ����
// 	int								nRetTagsCount;						// ʵ�ʷ��صı�ǩ��Ϣ����
// } NET_OUT_FILE_STREAM_FILTER_TAGS_INFO;

// �ӱ�ǩ��Ϣ
typedef struct tagNET_TAGMANAGER_SUB_TAG_INFO
{
	NET_TIME					stuTime;								// �ӱ�ǩʱ��
	char						szSubTagName[DH_COMMON_STRING_64];		// �ӱ�ǩ����
	BYTE						byReserved[512];						// �����ֶ�
}NET_TAGMANAGER_SUB_TAG_INFO;

// ��ǩ��Ϣ���ñ�ǩ�п�ʼ�ͽ���ʱ�䣬�� NET_FILE_STREAM_TAG_INFO_EX ��ͬ
typedef struct tagNET_TAGMANAGER_TAG_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// ��ǩ����	
	NET_TIME					stuStartTime;							// ¼���ǩ��ʼʱ��
	NET_TIME					stuEndTime;								// ¼���ǩ����ʱ��
	int							nSubTagVaildNum;						// �ӱ�ǩ��Ч����
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// �ӱ�ǩ����
	BYTE						byReserved[1024];						// �����ֶ�
}NET_TAGMANAGER_TAG_INFO;

// ��ǩ��ѯ��������Ϣ
typedef struct tagNET_FINDTAGS_CONDITION_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// ��ǩ����	
	BYTE						byReserved[1024];						// �����ֶ�
}NET_FINDTAGS_CONDITION_INFO;

// ��ѯ��ǩ��Ϣ, CLIENT_FileStreamFindTags �������
typedef struct tagNET_IN_FINDTAGS_INFO
{
	DWORD							dwSize;
	BOOL							bConditionEnable;					// ΪTrueʱ, stuCondition��Ч, lToken��Ч; ΪFalseʱ, stuCondition��Ч, lToken��Ч
	NET_FINDTAGS_CONDITION_INFO		stuCondition;						// ��ѯ��������һ�β�ѯʱʹ��
	UINT							lToken;								// ��ѯ������ڶ��β�ѯʱ��ʼʹ�ã��ɵ�һ�ε� NET_OUT_FINDTAGS_INFO ��ȡ
	int								nOffset;							// ��ѯƫ����
	int								nCount;								// ���β�ѯ������������60
}NET_IN_FINDTAGS_INFO;

// // ��ѯ��ǩ��Ϣ, CLIENT_FileStreamFindTags �������
typedef struct tagNET_OUT_FINDTAGS_INFO
{
	DWORD							dwSize;
	UINT							lToken;									// ��ѯ�������һ�β�ѯ����
	int								nTotal;									// �豸���صļ�¼����
	int								nMaxTagsNumber;							// ��ǩ����(pstuTagInfo)������, ��С�� NET_IN_FINDTAGS_INFO ��nCount�ֶ� 
	int								nRetTagsNumber;							// ��ǩ����(pstuTagInfo)ʵ�ʷ��صĸ���
	NET_TAGMANAGER_TAG_INFO*		pstuTagInfo;							// ��ǩ����ָ��, �û������ڴ�, ��СΪsizeof(NET_TAGMANAGER_TAG_INFO)*nMaxTagsNumber
}NET_OUT_FINDTAGS_INFO;

// ��ǩ״̬
typedef struct tagNET_TAGMANAGER_TAGSTATE_INFO
{
	int							nChannel;								// ͨ����
	char						szContext[DH_COMMON_STRING_64];			// ��ǩ����	
	NET_TIME					stuStartTime;							// ��ǩ��ʼʱ��
	int							nSubTagVaildNum;						// �ӱ�ǩ(stuSubTag)��Ч����
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// �ӱ�ǩ����
	BYTE						byReserved[1024];						// �����ֶ�
}NET_TAGMANAGER_TAGSTATE_INFO;

// ��ȡ�豸���ǩ״̬, CLIENT_TagManagerGetTagState �������
typedef struct tagNET_IN_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;
}NET_IN_TAGMANAGER_GETTAGSTATE_INFO;

// ��ȡ�豸���ǩ״̬, CLIENT_TagManagerGetTagState �������
typedef struct tagNET_OUT_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;
	int								nState;								// ���ǩ״̬, 0δ���ǩ, 1���ڴ��ǩ
	int								nMaxTagStaeNumber;					// ��ǩ����(pstuTagStateInfo)��������
	int								nRetTagStaeNumber;					// ��ǩ����(pstuTagStateInfo)��ʵ�ʷ��صĸ���
	NET_TAGMANAGER_TAGSTATE_INFO*	pstuTagStateInfo;					// ��ǩ�����ָ��, �û������ڴ�, ��СΪsizeof(NET_TAGMANAGER_TAGSTATE_INFO)*nMaxTagStaeNumber
}NET_OUT_TAGMANAGER_GETTAGSTATE_INFO;

// ��ʼ���ǩ, CLIENT_TagManagerStartTag �������
typedef struct tagNET_IN_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// ͨ����
	char						szContext[DH_COMMON_STRING_64];			// ��ǩ����	
}NET_IN_TAGMANAGER_STARTTAG_INFO;

// ��ʼ���ǩ, CLIENT_TagManagerStartTag �������
typedef struct tagNET_OUT_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_STARTTAG_INFO;

// ���ӱ�ǩ, CLIENT_TagManagerSetSubTag �������
typedef struct tagNET_IN_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// ͨ����
	char						szSubTagName[DH_COMMON_STRING_64];		// �ӱ�ǩ����	
}NET_IN_TAGMANAGER_SETSUBTAG_INFO;

// ���ӱ�ǩ, CLIENT_TagManagerSetSubTag �������
typedef struct tagNET_OUT_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_SETSUBTAG_INFO;

// ֹͣ���ǩ, CLIENT_TagManagerStopTag �������
typedef struct tagNET_IN_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// ͨ����
}NET_IN_TAGMANAGER_STOPTAG_INFO;

// ֹͣ���ǩ, CLIENT_TagManagerStopTag �������
typedef struct tagNET_OUT_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_STOPTAG_INFO;


///////////////////////////////������ض���///////////////////////////////

// ��ͨ������Ϣ
typedef struct
{
    int                  channelcount;
    int                  alarminputcount;
    unsigned char        alarm[16];                // �ⲿ����
    unsigned char        motiondection[16];        // ��̬���
    unsigned char        videolost[16];            // ��Ƶ��ʧ
} NET_CLIENT_STATE;

// ��ͨ������Ϣ
typedef struct
{
    int                  channelcount;
    int                  alarminputcount;
    unsigned char        alarm[32];                // �ⲿ����
    unsigned char        motiondection[32];        // ��̬���
    unsigned char        videolost[32];            // ��Ƶ��ʧ
    BYTE                 bReserved[32];
} NET_CLIENT_STATE_EX;

// �ⲿ����״̬��Ϣ��Ӧ�ṹ��
typedef struct
{
    DWORD                dwSize;
    int                  alarminputcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //ÿһ��DWORD��λ��ʾ32ͨ���ı���״̬, 0-��ʾ�ޱ���, 1-��ʾ�б���
}NET_CLIENT_ALARM_STATE;

// ��Ƶ��ʧ����״̬��Ϣ��Ӧ�ṹ��
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //ÿһ��DWORD��λ��ʾ32ͨ���ı���״̬, 0-��ʾ�ޱ���, 1-��ʾ�б���
}NET_CLIENT_VIDEOLOST_STATE;

// ��̬��ⱨ��״̬��Ϣ��Ӧ�ṹ��
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //ÿһ��DWORD��λ��ʾ32ͨ���ı���״̬, 0-��ʾ�ޱ���, 1-��ʾ�б���
}NET_CLIENT_MOTIONDETECT_STATE;

// ��Ƶ�ڵ�����״̬��Ϣ��Ӧ�ṹ��
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //ÿһ��DWORD��λ��ʾ32ͨ���ı���״̬, 0-��ʾ�ޱ���, 1-��ʾ�б���
}NET_CLIENT_VIDEOBLIND_STATE;

// ��ѯ ��̬��ⱨ��״̬��ϸ��Ϣ��Ӧ�ṹ��
typedef struct
{
    DWORD               dwSize;
    int                 nChannelID;                 // ͨ����
    BOOL                bAlarm;                     // �Ƿ񱨾� TRUE/FALSE
    int                 nLevel;                     // ��������,��λǧ��֮,�Զ��췢��С����������С��������
}NET_CLIENT_DETAILEDMOTION_STATE;

// ����IO����
typedef struct 
{
    unsigned short       index;                    // �˿����
    unsigned short       state;                    // �˿�״̬��0 - �رգ�1 - ��
} ALARM_CONTROL;

// ������ʽ
typedef struct
{
    unsigned short       index;                    // �˿����
    unsigned short       mode;                     // ������ʽ(0�ر�1�ֶ�2�Զ�);�����õ�ͨ��,sdkĬ�Ͻ�����ԭ�������á�
    BYTE                 bReserved[28];            
} TRIGGER_MODE_CONTROL;

// ��������������
typedef struct 
{
    int                 decoderNo;               // ������������,��0��ʼ
    unsigned short      alarmChn;                // ���������,��0��ʼ
    unsigned short      alarmState;              // �������״̬��1����,0���ر�
} DECODER_ALARM_CONTROL;

// �����Ӧ�𱨾��¼�
typedef struct __ALARM_NO_RESPONSE_INFO
{
    DWORD               dwSize;
    char                szCallID[DH_MAX_CALLID];                             //Call ID
}ALARM_NO_RESPONSE_INFO;

// �����ϴ����ܵı�����Ϣ
typedef struct  
{
    DWORD               dwAlarmType;                            // �������ͣ�dwAlarmType = DH_UPLOAD_EVENTʱ��dwAlarmMask��bAlarmDecoderIndex����Ч��
    DWORD               dwAlarmMask;                            // ������Ϣ���룬��λ��ʾ������ͨ��״̬
    char                szGlobalIP[DH_MAX_IPADDR_LEN];          // �ͻ���IP��ַ
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];   // �ͻ�������
    int                 nPort;                                  // �����ϴ�ʱ�ͻ������ӵĶ˿�
    char                szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];    // ����������ʱ��
    BYTE                bAlarmDecoderIndex;                     // ��ʾ�ڼ���������������dwAlarmType = DH_UPLOAD_DECODER_ALARM ����Ч.
    BYTE                bChannelIndex;                          // ͨ��������ʼֵ(0,1,2...)����0��Ч,�� dwHighAlarmMask ��ͬ��ʾ����32ͨ���ı���״̬
                                                                // �� bChannelIndex=1,��ʾdwHighAlarmMaskΪͨ��33-64�ı���״̬
    BYTE                bReserved[2];
    DWORD               dwHighAlarmMask;                        // ����32ͨ���ı�����Ϣ����,��λ��ʾ������ͨ��״̬
    BYTE                bReservedSpace[8];
} NEW_ALARM_UPLOAD;

// ���������̸б����¼�
typedef struct __ALARM_UPLOAD_SMOKESENSOR_INFO
{
    DWORD           dwSize;
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // �ͻ���IP��ַ
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];        // �ͻ�������
    int             nPort;                                       // �����ϴ�ʱ�ͻ������ӵĶ˿�
    char            szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];   // ����������ʱ��
    int             nChannel;                                    // ����ͨ�� ��0��ʼ
    BYTE            byHighTemperature;                           // 1:���±�����ʼ,0�����±�������
    BYTE            bySmoke;                                     // 1:�̸б�����ʼ,0���̸б�������
}ALARM_UPLOAD_SMOKESENSOR_INFO;

// �����������ܱ����¼�
typedef struct __ALARM_UPLOAD_IVS_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // �¼�����ʱ��    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // �ͻ�������
    int             nChannelID;                                 // ͨ����,��0��ʼ
    char            szType[MAX_PATH];                           // ��������, ������
                                                                // "CrossLineDetection" ������
                                                                // "CrossFenceDetection" ��ԽΧ��
                                                                // "CrossRegionDetection" ������
                                                                // "PasteDetection" ATM����
                                                                // "LeftDetection" ��Ʒ����
                                                                // "Preservation" ��Ʒ��ȫ
                                                                // "TakenAwayDetection" ��Ʒ����
                                                                // "StayDetection" ͣ��/����
                                                                // "ParkingDetection" �Ƿ�ͣ��
                                                                // "WanderDetection" �ǻ�
                                                                // "MoveDetection" �˶�
                                                                // "TailDetection" β��
                                                                // "RioterDetection" �ۼ�
                                                                // "FightDetection" ���
                                                                // "RetrogradeDetection" ����
                                                                // "FireDetection" ����
                                                                // "SmokeDetection" ����
                                                                // "NumberStat" ����ͳ��
                                                                // "VideoAbnormalDetection" ��Ƶ�쳣
                                                                // "PrisonerRiseDetection" ��������������
                                                                // "FaceDetection" �������
                                                                // "FaceRecognition" ����ʶ��
                                                                // "DensityDetection" �ܼ��ȼ��
                                                                // "QueueDetection" �ŶӼ��
    int             nState;                                     // ����״̬,0-������λ,1-������λ, 2-����ʽ����
    char            szRuleName[DH_COMMON_STRING_128];           // ��������  
    char            szIPAddress[DH_MAX_IPADDR_LEN_EX];          // �豸IP��ַ  
    int             nPort;                                      // �豸�˿ں�
    char            szMacAddress[DH_MACADDR_LEN];               // �豸��mac��ַ
    char            szPicFilePath[MAX_PATH];                    // ͼƬ����ļ���·��
    int             nPicFileNum;                                // ��ǰ������Ӧ��ͼƬ�ļ�����
    int             nUploadPicFileNum;                          // ���ϴ�FTP��ͼƬ�ļ�����
    DWORD           dwChannelMask;                              // ץͼ��Ƶͨ��������,15��ʾ�˴α���ץͼ����1,2,3,4ͨ�� 
} ALARM_UPLOAD_IVS_INFO;

// ���������ⲿ������չ��Ϣ
typedef struct _ALARM_UPLOAD_ALARMEX_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // �¼�����ʱ��    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // �ͻ�������
    DWORD           dwAlarmMask;                                // ������Ϣ����,��λ��ʾ������ͨ��״̬, 7��ʾ1,2,3��������ͨ��
    char            szDevMac[DH_MACADDR_LEN];                   // �豸��mac��ַ
    char            szPicFilePath[MAX_PATH];                    // ͼƬ����ļ���·��
    int             nPicFileNum;                                // ��ǰ������Ӧ��ͼƬ�ļ�����
    int             nUploadPicFileNum;                          // ���ϴ�FTP��ͼƬ�ļ�����
    char            szAreaName[DH_COMMON_STRING_128];           // ��������
    DWORD           dwChannelMask;                              // ץͼ��Ƶͨ��������,15��ʾ�˴α���ץͼ����1,2,3,4ͨ�� 
}ALARM_UPLOAD_ALARMEX_INFO;

typedef enum _EM_LOGIN_FAILED_TYPE
{
    LOGIN_FAILED_UNKNOW = 0 ,
    LOGIN_FAILED_PASSWORD   ,           //���벻��ȷ
    LOGIN_FAILED_USER       ,           //�ʺŲ�����
    LOGIN_FAILED_TIMEOUT    ,           //�ȴ���¼���س�ʱ
    LOGIN_FAILED_RELOGGIN   ,           //�ʺ��Ѿ���¼
    LOGIN_FAILED_LOCKED     ,           //�ʺ��ѱ�����
    LOGIN_FAILED_BLACKLIST  ,           //�ʺű����������
    LOGIN_FAILED_ERROR_BUSY ,           //��Դ����,ϵͳæ
    LOGIN_FAILED_VERSION    ,           //�汾����,�޷���½ 
}EM_LOGIN_FAILED_TYPE;

//Զ�̵�¼ʧ�ܱ�����Ϣ
typedef struct  __ALARM_UPLOAD_LOGIN_FAILED_INFO
{
    DWORD                   dwSize;
    EM_LOGIN_FAILED_TYPE    emFailedType;                       //��½ʧ������
    char                    szDeviceIP[DH_COMMON_STRING_64];    //�����豸IP
    DWORD                   nDevicePort;                        //�����豸�˿�
}ALARM_UPLOAD_LOGIN_FAILED_INFO;

// ¼��״̬�仯������Ϣ
typedef struct
{
    int                 nChannel;               // ¼��ͨ����
    char                reserved[12];
} ALARM_RECORDING_CHANGED;

// ¼��״̬�仯����(DH_ALARM_RECORD_CHANGED_EX)
typedef struct __ALARM_RECORD_CHANGED_INFO_EX
{
    int                 nAction;                // 0:��ʼ 1:ֹͣ
	int                 nChannel;               // ͨ��
	BYTE                byReserved[1024];       // ���� 
} ALARM_RECORD_CHANGED_INFO_EX;

// MPT¼����NVR�Ľ����¼�(DH_ALARM_POLICE_RECORD_PROGRESS)
typedef struct tagALARM_POLICE_RECORD_PROGRESS_INFO
{
    int                 nAction;                // 0:pulse,-1δ֪
    int                 nUsbSlot;               // MPT����USB��λ��
    UINT                nTotalSize;             // �ļ��ܴ�С����λKB
    UINT                nTransferSize;          // �Ѿ�����NVR���ļ���С����λKB
    BYTE                byReserved[1024];       // ���� 
}ALARM_POLICE_RECORD_PROGRESS_INFO;

// MPT�豸״̬
typedef enum tagEM_MPT_STATE
{
    EM_MPT_STATE_UNKNOWN,                                       // δ֪
    EM_MPT_STATE_PLUGIN_OUT,                                    // �豸�γ�
    EM_MPT_STATE_PLUGIN_IN_WORKING_PROPERLY,                    // �豸�����ҹ�������
    EM_MPT_STATE_PLUGIN_IN_STORAGE_ERROR,                       // �豸���뵫�洢������
}EM_MPT_STATE;

// MPT����γ��豸�¼�(DH_ALARM_POLICE_PLUGIN)
typedef struct tagALARM_POLICE_PLUGIN_INFO
{
    int                 nAction;                                // 0:pulse,-1δ֪
    int                 nUsbSlot;                               // MPT����USB��λ��
    EM_MPT_STATE        eState;                                 // MPT״̬
    char                szSerialNumber[DH_COMMON_STRING_32];    // MPT�豸���к�
    BYTE                byReserved[1024];                       // ���� 
}ALARM_POLICE_PLUGIN_INFO;

// GPSδ��λ����(DH_ALARM_GPS_NOT_ALIGNED)
typedef struct tagALARM_GPS_NOT_ALIGNED_INFO
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;  
	NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_GPS_NOT_ALIGNED_INFO;

// ����δ���ӱ���(����wifi��3G/4G)(DH_ALARM_WIRELESS_NOT_CONNECTED)
typedef struct tagALARM_WIRELESS_NOT_CONNECTED_INFO
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;  
	NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_WIRELESS_NOT_CONNECTED_INFO;

// ������־ͬ��״̬
typedef enum tagEM_OFFLINE_LOGSYNC_STATE
{
    EM_OFFLINE_LOGSYNC_STATE_UNKNOWN,                             // δ֪
    EM_OFFLINE_LOGSYNC_STATE_SUCCEEDED,                           // �ɹ�
    EM_OFFLINE_LOGSYNC_STATE_FAILED,                              // ʧ��
}EM_OFFLINE_LOGSYNC_STATE;

//ͬ��������־�¼�
typedef struct tagALARM_OFFLINE_LOGSYNC_INFO
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;  
	NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
	int                                 nDevAddrs;                      // �ֿ�����ID
	EM_OFFLINE_LOGSYNC_STATE            emState;                        //ͬ�����
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_OFFLINE_LOGSYNC_INFO;

#define NET_MAX_WINDINGID_NUM    8

// ��Ȧ/����������
typedef struct __ALARM_WINGDING_INFO
{
    int                 nDriveWayID;            // ������
    int                 nWindingID;             // ��ȦID,���ֶηϳ�,��nWindingIDsΪ׼
    NET_TIME            stuTime;                // ��������ʱ��
    int                 nState;                 // �豸״̬,0��ʾ���ϻָ�,1��ʾ��������
    DWORD               dwChannel;              // ������ͨ����
    char                reserve[28];
    int                 nWindingIDNum;          // ��ȦID����
    int                 nWindingIDs[NET_MAX_WINDINGID_NUM];// ������ȦID 
} ALARM_WINGDING_INFO;

// ��ͨӵ������
typedef struct __ALARM_TRAF_CONGESTION_INFO
{
    int                 nDriveWayID;            // ������
    int                 nCongestionLevel;       // ��ͨӵ���ȼ�:1,2,3,4,5,6;1��������
    NET_TIME            stuTime;                // ��������ʱ��
    int                 nState;                 // �豸״̬,0��ʾ���ϻָ�,1��ʾ��������
    DWORD               dwChannel;              // ������ͨ����
    char                reserve[28];
} ALARM_TRAF_CONGESTION_INFO;

// ��ͨ�쳣����
typedef struct __ALARM_TRAF_EXCEPTION_INFO
{
    int                 nDriveWayID;            // ������
    NET_TIME            stuTime;                // ��������ʱ��
    int                 nState;                 // �豸״̬,0��ʾ���ϻָ�,1��ʾ��������
    DWORD               dwChannel;              // ������ͨ����
    char                reserve[28];
} ALARM_TRAF_EXCEPTION_INFO;

// �����豸���ϱ���
typedef struct __ALARM_EQUIPMENT_FILL_INFO
{
    int                 nDriveWayID;            // ������
    NET_TIME            stuTime;                // ��������ʱ��
    int                 nState;                 // �豸״̬,0��ʾ���ϻָ�,1��ʾ��������
    DWORD               dwChannel;              // ������ͨ����
    char                reserve[28];
} ALARM_EQUIPMENT_FILL_INFO;

// ����������״̬��Ϣ
typedef struct __ALARM_ARM_DISARM_STATE_INFO
{
    BYTE                bState;                 // ������״̬,0��ʾ����,1��ʾ����,2��ʾǿ�Ʋ���
    char                reserve[31];
} ALARM_ARM_DISARM_STATE_INFO;

// 3G����������ֵ״̬��Ϣ 
typedef struct __DHDEV_3GFLOW_EXCEED_STATE_INFO
{
    BYTE                bState;                 // 3G����������ֵ״̬,0��ʾδ������ֵ,1��ʾ������ֵ
    char                reserve[31];
} DHDEV_3GFLOW_EXCEED_STATE_INFO;

// ���ٱ�����·�����ٱ��� (DH_DEVSTATE_SPEED_LIMIT)
typedef struct __ALARM_SPEED_LIMIT
{
    char                szType[DH_SPEEDLIMIT_TYPE_LEN];     // ���ٱ������LowerSpeed, UpperSpeed
    int                 iSpeedLimit;                        // ���� ��λKM/H 
    int                 iSpeed;                             // �ٶ� ��λKM/H
    char                szCrossingID[DH_MAX_CROSSING_ID];   // ·�����к�
    DWORD               dwLongitude;                        // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
    DWORD               dwLatidude;                         // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
                                                            // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    DHDEVTIME           stTime;                             // ��������ʱ��
    BYTE                bOffline;                           // 0-ʵʱ 1-���� 
    char                reserve[19];
}ALARM_SPEED_LIMIT;

// ���ٱ���

// ���ر���
typedef struct __ALARM_OVER_LOADING
{
    NET_TIME            stuCurTime;                         // ��ǰʱ��
    DWORD               dwLatidude;                         // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
    DWORD               dwLongitude;                        // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
                                                            // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    char                szDriverNo[DH_VEHICLE_DRIVERNO_LEN];// ��ʻԱID
    DWORD               dwCurSpeed;                         // ��ǰ�ٶ�
    BYTE                byReserved[128]; 
}ALARM_OVER_LOADING;

// ��ɲ������
typedef struct __ALARM_HARD_BRAKING
{
    NET_TIME        stuCurTime;                             // ��ǰʱ��
    DWORD           dwLatidude;                             // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
    DWORD           dwLongitude;                            // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
                                                            // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    char            szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // ��ʻԱID
    DWORD           dwCurSpeed;                             // ��ǰ�ٶ�
    BYTE            byReserved[128]; 
}ALARM_HARD_BRAKING;

// �̸б���
typedef struct __ALARM_SMOKE_SENSOR
{
    NET_TIME        stuCurTime;             // ��ǰʱ��
    int             nChannel;               // ����ͨ��
    BYTE            byHighTemperature;      // 1:���±�����ʼ,0�����±�������
    BYTE            bySmoke;                // 1:�̸б�����ʼ,0���̸б�������
    BYTE            byReservrd[126];
}ALARM_SMOKE_SENSOR;

// ��ͨ�ƹ��ϱ���
typedef struct _LIGHT_INFO
{
    BYTE               byDirection;            // ��ͨ�Ʒ���: 1-����,2-����,3-ֱ��, 4-��ͷ
    BYTE               byState;                // ��ͨ��״̬: 1-����,2-����
    BYTE               byReserved[62];         // �����ֽ� 
}LIGHT_INFO;

typedef struct __ALARM_TRAFFIC_LIGHT_FAULT 
{
    NET_TIME           stTime;                 // ��������ʱ��
    int                nInfoNumber;            // ������Ϣ��
    LIGHT_INFO         stLightInfo[8];         // ��ͨ�ƹ�����Ϣ
    BYTE               byReserved[128];        // �����ֶ�
}ALARM_TRAFFIC_LIGHT_FAULT;

// ����ͳ�Ʊ���ͨ����Ϣ
typedef struct __ALARM_TRAFFIC_FLUX_LANE_INFO
{
    NET_TIME            stuCurTime;            // ��ǰʱ��
    int                 nLane;                 // ������
    int                 nState;                // ״ֵ̬��1-��ʾӵ��, 2-��ʾӵ�»ָ�, 3-��ʾ����, 4-��ʾ�ж�, 5-��ʾ�жϻָ�
    int                 nFlow;                 // ����ֵ,��λ����/��
    BYTE                byReserved[124];       // ����
}ALARM_TRAFFIC_FLUX_LANE_INFO;

// SIP״̬�ı䱨��()
typedef struct __ALARM_SIP_STATE
{
    int     nChannelID;
    BYTE    byStatus;                         //0:ע��ɹ�,1:δע��,2:��Ч,3:ע����,4:ͨ����
    BYTE    bReserved[63];                    //����
}ALARM_SIP_STATE;

// �����Զ�����Ϣ�ϴ�(DH_DEVSTATE_VIHICLE_INFO_UPLOAD)
typedef struct __ALARM_VEHICLE_INFO_UPLOAD
{
    char                szType[DH_VEHICLE_TYPE_LEN];                 // ��Ϣ���: DriverCheck��˾��ǩ��ǩ��
    char                szCheckInfo[DH_VEHICLE_INFO_LEN];            // ǩ�룺CheckIn��ǩ����CheckOut  
    char                szDirverNO[DH_VEHICLE_DRIVERNO_LEN];         // ˾�������ַ���
    DHDEVTIME           stTime;                                      // ��������ʱ��
    BYTE                bOffline;                                    // 0-ʵʱ 1-���� 
    char                reserved[59];                     
}ALARM_VEHICLE_INFO_UPLOAD;
// �����Զ�����Ϣ�ϴ�

// ����¼����Ϣ�ϴ�
typedef struct __ALARM_CARD_RECORD_INFO_UPLOAD
{
    int                 nChannel;                           // ͨ����
    BOOL                bEnable;                            // �Ƿ����ڿ���¼��
    char                szCardInfo[DH_MAX_CARD_INFO_LEN];   // ������Ϣ
    NET_TIME            stuTime;                            // �ÿ�����Ч��ʼʱ��
    BOOL                bPreviewOverlayEn;                  // Ԥ������ʹ��
    BYTE                byOverlayPos;                       // ����λ��,1-����,2-����,3-����,4-����
    char                reserved[59];
}ALARM_CARD_RECORD_INFO_UPLOAD;



typedef enum __ATMTradeTypes{
    TRADE_TYPE_INC = 0,        //�忨INSERTCARD
    TRADE_TYPE_WDC,            //�˿�WITHDRAWCARD
    TRADE_TYPE_CKT,            //УʱCHECKTIME
    TRADE_TYPE_INQ,            //��ѯ
    TRADE_TYPE_CWD,            //ȡ��
    TRADE_TYPE_PIN,            //����
    TRADE_TYPE_TFR,            //ת��
    TRADE_TYPE_DEP,            //���
    TRADE_TYPE_NCINQ,          //�޿���ѯ
    TRADE_TYPE_NCDEP,          //�޿����
    TRADE_TYPE_OTHERS,         //����
    TRADE_TYPE_ALL,            //��
}DH_eATMTradeTypes;

typedef struct __ALARM_ATM_INFO_UPLOAD_CHNL
{
    int                 nChannel;                   // ��ѯ�ĵڼ�ͨ��ATM������Ϣ,��Χ0-N-1��N��ʾͨ������
    char                szATMID[32];                // ATM�ն˺�
    char                szCardNo[32];               // ����    ����6222421541208230456 
    char                szTradetime[32];            // ����ʱ��    ����20111118112200��ʾ2011-11-18 11:22:00
    DH_eATMTradeTypes   emTradeType;                // ��������    ��Χ: ATMTradeTypes
    int                 nAmount;                    // ���׽��    0-4294967296
    BYTE                byRerved[32];               // ����
}ALARM_ATM_INFO_UPLOAD_CHNL;

// ATM������Ϣ�ϴ�(DH_ALARM_ATM_INFO_UPLOAD)�¼���Ӧ�ṹ��
typedef struct __ALARM_ATM_INFO_UPLOAD
{
    int                           nCnt;
    ALARM_ATM_INFO_UPLOAD_CHNL    m_stAtmInfo[DH_MAX_CHANNUM];
}ALARM_ATM_INFO_UPLOAD;

// �������λ�����¼�
typedef struct __ALARM_CAMERA_MOVE_INFO
{
    int                         nChannelNum;                        // ��������ͨ����
    unsigned char               alarmChannels[DH_MAX_CHANNUM_EX];   // ��������ͨ������Ϣ
    BYTE                        byReserved[128];
}ALARM_CAMERA_MOVE_INFO;

// ��ϸ���챨����Ϣ
typedef struct __ALARM_DETAILEDMOTION_CHNL_INFO
{
    DWORD              dwSize;
    int                nChannelID;    // ͨ����
    BOOL               bAlarm;        // �Ƿ񱨾� TRUE/FALSE
    int                nLevel;        // ��������,��λǧ��֮,�Զ��췢��С����������С��������
}ALARM_DETAILEDMOTION_CHNL_INFO;

/// �洢�쳣����
typedef struct __ALARM_STORAGE_FAILURE
{
    DWORD     dwSize;                                     // �ṹ���С
    UINT      ActionType;                                 // 0��ֹͣ, 1����ʼ
    char      szProtocol[DH_MAX_STRING_LEN];              // Э������,Ŀǰֻ֧��FTP
    char      szServerAddr[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // ������IP��ַ
    DWORD     dwPort;                                     // �˿ں�
    NET_TIME  stuTime;                                    // �¼�����ʱ��
    int       nChannel;                                   // ͨ����, ��1��ʼ, 0��ʾ������ͨ��
}ALARM_STORAGE_FAILURE;

// ǰ�˶���������Ϣ
typedef struct __ALARM_FRONTDISCONNET_INFO
{
    DWORD              dwSize;                           // �ṹ���С
    int                nChannelID;                       // ͨ����
    int                nAction;                          // 0:��ʼ 1:ֹͣ
    NET_TIME           stuTime;                          // �¼�����ʱ��
    char               szIpAddress[MAX_PATH];            // ǰ��IPC��IP��ַ
}ALARM_FRONTDISCONNET_INFO;

// ��ص�ѹ���ͱ���
typedef struct __ALARM_BATTERYLOWPOWER_INFO
{
    DWORD             dwSize;                            // �ṹ���С
    int               nAction;                           // 0:��ʼ 1:ֹͣ
    int               nBatteryLeft;                      // ʣ������ٷֱ�,��λ%
    NET_TIME          stTime;                            // �¼�����ʱ��
    int               nChannelID;                        // ͨ����, ��ʶ���豸���, ��0��ʼ
}ALARM_BATTERYLOWPOWER_INFO;

// �¶ȹ��߱���
typedef struct __ALARM_TEMPERATURE_INFO
{
    DWORD              dwSize;                           // �ṹ���С
    char               szSensorName[DH_MACHINE_NAME_NUM];// �¶ȴ���������
    int                nChannelID;                       // ͨ����
    int                nAction;                          // 0:��ʼ 1:ֹͣ
    float              fTemperature;                     // ��ǰ�¶�ֵ, ��λ���϶�
    NET_TIME           stTime;                           // �¼�����ʱ��
}ALARM_TEMPERATURE_INFO;

// ƣ�ͼ�ʻ����
typedef struct __ALARM_TIREDDRIVE_INFO
{
    DWORD             dwSize;                            // �ṹ���С
    int               nAction;                           // 0:��ʼ 1:ֹͣ
    int               nDriveTime;                        // ������ʻʱ��,��λ����
    NET_TIME          stTime;                            // �¼�����ʱ��
}ALARM_TIREDDRIVE_INFO;

// ��¼���¼�����
typedef struct __ALARM_LOST_RECORD
{
    DWORD     dwSize;                                     //�ṹ���С
    UINT      ActionType;                                 // 0��ֹͣ, 1����ʼ
    UINT      nChannelID;                                 // ͨ����,��1��ʼ
    UINT      nStreamType;                                // ��������,0����������1��������1��2��������2��3��������3��4��ץͼ����
    NET_TIME  stuTime;                                    // �¼�����ʱ��    
}ALARM_LOST_RECORD;

// CPUռ���ʹ����¼�����,�ݶ�����95%��
typedef struct __ALARM_HIGH_CPU
{
    DWORD     dwSize;                                     //�ṹ���С
    UINT      ActionType;                                 // 0��ֹͣ, 1����ʼ
    UINT      nUsed;                                      // CPUռ���ʵ�1000��
    NET_TIME  stuTime;                                    // �¼�����ʱ��    
}ALARM_HIGH_CPU;

// ���緢�����ݶ����¼�����
typedef struct __ALARM_LOST_NETPACKET
{
    DWORD     dwSize;                                     //�ṹ���С
    UINT      ActionType;                                 // 0��ֹͣ, 1����ʼ
    UINT      nChannelID;                                 // ͨ����,��1��ʼ
    UINT      nStreamType;                                // ��������,0����������1��������1��2��������2��3��������3��4��ץͼ����
    char      szRemoteIP[DH_MAX_IPADDR_LEN];              // ���Ͷ�IP��ַ
    DWORD     dwRemotePort;                               // ���Ͷ˵Ķ˿ڵ�ַ
    NET_TIME  stuTime;                                    // �¼�����ʱ��    
}ALARM_LOST_NETPACKET;

// �ڴ�ռ���ʹ����¼�����,�ݶ�����95%��
typedef struct __ALARM_HIGH_MEMORY
{
    DWORD     dwSize;                                     //�ṹ���С
    UINT      ActionType;                                 // 0��ֹͣ, 1����ʼ
    UINT      nUsed;                                      // �ڴ�ռ���ʵ�1000��
    NET_TIME  stuTime;                                    // �¼�����ʱ��    
}ALARM_HIGH_MEMORY;

// ����������ץ���¼�
typedef struct __DH_BLACKLIST_SNAP_INFO
{
    DWORD     dwSize;
    char      szPlateNumber[32];                          // ���ƺ�
    NET_TIME  stuTime;                                    // �¼�����ʱ��
}DH_BLACKLIST_SNAP_INFO;

// Ӳ�������쳣�¼�
typedef struct __ALARM_DISK_FLUX
{
    DWORD                dwSize;    
    DWORD                dwAction;                         // 0-��ʼ, 1-ֹͣ
    DWORD                dwDataFlux;                       // ��ǰ��������, KB            
    NET_TIME             stuTime;                          // �¼�����ʱ��
} ALARM_DISK_FLUX;

// ���������쳣�¼�
typedef struct __ALARM_NET_FLUX
{
    DWORD                dwSize;    
    DWORD                dwAction;                           // 0-��ʼ, 1-ֹͣ
    DWORD                dwDataFlux;                         // ��ǰ��������, KB
    NET_TIME             stuTime;                            // �¼�����ʱ��
} ALARM_NET_FLUX;

// ����ת���쳣�¼�
typedef struct __ALARM_FAN_SPEED
{
    DWORD                dwSize;    
    DWORD                dwAction;                            // 0-��ʼ, 1-ֹͣ
    DWORD                dwIndex;                             // �������
    char                 szName[DH_MACHINE_NAME_NUM];         // ����������
    NET_TIME             stuTime;                             // �¼�����ʱ��
    DWORD                dwCurrent;                           // ��ǰת��
} ALARM_FAN_SPEED;

// Ӳ�̱���
typedef struct __ALARM_DISK_INFO 
{
    DWORD                dwSize;
    DWORD                nChannel;                            // Ӳ��ͨ����
    DWORD                nHDDNumber;                          // ���������, 0: ����,1: ��չ��1,  2: ��չ��2 
    DWORD                nHDDState;                           // Ӳ��״̬, 0: Unknown, 1: Running, 2: Offline, 3: Warning, 4: Failed
} ALARM_DISK_INFO;

// �ļ�ϵͳ�澯
typedef struct __ALARM_FILE_SYSTEM_INFO 
{
    DWORD                dwSize;
    char                 szMountDir[MAX_PATH];                // �ļ�ϵͳ������
    DWORD                nState;                              // �ļ�ϵͳ״̬, 0: Unkown, 1: Normal, 2: Error
} ALARM_FILE_SYSTEM_INFO;

// Զ���ⲿ������Ϣ
typedef struct __ALARM_REMOTE_ALARM_INFO
{
    DWORD      dwSize;
    int        nChannelID;                               // ͨ����,��1��ʼ
    int        nState;                                   // ����״̬,0-������λ,1-������λ
}ALARM_REMOTE_ALARM_INFO;

// ���ܱ����¼�
typedef struct __ALARM_IVS_INFO
{
    DWORD      dwSize;
    NET_TIME   stuTime;                                  // �¼�����ʱ��    
    int        nChannelID;                               // ͨ����,��0��ʼ
    char       szType[MAX_PATH];                         // ��������
    int        nState;                                   // ����״̬,0-������λ,1-������λ, 2-����ʽ����
}ALARM_IVS_INFO;

// ���ػ��ر���
typedef struct __ALARM_GOODS_WEIGHT_INFO
{
    DWORD        dwSize;
    int          nAction;                               // 0-��ʼ, 1-ֹͣ
    int          nAlarmType;                            // 0-����������, 1-С����С����, 2-���ر仯����������ֵ
    DWORD        dwGoodsWeight;                         // ��ǰ����(kg)
    DWORD        dwSelfWeight;                          // ����(kg)
    DWORD        dwTotalWeight;                         // ����(kg)
    DWORD        dwStandardWeight;                      // �˶�����(kg)
    DWORD        dwWeightScale;                         // ���ر���
    DWORD        dwMaxGoodsWeight;                      // ������(kg)
    DWORD        dwMinGoodsWeight;                      // ��С����(kg)
    DWORD        dwAlarmWeight;                         // ������ֵ(kg)
    int          nWeightChange;                         // �ɼ�ʱ�����ڻ��ر仯(kg)
    int          nCheckTime;                            // ��ֹ�ɼ�ʱ��(s)
} ALARM_GOODS_WEIGHT_INFO;

// ���ػ�����Ϣ�ϴ�
typedef struct __ALARM_GOODS_WEIGHT_UPLOAD_INFO 
{
    DWORD        dwSize;
    DWORD        dwGoodsWeight;                         // ��ǰ����(kg)
    DWORD        dwSelfWeight;                          // ����(kg)
    DWORD        dwTotalWeight;                         // ����(kg)
    DWORD        dwStandardWeight;                      // �˶�����(kg)
    DWORD        dwWeightScale;                         // ���ر���
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // ����
} ALARM_GOODS_WEIGHT_UPLOAD_INFO;

// ������Դ
typedef enum tagEM_DATE_SOURCE
{
    EM_DATE_SOURCE_GPS,                                     // GPS 
    EM_DATE_SOURCE_INERTIALNAVIGATION,                      // ���Ե�������
}EM_DATE_SOURCE;

// GPS״̬��Ϣ
typedef struct _NET_GPS_STATUS_INFO
{
    NET_TIME                revTime;                        // ��λʱ��
    char                    DvrSerial[50];                  // �豸���к�
	BYTE                    byRserved1[6];                 	// �����ֽ�
	double                  longitude;                      // ����(��λ�ǰ����֮��,��Χ0-360��)
    double                  latidude;                       // γ��(��λ�ǰ����֮��,��Χ0-180��)
    double                  height;                         // �߶�(��)
    double                  angle;                          // �����(��������Ϊԭ��,˳ʱ��Ϊ��)
    double                  speed;                          // �ٶ�(��λkm/H)
    WORD                    starCount;                      // ��λ����, emDateSourceΪ EM_DATE_SOURCE_GPSʱ��Ч
	BYTE                    byRserved2[2];                 	// �����ֽ�
	NET_THREE_STATUS_BOOL   antennaState;                   // ����״̬, emDateSourceΪ EM_DATE_SOURCE_GPSʱ��Ч    
    NET_THREE_STATUS_BOOL   orientationState;               // ��λ״̬
    int                     workStae;                       // ����״̬(0=δ��λ,1=�ǲ�ֶ�λ,2=��ֶ�λ,3=��ЧPPS,6=���ڹ��� 
                                                            // emDateSourceΪ EM_DATE_SOURCE_GPSʱ��Ч
    int                     nAlarmCount;                    // �����ı���λ�ø���
    int                     nAlarmState[128];               // �����ı���λ��,ֵ���ܶ��, emDateSourceΪ EM_DATE_SOURCE_GPSʱ��Ч
    BYTE                    bOffline;                       // 0-ʵʱ 1-���� 
    BYTE                    bSNR;                           // GPS�����,��ʾGPS�ź�ǿ��,ֵԽ��,�ź�Խǿ ��Χ��0~100,0��ʾ������	
	BYTE                    byRserved3[2];                 	// �����ֽ�
	EM_DATE_SOURCE          emDateSource;                   // ������Դ
    BYTE                    byRserved[124];                 // �����ֽ�
} NET_GPS_STATUS_INFO,*LPNET_GPS_STATUS_INFO;

// Ӳ�̿�¼�������¼�
typedef struct __ALARM_DISKBURNED_FULL_INFO
{
    DWORD       dwSize;
    int         nIndex;                             //���̺�
}ALARM_DISKBURNED_FULL_INFO;

// �洢���������¼�
typedef struct tagALARM_STORAGE_LOW_SPACE_INFO 
{
    DWORD               dwSize;
    int                 nAction;                            // 0:��ʼ 1:ֹͣ
    char                szName[DH_EVENT_NAME_LEN];          // �¼�����
    char                szDevice[DH_STORAGE_NAME_LEN];      // �洢�豸����
    char                szGroup[DH_STORAGE_NAME_LEN];       // �洢������
    INT64               nTotalSpace;                        // ������, byte
    INT64               nFreeSpace;                         // ʣ������, byte
    int                 nPercent;                           // �Ѿ�ʹ�õİٷֱ�
} ALARM_STORAGE_LOW_SPACE_INFO;

// �洢��������
typedef enum __EM_STORAGE_ERROR
{
    STORAGE_ERROR_NONE,                             // ��
    STORAGE_ERROR_PATITION,                         // ��������          
    STORAGE_ERROR_INIT_FS,                          // ��ʼ���ļ�ϵͳ����    
    STORAGE_ERROR_READ_DATA,                        // ������ʧ��
    STORAGE_ERROR_WRITE_DATA,                       // д����ʧ��
    STORAGE_ERROR_RAID_FAILED,                      // RAID����
    STORAGE_ERROR_RAID_DEGRADED,                    // RAID����
    STORAGE_ERROR_ISCSI_FAILED,                     // iSCSI����
} EM_STORAGE_ERROR;

// �洢���󱨾�
typedef struct __ALARM_STORAGE_FAILURE_EX
{
    DWORD               dwSize;
    int                 nAction;                            // 0:��ʼ 1:ֹͣ
    char                szName[DH_EVENT_NAME_LEN];          // �¼�����
    char                szDevice[DH_STORAGE_NAME_LEN];      // �洢�豸����
    char                szGroup[DH_STORAGE_NAME_LEN];       // �洢������
    char                szPath[MAX_PATH];                   // ·��
    EM_STORAGE_ERROR    emError;                            // ��������
    int                 nPhysicNo;                          // Ӳ�����ڲ۱���, ��1��ʼ
    NET_TIME_EX			stuTime;							// �¼�������ʱ��
} ALARM_STORAGE_FAILURE_EX;

// ¼���쳣����
typedef struct __ALARM_RECORD_FAILED_INFO 
{
    DWORD                dwSize;
    int                  nAction;                           // 0:��ʼ 1:ֹͣ
    int                  nIndex;                            // ͨ����
} ALARM_RECORD_FAILED_INFO;

// �洢�����¼�
typedef struct __ALARM_STORAGE_BREAK_DOWN_INFO 
{
    DWORD                dwSize;
    int                  nAction;                           // 0:��ʼ 1:ֹͣ
} ALARM_STORAGE_BREAK_DOWN_INFO;

//�Ȳ�ζ�������
typedef enum tagEM_STORAGE_HOT_PLUG_ACTION
{
    HOT_PLUG_ACTION_UNKNOW = 0  ,
    HOT_PLUG_ACTION_ADD         ,       //�����豸
    HOT_PLUG_ACTION_REMOVE      ,       //�γ��豸
}EM_STORAGE_HOT_PLUG_ACTION;

//�洢�Ȳ���¼�(��Ӧ�¼� DH_ALARM_STORAGE_HOT_PLUG)
typedef struct __ALARM_STORAGE_HOT_PLUG_INFO
{
    int                         nAction;                            // 0:��ʼ 1:ֹͣ
    EM_STORAGE_HOT_PLUG_ACTION  emHotPLugAction;                    // �Ȳ�ζ�������
    char                        szDevice[DH_STORAGE_NAME_LEN];      // �洢�豸����
    char                        szMediaType[DH_COMMON_STRING_32];   // ��������
    char                        szBusType[DH_COMMON_STRING_32];     // ��������
    char                        szMountOn[DH_COMMON_STRING_128];    // �豸���ص�
                                                                    // ����ǿ�,����ʱ��ʾ�豸�ѹ���
                                                                    //          �γ�ʱ��ʾ�豸û������ж��
    int                         nPhysicNo;                          // ������,��1��ʼ
    int                         nLogicNo;                           // �߼����
    BYTE                        bReserved[256];                     // �����ֽ�,�����չ.
}ALARM_STORAGE_HOT_PLUG_INFO;

// ����ʹ������¼�(��Ӧ�¼�DH_ALARM_FLOW_RATE)
typedef struct tagALARM_FLOW_RATE_INFO
{
	int				nAction;				// 0:��ͣ, 1:��ʼ, 2:ֹͣ
	int				nChannelID;				// ͨ����
	UINT			nFlowRate;				// ���������ֵ(��λ:MB)
	BYTE			bReserved[512];			// �����ֽ�
} ALARM_FLOW_RATE_INFO;
 
typedef enum tagEM_NET_UPS_STATUS
{
    EM_NET_UPS_SYS_SIGN=0,              //ϵͳ�¶�ֵ����λ. 1:��ʾ�¶ȸ�; 0:��ʾ�¶���
    EM_NET_UPS_SYS_SHUTDOWN,            //ϵͳ�ػ�.         1:��ʾ�ػ�����״̬
    EM_NET_UPS_SYS_TEST,                //ϵͳ������.       1:��ʾ������
    EM_NET_UPS_SYS_TYPE,                //UPS ����.         1:��ʾ�󱸻� ; 0:��ʾ���߻�
    EM_NET_UPS_SYS_FAULT,               //UPS ����.         1:��ʾUPS�ڲ����� ; 0:����
    EM_NET_UPS_ELE_SUPPLY,              //��·/���״̬.    1:AC���� ; 0:��ع���
    EM_NET_UPS_VOL_LOW,                 //��ص�ѹ��.       1:��ʾ��ص�ѹ�� ; 0:��ʾ�������
    EM_NET_UPS_BYPASS_STATUS,           //�е����.         1:��ʾ�е���� ; 0:��ʾ�е�����
    EM_NET_UPS_MAX = 64,                //
}EM_NET_UPS_STATUS;

typedef struct tagNET_UPS_INFO
{
    DWORD dwSize;
    float fInputVoltage;                        //�����ѹ    ����ο� ���ܽ�ͨר�õ�Դͨ��Э��(V1.2),����ר�ö���
    float fInputAbnormalVoltage;                //�����쳣��ѹ    
    float fOutputVoltage;                       //�����ѹ
    float fOutputCurrent;                       //��������ٷֱ�,��λ(%)
    float fInputFrequency;                      //����Ƶ��
    float fVoltage;                             //��ѹ
    float fTemp;                                //�¶�
    BYTE  bStatusInfo[EM_NET_UPS_MAX];          //UPS״̬��,�μ�NET_UPS_STATUSö��
    char  szVersionInfo[DH_MAX_VERSION_STR];    //�汾
}NET_UPS_INFO;

typedef struct tagALARM_COMM_PORT_EVENT_INFO
{
    DWORD           dwSize;
    UINT            nEventAction;       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    NET_UPS_INFO    stUPSInfo;          // UPS������Ϣ
}ALARM_COMM_PORT_EVENT_INFO;

// ��Ƶ����ͨ��ʧЧ�¼����������õ���Ƶ����ͨ������,�����豸����������DH_ALARM_VIDEO_ININVALID
typedef struct __ALARM_VIDEO_ININVALID_INFO 
{
    DWORD               dwSize;                         // �ṹ���С
    int                 nChannelID;                     // ͨ����,��0��ʼ
} ALARM_VIDEO_ININVALID_INFO;


// �洢�鲻�����¼���Ϣ
typedef struct tagALARM_STORAGE_NOT_EXIST_INFO 
{
    DWORD           dwSize;
    int             nAction;                            // 0:��ʼ 1:ֹͣ
    char            szGroup[DH_STORAGE_NAME_LEN];       // ��¼���ץͼ�洢�������õ������ڵ���
    NET_TIME        stuTime;                            // �¼�����ʱ��
}ALARM_STORAGE_NOT_EXIST_INFO;

//��������¼�����
typedef enum __EM_NETABORT_EVENT_TYPE
{
    EM_NETABORT_EVENT_TYPE_WIRE = 0,                    // ������������¼�
    EM_NETABORT_EVENT_TYPE_WIRELESS,                    // ������������¼�
    EM_NETABORT_EVENT_TYPE_3G,                          // 3G��������¼�
}EM_NETABORT_EVENT_TYPE;

// ��������¼�
typedef struct tagALARM_NETABORT_INFO
{
    DWORD                   dwSize;
    int                     nAction;                    // 0:��ʼ 1:ֹͣ
    EM_NETABORT_EVENT_TYPE  emNetAbortType;             // �¼�����
    NET_TIME                stuTime;                    // �¼�����ʱ��
}ALARM_NETABORT_INFO;

// IP��ͻ�¼�
typedef struct tagALARM_IP_CONFLICT_INFO
{
    DWORD            dwSize;
    int              nAction;                        // 0:��ʼ 1:ֹͣ
    NET_TIME         stuTime;                        // �¼�����ʱ��
}ALARM_IP_CONFLICT_INFO;


// MAC��ͻ�¼�
typedef struct tagALARM_MAC_CONFLICT_INFO
{
    DWORD           dwSize;
    int             nAction;                        // 0:��ʼ 1:ֹͣ
    NET_TIME        stuTime;                        // �¼�����ʱ��
}ALARM_MAC_CONFLICT_INFO;


// ��Դ����
typedef enum __EM_POWER_TYPE
{
    EM_POWER_TYPE_MAIN = 0,                          // ����Դ
    EM_POWER_TYPE_BACKUP,                            // ���õ�Դ
}EM_POWER_TYPE;

// ��Դ�����¼�����
typedef enum __EM_POWERFAULT_EVENT_TYPE
{
    EM_POWERFAULT_EVENT_LOST = 0                    // ��Դ���
}EM_POWERFAULT_EVENT_TYPE;

// ��Դ�����¼�
typedef struct tagALARM_POWERFAULT_INFO
{
    DWORD                    dwSize;            
    EM_POWER_TYPE            emPowerType;            // ��Դ����
    EM_POWERFAULT_EVENT_TYPE emPowerFaultEvent;      // ��Դ�����¼�
    NET_TIME                 stuTime;                // �����¼�������ʱ��
    int                      nAction;                // 0:��ʼ 1:ֹͣ
}ALARM_POWERFAULT_INFO;

// ���𱨾��¼�
typedef struct tagALARM_CHASSISINTRUDED_INFO
{
    DWORD               dwSize;
    int                 nAction;                // 0:��ʼ 1:ֹͣ
    NET_TIME            stuTime;                // �����¼�������ʱ��
    int                 nChannelID;             // ͨ����
    char                szReaderID[DH_COMMON_STRING_32];// ������ID    
    UINT 			    nEventID;				//�¼�ID
}ALARM_CHASSISINTRUDED_INFO;

// ��չģ�鱨���¼�
typedef struct tagALARM_ALARMEXTENDED_INFO
{
    DWORD               dwSize;
    int                 nChannelID;             // ͨ����
    int                 nAction;                // 0:��ʼ 1:ֹͣ
    NET_TIME            stuTime;                // �����¼�������ʱ��
}ALARM_ALARMEXTENDED_INFO;


// �Խ�����
typedef enum __EM_TALKING_CALLER
{
    EM_TALKING_CALLER_UNKNOWN = 0,                 // δ֪����
    EM_TALKING_CALLER_PLATFORM,                    // �Խ�����Ϊƽ̨
}EM_TALKING_CALLER;

// Invite�¼�Զ���豸Э��
typedef enum tagTALKINGINVITE_REMOTEDEVICE_PROTOCOL
{
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_UNKNOWN = 0,    // δ֪
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_HIKVISION       // ����
}EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL;

#define MAX_REMOTEDEVICEINFO_IPADDR_LEN         128       // Զ���豸IP��ַ��󳤶�
#define MAX_REMOTEDEVICEINFO_USERNAME_LEN       128       // Զ���豸�û�����󳤶�
#define MAX_REMOTEDEVICEINFO_USERPSW_LENGTH     128       // Զ���豸������󳤶�

// Invite�¼�Զ���豸��Ϣ
typedef struct tagTALKINGINVITE_REMOTEDEVICEINFO
{
    char		                            szIP[MAX_REMOTEDEVICEINFO_IPADDR_LEN];	        // �豸IP
	int	                                    nPort;					                        // �˿�
	EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL  emProtocol;                                     // Э������
	char		                            szUser[MAX_REMOTEDEVICEINFO_USERNAME_LEN];	    // �û���
	char		                            szPassword[MAX_REMOTEDEVICEINFO_USERPSW_LENGTH];// ����
	char                                    szReverse[1024];                                // �����ֶ�
}TALKINGINVITE_REMOTEDEVICEINFO;

// �����¼�����DH_ALARM_TALKING_INVITE(�豸����Է�����Խ��¼�)��Ӧ������������Ϣ
typedef struct tagALARM_TALKING_INVITE_INFO
{
    DWORD                                   dwSize;
    EM_TALKING_CALLER                       emCaller;                       // �豸ϣ���ĶԽ�����
    NET_TIME                                stuTime;                        // �¼�����ʱ��
    char                                    szCallID[DH_COMMON_STRING_64];  // ���Ωһ��ʶ��
    int                                     nLevel;                         // ��ʾ������豸�����㼶
    TALKINGINVITE_REMOTEDEVICEINFO          stuRemoteDeviceInfo;             // Զ���豸��Ϣ
}ALARM_TALKING_INVITE_INFO;

// �����¼�����DH_ALARM_TALKING_IGNORE_INVITE(�豸ȡ���Խ������¼�)��Ӧ������������Ϣ
typedef struct tagALARM_TALKING_IGNORE_INVITE_INFO
{
    DWORD                dwSize;
} ALARM_TALKING_IGNORE_INVITE_INFO;

// �����¼�����DH_ALARM_TALKING_HANGUP��Ӧ������������Ϣ
typedef struct tagALARM_TALKING_HANGUP_INFO 
{
    DWORD               dwSize;
    NET_TIME            stuTime;                // �¼�����ʱ��
}ALARM_TALKING_HANGUP_INFO;

// ��ͤ�����¼�״̬
typedef enum tagEM_GUARD_EVENT_STATE
{
    EM_GUARD_EVENT_STATE_UNKNOWN = 0,   // δ֪״̬
    EM_GUARD_EVNET_STATE_ONGUARD,       // ����
    EM_GUARD_EVENT_STATE_OFFGUARD       // ���
}EM_GUARD_EVENT_STATE;

// ��ͤ��Ϣ�����¼�,DH_ALARM_GUARD_INFO_UNPDATE���õ�����������Ϣ
typedef struct tagALARM_GUARD_UPDATE_INFO
{
    DWORD                dwSize;
    EM_GUARD_EVENT_STATE emEventState;                          // ��ͤ�����¼�״̬
    int                  nIDCount;                              // ��������¼�����ԱID����
    int                  nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];// ��ԱID����
    NET_TIME             stuTime;                               // �¼�����ʱ��
}ALARM_GUARD_UPDATE_INFO;

// ��ͤ����¼�,DH_ALARM_GUARD_DETECT��Ӧ������������Ϣ
typedef struct tagALARM_GUARD_DETECT_INFO
{
    DWORD               dwSize;
    int                 nAction;                                // 0:��ʼ 1:ֹͣ
    int                 nIndex;                                 // ��ͤ��������±� 
    int                 nIDCount;                               // ��������¼�����ԱID����
    int                 nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT]; // ��ԱID����
    NET_TIME            stuTime;                                // �¼�����ʱ��
}ALARM_GUARD_DETECT_INFO;

//���п��忨�¼�DH_ALARM_BANKCARDINSERT��Ӧ������������Ϣ
typedef struct tagALARM_BANKCARDINSERT_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:δ֪ 0:��ʼ 1:ֹͣ
}ALARM_BANKCARDINSERT_INFO;

#define MAX_CARD_RECORD_FIELD_NUM 16            // ����¼�����������

// �¼�����¼��,stopʱ�ı������
typedef enum tagNET_RECORD_SAVEFLAG
{
    NET_RECORD_SAVEFLAG_UNKNOWN = 0,            //δ֪����
    NET_RECORD_SAVEFLAG_MARK,                   //����¼�񡢲�����
    NET_RECORD_SAVEFLAG_SAVE,                   //������¼��
}NET_RECORD_SAVEFLAG;

//����¼���¼� DH_ALARM_CARD_RECORD ��Ӧ������������Ϣ
typedef struct tagALARM_CARD_RECORD_INFO 
{
    DWORD               dwSize;					
    int                 nAction;                // -1:δ֪ 0:��ʼ 1:ֹͣ
    int                 nChannelID;             // ͨ����,��0��ʼ
    unsigned int        nFieldCount;            // ������
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256]; // ����Ϣ
    NET_RECORD_SAVEFLAG emRecordSaveFlag;       // �¼�����¼��,stopʱ�ı������,���ö�� NET_RECORD_SAVEFLAG
}ALARM_CARD_RECORD_INFO;

// ���籨���¼� DH_ALARM_CARD_RECORD ��Ӧ������������Ϣ
typedef struct tagALARM_NET_INFO
{
    DWORD               dwSize;
    int                 nAction;                // -1:δ֪ 0:��ʼ 1:ֹͣ
    int                 nChannelID;             // ͨ����,��0��ʼ
} ALARM_NET_INFO;

//�����¼���Ӧ DH_ALARM_VIDEOMOTION_EVENT  
typedef struct tagALARM_VIDEOMOTION_EVENT_INFO
{
	DWORD				 dwSize;
	int                  nAction;             // -1:δ֪ 0:��ʼ 1:ֹͣ
	int                  nChannelID;          // ͨ����,��0��ʼ	
}ALARM_VIDEOMOTION_EVENT_INFO;

//WideViewRegions�¼� ��Ӧ DH_ALARM_WIDE_VIEW_REGION_EVENT  
typedef struct tagALARM_WIDE_VIEW_REGION_EVENT_INFO
{
    DWORD				 dwSize;
    int                  nAction;             // -1:δ֪ 0:����(Pusle)   
}ALARM_WIDE_VIEW_REGION_EVENT_INFO;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_NOTIFY_EVNENT �������(���豸�����¼�)
typedef struct tagNET_NOTIFY_EVENT_DATA
{
    DWORD                       dwSize;
    LONG                        lCommand;       // �¼�����
    void*                       pEventData;     // �¼�����,��lCommand��Ӧ�Ľṹ��ָ��
}NET_NOTIFY_EVENT_DATA;

// ��������Ӧ��ʽö������
typedef enum tagNET_SENSE_METHOD
{
    NET_SENSE_UNKNOWN = -1,      //δ֪����
    NET_SENSE_DOOR=0,            //�Ŵ�
    NET_SENSE_PASSIVEINFRA,      //��������
    NET_SENSE_GAS,               //����
    NET_SENSE_SMOKING,           //�̸�
    NET_SENSE_WATER,             //ˮ��
    NET_SENSE_ACTIVEFRA,         //��������
    NET_SENSE_GLASS,             //��������
    NET_SENSE_EMERGENCYSWITCH,   //�����
    NET_SENSE_SHOCK,             //��
    NET_SENSE_DOUBLEMETHOD,      //˫��(����+΢��)
    NET_SENSE_THREEMETHOD,       //������
    NET_SENSE_TEMP,              //�¶�
    NET_SENSE_HUMIDITY,          //ʪ��
    NET_SENSE_WIND,              //����
    NET_SENSE_CALLBUTTON,        //��а�ť
    NET_SENSE_GASPRESSURE,       //����ѹ��
    NET_SENSE_GASCONCENTRATION,  //ȼ��Ũ��
    NET_SENSE_GASFLOW,           //��������
    NET_SENSE_OTHER,             //����
    NET_SENSE_OIL,               // �������,���͡����͵ȳ������ͼ��
    NET_SENSE_MILEAGE,           // ��������   
    NET_SENSE_URGENCYBUTTON,     //���ť
    NET_SENSE_STEAL,             //����
    NET_SENSE_PERIMETER,         //�ܽ�
    NET_SENSE_PREVENTREMOVE,     //����
    NET_SENSE_DOORBELL,          //����
    NET_SENSE_ALTERVOLT,         //������ѹ������
    NET_SENSE_DIRECTVOLT,        //ֱ����ѹ������
    NET_SENSE_ALTERCUR,          //��������������
    NET_SENSE_DIRECTCUR,         //ֱ������������
    NET_SENSE_RSUGENERAL,        //������ͨ��ģ����	4~20mA��0~5V
    NET_SENSE_RSUDOOR,           //�������Ž���Ӧ
    NET_SENSE_RSUPOWEROFF,       //�����˶ϵ��Ӧ	
    NET_SENSE_TEMP1500 ,         //1500�¶ȴ�����	
    NET_SENSE_TEMPDS18B20 ,      //DS18B20�¶ȴ�����	
    NET_SENSE_HUMIDITY1500,      //1500ʪ�ȴ�����
    NET_SENSE_INFRARED,          //���ⱨ��
    NET_SENSE_FIREALARM,         //��
	NET_SENSE_CO2,				 //CO2Ũ�ȼ��,����ֵ:0~5000ppm
	NET_SNESE_SOUND,			 //������,����ֵ:30~130dB
	NET_SENSE_PM25,				 //PM2.5���,����ֵ:0~1000ug/m3
	NET_SENSE_SF6,				 //SF6Ũ�ȼ��,����ֵ:0~3000ppm
	NET_SENSE_O3,				 //����Ũ�ȼ��,����ֵ:0~100ppm
	NET_SENSE_AMBIENTLIGHT,		 //�������ռ��,����ֵ:0~20000Lux




	NET_SENSE_NUM               //ö����������
}NET_SENSE_METHOD;

//��������Ӧ��ʽ��Ӧ��λ��ö������
typedef enum tagEM_SENSE_METHOD_UNIT
{
	EM_SENSE_UNIT_UNKOWN =-1,		 // δ֪����
	EM_SENSE_TEMP_CENTIGRADE = 0,    // �¶ȵ�λ: Centigrade
	EM_SENSE_TEMP_FAHRENHEIT,	     // �¶ȵ�λ��Fahrenheit
	EM_SENSE_WIND_SPEED,             // ���ٵ�λ��m/s
	EM_SENSE_HUMIDITY_PERCENT,       // ʪ�ȵ�λ: Percent          
}EM_SENSE_METHOD_UNIT;	

// ������ģʽ
typedef enum tagNET_ALARM_MODE
{    
    NET_ALARM_MODE_UNKNOWN = -1,        // δ֪
    NET_ALARM_MODE_DISARMING,           // ����
    NET_ALARM_MODE_ARMING,              // ����
    NET_ALARM_MODE_FORCEON,             // ǿ�Ʋ���
    NET_ALARM_MODE_PARTARMING,          // ���ֲ���
}NET_ALARM_MODE;

// ����������ģʽ
typedef enum tagNET_SCENE_MODE
{
    NET_SCENE_MODE_UNKNOWN,             // δ֪����
    NET_SCENE_MODE_OUTDOOR,             // ���ģʽ
    NET_SCENE_MODE_INDOOR,              // ����ģʽ
    NET_SCENE_MODE_WHOLE,               // ȫ��ģʽ
    NET_SCENE_MODE_RIGHTNOW,            // ����ģʽ
    NET_SCENE_MODE_SLEEPING,            // ����ģʽ
    NET_SCENE_MODE_CUSTOM,              // �Զ���ģʽ
}NET_SCENE_MODE;

// ������ʽ
typedef enum tagNET_EM_TRIGGER_MODE
{
    NET_EM_TRIGGER_MODE_UNKNOWN = 0,
    NET_EM_TRIGGER_MODE_NET,            // �����û�(ƽ̨��Web)
    NET_EM_TRIGGER_MODE_KEYBOARD,       // ����
    NET_EM_TRIGGER_MODE_REMOTECONTROL,  // ң����
}NET_EM_TRIGGER_MODE;

// ������״̬�仯�¼�����Ϣ
typedef struct tagALARM_ARMMODE_CHANGE_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;        // �����¼�������ʱ��
    NET_ALARM_MODE      bArm;           // �仯���״̬
    NET_SCENE_MODE      emSceneMode;    // �龰ģʽ
    DWORD               dwID;           // ID��, ң������Ż���̵�ַ, emTriggerModeΪNET_EM_TRIGGER_MODE_NET����ʱΪ0
    NET_EM_TRIGGER_MODE emTriggerMode;  // ������ʽ
}ALARM_ARMMODE_CHANGE_INFO;

// ��������
typedef enum
{
    NET_DEFENCEAREA_TYPE_UNKNOWN,       // δ֪���ͷ���
    NET_DEFENCEAREA_TYPE_ALARM,         // ����������
}NET_DEFENCEAREA_TYPE;

// ��·״̬����
typedef enum
{
    NET_BYPASS_MODE_UNKNOW,             //δ֪״̬
    NET_BYPASS_MODE_BYPASS,             //��·
    NET_BYPASS_MODE_NORMAL,             //����
    NET_BYPASS_MODE_ISOLATED,           //����
}NET_BYPASS_MODE;

// ��·״̬�仯�¼�����Ϣ
typedef struct tagALARM_BYPASSMODE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // ͨ����
    NET_TIME                stuTime;                    // �����¼�������ʱ��
    NET_DEFENCEAREA_TYPE    emDefenceType;              // ��������
    int                     nIsExtend;                  // �Ƿ�Ϊ��չ(ͨ��)����, 1:��չͨ��, 0: ����չͨ��
    NET_BYPASS_MODE         emMode;                     // �仯���ģʽ
    DWORD                   dwID;                       // ID��, ң������Ż���̵�ַ, emTriggerModeΪNET_EM_TRIGGER_MODE_NET����ʱΪ0
    NET_EM_TRIGGER_MODE     emTriggerMode;              // ������ʽ
}ALARM_BYPASSMODE_CHANGE_INFO;


// ���¼�(��ӦDH_URGENCY_ALARM_EX2, ��ԭ�е�DH_URGENCY_ALARM_EX���͵�����, ָ��Ϊ�����Ľ��¼�, һ�㴦���������ⲿͨѶ�����������)
typedef struct tagALARM_URGENCY_ALARM_EX2 
{
    DWORD           dwSize;
    NET_TIME        stuTime;                     // �¼�������ʱ��
    DWORD           nID;                         // ���ڱ�ʶ��ͬ�Ľ��¼�
}ALARM_URGENCY_ALARM_EX2;

// ��������Դ�¼�����(ֻҪ������ͻ�������¼�,���۷�����ǰ��ģʽ,�޷�����)
typedef struct tagALARM_INPUT_SOURCE_SIGNAL_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // ͨ����
    int             nAction;                            // 0:��ʼ 1:ֹͣ
    NET_TIME        stuTime;                            // �����¼�������ʱ��
}ALARM_INPUT_SOURCE_SIGNAL_INFO;

// ģ������������ͨ���¼���Ϣ(��ӦDH_ALARM_ANALOGALARM_EVENT)
typedef struct tagALARM_ANALOGALARM_EVENT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // ͨ����
    int             nAction;                            // 0:��ʼ 1:ֹͣ
    NET_TIME        stuTime;                            // �����¼�������ʱ��
    NET_SENSE_METHOD  emSensorType;                     // ����������
    char            szName[DH_COMMON_STRING_128];       // ͨ������
    int             nIsValid;                           // �����Ƿ���Ч,-1:δ֪,0:��Ч,1:��Ч
    int             nStatus;                            // ����״̬, -1:δ֪,0:����,1:������Ч(��������),
                                                        // 2:������ֵ1,3:������ֵ2,4:������ֵ3,5:������ֵ4,
                                                        // 6:������ֵ1,7:������ֵ2,8:������ֵ3,9:������ֵ4
    float           fValue;                             // ̽������ֵ
    NET_TIME        stuCollectTime;                     // ���ݲɼ�ʱ��(UTC)
    NET_GPS_STATUS_INFO stGPSStatus;                    // GPS��Ϣ 
}ALARM_ANALOGALARM_EVENT_INFO;


// �Ž�״̬����
typedef enum tagNET_ACCESS_CTL_STATUS_TYPE
{
    NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN = 0,
    NET_ACCESS_CTL_STATUS_TYPE_OPEN,                    // ����
    NET_ACCESS_CTL_STATUS_TYPE_CLOSE,                   // ����
    NET_ACCESS_CTL_STATUS_TYPE_ABNORMAL,                // �쳣
}NET_ACCESS_CTL_STATUS_TYPE;

// �Ž�״̬�¼�
typedef struct tagALARM_ACCESS_CTL_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                  // ��ͨ����
    NET_TIME                    stuTime;                // �¼�������ʱ��
    NET_ACCESS_CTL_STATUS_TYPE  emStatus;               // �Ž�״̬
}ALARM_ACCESS_CTL_STATUS_INFO;

// �Ž�ץͼ����
typedef enum tagNET_ACCESS_SNAP_TYPE
{
    NET_ACCESS_SNAP_TYPE_UNKNOWN = 0,
    NET_ACCESS_SNAP_TYPE_CARD,                          // ˢ��
    NET_ACCESS_SNAP_TYPE_PASSWORD,                      // ����
}NET_ACCESS_SNAP_TYPE;

// �Ž�ץͼ�¼�
typedef struct tagALARM_ACCESS_SNAP_INFO
{
    DWORD           dwSize;
    NET_ACCESS_SNAP_TYPE emType;                        // ����
    char            szCardNO[DH_COMMON_STRING_32];      // ����, ˢ������ʱ��Ч
    char            szPassword[DH_COMMON_STRING_64];    // ����, ���뿪��ʱ����Ч    
    char            szFtpUrl[MAX_PATH];                 // ftp�ϴ���ַ, ͼƬ·��
    int             nImageNum;                          // ץͼ����
    NET_TIME        stuTime;                            // �¼�������ʱ��
}ALARM_ACCESS_SNAP_INFO;

// �����¼�
typedef struct tagALARM_ALARMCLEAR_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // ͨ����
    NET_TIME        stuTime;                            // �����¼�������ʱ��
    int             bEventAction;                       // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
}ALARM_ALARMCLEAR_INFO;

// CID�¼�
typedef struct tagALARM_CIDEVENT_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                            // �����¼�������ʱ��
    char            szCID[DH_COMMON_STRING_32];         // CID��,��׼Э���� �ַ�������Ϊ16,�ַ���ֵΪ0~F
                                                        // 4λ�û��� + 2λʶ���� + 1λ�¼��޶��� + 3λ�¼��� + 2λϵͳ�� + 3λ������ + 1λУ����
}ALARM_CIDEVENT_INFO;

// ������¼�����
typedef enum tagEM_RCEMERGENCY_CALL_TYPE
{
    EM_RCEMERGENCY_CALL_UNKNOWN = 0,
    EM_RCEMERGENCY_CALL_FIRE,                           // ��
    EM_RCEMERGENCY_CALL_DURESS,                         // в��
    EM_RCEMERGENCY_CALL_ROBBER,                         // �˾�
    EM_RCEMERGENCY_CALL_MEDICAL,                        // ҽ��
    EM_RCEMERGENCY_CALL_EMERGENCY,                      // ��
}EM_RCEMERGENCY_CALL_TYPE;

// ������ʽ
typedef enum tagEM_RCEMERGENCY_MODE_TYPE
{
    EM_RCEMERGENCY_MODE_UNKNOWN = 0,
    EM_RCEMERGENCY_MODE_KEYBOARD,                       // ����
    EM_RCEMERGENCY_MODE_WIRELESS_CONTROL,               // ң����
}EM_RCEMERGENCY_MODE_TYPE;

// ������¼�����
typedef struct tagALARM_RCEMERGENCY_CALL_INFO 
{
    DWORD                       dwSize;
    int                         nAction;                // -1:δ֪ 0:��ʼ 1:ֹͣ
    EM_RCEMERGENCY_CALL_TYPE    emType;                 // ������
    NET_TIME                    stuTime;                // �¼�����ʱ��
    EM_RCEMERGENCY_MODE_TYPE    emMode;                 // ������ʽ
    DWORD                       dwID;                   // ���ڱ�ʾ��ͬ�Ľ��¼�(ֻ��emMode��ң��������ʱ��Ч, ��ʾң�����ı��, 0��ʾ��ЧID)
}ALARM_RCEMERGENCY_CALL_INFO;

// ������Ͽ����¼�(��ӦDH_ALARM_OPENDOORGROUP����)
typedef struct tagALARM_OPEN_DOOR_GROUP_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // ��ͨ����(��0��ʼ)
    NET_TIME        stuTime;                            // �¼�ʱ��
}ALARM_OPEN_DOOR_GROUP_INFO;

// ��ȡָ���¼�(��ӦDH_ALARM_FINGER_PRINT����)
typedef struct tagALARM_CAPTURE_FINGER_PRINT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // ��ͨ����(��0��ʼ)
    NET_TIME        stuTime;                            // �¼�ʱ��
    char            szReaderID[DH_COMMON_STRING_32];    // �Ŷ�����ID
    int             nPacketLen;                         // ����ָ�����ݰ�����
    int             nPacketNum;                         // ָ�����ݰ�����
    char*           szFingerPrintInfo;                  // ָ������(�����ܳ��ȼ�nPacketLen*nPacketNum)
}ALARM_CAPTURE_FINGER_PRINT_INFO;

// ��ϵͳ״̬����
typedef enum __EM_SUBSYSTEM_STATE_TYPE
{
    EM_SUBSYSTEM_STATE_UNKNOWN = 0,                     // δ֪
    EM_SUBSYSTEM_STATE_ACTIVE,                          // �Ѽ���
    EM_SUBSYSTEM_STATE_INACTIVE,                        // δ����
}EM_SUBSYSTEM_STATE_TYPE;

// ��ϵͳ״̬�ı��¼�
typedef struct tagALARM_SUBSYSTEM_STATE_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // ��ϵͳ���(��0��ʼ)
    NET_TIME                stuTime;                    // �¼�������ʱ��
    EM_SUBSYSTEM_STATE_TYPE emState;                    // �仯���״̬
}ALARM_SUBSYSTEM_STATE_CHANGE_INFO;

// ��ص�����ʱ֪ͨ�¼�
typedef struct tagALARM_BATTERYPOWER_INFO
{
    DWORD       dwSize;
    int         nChannel;                                  // ������
    NET_TIME    stuTime;                                   // �¼�ʱ��
    int         nPercent;                                  // ��ص����ٷֱ�
    float       fVoltage;                                  // ��ѹ,��λ:��
    BOOL        bCharging;                                 // �Ƿ����ڳ�� true:���ڳ�� false:û�г��
}ALARM_BATTERYPOWER_INFO;

// ����״̬�¼�
typedef struct tagALARM_BELLSTATUS_INFO 
{
    DWORD       dwSize;
    int         nChannel;                                   // ����ͨ���� 
    NET_TIME    stuTime;                                    // �¼�ʱ��
    int         nAction;                                    // 0:��ʼ 1:ֹͣ
}ALARM_BELLSTATUS_INFO;

// ����״̬�仯�¼�, ��Ӧ�¼�����DH_ALARM_DEFENCE_STATE_CHANGE_EVENT
typedef struct tagALARM_DEFENCE_STATUS_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ����ID,����������ͨ����(��0��ʼ)
    NET_TIME                stuTime;                        // �¼�������ʱ��
    EM_DEFENCE_STATE_TYPE   emStatus;                       // �����仯���״̬
}ALARM_DEFENCE_STATUS_CHANGE_INFO;

// ��½ʧ���¼�
typedef struct tagALARM_LOGIN_FAILIUR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // 0:��ʼ 1:ֹͣ
    unsigned int            nSequence;                      // ���
    char                    szName[DH_EVENT_NAME_LEN];      // �¼���,���û�����
    char                    szType[DH_COMMON_STRING_128];   // ��¼����
    char                    szAddr[DH_MAX_IPADDR_EX_LEN];   // ��ԴIP��ַ
    int                     nError;                         // �û���½ʧ�ܴ�����
}ALARM_LOGIN_FAILIUR_INFO;

// ��Ʊͳ����Ϣ�¼� ��Ӧ�¼����� DH_ALARM_TICKET_STATISTIC
typedef struct tagALARM_TICKET_STATISTIC
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS��Ϣ
    NET_TIME                stuTime;                        // �¼��ϱ�ʱ��
    int                     nNormalCount;                   // ��ͨƱ����
    int                     nDiscountCount;                 // �Ż�Ʊ����
    int                     nSubsidyCount;                  // ���ײ���Ʊ����
    int                     nDriverCount;                   // ˾��Ʊ����
    int                     nNormalPrice;                   // ��ͨƱ�۸�
    int                     nDiscountPrice;                 // �Ż�Ʊ�۸�
    int                     nSubsidyPrice;                  // ���ײ���Ʊ�۸�
}ALARM_TICKET_STATISTIC;

#define MAX_ALARMEXT_MODULE_NUM        256                  // �����չģ����Ŀ

// ��������
typedef enum tagNET_BUS_TYPE
{
    NET_BUS_TYPE_UNKNOWN = 0,
    NET_BUS_TYPE_MBUS,                                      // M-BUS����
    NET_BUS_TYPE_RS485,                                     // RS-485����
    NET_BUS_TYPE_CAN,                                       // CAN����
}NET_BUS_TYPE;

// ��չģ������¼� ��Ӧ�¼����� DH_ALARM_MODULE_LOST
typedef struct tagALARM_MODULE_LOST_INFO 
{
    DWORD                   dwSize;
    NET_TIME                stuTime;                        // �¼��ϱ�ʱ��
    int                     nSequence;                      // ��չģ��ӵ����ߵ����(��0��ʼ)
    NET_BUS_TYPE            emBusType;                      // ��������
    int                     nAddr;                          // ���ߵ���չģ����Ŀ
    int                     anAddr[MAX_ALARMEXT_MODULE_NUM];// ���ߵ���չģ������(��0��ʼ)
	char					szDevType[DH_COMMON_STRING_64];	// �豸���� "SmartLock",�Ǽ����豸,���豸����"AlarmDefence"�ӿ����Ϊ�������
	BOOL					bOnline;						//�������   Ĭ��false��   false   ������   true ����
}ALARM_MODULE_LOST_INFO;

// PSTN�����¼�
typedef struct tagALARM_PSTN_BREAK_LINE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // �绰�����(��0��ʼ)
    int                     nAction;                    // 0:��ʼ 1:ֹͣ
    NET_TIME                stuTime;                    // �¼�������ʱ��
}ALARM_PSTN_BREAK_LINE_INFO;

// ģ���������¼�(˲ʱ���¼�), �ض�����������ʱ(�糬�١���̡�����)�Ŵ���
typedef struct tagALARM_ANALOGPULSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ģ��������ͨ����
    NET_TIME                stuEventTime;                   // �����¼�������ʱ��
    NET_SENSE_METHOD        emSense;                        // ����������
    char                    szName[DH_COMMON_STRING_128];   // ����������
    int                     nStatus;                        // ����״̬, -1:δ֪,0:����,1:������Ч(��������),
                                                            // 2:������ֵ1,3:������ֵ2,4:������ֵ3,5:������ֵ4,
                                                            // 6:������ֵ1,7:������ֵ2,8:������ֵ3,9:������ֵ4
    float                   fValue;                         // ��������ֵ
    NET_TIME                stuCollectTime;                 // �ɼ�ʱ��
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS��Ϣ
}ALARM_ANALOGPULSE_INFO;

//������Ϣȷ�϶�������
typedef enum tagNET_MISSION_CONFIRM_TYPE
{
    NET_MISSION_CONFIRM_UNKNOWN = 0  ,  //δ֪
    NET_MISSION_CONFIRM_YES ,           //ͬ�Ⲣִ��
    NET_MISSION_CONFIRM_NO ,            //�ܾ�ִ��
}NET_MISSION_CONFIRM_TYPE;

// ����ȷ���¼�(��Ӧ����DH_ALARM_MISSION_CONFIRM)
typedef struct tagALARM_MISSION_CONFIRM_INFO 
{
    DWORD                   dwSize;
    char                    szTitle[DH_COMMON_STRING_256];   // ��������
    char                    szMissionID[DH_COMMON_STRING_256];// ����ID
    char                    szComment[DH_COMMON_STRING_256]; // �ظ�����
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                // GPS��Ϣ
    NET_MISSION_CONFIRM_TYPE emConfirmType;                  //������Ϣȷ�϶�������
}ALARM_MISSION_CONFIRM_INFO;

// ��Ⱥ�ڵ��������
typedef enum tagNET_CLUSTER_GROUP_TYPE
{
    NET_CLUSTER_GROUP_UNKNOWN,                          // δ֪
    NET_CLUSTER_GROUP_IDLE,                             // ����
    NET_CLUSTER_GROUP_MASTER,                           // ����
    NET_CLUSTER_GROUP_SLAVE,                            // ����
}NET_CLUSTER_GROUP_TYPE;

// �ڵ㼤���¼�, ��Ӧ�¼����� DH_ALARM_NODE_ACTIVE
typedef struct tagALARM_NODE_ACTIVE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // ��Ⱥ�еĽڵ��
    NET_TIME                stuTime;                    // �¼������¼�
    NET_CLUSTER_GROUP_TYPE  emGroup;                    // ��ǰ�ڵ�������
}ALARM_NODE_ACTIVE_INFO;

// ��Ⱥ�ڵ�״̬
typedef struct tagNET_CLUSTER_STATE_INFO 
{
    DWORD                   dwSize;
    NET_CLUSTER_GROUP_TYPE  emGroup;                    // ��ǰ�ڵ�������
}NET_CLUSTER_STATE_INFO;

// �豸������ģʽ
typedef enum tagEM_ALARM_VIDEO_STATIC_MODE
{
    EM_ALARM_VIDEO_STATIC_MODE_UNKNOWN,                 // δ֪
    EM_ALARM_VIDEO_STATIC_MODE_INDOOR,                  // ����ģʽ "Indoor"
    EM_ALARM_VIDEO_STATIC_MODE_OUTDOOR,                 // ����ģʽ "Outdoor"
}EM_ALARM_VIDEO_STATIC_MODE;

// ��Ƶ��̬����¼�, ��Ӧ�¼����� DH_ALARM_VIDEO_STATIC
typedef struct tagALARM_VIDEO_STATIC_INFO 
{
    DWORD                       dwSize;
    DWORD                       dwAction;                       // �¼�����, 0:Start, 1:Stop
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                         // �豸������ģʽ
    int                         nChannelID;                     // ��Ƶ��̬��ⱨ��ͨ����
}ALARM_VIDEO_STATIC_INFO;

// ����ע���豸���µ�½�¼�, ��Ӧ�¼����� DH_ALARM_REGISTER_REONLINE
typedef struct tagALARM_REGISTER_REONLINE_INFO
{
    DWORD           dwSize;
}ALARM_REGISTER_REONLINE_INFO;

// ����״̬
typedef enum tagEM_ALARM_ISCSI_STATUS
{
    EM_ALARM_ISCSI_STATUS_UNKNOWN,                  // δ֪
    EM_ALARM_ISCSI_STATUS_CONNECTED,                // ������
    EM_ALARM_ISCSI_STATUS_NOT_CONNECTED,            // δ����
    EM_ALARM_ISCSI_STATUS_CONNECT_FAILED,           // ����ʧ��
    EM_ALARM_ISCSI_STATUS_AUTHENTICATION_FAILED,    // ��֤ʧ��
    EM_ALARM_ISCSI_STATUS_CONNECT_TIMEOUT,          // ���ӳ�ʱ
    EM_ALARM_ISCSI_STATUS_NOT_EXIST,                // �豸������
}EM_ALARM_ISCSI_STATUS;

// ISCSI�澯�¼�, ��Ӧ�¼����� DH_ALARM_ISCSI_STATUS
typedef struct tagALARM_ISCSI_STATUS_INFO
{
    DWORD                   dwSize;
    int                     nIndex;                             // ��ʾISCSI�豸������
    char                    szAddress[DH_COMMON_STRING_32];     // ��������ַ
    char                    szName[DH_COMMON_STRING_64];        // Target����
    char                    szUserName[DH_COMMON_STRING_64];    // �û���
    EM_ALARM_ISCSI_STATUS   emStatus;                           // ����״̬
}ALARM_ISCSI_STATUS_INFO;

// ���ɼ��豸�����¼�, ��Ӧ�¼����� DH_ALARM_SCADA_DEV_ALARM
typedef struct tagALARM_SCADA_DEV_INFO 
{
    DWORD                   dwSize;
    int                     nChannel;                           // ͨ����
    NET_TIME                stuTime;                            // �¼�������ʱ��
    char                    szDevName[DH_COMMON_STRING_64];     // �����豸����
    char                    szDesc[DH_COMMON_STRING_256];       // ��������
    int                     nAction;                            // -1:δ֪ 0:���� 1:��ʼ 2:ֹͣ
    char                    szID[DH_COMMON_STRING_32];          // ��λID, Ŀǰʹ��16�ֽ�
    char                    szSensorID[DH_COMMON_STRING_32];    // ̽����ID, Ŀǰʹ��16�ֽ�
    char                    szDevID[DH_COMMON_STRING_32];       // �豸ID, Ŀǰʹ��16�ֽ�
    char                    szPointName[DH_COMMON_STRING_64];   // ��λ��,����ƥ��
    int                     nAlarmFlag;                         // 0:��ʼ, 1:����
}ALARM_SCADA_DEV_INFO;

// ����ACC�����¼�, ��Ӧ�¼����� DH_ALARM_VEHICLE_ACC
typedef struct tagALARM_VEHICLE_ACC_INFO 
{
    DWORD                   dwSize;
    int                     nACCStatus;                         // ACC״̬, 0:��Ч, 1:����, 2:�ر� 
    int                     nAction;                            // �¼�����, 0:Start, 1:Stop
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPS��Ϣ
    int                     nConstantElectricStatus;            // ����״̬, 0:δ֪, 1:����, 2:�Ͽ�                            
	NET_TIME_EX				stuTime;							// �¼�������ʱ��
}ALARM_VEHICLE_ACC_INFO;

typedef NET_ACCESS_CTL_STATUS_TYPE  NET_ACCESS_LOCK_STATUS_TYPE;

// ����״̬�¼�, ��Ӧ�¼����� DH_ALARM_ACCESS_LOCK_STATUS
typedef struct tagALARM_ACCESS_LOCK_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                       // ��ͨ����(��0��ʼ)
    NET_TIME                    stuTime;                        // �¼�������ʱ��
    NET_ACCESS_LOCK_STATUS_TYPE emLockStatus;                   // ����״̬
}ALARM_ACCESS_LOCK_STATUS_INFO;

// ҵ������
typedef enum tagEM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE
{
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_UNKNOWN,         // δ֪
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_ORGANIZATION,    // ���������
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_SEAL,            // ���ʽ���
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EXCLUSIVE,       // ר�����
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_GATHER,          // ������Ƽƻ�
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EVEN,            // �������
}EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE;

// ��ƾ����¼�, ��Ӧ�¼����� DH_ALARM_FINACE_SCHEME
typedef struct tagALARM_FINACE_SCHEME_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                                   // ��Ƶͨ����
    char                        szBusinessSeverID[DH_COMMON_STRING_64];     // ҵ�񵥺�
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE  emBusinessSeverType;        // ҵ������
    NET_TIME                    stuFinaceSchemeTime;                        // ��ƾ���ʱ��
    NET_TIME                    stuSchemeStartTime;                         // �����Чʱ��
    NET_TIME                    stuSchemeEndTime;                           // ���ʧЧʱ��
    char                        szProductName[DH_COMMON_STRING_128];        // ��Ʋ�Ʒ����
    char                        szCardNo[DH_COMMON_STRING_64];              // ���п���
    char                        szPersonID[DH_COMMON_STRING_64];            // �ͻ����֤
    char                        szPersonName[DH_COMMON_STRING_64];          // �ͻ�����
    char                        szOrgNo[DH_COMMON_STRING_64];               // ֧�л�����
    char                        szStuffID[DH_COMMON_STRING_64];             // ����Ա������
    NET_TIME                    stuRecStartTime;                            // ¼��ʼʱ��
    NET_TIME                    stuRecEndTime;                              // ¼�����ʱ��
}ALARM_FINACE_SCHEME_INFO;

//////////////////////////////////////////////////////////////////////////

// ��¼����������(insert)�������
typedef struct tagNET_CTRL_RECORDSET_IN
{
    DWORD           dwSize;
    EM_NET_RECORD_TYPE emType;                          // ��¼����Ϣ����
    void*           pBuf;                               // ��¼����Ϣ����,���EM_NET_RECORD_TYPEע�ͣ����û������ڴ�.
	int             nBufLen;                            // ��¼����Ϣ�����С,��С���ռ�¼����Ϣ���Ͷ�Ӧ�Ľṹ��
}NET_CTRL_RECORDSET_INSERT_IN;

// ��¼����������(insert)�������
typedef struct tagNET_CTRL_RECORDSET_OUT 
{
    DWORD           dwSize;
    int             nRecNo;                             // ��¼���(����insertʱ�豸����)
}NET_CTRL_RECORDSET_INSERT_OUT;

// ��¼����������(insert)����
typedef struct tagNET_CTRL_RECORDSET_INSERT_PARAM 
{
    DWORD                           dwSize;
    NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // ��¼����Ϣ(�û���д)
    NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // ��¼����Ϣ(�豸����)
}NET_CTRL_RECORDSET_INSERT_PARAM;

// ��¼����������
typedef struct tagNET_CTRL_RECORDSET_PARAM 
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;                         // ��¼����Ϣ����
    void*               pBuf;                           // ����\����\��ѯ\����ʱ,Ϊ��¼����Ϣ����,���EM_NET_RECORD_TYPEע��,���û������ڴ棬����ΪnBufLen
                                                        // ɾ��ʱ,Ϊ��¼���(int��)
    int                 nBufLen;                        // ��¼����Ϣ�����С,��С���ռ�¼����Ϣ���Ͷ�Ӧ�Ľṹ��
}NET_CTRL_RECORDSET_PARAM;

// ��Ƶ����ģʽ
typedef enum tagEM_VIDEO_PLAY_MODE_TYPE
{
    EM_VIDEO_PLAY_MODE_TYPE_UNKNOWN,                    // δ֪
    EM_VIDEO_PLAY_MODE_TYPE_ONCE,                       // ����һ��
    EM_VIDEO_PLAY_MODE_TYPE_REPEAT,                     // ѭ������
}EM_VIDEO_PLAY_MODE_TYPE;

#define MAX_DELIVERY_FILE_NUM 128                       // ���Ͷ���ļ�����
#define DELIVERY_FILE_URL_LEN 128                       // Ͷ���ļ���URL����

// Ͷ�ŵ��ļ�����
typedef enum tagEM_DELIVERY_FILE_TYPE
{
    EM_DELIVERY_FILE_TYPE_UNKNOWN,                      // δ֪
    EM_DELIVERY_FILE_TYPE_VIDEO,                        // ��Ƶ
    EM_DELIVERY_FILE_TYPE_IMAGE,                        // ͼƬ
}EM_DELIVERY_FILE_TYPE;

// Ͷ���ļ���Ϣ
typedef struct tagNET_DELIVERY_FILE_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // �ļ�����
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // �ļ�����Դ��ַ
    int                     nImageSustain;                      // ÿ��ͼƬͣ��೤ʱ�䣬��λ�� (emFileTypeΪEM_DELIVERY_FILE_TYPE_IMAGEʱ���ֶ���Ч)
    BYTE                    byReserved[1024];                   // �����ֽ�
}NET_DELIVERY_FILE_INFO;

// ����Ƶ�����Ͷ����Ƶ��ͼƬ�ļ�
typedef struct tagNET_CTRL_DELIVERY_FILE 
{
    DWORD                   dwSize;                             // �ṹ���С
    int                     nPort;                              // ��Ƶ�����
    EM_VIDEO_PLAY_MODE_TYPE emPlayMode;                         // ��������
    NET_TIME                stuStartPlayTime;                   // ��ʼ���ŵ�ʱ��
    NET_TIME                stuStopPlayTime;                    // �������ŵ�ʱ�䣬emPlayModeΪEM_VIDEO_PLAY_MODE_TYPE_REPEATʱ����ֵ��Ч    
    int                     nFileCount;                         // Ͷ�ŵ��ļ�����
    NET_DELIVERY_FILE_INFO  stuFileInfo[MAX_DELIVERY_FILE_NUM]; // Ͷ�ŵ��ļ���Ϣ
}NET_CTRL_DELIVERY_FILE;

// Ͷ���ļ���Ϣ
typedef struct tagNET_DELIVERY_FILE_BYCAR_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // �ļ�����
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // �ļ�����Դ��ַ
    int                     nImageSustain;                      // ÿ��ͼƬͣ��೤ʱ�䣬��λ�� (emFileTypeΪEM_DELIVERY_FILE_TYPE_IMAGEʱ���ֶ���Ч)
    NET_TIME                stuStartPlayTime;                   // ��ʼ���ŵ�ʱ��
    NET_TIME                stuStopPlayTime;                    // �������ŵ�ʱ�䣬emPlayModeΪEM_VIDEO_PLAY_MODE_TYPE_REPEATʱ����ֵ��Ч    
    BYTE                    byReserved[1024];                   // �����ֽ�
}NET_DELIVERY_FILE_BYCAR_INFO;

// ����Ƶ�����Ͷ����Ƶ��ͼƬ�ļ�, ����ʹ�ã���浥��ʱ��Ͷ��
typedef struct tagNET_CTRL_DELIVERY_FILE_BYCAR
{
    DWORD                           dwSize;                             // �ṹ���С
    int                             nPort;                              // ��Ƶ�����
    EM_VIDEO_PLAY_MODE_TYPE         emPlayMode;                         // ��������
    int                             nFileCount;                         // Ͷ�ŵ��ļ�����
    NET_DELIVERY_FILE_BYCAR_INFO    stuFileInfo[MAX_DELIVERY_FILE_NUM]; // Ͷ�ŵ��ļ���Ϣ
}NET_CTRL_DELIVERY_FILE_BYCAR;

// ��״̬
typedef enum tagNET_ACCESSCTLCARD_STATE
{
    NET_ACCESSCTLCARD_STATE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_STATE_NORMAL = 0,                 // ����
    NET_ACCESSCTLCARD_STATE_LOSE   = 0x01,              // ��ʧ
    NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02,              // ע��
    NET_ACCESSCTLCARD_STATE_FREEZE = 0x04,              // ����
    NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08,           // Ƿ��
    NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10,             // ����
    NET_ACCESSCTLCARD_STATE_PREARREARAGE = 0x20,        // ԤǷ��(���ǿ��Կ���,����������ʾ)
}NET_ACCESSCTLCARD_STATE;

// ������
typedef enum tagNET_ACCESSCTLCARD_TYPE
{
    NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_TYPE_GENERAL,                     // һ�㿨
    NET_ACCESSCTLCARD_TYPE_VIP,                         // VIP��
    NET_ACCESSCTLCARD_TYPE_GUEST,                       // ������
    NET_ACCESSCTLCARD_TYPE_PATROL,                      // Ѳ�߿�
    NET_ACCESSCTLCARD_TYPE_BLACKLIST,                   // ��������
    NET_ACCESSCTLCARD_TYPE_CORCE,                       // в�ȿ�
    NET_ACCESSCTLCARD_TYPE_POLLING,                     // Ѳ�쿨
    NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff,           // ĸ��
}NET_ACCESSCTLCARD_TYPE;

#define DH_MAX_DOOR_NUM               32                // �����Ȩ���Ž���Ŀ
#define DH_MAX_TIMESECTION_NUM        32                // �����Чʱ�����Ŀ
#define DH_MAX_CARDNAME_LEN           64                // �Ž���������󳤶�
#define DH_MAX_CARDNO_LEN             32                // �Ž�������󳤶�
#define DH_MAX_USERID_LEN             32                // �Ž����û�ID��󳤶�
#define DH_MAX_IC_LEN				  32				// ���֤��󳤶�
#define DH_MAX_QRCODE_LEN			  128				// QRCode ��󳤶�

// ָ�����ݣ�ֻ�����·���Ϣ
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET
{
    DWORD   dwSize; 
    int     nLength;        // �������ݰ�����,��λ�ֽ�
    int     nCount;         // ������
    char*   pPacketData;    // ����ָ�����ݰ����û������ڴ沢��䣬����Ϊ nLength*nCount
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET;

// ָ��������չ���������·��ͻ�ȡ��Ϣ
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX
{
    int     nLength;        // �������ݰ�����,��λ�ֽ�
    int     nCount;         // ������
    char*   pPacketData;    // ����ָ�����ݰ�, �û������ڴ�,��С����ΪnLength * nCount
    int     nPacketLen;     // pPacketData ָ���ڴ����Ĵ�С���û���д
    int     nRealPacketLen; // ���ظ��û�ʵ��ָ���ܴ�С
	int	    nDuressIndex;   // в��ָ����ţ���Χ1~nCount
    BYTE    byReverseed[1020]; //�����С
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX;

#define MAX_REPEATENTERROUTE_NUM   12 //��Ǳ·������

// �Ž�����¼����Ϣ
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARD
{
    DWORD           dwSize;
    int             nRecNo;                                 // ��¼�����,ֻ��
    NET_TIME        stuCreateTime;                          // ����ʱ��
    char            szCardNo[DH_MAX_CARDNO_LEN];            // ����
    char            szUserID[DH_MAX_USERID_LEN];            // �û�ID, �豸�ݲ�֧��
    NET_ACCESSCTLCARD_STATE       emStatus;                 // ��״̬
    NET_ACCESSCTLCARD_TYPE        emType;                   // ������
    char            szPsw[DH_MAX_CARDPWD_LEN];              // ������
    int             nDoorNum;                               // ��Ч������Ŀ;
    int             sznDoors[DH_MAX_DOOR_NUM];              // ��Ȩ�޵������,��CFG_CMD_ACCESS_EVENT���õ������±�
    int             nTimeSectionNum;                        // ��Ч�ĵĿ���ʱ�����Ŀ
    int             sznTimeSectionNo[DH_MAX_TIMESECTION_NUM];  // ����ʱ�������,��CFG_ACCESS_TIMESCHEDULE_INFO�������±�
    int             nUserTime;                              // ʹ�ô���,����������ʱ��Ч
    NET_TIME        stuValidStartTime;                      // ��ʼ��Ч��, �豸�ݲ�֧��ʱ����
    NET_TIME        stuValidEndTime;                        // ������Ч��, �豸�ݲ�֧��ʱ����
    BOOL            bIsValid;                               // �Ƿ���Ч,TRUE��Ч;FALSE��Ч
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;// �·�ָ��������Ϣ����Ϊ�����Ա�����ʹ�� stuFingerPrintInfoEx
    BOOL            bFirstEnter;                            // �Ƿ�ӵ���׿�Ȩ��
    char            szCardName[DH_MAX_CARDNAME_LEN];        // ������
    char            szVTOPosition[DH_COMMON_STRING_64];     // �ſڻ�����λ��
    BOOL            bHandicap;                              // �Ƿ�Ϊ�м��˿�
    BOOL            bEnableExtended;                        // ���ó�Ա stuFingerPrintInfoEx
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX     stuFingerPrintInfoEx;	// ָ��������Ϣ
    int             nFaceDataNum;                           // �������ݸ���������20
    char            szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];	// ����ģ������
	char			szDynamicCheckCode[MAX_COMMON_STRING_16];			// ��̬У���롣
																		// VTO���豸�ᱣ���У���룬�Ժ�ÿ��ˢ������һ�����㷨������У���벢д��IC���У�ͬʱ����VTO�豸��У���룬ֻ�п��źʹ�У����ͬʱ��֤ͨ��ʱ�ſɿ��š�
																		// ȱ�㣺Ŀǰ����ֻ֧��һ��ˢһ���豸��
    int             nRepeatEnterRouteNum;                         // ��Ǳ·������
    int             arRepeatEnterRoute[MAX_REPEATENTERROUTE_NUM]; // ��Ǳ·��
    int             nRepeatEnterRouteTimeout;                     // ��Ǳ��ʱʱ��
    BOOL            bNewDoor;                                     // �Ƿ����¿�����Ȩ�ֶΣ�TRUE��ʾʹ��nNewDoorNum��nNewDoors�ֶ��·�����Ȩ��
    int             nNewDoorNum;                                  // ��Ч������Ŀ;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];                // ��Ȩ�޵������,��CFG_CMD_ACCESS_EVENT���õ������±�
    int             nNewTimeSectionNum;                           // ��Ч�ĵĿ���ʱ�����Ŀ
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];        // ����ʱ�������,��CFG_ACCESS_TIMESCHEDULE_INFO�������±�
	char			szCitizenIDNo[MAX_COMMON_STRING_32];		  // ���֤����
}NET_RECORDSET_ACCESS_CTL_CARD;

// �Ž������¼����Ϣ
typedef struct tagNET_RECORDSET_ACCESS_CTL_PWD 
{
    DWORD           dwSize;
    int             nRecNo;                                 // ��¼�����,ֻ��
    NET_TIME        stuCreateTime;                          // ����ʱ��
    char            szUserID[DH_MAX_USERID_LEN];            // �û�ID, �豸�ݲ�֧��
    char            szDoorOpenPwd[DH_MAX_CARDPWD_LEN];      // ��������
    char            szAlarmPwd[DH_MAX_CARDPWD_LEN];         // ��������
    int             nDoorNum;                               // ��Ч�ĵ�����Ŀ
    int             sznDoors[DH_MAX_DOOR_NUM];              // ��Ȩ�޵������,��CFG_CMD_ACCESS_EVENT����CFG_ACCESS_EVENT_INFO�������±�
    char            szVTOPosition[DH_COMMON_STRING_64];     // �ſڻ�����λ��
    int             nTimeSectionNum;                        // ����ʱ��θ���
    int             nTimeSectionIndex[DH_MAX_TIMESECTION_NUM];  // ����ʱ�������,�Ǹ����飬ÿ��Ԫ����sznDoors�е��Ŷ�Ӧ
    BOOL            bNewDoor;                               // �Ƿ����¿�����Ȩ�ֶΣ�TRUE��ʾʹ��nNewDoorNum��nNewDoors�ֶ��·�����Ȩ��
    int             nNewDoorNum;                            // ��Ч������Ŀ;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];          // ��Ȩ�޵������,��CFG_CMD_ACCESS_EVENT���õ������±�
    int             nNewTimeSectionNum;                     // ��Ч�ĵĿ���ʱ�����Ŀ
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];  // ����ʱ�������,��CFG_ACCESS_TIMESCHEDULE_INFO�������±�
}NET_RECORDSET_ACCESS_CTL_PWD;


// ���ŷ�ʽ(�Ž�����,�ŵ�һ�ֹ���ģʽ)
typedef enum tagNET_DOOR_OPEN_METHOD
{
    NET_DOOR_OPEN_METHOD_UNKNOWN = 0,
    NET_DOOR_OPEN_METHOD_PWD_ONLY,                          // ֻ�������뿪��
    NET_DOOR_OPEN_METHOD_CARD,                              // ֻ����ˢ������
    NET_DOOR_OPEN_METHOD_PWD_OR_CARD,                       // �����ˢ������
    NET_DOOR_OPEN_METHOD_CARD_FIRST,                        // ��ˢ�������뿪��
    NET_DOOR_OPEN_METHOD_PWD_FIRST,                         // �������ˢ������
    NET_DOOR_OPEN_METHOD_SECTION,                           // ��ʱ�ο���
}NET_DOOR_OPEN_METHOD;

// ���ŷ�ʽ(�Ž��¼�,�Ž������¼,ʵ�ʵĿ��ŷ�ʽ)
typedef enum tagNET_ACCESS_DOOROPEN_METHOD
{
    NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0,
    NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY,                    // ���뿪��
    NET_ACCESS_DOOROPEN_METHOD_CARD,                        // ˢ������
    NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST,                  // ��ˢ�������뿪��
    NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST,                   // �������ˢ������
    NET_ACCESS_DOOROPEN_METHOD_REMOTE,                      // Զ�̿���,��ͨ�����ڻ�����ƽ̨���ſڻ�����
    NET_ACCESS_DOOROPEN_METHOD_BUTTON,                      // ������ť���п���
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT,                 // ָ�ƿ���
    NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT,        // ����+ˢ��+ָ����Ͽ���
    NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10,        // ����+ָ����Ͽ���
    NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11,       // ˢ��+ָ����Ͽ���
    NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12,                // ���˿���
    NET_ACCESS_DOOROPEN_METHOD_KEY = 13,                    // Կ�׿���
    NET_ACCESS_DOOROPEN_METHOD_COERCE_PWD = 14,             // в�����뿪��
    NET_ACCESS_DOOROPEN_METHOD_FACE_RECOGNITION = 16,       // ����ʶ����
}NET_ACCESS_DOOROPEN_METHOD;

//����״̬
typedef enum tagNET_ATTENDANCESTATE
{
    NET_ATTENDANCESTATE_UNKNOWN,
    NET_ATTENDANCESTATE_SIGNIN,                    //ǩ��
    NET_ATTENDANCESTATE_GOOUT,                     //���
    NET_ATTENDANCESTATE_GOOUT_AND_RETRUN,          //�������
    NET_ATTENDANCESTATE_SIGNOUT,                   // ǩ��
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNIN,      // �Ӱ�ǩ��
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNOUT,     // �Ӱ�ǩ��
}NET_ATTENDANCESTATE;

// ���ŷ���
typedef enum tagNET_ENUM_DIRECTION_ACCESS_CTL
{
    NET_ENUM_DIRECTION_UNKNOWN,
    NET_ENUM_DIRECTION_ENTRY,                              // ����             
    NET_ENUM_DIRECTION_EXIT,                               // ����
}NET_ENUM_DIRECTION_ACCESS_CTL;

// �Ž�ˢ����¼��¼����Ϣ
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARDREC
{
    DWORD           dwSize;
    int             nRecNo;                                 // ��¼�����,ֻ��
    char            szCardNo[DH_MAX_CARDNO_LEN];            // ����
    char            szPwd[DH_MAX_CARDPWD_LEN];              // ����
    NET_TIME        stuTime;                                // ˢ��ʱ��
    BOOL            bStatus;                                // ˢ�����,TRUE��ʾ�ɹ�,FALSE��ʾʧ��
    NET_ACCESS_DOOROPEN_METHOD    emMethod;                 // ���ŷ�ʽ
    int             nDoor;                                  // �ź�,��CFG_CMD_ACCESS_EVENT����CFG_ACCESS_EVENT_INFO�������±�
    char            szUserID[DH_MAX_USERID_LEN];            // �û�ID
    int             nReaderID;                              // ������ID (����,����ʹ��)
	char			szSnapFtpUrl[MAX_PATH];					// ����ץ���ϴ���FTP��ַ

	char            szReaderID[DH_COMMON_STRING_32];        // ������ID													// ���Ų��ϴ�ץ����Ƭ,�ڼ�¼����¼�洢��ַ,�ɹ�����
    NET_ACCESSCTLCARD_TYPE      emCardType;                 // ������
    int                         nErrorCode;                 // ����ʧ�ܵ�ԭ��,����bStatusΪFALSEʱ��Ч
                                                            // 0x00 û�д���
                                                            // 0x10 δ��Ȩ
                                                            // 0x11 ����ʧ��ע��
                                                            // 0x12 û�и���Ȩ��
                                                            // 0x13 ����ģʽ����
                                                            // 0x14 ��Ч�ڴ���
                                                            // 0x15 ����Ǳģʽ
                                                            // 0x16 в�ȱ���δ��
                                                            // 0x17 �ų���״̬
                                                            // 0x18 AB����״̬
                                                            // 0x19 Ѳ�߿�
                                                            // 0x1A �豸���ڴ��뱨��״̬
                                                            // 0x20 ʱ��δ���
                                                            // 0x21 �����ڿ���ʱ��δ���
                                                            // 0x30 ��Ҫ����֤���׿�Ȩ�޵Ŀ�Ƭ
                                                            // 0x40 ��Ƭ��ȷ,�����������
                                                            // 0x41 ��Ƭ��ȷ,�������볬ʱ
                                                            // 0x42 ��Ƭ��ȷ,����ָ�ƴ���
                                                            // 0x43 ��Ƭ��ȷ,����ָ�Ƴ�ʱ
                                                            // 0x44 ָ����ȷ,�����������
                                                            // 0x45 ָ����ȷ,�������볬ʱ
                                                            // 0x50 ��Ͽ���˳�����
                                                            // 0x51 ��Ͽ�����Ҫ������֤
                                                            // 0x60 ��֤ͨ��,����̨δ��Ȩ

    char           szRecordURL[MAX_COMMON_STRING_128];      // ˢ��¼��ĵ�ַ
    int            nNumbers;                                // ץͼ������
	NET_ATTENDANCESTATE         emAttendanceState;          // ����״̬ 
    NET_ENUM_DIRECTION_ACCESS_CTL   emDirection;            // ���ŷ���
}NET_RECORDSET_ACCESS_CTL_CARDREC;

// ���ռ�¼����Ϣ
typedef struct tagNET_RECORDSET_HOLIDAY
{
    DWORD           dwSize;
    int             nRecNo;                                 // ��¼�����,ֻ��
    int             nDoorNum;                               // ��Ч�ĵ�����Ŀ    
    int             sznDoors[DH_MAX_DOOR_NUM];              // ��Ȩ�޵������,��CFG_CMD_ACCESS_EVENT����CFG_ACCESS_EVENT_INFO�������±�
    NET_TIME        stuStartTime;                           // ��ʼʱ��
    NET_TIME        stuEndTime;                             // ����ʱ��
    BOOL            bEnable;                                // ����ʹ��
    char            szHolidayNo[DH_COMMON_STRING_32];       // ���ڱ��
    char            szHolidayName[DH_COMMON_STRING_128];    // ��������
}NET_RECORDSET_HOLIDAY;

// ����ʡ��
typedef enum tagEM_CARD_PROVINCE
{
	EM_CARD_UNKNOWN			= 10,		// ��������δ֪ʡ��
	EM_CARD_BEIJING			= 11,		// ����
	EM_CARD_TIANJIN			= 12,		// ���
	EM_CARD_HEBEI			= 13,		// �ӱ�
	EM_CARD_SHANXI_TAIYUAN	= 14,		// ɽ��
	EM_CARD_NEIMENGGU		= 15,		// ���ɹ�
	EM_CARD_LIAONING		= 21,		// ����
	EM_CARD_JILIN			= 22,		// ����
	EM_CARD_HEILONGJIANG	= 23,		// ������
	EM_CARD_SHANGHAI		= 31,		// �Ϻ�
	EM_CARD_JIANGSU			= 32,		// ����
	EM_CARD_ZHEJIANG		= 33,		// �㽭
	EM_CARD_ANHUI			= 34,		// ����
	EM_CARD_FUJIAN			= 35,		// ����
	EM_CARD_JIANGXI			= 36,		// ����
	EM_CARD_SHANDONG		= 37,		// ɽ��
	EM_CARD_HENAN			= 41,		// ����
	EM_CARD_HUBEI			= 42,		// ����
	EM_CARD_HUNAN			= 43,		// ����
	EM_CARD_GUANGDONG		= 44,		// �㶫
	EM_CARD_GUANGXI			= 45,		// ����
	EM_CARD_HAINAN			= 46,		// ����
	EM_CARD_CHONGQING		= 50,		// ����
	EM_CARD_SICHUAN			= 51,		// �Ĵ�
	EM_CARD_GUIZHOU			= 52,		// ����
	EM_CARD_YUNNAN			= 53,		// ����
	EM_CARD_XIZANG			= 54,		// ����
	EM_CARD_SHANXI_XIAN		= 61,		// ����
	EM_CARD_GANSU			= 62,		// ����
	EM_CARD_QINGHAI			= 63,		// �ຣ
	EM_CARD_NINGXIA			= 64,		// ����
	EM_CARD_XINJIANG		= 65,		// �½�
	EM_CARD_XIANGGANG		= 71,		// ���
	EM_CARD_AOMEN			= 82,		// ����
} EM_CARD_PROVINCE;

// ��������
typedef enum tagEM_CAR_TYPE
{
	EM_CAR_UNKNOWN,				// δ֪
	EM_CAR_BUS,					// �ͳ�
	EM_CAR_BIG_TRUCK,			// �����
	EM_CAR_MEDIUM_TRUCK,		// �л���
	EM_CAR_CAR,					// �γ�
	EM_CAR_VAN,					// �����
	EM_CAR_SMALL_TRUCK,			// С����
	EM_CAR_TRICYCLE,			// ���ֳ�
	EM_CAR_MOTORCYCLE,			// Ħ�г�
	EM_CAR_PEDESTRIAN,			// ����
	EM_CAR_SUVMPV,				// SUV-MPV
	EM_CAR_MEDIUM_BUS,			// �пͳ�
	EM_CAR_DANGE_VEHICLE,		// Σ��Ʒ����
} EM_CAR_TYPE;

// ��������
typedef enum tagEM_PLATE_TYPE
{
	EM_PLATE_UNKNOWN,				// δ֪
	EM_PLATE_BIGCAR,				// �����������Ƶ׺��֣�
	EM_PLATE_SMALLCAR,				// С�����������װ��֣�
	EM_PLATE_EMBASSYCAR,			// ʹ���������ڵװ��֡���'ʹ'�֣�
	EM_PLATE_CONSULATECAR,			// ����������ڵװ��֣���'��'�֣�
	EM_PLATE_ABROADCAR,				// �����������ڵװ�/���֣�
	EM_PLATE_FOREIGNCAR,			// �⼮�������ڵװ��֣�
	EM_PLATE_POLICE,				// ����
	EM_PLATE_ARMEDPOLICE,			// �侯��
	EM_PLATE_TROOPS,				// ���Ӻ���
	EM_PLATE_TROOPSDOUBLE,			// ����˫��	
	EM_PLATE_YELLOWTAILDOUBLE,		// ˫���β��	
	EM_PLATE_COACHCAR,				// ����������
	EM_PLATE_PERSONALITY,			// ���Ժ���
	EM_PLATE_AGRICULTURAL,			// ũ����
	EM_PLATE_MOTORCYCLE,			// Ħ�г�����
	EM_PLATE_TRACTOR,				// ����������
	EM_PLATE_SMALLCAR_BLACK,		// С������(�ڵװ���)
	EM_PLATE_RED,					// ���Ƴ�
	EM_PLATE_BLUE,					// ���Ƴ�
	EM_PLATE_WHITE,					// ���Ƴ�
	EM_PLATE_PURE_NEW_SMALLCAR,		// ���綯����ԴС��
	EM_PLATE_BLEND_NEW_SMALLCAR,	// �������ԴС�� 
	EM_PLATE_PURE_NEW_BIGCAR,		// ���綯����Դ��
	EM_PLATE_BLEND_NEW_BIGCAR,		// �������Դ��
} EM_PLATE_TYPE;

// ������ɫ
typedef enum tagEM_CAR_COLOR_TYPE
{
	EM_CAR_COLOR_WHITE,				// ��ɫ
	EM_CAR_COLOR_BLACK,				// ��ɫ
	EM_CAR_COLOR_RED,				// ��ɫ
	EM_CAR_COLOR_YELLOW,			// ��ɫ
	EM_CAR_COLOR_GRAY,				// ��ɫ
	EM_CAR_COLOR_BLUE,				// ��ɫ
	EM_CAR_COLOR_GREEN,				// ��ɫ
	EM_CAR_COLOR_PINK,				// ��ɫ
	EM_CAR_COLOR_PURPLE,			// ��ɫ
	EM_CAR_COLOR_DARK_PURPLE,		// ����ɫ
	EM_CAR_COLOR_BROWN,				// ��ɫ
	EM_CAR_COLOR_MAROON,			// ��ɫ
	EM_CAR_COLOR_SILVER_GRAY,		// ����ɫ
	EM_CAR_COLOR_DARK_GRAY,			// ����ɫ
	EM_CAR_COLOR_WHITE_SMOKE,		// ����ɫ
	EM_CAR_COLOR_DEEP_ORANGE,		// ���ɫ
	EM_CAR_COLOR_LIGHT_ROSE,		// ǳõ��ɫ
	EM_CAR_COLOR_TOMATO_RED,		// ���Ѻ�ɫ
	EM_CAR_COLOR_OLIVE,				// ���ɫ
	EM_CAR_COLOR_GOLDEN,			// ��ɫ
	EM_CAR_COLOR_DARK_OLIVE,		// �����ɫ
	EM_CAR_COLOR_YELLOW_GREEN,		// ����ɫ
	EM_CAR_COLOR_GREEN_YELLOW,		// �̻�ɫ
	EM_CAR_COLOR_FOREST_GREEN,		// ɭ����
	EM_CAR_COLOR_OCEAN_BLUE,		// ������
	EM_CAR_COLOR_DEEP_SKYBLUE,		// ������	
	EM_CAR_COLOR_CYAN,				// ��ɫ
	EM_CAR_COLOR_DEEP_BLUE,			// ����ɫ
	EM_CAR_COLOR_DEEP_RED,			// ���ɫ
	EM_CAR_COLOR_DEEP_GREEN,		// ����ɫ
	EM_CAR_COLOR_DEEP_YELLOW,		// ���ɫ
	EM_CAR_COLOR_DEEP_PINK,			// ���ɫ
	EM_CAR_COLOR_DEEP_PURPLE,		// ����ɫ
	EM_CAR_COLOR_DEEP_BROWN,		// ����ɫ
	EM_CAR_COLOR_DEEP_CYAN,			// ����ɫ
	EM_CAR_COLOR_ORANGE,			// ��ɫ
	EM_CAR_COLOR_DEEP_GOLDEN,		// ���ɫ
	EM_CAR_COLOR_OTHER	= 255,		// δʶ������
} EM_CAR_COLOR_TYPE;

// ʹ������
typedef enum tagEM_USE_PROPERTY_TYPE
{
	EM_USE_PROPERTY_OTHER,					// ����
	EM_USE_PROPERTY_NOTOPERATING,			// ��Ӫ��
	EM_USE_PROPERTY_HIGWAY,					// ��·����
	EM_USE_PROPERTY_BUS,					// ��������
	EM_USE_PROPERTY_TAXI,					// �������
	EM_USE_PROPERTY_TOURISM,				// ���ο���
	EM_USE_PROPERTY_FREIGHT,				// ����
	EM_USE_PROPERTY_LEASE,					// ����
	EM_USE_PROPERTY_POLICE,					// ����
	EM_USE_PROPERTY_FIRE,					// ����
	EM_USE_PROPERTY_RESCUE,					// �Ȼ�
	EM_USE_PROPERTY_ENGINEERING,			// ���̾���
	EM_USE_PROPERTY_OPERATION_TO_NOT,		// Ӫת��
	EM_USE_PROPERTY_TAXI_TO_NOT,			// ����ת��
	EM_USE_PROPERTY_COACH,					// ����
	EM_USE_PROPERTY_KINDER_SCHOOLBUS,		// �׶�У��
	EM_USE_PROPERTY_PUPIL_SCHOOLBUS,		// Сѧ��У��
	EM_USE_PROPERTY_OTHER_SCHOOLBUS,		// ����У��
	EM_USE_PROPERTY_FOR_DANGE_VEHICLE,		// Σ��Ʒ����
} EM_USE_PROPERTY_TYPE;

// RFID ���ӳ��Ʊ�ǩ��Ϣ
typedef struct tagNET_RFIDELETAG_INFO
{
	BYTE					szCardID[MAX_RFIDELETAG_CARDID_LEN];			// ����
	int						nCardType;										// ��������, 0:��ͨ������ط��п�, 1:�³�����Ԥװ��
	EM_CARD_PROVINCE		emCardPrivince;									// ����ʡ��
	char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];			// ���ƺ���
	char					szProductionDate[MAX_RFIDELETAG_DATE_LEN];		// ��������
	EM_CAR_TYPE				emCarType;										// ��������
	int						nPower;											// ����,��λ��ǧ��ʱ������ֵ��Χ0~254��255��ʾ�ó����ʴ��ڿɴ洢�������ֵ
	int						nDisplacement;									// ����,��λ���ٺ���������ֵ��Χ0~254��255��ʾ�ó��������ڿɴ洢���������ֵ
	int						nAntennaID;										// ����ID��ȡֵ��Χ:1~4
	EM_PLATE_TYPE			emPlateType;									// ��������
	char					szInspectionValidity[MAX_RFIDELETAG_DATE_LEN];	// ������Ч�ڣ���-��
	int						nInspectionFlag;								// ����δ����־, 0:�����, 1:����δ���
	int						nMandatoryRetirement;							// ǿ�Ʊ����ڣ��Ӽ�����Ч�ڿ�ʼ������ǿ�Ʊ����ڵ�����
	EM_CAR_COLOR_TYPE		emCarColor;										// ������ɫ
	int						nApprovedCapacity;								// �˶��ؿ�������ֵ<0ʱ����Ч����ֵ��ʾ�˶��ؿͣ���λΪ��
	int						nApprovedTotalQuality;							// ��ֵ��ʾ����������λΪ��ǧ�ˣ���ֵ<0ʱ����Ч����ֵ����Ч��ΧΪ0~0x3FF��0x3FF��1023����ʾ����ֵ�����˿ɴ洢�����ֵ
	NET_TIME_EX				stuThroughTime;									// ����ʱ��
	EM_USE_PROPERTY_TYPE	emUseProperty;									// ʹ������
	char					szPlateCode[MAX_COMMON_STRING_8];				// ���ƴ��ţ�UTF-8����
	char					szPlateSN[MAX_COMMON_STRING_16];				// ���ƺ�����ţ�UTF-8����
	BYTE               		bReserved[104];		                      		// �����ֽ�,�����չ.
} NET_RFIDELETAG_INFO;

// ���ӳ��Ƽ�¼��Ϣ
typedef struct tagNET_RECORD_ELECTRONICSTAG_INFO
{
	DWORD					dwSize;
	int						nRecNo;							// ��¼�����,ֻ��
	BOOL					bMatch;							// �Ƿ���ƥ��ͼƬ
	UINT					unDevID;						// ��д����ţ���0��ʼ
	NET_RFIDELETAG_INFO		stuEleTagInfo;					// ���ӳ��Ʊ�ǩ��Ϣ
} NET_RECORD_ELECTRONICSTAG_INFO;

// GPSλ�ü�¼����Ϣ
typedef struct tagNET_RECORD_GPS_LOCATION_INFO
{
    DWORD           dwSize;                                 // �ṹ���С
    int             nRecNo;                                 // ��¼�����,ֻ��
    double          dLongitude;                             // GPS���꾭��ֵ, ��λ��
    double          dLatitude;                              // GPS����γ��ֵ, ��λ��
    char            szPlaceName[128];                       // GPS�����Ӧ�ĵ���
    char            szRadius[16];                           // �뾶
} NET_RECORD_GPS_LOCATION_INFO;

// ���ⷿ�⻧��¼����Ϣ
typedef struct tagNET_RECORD_RESIDENT_INFO
{
    DWORD           dwSize;                                 // �ṹ���С
    int             nRecNo;                                 // ��¼�����,ֻ��
    char            szResidentName[DH_MAX_USERID_LEN];      // �û�����
    char            szCardNo[DH_MAX_CARDNO_LEN];            // ����
    NET_TIME        stuStartTime;                           // ��Ч�ڿ�ʼʱ��
    NET_TIME        stuEndTime;                             // ��Ч�ڽ�ֹʱ��
    char 			szICNum[DH_MAX_IC_LEN];					// ���֤
}NET_RECORD_RESIDENT_INFO;

// ��������ݼ�¼��Ϣ
typedef struct tagNET_RECORD_SENSOR_RECORD
{
	DWORD						dwSize;                                 // �ṹ���С
	UINT						uRecNo;                                 // ��¼�����,ֻ��
	NET_TIME					stuTime;								// �ɼ�ʱ��, �ֶ�Ϊ"time" 
	UINT						uDeviceID;                              // �ɼ��豸ID��, ��8λ��ʾ�Ǳ����ͣ���24λ��ʾ�Ǳ�������š��Ǳ��������£�0-������ 1-ģ�⴫������
	BYTE						byStatus;                               // ����״̬, 0:����,1:�쳣
	BYTE						byExceptionCode;                        // �쳣����״̬���룬������Ǳ������Status =1ʱ��Ч��
	// ���豸����Ϊ����ʱ������Ϊ:Bit0-Ƿѹ,Bit1-��ѹ,Bit2-Ƿ��,Bit3-����,Bit4-״̬��Ч����״̬��������ͬʱ��λ
	BYTE						bySwitchOn;								// ������,0���أ�1:��
	BYTE						byReserved;                             // �����ֽ�
	int							nPowerVoltage;                          // ��ѹ,��λ��mV
	int							nPowerCurrent;                          // ����,��λ��mA
	int							nPowerValue;							// ����,��λ��mW
	BYTE						byReservedSpace[4];                     // �����ֽ�							
	double						dActualValue;							// ģ����ʹ�á�����ֵ�������ģ�����Ǳ����
	char			            szName[128];							// �Ǳ�����
	NET_SENSE_METHOD			emSenseMethod;						    // SenseMethod, ��Ӧ��ʽ,�μ�����ö�ٶ���
	EM_SENSE_METHOD_UNIT		emUnit;							        // ��λ, ���嵥λ��emSenseMethod�����й�
} NET_RECORD_SENSOR_RECORD;

//���Ŷ�ά���¼����Ϣ
typedef struct tagNET_RECORD_ACCESSQRCODE_INFO
{
	DWORD                       dwSize;                                 // �ṹ���С
	int                         nRecNo;                                 // ��¼�����,ֻ��
	char						szQRCode[DH_MAX_QRCODE_LEN];            // ��ά��
	UINT						nLeftTimes;                             // ʣ�����Ч����
	NET_TIME        			stuStartTime;                           // ��Ч�ڿ�ʼʱ��
    NET_TIME        			stuEndTime;                             // ��Ч�ڽ�ֹʱ��
}NET_RECORD_ACCESSQRCODE_INFO;

//�������ż�¼����Ϣ
typedef struct tagNET_RECORD_ACCESS_BLUETOOTH_INFO
{
    DWORD                       dwSize;                                 // �ṹ���С
    int                         nRecNo;                                 // ��¼�����,ֻ��
    char						szUserName[DH_COMMON_STRING_128];       // �û���
    char						szPassword[DH_COMMON_STRING_128];       // ����
    char        			    szMac[DH_COMMON_STRING_32];             // mac��ַ
    char        			    szNote[DH_COMMON_STRING_128];           // �û���ע��Ϣ
}NET_RECORD_ACCESS_BLUETOOTH_INFO;

// �������ż�¼����Ϣ��ѯ����
typedef struct tagFIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION
{
    DWORD					dwSize;
    char					szUserName[DH_COMMON_STRING_128];       // �û���
} FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION;


// �������
typedef enum tagEM_VIDEO_TALK_LOG_CALLTYPE
{
    EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0,         // δ֪
    EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING,            // ����
    EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING,            // ���
    EM_VIDEO_TALK_LOG_CALLTYPE_MAX,                 //
}EM_VIDEO_TALK_LOG_CALLTYPE;

// ����״̬
typedef enum tagEM_VIDEO_TALK_LOG_ENDSTATE
{
    EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0,         // δ֪
    EM_VIDEO_TALK_LOG_ENDSTATE_MISSED,              // δ��
    EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED,            // �ѽ�
    EM_VIDEO_TALK_LOG_ENDSTATE_MAX,                 //
}EM_VIDEO_TALK_LOG_ENDSTATE;

// �Է�����
typedef enum tagEM_VIDEO_TALK_LOG_PEERTYPE
{
    EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0,         // δ֪
    EM_VIDEO_TALK_LOG_PEERTYPE_VTO,                 // �ſڻ�
    EM_VIDEO_TALK_LOG_PEERTYPE_VTH,                 // ���ڻ�
    EM_VIDEO_TALK_LOG_PEERTYPE_VTS,                 // ��������
}EM_VIDEO_TALK_LOG_PEERTYPE;


//��¼�Ƿ��Ѿ����
typedef enum tagNET_RECORD_READFLAG
{
	NET_RECORD_READFLAG_UNREADED = 0, //δ��
	NET_RECORD_READFLAG_READED,	    //�Ѷ�
	NET_RECORD_READFLAG_UNKNOWN,      //δ֪
}NET_RECORD_READFLAG;

// ͨ����¼��¼����Ϣ
typedef struct tagNET_RECORD_VIDEO_TALK_LOG
{
    DWORD                           dwSize;
    int                             nRecNo;                             // ��¼�����,ֻ��
    NET_TIME                        stuCreateTime;                      // ��ʼʱ��
    EM_VIDEO_TALK_LOG_CALLTYPE      emCallType;                         // �������
    EM_VIDEO_TALK_LOG_ENDSTATE      emEndState;                         // ����״̬
    char                            szPeerNumber[DH_COMMON_STRING_64];  // �Է����� �����Ƕ̺�,�кŻ򳤺�
    EM_VIDEO_TALK_LOG_PEERTYPE      emPeerType;                         // �Է�����
    char                            szLocalNumber[DH_COMMON_STRING_64]; // �������� �����Ƕ̺�,�кŻ򳤺�
    int                             nTalkTime;                          // ͨ��ʱ�� ��λ��
    int                             nMessageTime;                       // ����ʱ�� ��λ��
    char                            szPicturePath[DH_COMMON_STRING_128];// 
}NET_RECORD_VIDEO_TALK_LOG;

// ����Խ�״̬
typedef enum tagEM_REGISTER_USER_STATE
{
    EM_REGISTER_USER_STATE_UNKNOWN = 0,         // δ֪
    EM_REGISTER_USER_STATE_IDLE,                // ��ʼ״̬
    EM_REGISTER_USER_STATE_CALLING,             // ���״̬���Է�δ��Ӧ��
    EM_REGISTER_USER_STATE_RINGING,             // ����״̬���Է���Ӧ,��û�н�����
    EM_REGISTER_USER_STATE_PREVIEWING,          // ����Ԥ��
    EM_REGISTER_USER_STATE_LEAVINGMESSAGE,      // ��������
    EM_REGISTER_USER_STATE_TALKING,             // ͨ����
    EM_REGISTER_USER_STATE_MAX,                 //
}EM_REGISTER_USER_STATE;

// �豸����
typedef enum tagEM_REGISTER_USER_STATE_DEV_TYPE
{
    EM_REGISTER_USER_STATE_DEV_TYPE_UNKNOWN = 0,            // δ֪
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTH,              // ����VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTH,             // ģ��VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTO,              // ����VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTO,             // ģ��VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_MAX,                    //
}EM_REGISTER_USER_STATE_DEV_TYPE;

// �Ƿ�֧����
typedef enum tagEM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE
{
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_UNKNOWN = 0,                // δ֪
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_SUPPORTLOCK,                // ֧��
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_NOT_SUPPORTLOCK,            // ��֧��
}EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE;

typedef enum tagNET_MONITORSTATE_TYPE
{
	NET_MONITORSTATE_TYPE_UNMONITORED = 0,		// 0 δ���ӣ���ʼ״̬��
	NET_MONITORSTATE_TYPE_MONITORREQUEST,		// 1 �յ���������
	NET_MONITORSTATE_TYPE_MONITORED,			// 2 ������״̬
	NET_MONITORSTATE_TYPE_UNKNOWN,				// δ֪״̬
}NET_MONITORSTATE_TYPE;


// ״̬��¼��¼����Ϣ
typedef struct tagNET_RECORD_REGISTER_USER_STATE
{
    DWORD                                   dwSize;
    int                                     nRecNo;                             // ��¼�����,ֻ��
    NET_TIME                                stuCreateTime;                      // ����ʱ��
    char                                    szUserID[DH_MAX_USERID_LEN];       // �û�ID
    BOOL                                    bOnline;                            // �Ƿ�����
    char                                    szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];     // �����ַ
    int                                     nPort;                              // �˿ں�
    EM_REGISTER_USER_STATE                  emVideoTalkState;                   // ����Խ�״̬
    NET_TIME                                stuOnlineTime;                      // ����ʱ��
    NET_TIME                                stuOfflineTime;                     // ����ʱ��
    EM_REGISTER_USER_STATE_DEV_TYPE         emDevType;                          // �豸����
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE emSupportLock;                      // �Ƿ�֧����
	NET_MONITORSTATE_TYPE					emMonitorState;						// ����״̬
}NET_RECORD_REGISTER_USER_STATE;

// ���ӶԽ�ģ�����ڻ�����ʱ��ģʽ
typedef enum tagEM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE
{
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_UNKNOWN,              // δ֪
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEADDRESS,         // ͨ��SlaveAddress
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEID_SLAVEPORT,    // ͨ��SlaveID+SlavePort
}EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE;

// �û�����
typedef enum tagEM_VIDEO_TALK_CONTACT_TYPE
{
    EM_VIDEO_TALK_CONTACT_TYPE_UNKNOWN,             // δ֪
    EM_VIDEO_TALK_CONTACT_TYPE_VTH,                 // "VTH" ���ڻ�
    EM_VIDEO_TALK_CONTACT_TYPE_VTO,                 // "VTO" �ſڻ�
}EM_VIDEO_TALK_CONTACT_TYPE;

// ע�᷽ʽ
typedef enum tagEM_VIDEO_TALK_CONTACT_REGISTER_TYPE
{
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_UNKNOWN,                // δ֪
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_PUBLIC,                 // "public"
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_LOCAL,                  // "local"
}EM_VIDEO_TALK_CONTACT_REGISTER_TYPE;

// ��ϵ�˼�¼��¼����Ϣ
typedef struct tagNET_RECORD_VIDEO_TALK_CONTACT
{
    DWORD                                   dwSize;
    int                                     nRecNo;                                 // ��¼�����,ֻ��
    NET_TIME                                stuCreateTime;                          // ����ʱ��
    char                                    szFirstName[DH_COMMON_STRING_32];       // ����
    char                                    szFamilyName[DH_COMMON_STRING_32];      // ��
    char                                    szVTShortNumber[DH_COMMON_STRING_16];   // ���ӶԽ��̺�
    char                                    szVTMiddleNumber[DH_COMMON_STRING_32];  // ���ӶԽ��к�
    char                                    szVTLongNumber[DH_COMMON_STRING_64];    // ���ӶԽ�����,��VTHģ�����ڻ������к�
    char                                    szVTNetAddress[DH_MAX_IPADDR_LEN_EX];   // ���ӶԽ������ַ
    char                                    szVTOPosition[DH_COMMON_STRING_64];     // ���ڻ��������ſڻ�λ��
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE   emVTSlaveBindMode;                      // ���ӶԽ�ģ�����ڻ�����ʱ��ģʽ
    char                                    szVTSlaveId[DH_COMMON_STRING_32];       // ���ֶ��ѷ���,ʹ�� nVTSlaveId
    char                                    szVTSlavePort[DH_COMMON_STRING_32];     // ���ֶ��ѷ���,ʹ�� nVTSlavePort
    char                                    szVTSlaveAddress[DH_COMMON_STRING_64];  // ���ӶԽ�ģ�����ڻ��ĵ�ַ
    char                                    szNickname[DH_COMMON_STRING_64];        // �ǳ�
    char                                    szNotes[DH_COMMON_STRING_64];           // ��ע
    EM_VIDEO_TALK_CONTACT_TYPE              emType;                                 // �û�����
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE     emRegisterType;                         // ע�᷽ʽ
    char                                    szVTHPassword[DH_COMMON_STRING_64];     // ע������
    char                                    szVTOBuilding[DH_COMMON_STRING_64];     // �����
    char                                    szVTOUnit[DH_COMMON_STRING_64];         // ����Ԫ��
    char                                    szGroupNumber[DH_COMMON_STRING_64];     // ����Ⱥ��
    int                                     nVTSlaveId;                             // ���ӶԽ�ģ�����ڻ�����ʱ�ķ�������ַ
    int                                     nVTSlavePort;                           // ���ӶԽ�ģ�����ڻ�����ʱ�ķ������˿�
}NET_RECORD_VIDEO_TALK_CONTACT;

//�����״̬
typedef enum tagNET_ANNOUNCE_STATE
{
	NET_ANNOUNCE_STATE_UNSENDED = 0, //��ʼ״̬(δ����)
	NET_ANNOUNCE_STATE_SENDED,		//�Ѿ�����
	NET_ANNOUNCE_STATE_EXPIRED,		//�Ѿ�����
	NET_ANNOUNCE_STATE_UNKNOWN,		//δ֪
}NET_ANNOUNCE_STATE;

//�����Ƿ��Ѿ����
typedef enum tagNET_ANNOUNCE_READFLAG
{
	NET_ANNOUNCE_READFLAG_UNREADED = 0, //δ��
	NET_ANNOUNCE_READFLAG_READED,	    //�Ѷ�
	NET_ANNOUNCE_READFLAG_UNKNOWN,      //δ֪
}NET_ANNOUNCE_READFLAG;

//�����¼��Ϣ
typedef struct tagNET_RECORD_ANNOUNCEMENT_INFO
{
	DWORD									dwSize;									
	int										nRecNo;									// ��¼�����,ֻ��
	NET_TIME                                stuCreateTime;                          // ����ʱ��
	NET_TIME								stuIssueTime;							// ���淢��ʱ��
	char									szAnnounceTitle[DH_COMMON_STRING_64];	// �������
	char									szAnnounceContent[DH_COMMON_STRING_256];	//��������
	char									szAnnounceDoor[DH_COMMON_STRING_16];	//����Ҫ���͵ķ����
	NET_TIME								stuExpireTime;							//������ڵ�ʱ��
	NET_ANNOUNCE_STATE						emAnnounceState;						//�����״̬
	NET_ANNOUNCE_READFLAG					emAnnounceReadFlag;						//�����Ƿ��Ѿ����
}NET_RECORD_ANNOUNCEMENT_INFO;


// �����¼��Ϣ��ѯ����
typedef struct tagFIND_RECORD_ANNOUNCEMENT_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // ����ʱ��β�ѯ
	NET_TIME                  stStartTime;                      // ��ʼʱ��
	NET_TIME                  stEndTime;                        // ����ʱ��
}FIND_RECORD_ANNOUNCEMENT_CONDITION;


//������¼��Ϣ
typedef struct tagNET_RECORD_ALARMRECORD_INFO
{
	DWORD									dwSize;
	int										nRecNo;									// ��¼�����,ֻ��
	NET_TIME                                stuCreateTime;							// ����ʱ��,UTC����,ֻ��
	int										nChannelID;								//����ͨ����
	NET_SENSE_METHOD						emSenseMethod;							// ��������Ӧ��ʽ
	char									szRoomNumber[DH_MAX_DOOR_NUM];			// ��������� 
	NET_ANNOUNCE_READFLAG					emReadFlag;								//0δ����1�Ѷ�
}NET_RECORD_ALARMRECORD_INFO;

//������¼��Ϣ��ѯ����
typedef struct tagFIND_RECORD_ALARMRECORD_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // ����ʱ��β�ѯ
	NET_TIME                  stStartTime;                      // ��ʼʱ��
	NET_TIME                  stEndTime;                        // ����ʱ��
}FIND_RECORD_ALARMRECORD_CONDITION;


// �Ž�δ���¼���ϸ��Ϣ
typedef struct tagALARM_ACCESS_CTL_NOT_CLOSE_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // ��ͨ����
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // �Ž�����
    NET_TIME        stuTime;                                // �����¼�������ʱ��
    int             nAction;                                // 0:��ʼ 1:ֹͣ    
    UINT 		    nEventID;				                //�¼�ID
}ALARM_ACCESS_CTL_NOT_CLOSE_INFO;

// �����¼���ϸ��Ϣ
typedef struct tagALARM_ACCESS_CTL_BREAK_IN_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // ��ͨ����
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // �Ž�����
    NET_TIME        stuTime;                                // �����¼�������ʱ��    
    UINT 			nEventID;				                //�¼�ID
}ALARM_ACCESS_CTL_BREAK_IN_INFO;


// ���������¼���ϸ��Ϣ
typedef struct tagALARM_ACCESS_CTL_REPEAT_ENTER_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // ��ͨ����
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // �Ž�����
    NET_TIME        stuTime;                                // �����¼�������ʱ��
    char            szCardNo[DH_MAX_CARDNO_LEN];            // ����    
    UINT 			nEventID;				                //�¼�ID
}ALARM_ACCESS_CTL_REPEAT_ENTER_INFO;


// в�ȿ�ˢ���¼���ϸ��Ϣ
typedef struct tagALARM_ACCESS_CTL_DURESS_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // ��ͨ����
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // �Ž�����
    char            szCardNo[DH_MAX_CARDNO_LEN];            // в�ȿ���
    NET_TIME        stuTime;                                // �����¼�������ʱ��    
    UINT 			nEventID;				                //�¼�ID
}ALARM_ACCESS_CTL_DURESS_INFO;


// �Ž��¼�����
typedef enum tagNET_ACCESS_CTL_EVENT_TYPE
{
    NET_ACCESS_CTL_EVENT_UNKNOWN = 0,
    NET_ACCESS_CTL_EVENT_ENTRY,                             // ����
    NET_ACCESS_CTL_EVENT_EXIT,                              // ����
}NET_ACCESS_CTL_EVENT_TYPE;

// �Ž��¼�
typedef struct tagALARM_ACCESS_CTL_EVENT_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                              // ��ͨ����
    char                        szDoorName[DH_MAX_DOORNAME_LEN];    // �Ž�����
    NET_TIME                    stuTime;                            // �����¼�������ʱ��
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // �Ž��¼�����
    BOOL                        bStatus;                            // ˢ�����,TRUE��ʾ�ɹ�,FALSE��ʾʧ��
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // ������
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // ���ŷ�ʽ
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // ����
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // ����
    char                        szReaderID[DH_COMMON_STRING_32];    // �Ŷ�����ID
    char                        szUserID[DH_COMMON_STRING_64];      // �����û�
    char                        szSnapURL[DH_COMMON_STRING_256];    // ץ����Ƭ�洢��ַ
    int                         nErrorCode;                         // ����ʧ�ܵ�ԭ��,����bStatusΪFALSEʱ��Ч
                                                                    // 0x00 û�д���
                                                                    // 0x10 δ��Ȩ
                                                                    // 0x11 ����ʧ��ע��
                                                                    // 0x12 û�и���Ȩ��
                                                                    // 0x13 ����ģʽ����
                                                                    // 0x14 ��Ч�ڴ���
                                                                    // 0x15 ����Ǳģʽ
                                                                    // 0x16 в�ȱ���δ��
                                                                    // 0x17 �ų���״̬
                                                                    // 0x18 AB����״̬
                                                                    // 0x19 Ѳ�߿�
                                                                    // 0x1A �豸���ڴ��뱨��״̬
                                                                    // 0x20 ʱ��δ���
                                                                    // 0x21 �����ڿ���ʱ��δ���
                                                                    // 0x30 ��Ҫ����֤���׿�Ȩ�޵Ŀ�Ƭ
                                                                    // 0x40 ��Ƭ��ȷ,�����������
                                                                    // 0x41 ��Ƭ��ȷ,�������볬ʱ
                                                                    // 0x42 ��Ƭ��ȷ,����ָ�ƴ���
                                                                    // 0x43 ��Ƭ��ȷ,����ָ�Ƴ�ʱ
                                                                    // 0x44 ָ����ȷ,�����������
                                                                    // 0x45 ָ����ȷ,�������볬ʱ
                                                                    // 0x50 ��Ͽ���˳�����
                                                                    // 0x51 ��Ͽ�����Ҫ������֤
                                                                    // 0x60 ��֤ͨ��,����̨δ��Ȩ
    int                         nPunchingRecNo;                     // ˢ����¼���еļ�¼���
	int							nNumbers;							// ץͼ����
    NET_ACCESSCTLCARD_STATE     emStatus;		                    // ��״̬                         
}ALARM_ACCESS_CTL_EVENT_INFO;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_UNKNOWN,        // δ֪
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_SUPERMARKET,    // ����
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_RESTAURANT,     // ����
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_FRUITSTORE,     // ˮ����
}EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_UNKNOWN,        // δ֪
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_YES,            // �ؼ�
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_NO,             // �����ؼ�
}EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE;

// �·���Ʒ��¼��¼����Ϣ
typedef struct tagNET_RECORD_COMMODITY_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // ��¼�����,ֻ��
    NET_TIME                                        stuSaleTime;                            // ��Ʒ�ϼ�ʱ��
    char                                            szName[DH_COMMON_STRING_128];           // ��Ʒ����
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE      emSource;                               // ��Ʒ����
    char                                            szURL[DH_COMMON_STRING_256];            // ��ƷͼƬ·��, ftp ·��
    float                                           fPrice;                                 // ��Ʒ�۸�, ��λ��Ԫ float
    char                                            szID[DH_COMMON_STRING_64];              // ID��,��ƽ̨ͳһ����	һ�ֻ�Ʒ��Ψһ��ID��ʶ
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE     emBargain;                              // �Ƿ��ؼ���Ʒ
}NET_RECORD_COMMODITY_NOTICE;


typedef enum tagEM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE
{
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_UNKNOWN,           // δ֪
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_DIGEST,            // ������
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_STOMATOLOGY,       // ��ǻ��
}EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE;

// ������Ϣ��¼��¼����Ϣ
typedef struct tagNET_RECORD_HEALTH_CARE_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // ��¼�����,ֻ��
    NET_TIME                                        stuStartTime;                           // �ϰ�ʱ��
    NET_TIME                                        stuEndTime;                             // �°�ʱ��
    char                                            szHospital[DH_COMMON_STRING_128];       // ����ҽԺ
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE    emOffice;                               // ����
    char                                            szOfficeNumber[DH_COMMON_STRING_64];    // ���Һ�
    char                                            szDoctorName[DH_COMMON_STRING_128];     // ҽ������
    char                                            szID[DH_COMMON_STRING_64];              // ID��,��ƽ̨ͳһ����	һ�ֻ�Ʒ��Ψһ��ID��ʶ
}NET_RECORD_HEALTH_CARE_NOTICE;

///////////////////////// ���ܽ�ͨ�����¼�[CLIENT_StartListenEx] /////////////////////////////////////

//�¼����� DH_IVS_TRAFFIC_REALFLOWINFO(��ͨʵʱ������Ϣ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_IVS_TRAFFIC_REALFLOW_INFO
{
    int                 nChannelID;                     // ͨ����
    char                szName[128];                    // �¼�����
    char                bReserved1[4];                  // �ֽڶ���
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    unsigned int        nSequence;                      // ���
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[3];
    int                 nLane;                          // ��Ӧ������
    int                 nCount;                         // ��������
    int                 nSpeed;                         // ����,km/h
    int                 nOverPercent;                   // ƽ�����ٰٷֱ�
    int                 nMetersUints;                   // �ٶȵ�λ,0������,1��Ӣ��
    BYTE                bReserved[1024];                // �����ֽ�,�����չ.
}ALARM_IVS_TRAFFIC_REALFLOW_INFO;

//�¼����� DH_YUEQINGLIGHTING_STATE_EVENT(ƽ̨ͳ�Ƶƹ⿪�ص�ʱ���¼�)��Ӧ�����ݿ�������Ϣ 
typedef struct tagDEV_YUEQINGLIGHTING_STATE_INFO
{
	DWORD               dwAction;                       // �¼�����, 0:��ʼ, 1:����
	int                 nChannelID;                     // ͨ����
	NET_TIME_EX         UTC;							// �¼�������ʱ�� 
	BYTE                bReserved[1024];                // �����ֽ�,�����չ.
}DEV_YUEQINGLIGHTING_STATE_INFO;

// �����¼����� DH_ALARM_VEHICLE_TURNOVER(�����෭�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VEHICEL_TURNOVER_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS��Ϣ
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved[1023];                // �����ֽ�,�����չ.
}ALARM_VEHICEL_TURNOVER_EVENT_INFO;

// �����¼�����DH_ALARM_VEHICLE_COLLISION(����ײ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VEHICEL_COLLISION_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS��Ϣ
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved[1023];                // �����ֽ�,�����չ.
}ALARM_VEHICEL_COLLISION_EVENT_INFO;

// �����¼�����DH_ALARM_VEHICLE_CONFIRM(�����ϴ���Ϣ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VEHICEL_CONFIRM_INFO
{
    DWORD               dwStructSize;                   // �ṹ���С
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS��Ϣ
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byRserved[3];                   // ����
    char                szInfo[128];                    // �ϴ�����������Ϣ
}ALARM_VEHICEL_CONFIRM_INFO;

//�¼�����DH_EVENT_REGISTER_OFF(�����豸���������¼�)��Ӧ������������Ϣ
typedef struct tagEVENT_REGISTER_OFF_INFO
{
    DWORD               dwStructSize;                   // �ṹ���С
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS��Ϣ
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byRserved[3];                   // ����
}EVENT_REGISTER_OFF_INFO;

// �����¼�����DH_ALARM_VIDEO_TIMING(��Ƶ��ʱ����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VIDEO_TIMING
{
    DWORD               dwStructSize;                   // �ṹ���С
    DWORD               dwAction;                       // �¼�����, 0:Pause, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // ��Ƶͨ����
}ALARM_VIDEO_TIMING;

// �����¼�����DH_ALARM_VEHICLE_LARGE_ANGLE(��������ͷ��Ƕ�Ťת�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VEHICEL_LARGE_ANGLE
{
    DWORD               dwStructSize;                   // �ṹ���С
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS��Ϣ
    BYTE                bEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byRserved[3];                   // ����
    unsigned int        nSequence;                      // ���
}ALARM_VEHICEL_LARGE_ANGLE;

// �����¼�����DH_ALARM_AUDIO_ANOMALY(��Ƶ�쳣�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_AUDIO_ANOMALY
{
    DWORD               dwStructSize;                   // �ṹ���С
    DWORD               dwAction;                       // �¼�����, 0:Start, 1:Stop
    DWORD               dwChannelID;                    // ��Ƶͨ����

    int                 nDecibel;                       // ����ǿ��
    int                 nFrequency;                     // ����Ƶ��
}ALARM_AUDIO_ANOMALY;

// �����¼�����DH_ALARM_AUDIO_MUTATION(��ǿͻ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_AUDIO_MUTATION
{
    DWORD               dwStructSize;                   // �ṹ���С
    DWORD               dwAction;                       // �¼�����, 0:Start, 1:Stop
    DWORD               dwChannelID;                    // ��Ƶͨ����
}ALARM_AUDIO_MUTATION;

// �����¼����� DH_ALARM_AUDIO_DETECT (��Ƶ����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_AUDIO_DETECT
{
    DWORD               dwAction;                       // �¼�����, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // ��Ƶͨ����
    char                reserved[512];                  // ����
} ALARM_AUDIO_DETECT;

#define MAX_SENSORID_NUMBER 20                          // ������������
#define MAX_TYRE_NUM        128                         // �����̥����
// ��̥�澯��־λ��Ӧö��
typedef enum tagAlarmTyreFlag
{
    ALARM_TYRE_FLAG_NONE,                               // ����Ч����
    ALARM_TYRE_FLAG_NORMAL,                             // ����
    ALARM_TYRE_FLAG_HIGHPRESSURE,                       // ��ѹ
    ALARM_TYRE_FLAG_LOWERPRESSURE,                      // ��ѹ
    ALARM_TYRE_FLAG_HIGHTEMP,                           // ����
    ALARM_TYRE_FLAG_HIGHTEMP_HIGHPRESSURE,              // ���¡���ѹ
    ALARM_TYRE_FLAG_HIGHTEMP_LOWERPRESSURE,             // ���¡���ѹ

    ALARM_TYRE_FLAG_INVALID,                            // �Ƿ��ı�־λ����
}EM_ALARM_TYER_FALG;

// ��̥��Ϣ�ṹ
typedef struct tagTYRE_INFO_UNIT
{
    DWORD               dwStructSize;                    // �ṹ���С
    DWORD               dwSensorIDNum;                   // ����������
    DWORD               dwSensorID[MAX_SENSORID_NUMBER]; // ������ID��Ϣ
    DWORD               dwTyreNum;                       // ̥λ���
    DWORD               dwTyrePlace;                     // ��̥λ�ڵڼ���

    EM_ALARM_TYER_FALG  emAlarmFlag;                     // ��̥�澯��־λ

    int                 nTemp;                           // �¶�,��λ��
    int                 nTempLimit;                      // �¶�,��λ��

    float               fPressure;                       // ѹ��,��λKpa
    float               fUpperLimit;                     // �澯ѹ����ֵ����,��λKpa
    float               fLowerLimit;                     // �澯ѹ����ֵ����,��λKpa
    float               fVoltage;                        // ��ǰ�Ĵ�������ѹ,��λ V
}TYRE_INFO_UNIT;

// �����¼�����DH_EVENT_TYREINFO(��̥��Ϣ�ϱ��¼�)��Ӧ������������Ϣ
typedef struct tagEVENT_TYRE_INFO
{
    DWORD               dwStructSize;                   // �ṹ���С
    DWORD               dwAction;                       // �¼�����, 0:Pause, 1:Stop
    DWORD               dwTyreNum;                      // ��̥����
    TYRE_INFO_UNIT      *pstuTyre;                      // ��̥��Ϣ
}EVENT_TYRE_INFO;

/////////////////////////////����Խ���ض���/////////////////////////////

// ��Ƶ��ʽ��Ϣ
typedef struct
{
    BYTE                byFormatTag;                    // ��������,��0��PCM
    WORD                nChannels;                      // ������
    WORD                wBitsPerSample;                 // �������            
    DWORD               nSamplesPerSec;                 // ������
} DH_AUDIO_FORMAT, *LPDH_AUDIO_FORMAT;

/////////////////////////////�û�������ض���/////////////////////////////

// ֧���û�����󳤶�Ϊ8λ���豸,��ӦCLIENT_QueryUserInfo��CLIENT_OperateUserInfo�ӿ�
// Ȩ����Ϣ
typedef struct _OPR_RIGHT
{
    DWORD               dwID;
    char                name[DH_RIGHT_NAME_LENGTH];
    char                memo[DH_MEMO_LENGTH];
} OPR_RIGHT;

// �û���Ϣ
typedef struct _USER_INFO
{
    DWORD               dwID;
    DWORD               dwGroupID;
    char                name[DH_USER_NAME_LENGTH];
    char                passWord[DH_USER_PSW_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
    DWORD               dwReusable;                     // �Ƿ��ã�1������,0��������
} USER_INFO;

// �û�����Ϣ
typedef struct _USER_GROUP_INFO
{
    DWORD               dwID;
    char                name[DH_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO;

// �û���Ϣ��
typedef struct _USER_MANAGE_INFO
{
    DWORD                dwRightNum;                    // Ȩ����Ϣ
    OPR_RIGHT            rightList[DH_MAX_RIGHT_NUM];
    DWORD                dwGroupNum;                    // �û�����Ϣ
    USER_GROUP_INFO      groupList[DH_MAX_GROUP_NUM];
    DWORD                dwUserNum;                     // �û���Ϣ
    USER_INFO            userList[DH_MAX_USER_NUM];
    DWORD                dwSpecial;                     // �û�����������1��֧���û�����,0����֧���û�����
} USER_MANAGE_INFO;

// ֧���û�����󳤶�Ϊ8λ��16λ���豸,��Ӧ��չ�ӿ�CLIENT_QueryUserInfoEx��CLIENT_OperateUserInfoEx
#define DH_USER_NAME_LENGTH_EX       16                 // �û�������
#define DH_USER_PSW_LENGTH_EX        16                 // ����

// Ȩ����Ϣ
typedef struct _OPR_RIGHT_EX
{
    DWORD                dwID;
    char                 name[DH_RIGHT_NAME_LENGTH];
    char                 memo[DH_MEMO_LENGTH];
} OPR_RIGHT_EX;

// �û���Ϣ
typedef struct _USER_INFO_EX
{
    DWORD                dwID;
    DWORD                dwGroupID;
    char                 name[DH_USER_NAME_LENGTH_EX];
    char                 passWord[DH_USER_PSW_LENGTH_EX];
    DWORD                dwRightNum;
    DWORD                rights[DH_MAX_RIGHT_NUM];
    char                 memo[DH_MEMO_LENGTH];
    DWORD                dwFouctionMask;                // ����,0x00000001 - ֧���û�����
    BYTE                 byReserve[32];
} USER_INFO_EX;

// �û�����Ϣ
typedef struct _USER_GROUP_INFO_EX
{
    DWORD                dwID;
    char                 name[DH_USER_NAME_LENGTH_EX];
    DWORD                dwRightNum;
    DWORD                rights[DH_MAX_RIGHT_NUM];
    char                 memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX;

// �û���Ϣ��
typedef struct _USER_MANAGE_INFO_EX
{
    DWORD                dwRightNum;                    // Ȩ����Ϣ
    OPR_RIGHT_EX         rightList[DH_MAX_RIGHT_NUM];
    DWORD                dwGroupNum;                    // �û�����Ϣ
    USER_GROUP_INFO_EX   groupList[DH_MAX_GROUP_NUM];
    DWORD                dwUserNum;                     // �û���Ϣ
    USER_INFO_EX         userList[DH_MAX_USER_NUM];
    DWORD                dwFouctionMask;                // ���룻0x00000001 - ֧���û�����,0x00000002 - �����޸���ҪУ��
    BYTE                 byNameMaxLength;               // ֧�ֵ��û�����󳤶�
    BYTE                 byPSWMaxLength;                // ֧�ֵ�������󳤶�
    BYTE                 byReserve[254];
} USER_MANAGE_INFO_EX;

// ���֧��64ͨ�����豸,��Ӧ��չ�ӿ�CLIENT_QueryUserInfoNew��CLIENT_OperateUserInfoNew
#define DH_NEW_MAX_RIGHT_NUM        1024
#define DH_NEW_USER_NAME_LENGTH     128                 // �û�������
#define DH_NEW_USER_PSW_LENGTH      128                 // ����


// Ȩ����Ϣ
typedef struct _OPR_RIGHT_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_RIGHT_NAME_LENGTH];
    char                memo[DH_MEMO_LENGTH];
} OPR_RIGHT_NEW;

// �û���Ϣ
typedef struct _USER_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    DWORD               dwGroupID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    char                passWord[DH_NEW_USER_PSW_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
    DWORD               dwFouctionMask;                 // ����,0x00000001 - ֧���û�����
    NET_TIME            stuTime;                        // ����޸�ʱ��
    BYTE                byIsAnonymous;                  // �Ƿ����������¼, 0:����������¼, 1: ����������¼
    BYTE                byReserve[7];
} USER_INFO_NEW;

// �û�����Ϣ
typedef struct _USER_GROUP_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_USER_NAME_LENGTH_EX];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_NEW;

// �û�����Ϣ��չ,�û������ӳ�
typedef struct _USER_GROUP_INFO_EX2
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX2;

// �û���Ϣ��
typedef struct _USER_MANAGE_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwRightNum;                         // Ȩ����Ϣ
    OPR_RIGHT_NEW       rightList[DH_NEW_MAX_RIGHT_NUM];
    DWORD               dwGroupNum;                         // �û�����
    USER_GROUP_INFO_NEW groupList[DH_MAX_GROUP_NUM];        // �û�����Ϣ,�˲�������,��ʹ��groupListEx
    DWORD               dwUserNum;                          // �û���Ϣ
    USER_INFO_NEW       userList[DH_MAX_USER_NUM];
    DWORD               dwFouctionMask;                     // ���룻0x00000001 - ֧���û�����,0x00000002 - �����޸���ҪУ��
    BYTE                byNameMaxLength;                    // ֧�ֵ��û�����󳤶�
    BYTE                byPSWMaxLength;                     // ֧�ֵ�������󳤶�
    BYTE                byReserve[254];
    USER_GROUP_INFO_EX2 groupListEx[DH_MAX_GROUP_NUM];      // �û�����Ϣ��չ
} USER_MANAGE_INFO_NEW;

///////////////////////////////��ѯ��ض���///////////////////////////////

// �豸֧����������
typedef struct _DH_LANGUAGE_DEVINFO
{
    DWORD               dwLanguageNum;                      // ֧�����Ը���
    BYTE                byLanguageType[252];                // ö��ֵ,���DH_LANGUAGE_TYPE
} DH_DEV_LANGUAGE_INFO, *LPDH_DEV_LANGUAGE_INFO;

// ��ѯ�豸֧�ֵ�IPC������Ϣ
typedef struct
{
    int                 nTypeCount;                         // ֧�ֵ�IPC����
    BYTE                bSupportTypes[128];                 // ö��ֵ,���EM_IPC_TYPE
}DH_DEV_IPC_INFO;

//3G����������Ϣ
typedef struct
{
    int                 nStrategy;                          // ���²���,0-����������,1-��ʱ�����
    int                 nUplimit;                           // ��������, ����Զ�Ӧ, ������, ��λMB; ��ʱ��,��λСʱ
    int                 nUsed;                              // ��ʹ������,��λ��nUplimit��ͬ
    BYTE                bReserved[64];                      // �����ֶ�
}DH_DEV_3GFLOW_INFO;

// 3Gģ����Ϣ
typedef struct
{
    BYTE                byEthNum;                           // 3Gģ����
    BYTE                byReserved[255];                    // �����ֽ�
}DH_DEV_3GMODULE_INFO;

typedef struct
{
    DWORD               dwId;                               // ddns ������id��
    char                szState[DH_MAX_DDNS_STATE_LEN];     // ddns ״̬
    BYTE                bReserved[512];                     // �����ֶ�
}DH_DEV_DNS_INFO;
typedef struct
{
    DWORD               dwDdnsServerNum;    
    DH_DEV_DNS_INFO     stDdns[DH_MAX_DDNS_NUM];
}DH_DEV_MULTI_DDNS_INFO;

// �豸URL��Ϣ
typedef struct
{
    char               szURLInfo[512];                      //�豸URL��Ϣ, ���ַ������
    BYTE               bReserved[512];
}DH_DEV_URL_INFO;
// Ӳ����Ϣ
typedef struct
{
    DWORD               dwVolume;                           // Ӳ�̵�����, ��λMB(B��ʾ�ֽ�)
    DWORD               dwFreeSpace;                        // Ӳ�̵�ʣ��ռ�, ��λMB(B��ʾ�ֽ�)
    BYTE                dwStatus;                           // ����λ��ֵ��ʾӲ������,�����ö������EM_DISK_TYPE������λ��ֵ��ʾӲ�̵�״̬,0-����,1-�,2-���ϵȣ���DWORD����ĸ�BYTE
    BYTE                bDiskNum;                           // Ӳ�̺�
    BYTE                bSubareaNum;                        // ������
    BYTE                bSignal;                            // ��ʶ,0Ϊ���� 1ΪԶ��
} NET_DEV_DISKSTATE,*LPNET_DEV_DISKSTATE;

// �豸Ӳ����Ϣ
typedef struct _DH_HARDDISK_STATE
{
    DWORD                dwDiskNum;                         // ����
    NET_DEV_DISKSTATE    stDisks[DH_MAX_DISKNUM];           // Ӳ�̻������Ϣ
} DH_HARDDISK_STATE, *LPDH_HARDDISK_STATE;

typedef DH_HARDDISK_STATE    DH_SDCARD_STATE;             // SD��,���ݽṹͬӲ����Ϣ

// ���������Ϣ
typedef struct  
{
    DH_TALK_CODING_TYPE encodeType;                         // ��������, Ŀǰֻ����DH_TALK_PCM
    int                 nAudioBit;                          // λ��,��8��16, Ŀǰֻ����16
    DWORD               dwSampleRate;                       // ������,��8000��16000, Ŀǰֻ����16000
    int                 nPacketPeriod;                      // �������, ��λms, Ŀǰֻ����25
    char                reserved[60];
} DHDEV_TALKDECODE_INFO;

// �豸֧�ֵ�����Խ�����
typedef struct 
{
    int                     nSupportNum;                    // ����
    DHDEV_TALKDECODE_INFO   type[64];                       // ��������
    char                    reserved[64];
} DHDEV_TALKFORMAT_LIST;

// ��̨������Ϣ
#define  NAME_MAX_LEN 16
typedef struct 
{
    DWORD               dwHighMask;                 // �����������λ
    DWORD               dwLowMask;                  // �����������λ
    char                szName[NAME_MAX_LEN];       // ������Э����
    WORD                wCamAddrMin;                // ͨ����ַ����Сֵ
    WORD                wCamAddrMax;                // ͨ����ַ�����ֵ
    WORD                wMonAddrMin;                // ���ӵ�ַ����Сֵ
    WORD                wMonAddrMax;                // ���ӵ�ַ�����ֵ
    BYTE                bPresetMin;                 // Ԥ�õ����Сֵ
    BYTE                bPresetMax;                 // Ԥ�õ�����ֵ
    BYTE                bTourMin;                   // �Զ�Ѳ����·����Сֵ
    BYTE                bTourMax;                   // �Զ�Ѳ����·�����ֵ
    BYTE                bPatternMin;                // �켣��·����Сֵ
    BYTE                bPatternMax;                // �켣��·�����ֵ
    BYTE                bTileSpeedMin;              // ��ֱ�ٶȵ���Сֵ
    BYTE                bTileSpeedMax;              // ��ֱ�ٶȵ����ֵ
    BYTE                bPanSpeedMin;               // ˮƽ�ٶȵ���Сֵ
    BYTE                bPanSpeedMax;               // ˮƽ�ٶȵ����ֵ
    BYTE                bAuxMin;                    // �������ܵ���Сֵ
    BYTE                bAuxMax;                    // �������ܵ����ֵ
    int                 nInternal;                  // ���������ʱ����
    char                cType;                      // Э�������
    BYTE                bReserved_1;                // ����
    BYTE                bFuncMask;                  // Э�鹦������,��λ��ʾ,�ã���ʾ֧��,��һλ��ʾ������̨����,������λ��ʱ����
    BYTE                bReserved_2;
    char                Reserved[4];
} PTZ_OPT_ATTR;

// ��������״̬
typedef enum tagEM_NET_BURN_DEV_TRAY_TYPE
{
    EM_NET_BURN_DEV_TRAY_TYPE_UNKNOWN,    // δ֪
	EM_NET_BURN_DEV_TRAY_TYPE_READY,      // ���̾���
	EM_NET_BURN_DEV_TRAY_TYPE_OPEN,       // ���̵���
	EM_NET_BURN_DEV_TRAY_TYPE_NODISK,     // ����
	EM_NET_BURN_DEV_TRAY_TYPE_NOT_READY,  // ����δ����
}EM_NET_BURN_DEV_TRAY_TYPE;

// ����ʹ��״̬
typedef enum tagEM_NET_BURN_DEV_OPERATE_TYPE
{
    EM_NET_BURN_DEV_OPERATE_TYPE_UNKNOWN, // δ֪
	EM_NET_BURN_DEV_OPERATE_TYPE_WRITE,   // ִ��д
	EM_NET_BURN_DEV_OPERATE_TYPE_READ,    // ִ�ж�
	EM_NET_BURN_DEV_OPERATE_TYPE_IDLE,    // ����
}EM_NET_BURN_DEV_OPERATE_TYPE;

// ��¼����Ϣ
typedef struct _NET_DEV_BURNING
{
    DWORD               dwDriverType;               // ��¼���������ͣ�0��DHFS,1��DISK,2��CDRW
    DWORD               dwBusType;                  // �������ͣ�0��USB,1��1394,2��IDE, 3: SATA, 4: ESATA
    DWORD               dwTotalSpace;               // ������(KB)
    DWORD               dwRemainSpace;              // ʣ������(KB)
    BYTE                dwDriverName[DH_BURNING_DEV_NAMELEN];    // ��¼����������
	EM_NET_BURN_DEV_TRAY_TYPE  emTrayType;						 // ��������״̬
	EM_NET_BURN_DEV_OPERATE_TYPE emOperateType;					 // ����ʹ��״̬
} NET_DEV_BURNING, *LPNET_DEV_BURNING;

// �豸��¼����Ϣ
typedef struct _DH_BURNING_DEVINFO
{
    DWORD               dwDevNum;                           // ��¼�豸����
    NET_DEV_BURNING     stDevs[DH_MAX_BURNING_DEV_NUM];     // ����¼�豸��Ϣ
} DH_BURNING_DEVINFO, *LPDH_BURNING_DEVINFO;

// ��¼����
typedef struct _DH_BURNING_PROGRESS
{

    BYTE                bBurning;                   // ��¼��״̬��0�����Կ�¼,1����¼�����Ͳ���,��һ���ǹ����豸,
                                                    // 2��δ�ҵ���¼��(��ʣ��ռ�Ϊ0),3�������������ڿ�¼,4����¼�����ڷǿ���״̬,���ڱ��ݡ���¼��ط���
    BYTE                bRomType;                   // ��Ƭ���ͣ�0��˽���ļ�ϵͳ,1���ƶ�Ӳ�̻�U��,2������
    BYTE                bOperateType;               // �������ͣ�0������,1�����ڱ�����,2�����ڿ�¼��,3�����ڽ��й��̻ط�, 4: ���̿�¼
    BYTE                bType;                      // ���ݻ��¼����״̬��0-ֹͣ 1-��ʼ 2-���� 3-�� 4-���� 5-���ڳ�ʼ�� 6-��ͣ 7-�ȴ�����
    NET_TIME            stTimeStart;                // ��ʼʱ�䡡
    DWORD               dwTimeElapse;               // �ѿ�¼ʱ��(��)
    DWORD               dwTotalSpace;               // ����������
    DWORD               dwRemainSpace;              // ����ʣ������
    DWORD               dwBurned;                   // �ѿ�¼����
    WORD                dwStatus;                   // ����
    WORD                wChannelMask;               // ���ڿ�¼��ͨ������
} DH_BURNING_PROGRESS, *LPDH_BURNING_PROGRESS;

// ��־��Ϣ,��Ӧ�ӿ�CLIENT_QueryLog�ӿ�
typedef struct _DH_LOG_ITEM
{
    DHDEVTIME           time;                       // ����
    unsigned short      type;                       // ��־���ͣ���Ӧ�ṹ�� DH_LOG_TYPE
    unsigned char       reserved;                   // ����
    unsigned char       data;                       // ����
    unsigned char       context[8];                 // ����
} DH_LOG_ITEM, *LPDH_LOG_ITEM;

// ��־��Ϣ,��Ӧ��չ�ӿ�CLIENT_QueryLogEx,����reserved(int nType=1;reserved=&nType;)
typedef struct _DH_NEWLOG_ITEM
{
    DHDEVTIME           time;                       // ����
    WORD                type;                       // ��չ��־���ͣ���Ӧ�ṹ�� DH_NEWLOG_TYPE
    WORD                data;                       // ����
    char                szOperator[8];              // �û���
    BYTE                context[16];                // ����    
} DH_NEWLOG_ITEM, *LPDH_NEWLOG_ITEM;

// ��־��Ϣ,��Ӧ�ӿ�CLIENT_QueryDeviceLog�ӿ�
typedef struct _DH_DEVICE_LOG_ITEM
{
    int                 nLogType;                   // ��־����
    DHDEVTIME           stuOperateTime;             // ����
    char                szOperator[16];             // ������
    BYTE                bReserved[3];
    BYTE                bUnionType;                 //  union�ṹ����,0:szLogContext��1:stuOldLog��
    union
    {
        char            szLogContext[64];           // ��־��ע��Ϣ
        struct 
        {
            DH_LOG_ITEM     stuLog;                 // �ɵ���־�ṹ��
            BYTE            bReserved[48];          // ����
        }stuOldLog;
    };
    char                reserved[16];
} DH_DEVICE_LOG_ITEM, *LPDH_DEVICE_LOG_ITEM;

// ����־��Ϣ�ṹ,��Ӧ�ӿ�CLIENT_QueryDeviceLog�ӿ�
typedef struct _DH_DEVICE_LOG_ITEM_EX
{
    int                 nLogType;                   // ��־����
    DHDEVTIME           stuOperateTime;             // ����
    char                szOperator[16];             // ������
    BYTE                bReserved[3];
    BYTE                bUnionType;                 //  union�ṹ����,0:szLogContext��1:stuOldLog��
    union
    {
        char            szLogContext[64];           // ��־��ע��Ϣ
        struct 
        {
            DH_LOG_ITEM     stuLog;                 // �ɵ���־�ṹ��
            BYTE            bReserved[48];          // ����
        }stuOldLog;
    };
    char                szOperation[32];            // ����Ĳ�������
    char                szDetailContext[4*1024];    // ��ϸ��־��Ϣ����
} DH_DEVICE_LOG_ITEM_EX, *LPDH_DEVICE_LOG_ITEM_EX;

// ¼����־��Ϣ,��Ӧ��־�ṹ�����context
typedef struct _LOG_ITEM_RECORD
{
    DHDEVTIME           time;                       // ʱ��
    BYTE                channel;                    // ͨ��
    BYTE                type;                       // ¼������
    BYTE                reserved[2];
} LOG_ITEM_RECORD, *LPLOG_ITEM_RECORD;

typedef struct _QUERY_DEVICE_LOG_PARAM
{
    DH_LOG_QUERY_TYPE   emLogType;                  // ��ѯ��־����
    NET_TIME            stuStartTime;               // ��ѯ��־�Ŀ�ʼʱ��
    NET_TIME            stuEndTime;                 // ��ѯ��־�Ľ���ʱ��
    int                 nStartNum;                  // ��ʱ����дӵڼ�����־��ʼ��ѯ,��ʼ��һ�β�ѯ����Ϊ0
    int                 nEndNum;                    // һ�β�ѯ�е��ڼ�����־����,��־�������������ֵΪ1024
    BYTE                nLogStuType;                // ��־���ݽṹ������,0:��ʾDH_DEVICE_LOG_ITEM��1:��ʾDH_DEVICE_LOG_ITEM_EX
    BYTE                reserved[3];                // ���� ����
    unsigned int        nChannelID;                 // ͨ����,0:����֮ǰ��ʾ����ͨ����,����ͨ���Ŵ�1��ʼ; 1:��һ��ͨ��
    BYTE                bReserved[40];
} QUERY_DEVICE_LOG_PARAM;

// �豸Ӳ�����¼����Ϣ
typedef struct __DEV_DISK_RECORD_INFO 
{
    NET_TIME            stuBeginTime;               // ����¼��ʱ��
    NET_TIME            stuEndTime;                 // ���¼��ʱ��
    char                reserved[128];
} DEV_DISK_RECORD_INFO;

// �豸Ӳ��¼��ʱ����Ϣ
typedef struct __DEV_DISK_RECORD_TIME
{
    NET_TIME            stuStartTime1;              // ¼��ʱ���1��ʼʱ��
    NET_TIME            stuEndTime1;                // ¼��ʱ���1����ʱ��
    BOOL                bTwoPart;                   // �Ƿ��еڶ���
    NET_TIME            stuStartTime2;              // ¼��ʱ���2��ʼʱ��
    NET_TIME            stuEndTime2;                // ¼��ʱ���2����ʱ��
    BYTE                bDiskNum;                   // Ӳ�̺�
    BYTE                bSubareaNum;                // ������
    BYTE                byReserved[62];             // �����ֽ�  

}DEV_DISK_RECORD_TIME;

///////////////////////////////������ض���///////////////////////////////
//��������̿���
typedef struct _NKB_PARAM
{
    BYTE                bAddressCode;               // ΪDVR���豸�������ַ��,0xFFΪ�㲥��ַ
    BYTE                bKeyStatus;                 // ״̬�� 0/1 0��ʾ�������� 1��ʾ�����ſ�
    BYTE                bExtern1;                   // ��չ�ֽ�1
    BYTE                bExtern2;                   // ��չ�ֽ�2
    BYTE                bReserved[60];
}NKB_PARAM;

// Ӳ�̲���
typedef struct _DISKCTRL_PARAM
{
    DWORD               dwSize;                     // �ṹ���С,�汾������
    int                 nIndex;                     // ΪӲ����Ϣ�ṹ��DH_HARDDISK_STATE�������stDisks�±�,��0��ʼ
    int                 ctrlType;                   // ��������,
                                                    // 0 - �������, 1 - ��Ϊ��д��, 2 - ��Ϊֻ����
                                                    // 3 - ��Ϊ������, 4 - �ָ�����, 5 - ��Ϊ������,7 - ����SD������SD��������Ч��
    NET_DEV_DISKSTATE   stuDisk;                    // ������Ϣ, ���ڴ���˳����ܸı䵼���±겻׼, ���������±�
} DISKCTRL_PARAM;

typedef struct  
{
    BYTE                bSubareaNum;                // Ԥ�����ĸ���
    BYTE                bIndex;                     // ΪӲ����Ϣ�ṹ��DH_HARDDISK_STATE�������stDisks�±�,��0��ʼ
    BYTE                bSubareaSize[32];           // ������С���ٷֱȣ�
    BYTE                bReserved[30];              // ����
} DISKCTRL_SUBAREA;

// ����״̬
typedef struct _ALARMCTRL_PARAM
{
    DWORD               dwSize;
    int                 nAlarmNo;                   // ����ͨ����,��0��ʼ
    int                 nAction;                    // 1����������,0��ֹͣ����
} ALARMCTRL_PARAM;

// �������
typedef struct _MATRIXCTRL_PARAM
{
    DWORD               dwSize;
    int                 nChannelNo;                 // ��Ƶ�����,��0��ʼ
    int                 nMatrixNo;                  // ���������,��0��ʼ
} MATRIXCTRL_PARAM;

// ��¼����
typedef struct _BURNING_PARM
{
    int                 channelMask;                // ͨ������,��λ��ʾҪ��¼��ͨ��
    BYTE                devMask;                    // ��¼������,���ݲ�ѯ���Ŀ�¼���б�,��λ��ʾ
    BYTE                bySpicalChannel;            // ���л�ͨ��(ͨ����+31,�������4ͨ���豸,��ֵӦΪ35)
    BYTE                byReserved[2];              // �����ֶ�
} BURNNG_PARM;

// ������¼
typedef struct _BURNING_PARM_ATTACH
{
    BOOL                bAttachBurn;                // �Ƿ�Ϊ������¼,0:����; 1:��
    BYTE                bReserved[12];              // �����ֶ�
} BURNING_PARM_ATTACH;

// �ֶ�ץ�Ĳ���
typedef struct  _MANUAL_SNAP_PARAMETER{
    int                 nChannel;                   // ץͼͨ��,��0��ʼ
    BYTE                bySequence[64];             // ץͼ���к��ַ���
    BYTE                byReserved[60];             // �����ֶ�
}MANUAL_SNAP_PARAMETER;

// �����豸�˱���Ԥ���ָ����
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_PARAMETER
{
    int                 nSliptMode;                 // �ָ�ģʽ,���豸�˱���Ԥ��֧�ֵķָ�ģʽ
    int                 nSubSliptNum;               // ��ǰҪԤ�����ӷָ�,��1��ʼ
    BYTE                byReserved[64];             // �����ֶ�
}DEVICE_LOCALPREVIEW_SLIPT_PARAMETER;

// �豸�˱���Ԥ��֧�ֵķָ�ģʽ
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_CAP
{
    int                 nModeNumber;
    int                 nSliptMode[36];             // ֧�ֵķָ�ģʽ,
    BYTE                byReserved[64];             // �����ֶ�
}DEVICE_LOCALPREVIEW_SLIPT_CAP;

// ·����Ϣ
typedef struct  _CROSSING_INFO
{
    char                szCrossingID[DH_MAX_CROSSING_ID];   // ·�����к�
    DWORD               dwLatitude;                         // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30��.��183382�ȱ�ʾΪ120183382)
    DWORD               dwLongitude;                        // ����(��λ�ǰ����֮��,��Χ0-360��) �綫��100��.��178274�ȱ�ʾΪ280178274��
                                                            // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    WORD                wSpeedLimit;                        // ·������ֵ,��λKm/h 0��ʾ������,������ʾ����ֵ����
    BYTE                byReserved[22];
}CROSSING_INFO;

// ·�ߵ�λ��Ϣ
typedef struct  _ROUTE_CROSSING_INFO
{
    BYTE                byCrossingNum;                      // ·����Ч������Χ1~DH_MAX_CROSSING_NUM
    BYTE                byReserved1;
    WORD                wCrossingRange;                     // ��λ���ȷ�Χ��λm
    CROSSING_INFO       stCrossingInfo[DH_MAX_CROSSING_NUM];// ·����Ϣ���֧��128��·��
    BYTE                byReserved2[2044];
}ROUTE_CROSSING_INFO;

// raid����
typedef struct _CTRL_RAID_INFO
{
    char                szAction[16];                       // Add����,Deleteɾ��
    char                szName[16];                         // Raid����
    int                 nType;                              // ���� 1:Jbod     2:Raid0      3:Raid1     4:Raid5
    int                 nStatus;                            // ״̬ 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
    int                 nCntMem;                            // nMember�������Ч���ݸ���
    int                 nMember[32];                        // 1,2,3,... ��ɴ���ͨ��,�Ǹ�����
    int                 nCapacity;                          // ����,��λG
    int                 nRemainSpace;                       // ʣ������,��λM
    int                 nTank;                              // ��չ�� 0:����,1:��չ��1,2:��չ��2,����
    char                reserved[128];
}CTRL_RAID_INFO;

// �ȱ�����
typedef struct _CTRL_SPARE_DISK_INFO
{
    char                szAction[16];                       // Enable,ʹ��,Disable,��ʹ��
    char                szScope[16];                        // Global,ȫ���ȱ�,Local,��ȫ���ȱ�
    char                szName[16];                         // �ȱ�����,��ScopeΪGlobal,��Ϊ�ȱ��ص�����,�����ʾRaid�������
    unsigned int        nIndex;                             // �������
    const char*         pszDevName;                         // �洢�豸����,���û������ڴ�
    char                reserved[124];
}CTRL_SPARE_DISK_INFO;

typedef struct _CTRL_SPARE_DISK_INFO_A
{
    int                     nCnt;                           // �ȱ��̵ĸ���
    CTRL_SPARE_DISK_INFO    stSpaceDiskInfo[32];
}CTRL_SPARE_DISK_INFO_A;

// ��������������
typedef struct __CTRL_ARM_DISARM_PARAM
{
    BYTE                bState;                             // ������״̬,0��ʾ����,1��ʾ����,2��ʾǿ�Ʋ���
    char                reserve[3];
    const char*         szDevPwd;                           // �û�����
    NET_SCENE_MODE      emSceneMode;                        // �龰ģʽ
    const char*         szDevID;                            // ת��Ŀ���豸ID,ΪNULL��ʾ��ת��
    char                reserve1[16];
} CTRL_ARM_DISARM_PARAM;

// ����������������չ�������
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_IN
{
    DWORD               dwSize;
    NET_ALARM_MODE      emState;                            // ������״̬
    const char*         szDevPwd;                           // �û�����
    NET_SCENE_MODE      emSceneMode;                        // �龰ģʽ
    const char*         szDevID;                            // ת��Ŀ���豸ID,ΪNULL��ʾ��ת��
} CTRL_ARM_DISARM_PARAM_EX_IN;

#define ARM_DISARM_ZONE_MAX (256)                           // ����������

// ����������������չ�������
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_OUT
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // �б���Դ���벼��ʧ�ܵķ�������
    int                 nSource[ARM_DISARM_ZONE_MAX];       // �б���Դ����ʧ�ܵķ�����, �����Ŵ�0��ʼ
    DWORD               dwLinkNum;                          // ��������������ʧ�ܵķ�������
    int                 nLink[ARM_DISARM_ZONE_MAX];         // ����������ʧ�ܵķ�����, �����Ŵ�0��ʼ
} CTRL_ARM_DISARM_PARAM_EX_OUT;

// ����������������չ(��ӦDH_CTRL_ARMED_EX)
typedef struct tagCTRL_ARM_DISARM_PARAM_EX
{
    DWORD                        dwSize;
    CTRL_ARM_DISARM_PARAM_EX_IN  stuIn;                     // ������������������
    CTRL_ARM_DISARM_PARAM_EX_OUT stuOut;                    // �����������������
} CTRL_ARM_DISARM_PARAM_EX;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_IN
{
    DWORD               dwSize;
    int                 nType;                              // WPS��������,0:���ⰴť��ʽ; 1:(�豸��)pin�뷽ʽ; 2:(wifi�ȵ��)pin�뷽ʽ
    char                szSSID[DH_MAX_SSID_LEN];            // SSID,nTypeΪ1��2ʱ��Ч,���֧��32λ
    char                szApPin[DH_MAX_APPIN_LEN];          // APPIN��, nTypeΪ2ʱ��Ч,PIN��Ϊ8λ����,���pin���Ǵ�wifi�ȵ���õ���
    char                szWLanPin[DH_MAX_APPIN_LEN];        // �豸pin��,nTypeΪ1ʱ��Ч:Ϊ��ʱ���豸����;��Ϊ��ʱ����ʾ���û��趨,���֧��8λ����,���pin��Ҫ��WIFI�ȵ������
}DHCTRL_CONNECT_WIFI_BYWPS_IN;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_OUT
{
    DWORD               dwSize;
    char                szRetWLanPin[DH_MAX_APPIN_LEN];// �����豸PIN��,��WPS��������Ϊ(�豸��)pin�뷽ʽʱ�����������Ч
}DHCTRL_CONNECT_WIFI_BYWPS_OUT;

// CLIENT_ControlDevice�ӿڵ�DH_CTRL_WIFI_BY_WPS�������(WPS��������WIFI)
typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS
{
    DWORD                dwSize;
    DHCTRL_CONNECT_WIFI_BYWPS_IN     stuWpsInfo;            // ���Ӳ���(���û���д)
    DHCTRL_CONNECT_WIFI_BYWPS_OUT    stuWpsResult;          // ��������(���豸����)
} DHCTRL_CONNECT_WIFI_BYWPS;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_CLOSE_BURNER �� �������
typedef struct tagNET_CTRL_BURNERDOOR
{
    DWORD               dwSize;
    const char*         szBurnerName;                       // ��������,�硰/dev/sda��
    BOOL                bResult;                            // �������
    BOOL                bSafeEject;                         // �Ƿ�ȫ��������, TRUE-����ǰ�����ݱ���, FALSE-ֱ�ӵ���
}NET_CTRL_BURNERDOOR;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_START_PLAYAUDIO �������
typedef struct tagNET_CTRL_START_PLAYAUDIO
{
    DWORD               dwSize;
    char                szAudioPath[DH_MAX_AUDIO_PATH];
}NET_CTRL_START_PLAYAUDIO;

// ������Ԫ����
typedef enum tagNET_PLAYAUDIO_TYPE
{
    NET_PLAYAUDIO_TYPE_UNKNOWN = 0,
    NET_PLAYAUDIO_TYPE_PHRASE,                          // ��������,�����н���,���ζ�ÿ����,�и��ֵ������ļ�֧��
    NET_PLAYAUDIO_TYPE_FILE,                            // ����ָ��·���������ļ�(�豸������·��)
    NET_PLAYAUDIO_TYPE_PLATERNUM,                       // �������ƺ���,�����ƺ����ʽ����
    NET_PLAYAUDIO_TYPE_MONEY,                           // �������,�������ʽ����
    NET_PLAYAUDIO_TYPE_DATE,                            // ��������,��������ʽ����
    NET_PLAYAUDIO_TYPE_TIME,                            // ����ʱ��,��ʱ����ʽ����
    NET_PLAYAUDIO_TYPE_EMPTY,                           // ������,ͣ��һ���ַ�ʱ��
}NET_PLAYAUDIO_TYPE;

// ���������
typedef struct tagNET_CTRL_PLAYAUDIO_INFO
{
    DWORD               dwSize;
    NET_PLAYAUDIO_TYPE  emPlayAudioType;                // ������Ԫ����,���NET_PLAYAUDIO_TYPE
    char                szDetail[DH_COMMON_STRING_128]; // ��ϸ���ݸ�������ϸ���ݣ�
                                                        // Phrase����:"��ӭ"
                                                        // File����: "/home/ͣ��.pcm"
                                                        // PlateNumbe����: "��A12345"
                                                        // Money����: "80.12Ԫ"
                                                        // Date����: "2014��4��10��"
                                                        // Time����: "1��10Сʱ20��5��
}NET_CTRL_PLAYAUDIO_INFO;

#define DH_MAX_PLAYAUDIO_COUNT    16  // ��󲥱�������Ŀ
// CLIENT_ControlDevice�ӿڵ� DH_CTRL_START_PLAYAUDIOEX �������
typedef struct tagNET_CTRL_START_PLAYAUDIOEX
{
    DWORD                       dwSize;
    unsigned int                nAudioCount;                            // ����������Ŀ               
    NET_CTRL_PLAYAUDIO_INFO     stuAudioInfos[DH_MAX_PLAYAUDIO_COUNT];  // ���������
}NET_CTRL_START_PLAYAUDIOEX;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_START_ALARMBELL��DH_CTRL_STOP_ALARMBELL�������
typedef struct tagNET_CTRL_ALARMBELL
{
    DWORD               dwSize;
    int                 nChannelID;             // ͨ����(0��ʼ)            
}NET_CTRL_ALARMBELL;

// �Ž�����--���ŷ�ʽ
typedef enum tagEM_OPEN_DOOR_TYPE
{
	EM_OPEN_DOOR_TYPE_UNKNOWN = 0,
	EM_OPEN_DOOR_TYPE_REMOTE,						// Զ�̿���
	EM_OPEN_DOOR_TYPE_LOCAL_PASSWORD,				// �������뿪��
	EM_OPEN_DOOR_TYPE_LOCAL_CARD,					// ����ˢ������
	EM_OPEN_DOOR_TYPE_LOCAL_BUTTON,					// ���ذ�ť����
}EM_OPEN_DOOR_TYPE;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_ACCESS_OPEN �������
typedef struct tagNET_CTRL_ACCESS_OPEN
{
    DWORD               dwSize;
    int                 nChannelID;                    // ͨ����(0��ʼ)
    const char*         szTargetID;                    // ת��Ŀ���豸ID,ΪNULL��ʾ��ת��
    char                szUserID[MAX_COMMON_STRING_32];// Զ���û�ID
	EM_OPEN_DOOR_TYPE	emOpenDoorType;                // ���ŷ�ʽ
}NET_CTRL_ACCESS_OPEN;

// �Ž�����ģʽ����
typedef enum tagEM_NET_DOOR_WORK_MODE_TYPE
{
    NET_DOOR_WORK_MODE_UNKNOWN,            // δ֪
	NET_DOOR_WORK_MODE_NORMAL,             // ����ģʽ
	NET_DOOR_WORK_MODE_SHUTDOWN,           // �ر�
	NET_DOOR_WORK_MODE_UNUSED,             // ͣ��
	NET_DOOR_WORK_MODE_OPEN_DOOR_CONTINUE, // ������

}EM_NET_DOOR_WORK_MODE_TYPE;

// �����Ž�����ģʽ����Σ�
typedef struct tagNET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
	DWORD                   dwSize;
	EM_NET_DOOR_WORK_MODE_TYPE emWorkMode;    // ����ģʽ����
}NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// �����Ž�����ģʽ�����Σ�
typedef struct tagNET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
    DWORD                   dwSize;
}NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// ͬ��������LED��ʱ�䣨��Σ�
typedef struct tagNET_IN_CTRL_SYNC_CABINLED_TIME
{
	DWORD                   dwSize;
}NET_IN_CTRL_SYNC_CABINLED_TIME;

// ͬ��������LED��ʱ�䣨���Σ�
typedef struct tagNET_OUT_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_OUT_CTRL_SYNC_CABINLED_TIME;

// ������LED���ſ�������
typedef enum tagEM_NET_CABIN_LED_PLAY_CONTROL_MODE
{
    NET_CABIN_LED_PLAY_CONTROL_MODE_UNKNOWN,          // δ֪
    NET_CABIN_LED_PLAY_CONTROL_MODE_NORMAL_TURN_ON,   // �������� ( ���� )
    NET_CABIN_LED_PLAY_CONTROL_MODE_NEXT_PROGRAM,     // ��һ��Ŀ       
    NET_CABIN_LED_PLAY_CONTROL_MODE_PREVIOUS_PROGRAM, // ǰһ��Ŀ
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE,            // ��ͣ����
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE_TURN_OFF,   // ��ͣ���� ( ���� )
    NET_CABIN_LED_PLAY_CONTROL_MODE_PLAY_GO_ON,       // ��������
    NET_CABIN_LED_PLAY_CONTROL_MODE_GO_TO_TEST_ITSELF,// �����Բ�
    NET_CABIN_LED_PLAY_CONTROL_MODE_EXIT_TEST_ITSELF, // �˳��Բ�
    NET_CABIN_LED_PLAY_CONTROL_MODE_SYSTEM_RESET,     // ��λϵͳ
}EM_NET_CABIN_LED_PLAY_CONTROL_MODE;

// ������LED���ſ��ƣ���Σ�
typedef struct tagNET_IN_CTRL_CABINLED_PLAYCONTROL
{
	DWORD                                   dwSize;
	EM_NET_CABIN_LED_PLAY_CONTROL_MODE         emAction; // ��������
}NET_IN_CTRL_CABINLED_PLAYCONTROL;

// ������LED���ſ��ƣ����Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_PLAYCONTROL;

// ������LED�������ݵ���������
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE
{
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_UNKNOWN,
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_ADD       = 0, // ����
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_MODIFY    = 1, // �޸�
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_DELETE    = 2, // ɾ��
}EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE;

// ������LED���ſ���Ч��
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE
{
    NET_MODIFY_CONTENT_EFFECT_TYPE_UNKNOWN = -1,
    NET_MODIFY_CONTENT_EFFECT_TYPE_SHOW = 0,                      // ������ʾ
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_LEFT,                     // ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_RIGHT,                    // ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_UP,                       // ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_DOWN,                     // ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT,                  // �����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_RIGHT,                 // �����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP,                    // �����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN,                  // �����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_LEFT,               // �����Ͻ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_LEFT,             // �����½����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_RIGHT,              // �����Ͻ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_RIGHT,            // �����½����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_RIGHT_TO_CENTER,  // �������м����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_LEFT_RIGHT,  // �м����������
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_DOWN_TO_CENTER,     // �������м����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_UP_DOWN,     // �м����������
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_CROSS_RIGHT,      // ���ҽ������
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_CROSS_DOWN,         // ���½������
    NET_MODIFY_CONTENT_EFFECT_TYPE_VERTICAL_BLINDS,               // ��ֱ��Ҷ��
    NET_MODIFY_CONTENT_EFFECT_TYPE_HORIZONTAL_BLINDS,             // ˮƽ��Ҷ��  
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_SIDES,       // �м����ı����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_SIDES_TO_CENTER,       // �ı����м����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_CORNER,      // �м����Ľ����
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CORNER_TO_CENTER,      // �Ľ����м����
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_360,                    // ��ת360��
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_180,                    // ��ת180��
}EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE;

// ������LED���ݸ��ģ���Σ�
typedef struct tagNET_IN_CTRL_CABINLED_MODIFY_CONTENT
{
	DWORD                                    dwSize;
	EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE emCmd;             // ��Ϣ����
	int                                      nMsgID;            // ��ϢID ȡֵ1-5
	EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;       // ��Ч����
	int                                      nSpeed;            // ��ʾ�ٶ� ȡֵΪ0��15
	int                                      nDuration;         // ͣ��ʱ�� ��λΪ��
	char                                     szText[512];       // �ı�������
}NET_IN_CTRL_CABINLED_MODIFY_CONTENT;

// ������LED���ݸ��ģ����Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_MODIFY_CONTENT;

// ��ȡ������LED���ݣ���Σ�
typedef struct tagNET_IN_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;    
    int                     nMsgID;            // ��ϢID ȡֵ1-5   
}NET_IN_CTRL_CABINLED_GET_CONTENT;

// ��ȡ������LED���ݣ����Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;
    int                     nMsgID;            // ��ϢID ȡֵ1-5
    EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;          // ��Ч����
    int                     nSpeed;            // ��ʾ�ٶ� ȡֵΪ0��15
    int                     nDuration;         // ͣ��ʱ�� ��λΪ��
    char                    szText[512];       // �ı�������
}NET_OUT_CTRL_CABINLED_GET_CONTENT;

// ʱ��νṹ                                                                
typedef struct tagDH_TSECT
{
    int             bEnable;                        // ����ʾ¼��ʱ���ʱ,��λ��ʾ�ĸ�ʹ��,�ӵ�λ����λ�ֱ��ʾ����¼�󡢱���¼����ͨ¼�󡢶���ͱ���ͬʱ������¼��
													// ����ʾ������ʱ���ʱ, ��ʾʹ��
    int             iBeginHour;
    int             iBeginMin;
    int             iBeginSec;
    int             iEndHour;
    int             iEndMin;
    int             iEndSec;
} DH_TSECT, *LPDH_TSECT;

#define NET_CABINLED_SCHEDULE_TIME_SECTION_NUM 8  // ������LED��ʾ�ƻ�ʱ��ε������Ŀ

// ���÷�����LED��ʾ���üƻ�����Σ�
typedef struct tagNET_IN_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // �ƻ������� 0 ��ʾ���� 1~6 ��ʾ��һ������    
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // ʱ����������� DH_TSECT�е��ֶ�bEnable Ϊ0��ʾ��Ч����ֵ��ʾ��Ϣ��

}NET_IN_CTRL_CABINLED_SET_SCHEDULE;

// ���÷�����LED��ʾ���üƻ������Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD dwSize;   
}NET_OUT_CTRL_CABINLED_SET_SCHEDULE;

// ��ȡ������LED��ʾ���üƻ�����Σ�
typedef struct tagNET_IN_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // �ƻ������� 0 ��ʾ���� 1~6 ��ʾ��һ������
}NET_IN_CTRL_CABINLED_GET_SCHEDULE;

// ��ȡ������LED��ʾ���üƻ������Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD dwSize;
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // ʱ����������� DH_TSECT�е��ֶ�bEnable Ϊ0��ʾ��Ч����ֵ��ʾ��Ϣ��
}NET_OUT_CTRL_CABINLED_GET_SCHEDULE;

// ��ȡ������LED��ʾ�ַ����뷽ʽ����Σ�
typedef struct tagNET_IN_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD                       dwSize;                     // �ṹ���С    
}NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING;

// ��ȡ������LED��ʾ�ַ����뷽ʽ�����Σ�
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD dwSize;                                           // �ṹ���С
    int nCharacterEncoding;                                 // �ַ����뷽ʽ 0-GB2312 1-Unicode                         
}NET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING;


// ������LED��������
typedef enum tagEM_CABIN_LED_CONTROL_TYPE
{
    DH_CABIN_LED_CONTROL_UNKNOWN,                       // δ֪                      
    DH_CABIN_LED_CONTROL_SYNC_TIME,                     // ͬ��������LED��ʱ��(pInParam��Ӧ�ṹ��NET_IN_CTRL_SYNC_CABINLED_TIME,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_SYNC_CABINLED_TIME)
    DH_CABIN_LED_CONTROL_PLAY_CONTROL,                  // ������LED���ſ���(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_PLAYCONTROL,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_PLAYCONTROL)
    DH_CABIN_LED_CONTROL_MODIFY_CONTENT,                // ������LED��������(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_MODIFY_CONTENT,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_MODIFY_CONTENT)
    DH_CABIN_LED_CONTROL_GET_CONTENT,                   // ��ȡ������LED����(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_GET_CONTENT,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_GET_CONTENT)
    DH_CABIN_LED_CONTROL_SET_SCHEDULE,                  // ���÷�����LED��ʾ�ƻ�(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_SET_SCHEDULE,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_SET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_SCHEDULE,                  // ��ȡ������LED��ʾ�ƻ�(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_GET_SCHEDULE,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_GET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_CHAR_ENCODING,             // ��ȡ������LED��ʾ�ַ����뷽ʽ(pInParam��Ӧ�ṹ��NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING,pOutParam��Ӧ�ṹ��NET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING)
}EM_CABIN_LED_CONTROL_TYPE;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_ACCESS_CLOSE �������
typedef struct tagNET_CTRL_ACCESS_CLOSE
{
    DWORD               dwSize;
    int                 nChannelID;             // ͨ����(0��ʼ)
}NET_CTRL_ACCESS_CLOSE;

typedef enum tagNET_ALARM_TYPE
{
    NET_ALARM_LOCAL = 0,                        //�����������ı����¼�(��Ӧ DH_ALARM_ALARM_EX2 �¼�)
    NET_ALARM_ALARMEXTENDED,                    //��չģ�鱨���¼�(��Ӧ DH_ALARM_ALARMEXTENDED �¼�)
    NET_ALARM_TEMP,                             //�¶ȱ����¼�(��Ӧ DH_ALARM_TEMPERATURE �¼�)
    NET_ALARM_URGENCY,                          //������¼�(��Ӧ DH_URGENCY_ALARM_EX �¼�)
    NET_ALARM_RCEMERGENCYCALL,                  //���б����¼�(��Ӧ DH_ALARM_RCEMERGENCY_CALL �¼�)
    NET_ALARM_ALL,                              //���б����¼�
}NET_ALARM_TYPE;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_CLEAR_ALARM �������
typedef struct tagNET_CTRL_CLEAR_ALARM
{
    DWORD               dwSize;
    int                 nChannelID;             // ����ͨ����, -1 ��ʾ����ͨ��
    NET_ALARM_TYPE      emAlarmType;            // �¼�����(֧�ֵ����ͽ���,������nEventType�ֶ�)
    const char*         szDevPwd;               // ��½�豸������,�粻ʹ�ü�������,ֱ�Ӹ�ֵΪNULL
    BOOL                bEventType;             // ��ʾ�Ƿ�����nEventType�ֶ�, TRUE:nEventType����emAlarmType�ֶ�, FALSE:����emAlarmType�ֶ�,����nEventType�ֶ�
    int                 nEventType;             // �¼�����, ��Ӧ fMessCallBack �ص����ϵ�lCommand�ֶ�, ��CLIENT_StartListenEx�ӿڻ���¼�����
                                                // ����DH_ALARM_ALARM_EX2��ʾ���ر����¼�
}NET_CTRL_CLEAR_ALARM;

// ����ǽ��ʾ��Ϣ���Ʋ���
typedef struct tagNET_CTRL_MONITORWALL_TVINFO 
{
    DWORD               dwSize;
    int                 nMonitorWallID;         // ����ǽID, DH_CTRL_MONITORWALL_TVINFO �� DH_DEVSTATE_MONITORWALL_TVINFO����Ҫ��д
    BOOL                bDecodeChannel;         // ��ʾ����ͨ����Ϣ, DH_CTRL_MONITORWALL_TVINFO ��д
    BOOL                bControlID;             // ��ʾ��Ļ����ID, DH_CTRL_MONITORWALL_TVINFO ��д
    BOOL                bCameraID;              // ��ʾ����ͨ����ƵԴ����ID, DH_CTRL_MONITORWALL_TVINFO ��д
} NET_CTRL_MONITORWALL_TVINFO;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_START_VIDEO_ANALYSE �������
typedef struct tagNET_CTRL_START_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // ͨ����  
}NET_CTRL_START_VIDEO_ANALYSE;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_STOP_VIDEO_ANALYSE �������
typedef struct tagNET_CTRL_STOP_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // ͨ����  
}NET_CTRL_STOP_VIDEO_ANALYSE;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_MULTIPLAYBACK_CHANNALES ������� 
typedef struct tagNET_CTRL_MULTIPLAYBACK_CHANNALES
{
    DWORD               dwSize;
    LLONG               lPlayBackHandle;        // �طž��,CLIENT_MultiPlayBack�ӿڷ���ֵ
    int                 nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM];// Ԥ��ͨ����
    int                 nChannelNum;            // Ԥ��ͨ���� 
}NET_CTRL_MULTIPLAYBACK_CHANNALES;

// CLIENT_ControlDevice�ӿڵ� DH_CTRL_SET_BYPASS �������
typedef struct tagNET_CTRL_SET_BYPASS
{
    DWORD               dwSize;
    const char*         szDevPwd;               // �����豸������
    NET_BYPASS_MODE     emMode;                 // ͨ��״̬
    int                 nLocalCount;            // ���ر�������ͨ������
    int*                pnLocal;                // ���ر�������ͨ����    
    int                 nExtendedCount;         // ��չģ�鱨������ͨ������
    int*                pnExtended;             // ��չģ�鱨������ͨ����
}NET_CTRL_SET_BYPASS;
 
// CLIENT_ControlDevice�ӿڵ�  DH_CTRL_SET_MEDIAKIND �������
typedef struct tagNET_CTRL_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_CTRL_SET_MEDIAKIND)
    int                  nMediaKind;                    //  ý������,0:������Ƶ����Ƶ,1:ֻ������Ƶ,2:ֻ������Ƶ
    DWORD                dwChannelCount;                //  ��Чͨ����
    int                  nChannels[256];                //  ��Ƶͨ����(��0��ʼ)
} NET_IN_SET_MEDIAKIND;

// CLIENT_ControlDevice�ӿڵ�  DH_CTRL_SET_MEDIAKIND �������
typedef struct tagNET_OUT_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_OUT_SET_MEDIAKIND)
} NET_OUT_SET_MEDIAKIND;

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CLIENT_QueryDevState�ӿڵ� DH_DEVSTATE_GET_BYPASS �������
typedef struct tagNET_DEVSTATE_GET_BYPASS
{
    DWORD               dwSize;
    int                 nLocalCount;            // ���ر�������ͨ������
    int*                pnLocal;                // ���ر�������ͨ����    
    int                 nExtendedCount;         // ��չģ�鱨������ͨ������
    int*                pnExtended;             // ��չģ�鱨������ͨ����
    NET_BYPASS_MODE*    pemLocal;               // ���ر�������ͨ��״̬
    NET_BYPASS_MODE*    pemExtended;            // ��չģ�鱨������ͨ��״̬
}NET_DEVSTATE_GET_BYPASS;

// CLIENT_QueryDevState�ӿڵ� DH_DEVSTATE_BURNERDOOR �������
typedef struct tagNET_DEVSTATE_BURNERDOOR
{
    DWORD               dwSize;
    const char*         szBurnerName;            // ��������,�硰/dev/sda��
    bool                bEjected;                // �Ƿ��Ѿ�����
    BYTE                Reserved[3];             // ����
}NET_DEVSTATE_BURNERDOOR;

// CLIENT_QueryDevState�ӿڵ� DH_DEVSTATE_GET_DATA_CHECK �������
typedef struct tagNET_DEVSTATE_DATA_CHECK
{
    DWORD               dwSize;                     // �ṹ���С
    const char*         szBurnerName;               // ��������,�硰/dev/s",����Ƕ���̵Ļ�,�κ�һ�����̶�����
    char                szState[DH_MAX_STRING_LEN]; // "NotStart":��δ��ʼ,"Verifying":У����,"Failed":ʧ��,"Successed":�ɹ�
    int                 nPercent;                   // У��ٷֱ�:0-100,state��Verifyingʱ����Ч
}NET_DEVSTATE_DATA_CHECK;

// CLIENT_ListenServer �ӿڻص�fServiceCallBack����֧�ֵ���������
enum { 
    DH_DVR_DISCONNECT=-1,                           // ��֤�ڼ��豸���߻ص�
    DH_DVR_SERIAL_RETURN=1,                         // �豸ע��Я�����к� ��Ӧ char* szDevSerial
    NET_DEV_AUTOREGISTER_RETURN,                    // �豸ע��Я�����кź����� ��ӦNET_CB_AUTOREGISTER
    NET_DEV_NOTIFY_IP_RETURN,                       // �豸���ϱ�IP, ����Ϊ����ע����, �û���ȡip��ֻ�ܰ���Լ���Ķ˿ڰ��շ�����ע������͵�¼
};
typedef struct tagNET_CB_AUTOREGISTER
{
    DWORD           dwSize;                          // �ṹ���С
    char            szDevSerial[DH_DEV_SERIALNO_LEN];// ���к�
    char            szToken[MAX_PATH];               // ����
}NET_CB_AUTOREGISTER;

// ��������ע����ؽṹ��
typedef struct tagCLOUDSERVICE_CONNECT_PARAM
{
    DWORD               dwSize;   
    char                szDstIp[DH_MAX_IPADDR_EX_LEN];    // ������IP
    int                 nDstPort;                         // �������˿ں� 
    DWORD               dwConnectType;                    // �������ͣ�0��ʾ������,1��ʾ�������,2��������, 3��̬ע�������ӣ�ʹ��0Xb4ע�ᣩ  
    char                szToken[MAX_PATH];                // ʹ�����Զ����豸ͨ��ΨһID����
}NET_CLOUDSERVICE_CONNECT_PARAM;

typedef struct tagCLOUDSERVICE_CONNECT_RESULT
{
    DWORD               dwSize;  
    DWORD               dwConnectState;                           // ��ǰ����״̬��1�ɹ�,0ʧ��
    char                szMessage[DH_MAX_CLOUDCONNECT_STATE_LEN]; // ����״̬��Ϣ,"Success","Password Error","Network Error","Timeout"
}NET_CLOUDSERVICE_CONNECT_RESULT;
///////////////////////////////������ض���///////////////////////////////

//-------------------------------�豸����---------------------------------
// �豸��Ϣ
typedef struct
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];     // ���к�
    BYTE                byAlarmInPortNum;                   // DVR�����������
    BYTE                byAlarmOutPortNum;                  // DVR�����������
    BYTE                byDiskNum;                          // DVRӲ�̸���
    BYTE                byDVRType;                          // DVR����,��ö�� NET_DEVICE_TYPE
    union
    {
        BYTE            byChanNum;                          // DVRͨ������,��½�ɹ�ʱ��Ч
        BYTE            byLeftLogTimes;                     // ����½ʧ��ԭ��Ϊ�������ʱ,ͨ���˲���֪ͨ�û�,ʣ���½����,Ϊ0ʱ��ʾ�˲�����Ч
    };
} NET_DEVICEINFO, *LPNET_DEVICEINFO;

// �豸��Ϣ��չ
typedef struct
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];     // ���к�
    int                 nAlarmInPortNum;                    // DVR�����������
    int                 nAlarmOutPortNum;                   // DVR�����������
    int                 nDiskNum;                           // DVRӲ�̸���
    int                 nDVRType;                           // DVR����,��ö��NET_DEVICE_TYPE
    int                 nChanNum;                           // DVRͨ������
    BYTE                byLimitLoginTime;                   // ���߳�ʱʱ��,Ϊ0��ʾ�����Ƶ�½,��0��ʾ���Ƶķ�����
    BYTE                byLeftLogTimes;                     // ����½ʧ��ԭ��Ϊ�������ʱ,ͨ���˲���֪ͨ�û�,ʣ���½����,Ϊ0ʱ��ʾ�˲�����Ч
    BYTE                bReserved[2];                       // �����ֽ�,�ֽڶ���
    int                 nLockLeftTime;                      // ����½ʧ��,�û�����ʣ��ʱ�䣨������, -1��ʾ�豸δ���øò���
    char                Reserved[24];                       // ����
} NET_DEVICEINFO_Ex, *LPNET_DEVICEINFO_Ex;

// �豸����汾��Ϣ,��16λ��ʾ���汾��,��16λ��ʾ�ΰ汾��
typedef struct 
{
    DWORD               dwSoftwareVersion;
    DWORD               dwSoftwareBuildDate;
    DWORD               dwDspSoftwareVersion;
    DWORD               dwDspSoftwareBuildDate;
    DWORD               dwPanelVersion;
    DWORD               dwPanelSoftwareBuildDate;
    DWORD               dwHardwareVersion;
    DWORD               dwHardwareDate;
    DWORD               dwWebVersion;
    DWORD               dwWebBuildDate;
} DH_VERSION_INFO, *LPDH_VERSION_INFO;

// �豸����汾��Ϣ,��ӦCLIENT_QueryDevState�ӿ�
typedef struct  
{
    char                szDevSerialNo[DH_DEV_SERIALNO_LEN];         // ���к�
    char                byDevType;                                  // �豸����,��ö��NET_DEVICE_TYPE
    char                szDevType[DH_DEV_TYPE_LEN];                 // �豸��ϸ�ͺ�,�ַ�����ʽ,����Ϊ��
    int                 nProtocalVer;                               // Э��汾��
    char                szSoftWareVersion[DH_MAX_URL_LEN];
    DWORD               dwSoftwareBuildDate;
    char                szPeripheralSoftwareVersion[DH_MAX_URL_LEN];// ��Ƭ�汾��Ϣ,�ַ�����ʽ,����Ϊ��
    DWORD               dwPeripheralSoftwareBuildDate;
    char                szGeographySoftwareVersion[DH_MAX_URL_LEN]; // ������Ϣ��λоƬ�汾��Ϣ,�ַ�����ʽ,����Ϊ��
    DWORD               dwGeographySoftwareBuildDate;
    char                szHardwareVersion[DH_MAX_URL_LEN];
    DWORD               dwHardwareDate;
    char                szWebVersion[DH_MAX_URL_LEN];
    DWORD               dwWebBuildDate;
    char                szDetailType[MAX_COMMON_STRING_64];          // �豸��ϸ�ͺ�,�ַ�����ʽ,����Ϊ��
    char                reserved[192];
} DHDEV_VERSION_INFO;

// DSP��������,��ӦCLIENT_GetDevConfig�ӿ�
typedef struct 
{
    DWORD               dwVideoStandardMask;        // ��Ƶ��ʽ����,��λ��ʾ�豸�ܹ�֧�ֵ���Ƶ��ʽ
    DWORD               dwImageSizeMask;            // �ֱ�������,��λ��ʾ�豸�ܹ�֧�ֵķֱ�������
    DWORD               dwEncodeModeMask;           // ����ģʽ����,��λ��ʾ�豸�ܹ�֧�ֵı���ģʽ����    
    DWORD               dwStreamCap;                // ��λ��ʾ�豸֧�ֵĶ�ý�幦��,
                                                    // ��һλ��ʾ֧��������
                                                    // �ڶ�λ��ʾ֧�ָ�����1
                                                    // ����λ��ʾ֧�ָ�����2
                                                    // ����λ��ʾ֧��jpgץͼ
    DWORD               dwImageSizeMask_Assi[8];    // ��ʾ������Ϊ���ֱ���ʱ,֧�ֵĸ������ֱ������롣
    DWORD               dwMaxEncodePower;           // DSP֧�ֵ���߱������� 
    WORD                wMaxSupportChannel;         // ÿ��DSP֧�����������Ƶͨ���� 
    WORD                wChannelMaxSetSync;         // DSPÿͨ���������������Ƿ�ͬ����0����ͬ��,1��ͬ��
} DH_DSP_ENCODECAP, *LPDH_DSP_ENCODECAP;

// DSP��������,��չ����,��ӦCLIENT_QueryDevState�ӿ�
typedef struct 
{
    DWORD               dwVideoStandardMask;        // ��Ƶ��ʽ����,��λ��ʾ�豸�ܹ�֧�ֵ���Ƶ��ʽ
    DWORD               dwImageSizeMask;            // �ֱ�������,��λ��ʾ�豸�ܹ�֧�ֵķֱ���
    DWORD               dwEncodeModeMask;           // ����ģʽ����,��λ��ʾ�豸�ܹ�֧�ֵı���ģʽ
    DWORD               dwStreamCap;                // ��λ��ʾ�豸֧�ֵĶ�ý�幦��,
                                                    // ��һλ��ʾ֧��������
                                                    // �ڶ�λ��ʾ֧�ָ�����1
                                                    // ����λ��ʾ֧�ָ�����2
                                                    // ����λ��ʾ֧��jpgץͼ
    DWORD               dwImageSizeMask_Assi[32];   // ��ʾ������Ϊ���ֱ���ʱ,֧�ֵĸ������ֱ������롣
    DWORD               dwMaxEncodePower;           // DSP֧�ֵ���߱������� 
    WORD                wMaxSupportChannel;         // ÿ��DSP֧�����������Ƶͨ���� 
    WORD                wChannelMaxSetSync;         // DSPÿͨ���������������Ƿ�ͬ����0����ͬ��,1��ͬ��
    BYTE                bMaxFrameOfImageSize[32];   // ��ͬ�ֱ����µ����ɼ�֡��,��dwVideoStandardMask��λ��Ӧ
    BYTE                bEncodeCap;                 // ��־,����ʱҪ�������������,�������ò�����Ч��
                                                    // 0���������ı�������+�������ı������� <= �豸�ı�������,
                                                    // 1���������ı�������+�������ı������� <= �豸�ı�������,
                                                    // �������ı������� <= �������ı�������,
                                                    // �������ķֱ��� <= �������ķֱ���,
                                                    // �������͸�������֡�� <= ǰ����Ƶ�ɼ�֡��
                                                    // 2��N5�ļ��㷽��
                                                    // �������ķֱ��� <= �������ķֱ���
                                                    // ��ѯ֧�ֵķֱ��ʺ���Ӧ���֡��
    char                reserved[95];
} DHDEV_DSP_ENCODECAP, *LPDHDEV_DSP_ENCODECAP;

// DSP��չ��������,��ӦCLIENT_QueryDevState�ӿ�
typedef struct 
{
    DWORD               dwVideoStandardMask;        // ��Ƶ��ʽ����,��λ��ʾ�豸�ܹ�֧�ֵ���Ƶ��ʽ
    DWORD               dwImageSizeMask;            // �ֱ�������,��λ��ʾ�豸�ܹ�֧�ֵķֱ���
    DWORD               dwEncodeModeMask;           // ����ģʽ����,��λ��ʾ�豸�ܹ�֧�ֵı���ģʽ
    DWORD               dwStreamCap;                // ��λ��ʾ�豸֧�ֵĶ�ý�幦��,
                                                    // ��һλ��ʾ֧��������
                                                    // �ڶ�λ��ʾ֧�ָ�����1
                                                    // ����λ��ʾ֧�ָ�����2
                                                    // ����λ��ʾ֧�ָ�����3
                                                    // ����λ��ʾ֧��jpgץͼ
    DWORD               dwImageSizeMask_Assi[3][64];// ��ʾ������Ϊ���ֱ���ʱ,֧�ֵĸ������ֱ�������, �����е�0,1,2Ԫ�طֱ��������1,2,3
    DWORD               dwMaxEncodePower;           // DSP֧�ֵ���߱������� 
    WORD                wMaxSupportChannel;         // ÿ��DSP֧�����������Ƶͨ���� 
    WORD                wChannelMaxSetSync;         // DSPÿͨ���������������Ƿ�ͬ����0����ͬ��,1��ͬ��
    BYTE                bMaxFrameOfImageSize[32];   // ��ͬ�ֱ����µ����ɼ�֡��,��dwVideoStandardMask��λ��Ӧ
    BYTE                bEncodeCap;                 // ��־,����ʱҪ�������������,�������ò�����Ч��
                                                    // 0���������ı�������+�������ı������� <= �豸�ı�������,
                                                    // 1���������ı�������+�������ı������� <= �豸�ı�������,
                                                    // �������ı������� <= �������ı�������,
                                                    // �������ķֱ��� <= �������ķֱ���,
                                                    // �������͸�������֡�� <= ǰ����Ƶ�ɼ�֡��
                                                    // 2��N5�ļ��㷽��
                                                    // �������ķֱ��� <= �������ķֱ���
                                                    // ��ѯ֧�ֵķֱ��ʺ���Ӧ���֡��
    BYTE                btReserve1[3];              // �ֽڶ���

    DWORD               dwExtraStream;              // ��0λ��ʾ������, ������λ���α�ʾ������, ���һλ��ʾ������1,�ڶ��Ǳ�ʾ������2
    DWORD               dwCompression[3];           // ÿһ��ֵ��ʾ��Ӧ�������ı����ʽ֧��
    
    char                reserved[108];
} DHDEV_DSP_ENCODECAP_EX, *LPDHDEV_DSP_ENCODECAP_EX;

// ϵͳ��Ϣ
typedef struct 
{
    DWORD               dwSize;
    /* �������豸��ֻ������ */
    DH_VERSION_INFO     stVersion;
    DH_DSP_ENCODECAP    stDspEncodeCap;                     // DSP��������
    BYTE                szDevSerialNo[DH_DEV_SERIALNO_LEN]; // ���к�
    BYTE                byDevType;                          // �豸����,��ö��NET_DEVICE_TYPE
    BYTE                szDevType[DH_DEV_TYPE_LEN];         // �豸��ϸ�ͺ�,�ַ�����ʽ,����Ϊ��
    BYTE                byVideoCaptureNum;                  // ��Ƶ������
    BYTE                byAudioCaptureNum;                  // ��Ƶ������
    BYTE                byTalkInChanNum;                    // �Խ�����ӿ�����
    BYTE                byTalkOutChanNum;                   // �Խ�����ӿ�����
    BYTE                byDecodeChanNum;                    // NSP
    BYTE                byAlarmInNum;                       // �����������
    BYTE                byAlarmOutNum;                      // �����������
    BYTE                byNetIONum;                         // �������
    BYTE                byUsbIONum;                         // USB������
    BYTE                byIdeIONum;                         // IDE����
    BYTE                byComIONum;                         // ��������
    BYTE                byLPTIONum;                         // ��������
    BYTE                byVgaIONum;                         // NSP
    BYTE                byIdeControlNum;                    // NSP
    BYTE                byIdeControlType;                   // NSP
    BYTE                byCapability;                       // NSP,��չ����
    BYTE                byMatrixOutNum;                     // ��Ƶ�����������
    /* �������豸�Ŀ�д���� */
    BYTE                byOverWrite;                        // Ӳ��������ʽ(���ǡ�ֹͣ)
    BYTE                byRecordLen;                        // ¼��������
    BYTE                byDSTEnable;                        // �Ƿ�ʵ������ʱ 1-ʵ�� 0-��ʵ��
    WORD                wDevNo;                             // �豸���,����ң��
    BYTE                byVideoStandard;                    // ��Ƶ��ʽ:0-PAL,1-NTSC
    BYTE                byDateFormat;                       // ���ڸ�ʽ
    BYTE                byDateSprtr;                        // ���ڷָ��(0��".",1��"-",2��"/")
    BYTE                byTimeFmt;                          // ʱ���ʽ (0-24Сʱ,1��12Сʱ)
    BYTE                byLanguage;                         // ö��ֵ���DH_LANGUAGE_TYPE
} DHDEV_SYSTEM_ATTR_CFG, *LPDHDEV_SYSTEM_ATTR_CFG;

// �޸��豸���÷�����Ϣ
typedef struct
{
    DWORD               dwType;                     // ����(��GetDevConfig��SetDevConfig������)
    WORD                wResultCode;                // �����룻0���ɹ�,1��ʧ��,2�����ݲ��Ϸ�,3����ʱ�޷�����,4��û��Ȩ��
    WORD                wRebootSign;                // �����־��0������Ҫ����,1����Ҫ�������Ч
    DWORD               dwReserved[2];              // ����    
} DEV_SET_RESULT;

// ������ӻ�طŵĴ��󷵻���Ϣ
typedef struct
{
    DWORD               dwResultCode;               // ���󷵻���
                                                    // 1:��Ȩ��,2:�豸��֧�ִ˲���,3:��Դ����, 4:�豸�޷���ȡ��ǰ��������
                                                    // 11:��ʾ�߼��û���ռ�ͼ��û���Դ, 12:��ֹ����, 13:���̶���������
                                                    // 14: �໭��Ԥ���Ѵ�,��Դ����,ѹ���ط�ʧ��, 15: ѹ���طŹ����Ѵ�,����ʧ�� 
    LLONG               lPlayHandle;                // ��Ӧ���ֵ
    BYTE                byReserved[32];             // �����ֽ�                         

}DEV_PLAY_RESULT;

// ��������Խ��Ĵ��󷵻���Ϣ
typedef struct
{
    DWORD               dwResultCode;               // ���󷵻��� CLIENT_GetLastError�ӿڵķ���ֵ
                                                    // NET_ERROR_TALK_REJECT _EC(375) // �ܾ��Խ�
                                                    // NET_ERROR_TALK_RESOURCE_CONFLICIT _EC(377) // ��Դ��ͻ
                                                    // NET_ERROR_TALK_UNSUPPORTED_ENCODE _EC(378) // ��֧�ֵ���������ʽ
                                                    // NET_ERROR_TALK_RIGHTLESS _EC(379) // ��Ȩ��
    LLONG               lTalkHandle;                // ��Ӧ���ֵ
    BYTE                byReserved[32];             // �����ֽ�                         
}DEV_TALK_RESULT;

//DST(����ʱ)����
typedef struct  
{
    int                 nYear;                      // ��[200 - 2037]
    int                 nMonth;                     // ��[1 - 12]
    int                 nHour;                      // Сʱ [0 - 23]
    int                 nMinute;                    // ���� [0 - 59]
    int                 nWeekOrDay;                 // [-1 - 4]0:��ʾʹ�ð����ڼ���ķ���
                                                    // 1: ���ܼ���: ��һ��,2: �ڶ���,3: ������,4: ������,-1: ���һ��
    union
    {
        int             iWeekDay;                   // ��[0 - 6](nWeekOrDay�����ܼ���ʱ)0:������, 1:����һ, 2:���ڶ�,3:������,4:������,5:������,6:������
        int             iDay;                       // ����[1 - 31] (nWeekOrDay�������ڼ���)
    };
    
    DWORD               dwReserved[8];              // ����    
}DH_DST_POINT;

typedef struct  
{
    DWORD               dwSize;
    int                 nDSTType;                   // ����ʱ��λ��ʽ 0:�����ڶ�λ��ʽ, 1:���ܶ�λ��ʽ
    DH_DST_POINT        stDSTStart;                 // ��ʼ����ʱ
    DH_DST_POINT        stDSTEnd;                   // ��������ʱ
    DWORD               dwReserved[16];             // ����    
}DHDEV_DST_CFG;


// �Զ�ά������
typedef struct
{
    DWORD               dwSize;
    BYTE                byAutoRebootDay;            // �Զ�����0���Ӳ�, 1��ÿ��,2��ÿ������,3��ÿ����һ,......
    BYTE                byAutoRebootTime;           // 0��0:00,1��1:00,......23��23:00
    BYTE                byAutoDeleteFilesTime;      // �Զ�ɾ���ļ���0���Ӳ�,1��24H,2��48H,3��72H,4��96H,5��ONE WEEK,6��ONE MONTH
    BYTE                reserved[13];               // ����λ
} DHDEV_AUTOMT_CFG;

// ������Ӳ����Ϣ
typedef struct  
{
    DWORD               dwSize;                                     // �ṹ���С,�����Ա����ʼ��
    DWORD               dwVolume;                                   // Ӳ������
    DWORD               dwFreeSpace;                                // Ӳ�̵�ʣ��ռ�, ��λMB(B��ʾ�ֽ�)
    BYTE                byModle[DH_MAX_HARDDISK_TYPE_LEN];          // Ӳ���ͺ�
    BYTE                bySerialNumber[DH_MAX_HARDDISK_SERIAL_LEN]; // Ӳ�����к�
}DHDEV_VEHICLE_DISK;

// ������ص�3Gģ����Ϣ,���֧��DH_MAX_SIM_NUM��ģ��
typedef struct
{
    DWORD               dwSize;                                     // �ṹ���С,�����Ա����ʼ��
    BYTE                szIMSI[DH_MAX_SIM_LEN];                     // SIM����ֵ����460012002778636 ,ǰ3λΪ���Ҵ���MCC,4-6λΪ�������MNC,�����Ϊ�ƶ��û���ݱ�ʶMSIN,�ܹ����ᳬ��15���ַ�
    BYTE                szMDN[DH_MAX_MDN_LEN];                      // SIM��MDNֵ
}DHDEV_VEHICLE_3GMODULE;

// ���صĻ�����Ϣ
typedef struct 
{
    DWORD                   dwSize;                                 // �ṹ���С,�����Ա����ʼ��
    DWORD                   dwSoftwareBuildDate;                    // �����������
    char                    szVersion[DH_MAX_VERSION_LEN];          // ����汾
    char                    szDevSerialNo[DH_DEV_SERIALNO_LEN];     // �������к�
    char                    szDevType[DH_DEV_TYPE_LEN];             // �豸��ϸ�ͺ�,�ַ�����ʽ,����Ϊ��
    DWORD                   dwDiskNum;                              // Ӳ�̸���
    DHDEV_VEHICLE_DISK      stuHarddiskInfo[DH_MAX_DISKNUM];        // Ӳ�������Ϣ
    DWORD                   dw3GModuleNum;                          // 3Gģ�����
    DHDEV_VEHICLE_3GMODULE  stu3GModuleInfo[DH_MAX_SIM_NUM];        // 3Gģ�������Ϣ
}DHDEV_VEHICLE_INFO;

// ����ӿ�,���֧��DH_MAX_NETINTERFACE_NUM������
typedef struct tagDHDEV_NETINTERFACE_INFO
{
    int             dwSize;
    BOOL            bValid;                                         // �Ƿ���Ч
    BOOL            bVirtual;                                       // �Ƿ���������
    int             nSpeed;                                         // ���������ٶ�(Mbps)
    int             nDHCPState;                                     // 0-δʹ��, 1-���ڻ�ȡ, 2-��ȡ�ɹ�
    char            szName[DH_NETINTERFACE_NAME_LEN];               // ��������
    char            szType[DH_NETINTERFACE_TYPE_LEN];               // ��������
    char            szMAC[DH_MACADDR_LEN];                          // MAC��ַ
    char            szSSID[DH_MAX_SSID_LEN];                        // SSID, ֻ������������Ч(szType == "Wireless")
    char            szConnStatus[DH_MAX_CONNECT_STATUS_LEN];        // Wifi��3G������״̬,"Inexistence" : ���粻���� "Down"���ر� "Disconn"��δ���� "Connecting"�������� "Connected"�� ������
    int             nSupportedModeNum;                              // ʵ��3G֧�ֵ�����ģʽ����
    char            szSupportedModes[DH_MAX_MODE_NUM][DH_MAX_MODE_LEN];// 3G֧�ֵ�����ģʽ    "TD-SCDMA", "WCDMA", "CDMA1x", "EDGE", "EVDO"
} DHDEV_NETINTERFACE_INFO;

//-----------------------------ͼ��ͨ������-------------------------------

// ���򣻸��߾ఴ����8192�ı���
typedef struct 
{
   long             left;
   long             top;
   long             right;
   long             bottom;
} DH_RECT, *LPDH_RECT;

typedef struct tagNET_RECT
{
    int             nLeft;
    int             nTop;
    int             nRight;
    int             nBottom;
} NET_RECT;

// ��ά�ռ��
typedef struct 
{
   short            nx;
   short            ny;
} DH_POINT, *LPDH_POINT;

// ��������߶�����Ϣ
typedef struct
{
    int        nPointNum;                               // ������
    DH_POINT   stuPoints[DH_MAX_DETECT_REGION_NUM];     // ������Ϣ
}DH_POLY_POINTS;

// OSD���Խṹ
typedef struct  tagENCODE_WIDGET
{
    DWORD               rgbaFrontground;                // �����ǰ�������ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����
    DWORD               rgbaBackground;                 // ����ı��������ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����
    DH_RECT             rcRect;                         // λ��
    BYTE                bShow;                          // ��ʾʹ��
    BYTE                bExtFuncMask;                   // ��չʹ�� ,���� 
                                                        // bit0 ��ʾ�Ƿ���ʾ���ڼ�,0-����ʾ 1-��ʾ 
    BYTE                byReserved[2];
} DH_ENCODE_WIDGET, *LPDH_ENCODE_WIDGET;

// ͨ������Ƶ����
typedef struct 
{
    // ��Ƶ����
    BYTE                byVideoEnable;                  // ��Ƶʹ�ܣ�1����,0���ر�
    BYTE                byBitRateControl;               // �������ƣ����ճ���"��������"����
    BYTE                byFramesPerSec;                 // ֡��
    BYTE                byEncodeMode;                   // ����ģʽ�����ճ���"����ģʽ"����
    BYTE                byImageSize;                    // �ֱ��ʣ����ճ���"�ֱ���"����
    BYTE                byImageQlty:7;                  // ��byImageQlty������չ,��byImageQltyΪ0,ץͼ���õ�ImgQltyΪ10/30/50/60/80/100����ֵ,�������õ�ImgQltyֵΪ1-6,����֮ǰ��1-6����,��//ImgQltyTypeΪ1,��ImgQlty��ΧΪ0~100
    BYTE                byImageQltyType:1;       
    WORD                wLimitStream;                   // ����������
    // ��Ƶ����
    BYTE                byAudioEnable;                  // ��Ƶʹ�ܣ�1����,0���ر�
    BYTE                wFormatTag;                     // ��Ƶ��������: 0:G711A,1:PCM,2:G711U,3:AMR,4:AAC
    WORD                nChannels;                      // ������
    WORD                wBitsPerSample;                 // �������    
    BYTE                bAudioOverlay;                  // ��Ƶ����ʹ��
    BYTE                bH264ProfileRank;               // H.264 Profile�ȼ�(������ģʽΪH264ʱ�˲���ֵ��Ч),����ö������EM_H264_PROFILE_RANK,��0,������ǰ,��ʾ���ֶ���Ч,����Ҫ���Ǽ���
    DWORD               nSamplesPerSec;                 // ������
    BYTE                bIFrameInterval;                // I֡���֡����,��������I֮֡���P֡����,0-149
    BYTE                bScanMode;                      // NSP
    BYTE                bReserved_3;
    BYTE                bReserved_4;
} DH_VIDEOENC_OPT, *LPDH_VIDEOENC_OPT;

// ������ɫ����
typedef struct 
{
    DH_TSECT            stSect;
    BYTE                byBrightness;                   // ���ȣ�0-100
    BYTE                byContrast;                     // �Աȶȣ�0-100
    BYTE                bySaturation;                   // ���Ͷȣ�0-100
    BYTE                byHue;                          // ɫ�ȣ�0-100
    BYTE                byGainEn;                       // ����ʹ��
    BYTE                byGain;                         // ���棻0-100
    BYTE                byGamma;                        // ٤��ֵ 0-100
    BYTE                byReserved[1];
} DH_COLOR_CFG, *LPDH_COLOR_CFG;

// ͼ��ͨ�����Խṹ��
typedef struct 
{
    WORD                dwSize;
    BYTE                bNoise;
    BYTE                bMode;                          // (������������)ģʽһ(��������):¼��ֱ��ʲ���4·D1,֡��2fps,����128kbps(ÿСʱ225MB)
                                                        // ģʽ��(��������):¼��ֱ��ʲ���4·CIF,֡��12fps,����256kbps(ÿСʱ550MB)
                                                        // ģʽ��(�Զ���)¼��ֱ��ʿ������û��Զ���,�޶��������Ϊ4CIF/25fps
    char                szChannelName[DH_CHAN_NAME_LEN];
    DH_VIDEOENC_OPT     stMainVideoEncOpt[DH_REC_TYPE_NUM];
    DH_VIDEOENC_OPT     stAssiVideoEncOpt[DH_N_ENCODE_AUX];        
    DH_COLOR_CFG        stColorCfg[DH_N_COL_TSECT];
    DH_ENCODE_WIDGET    stTimeOSD;
    DH_ENCODE_WIDGET    stChannelOSD;
    DH_ENCODE_WIDGET    stBlindCover[DH_N_COVERS];      // �������ڵ�
    BYTE                byBlindEnable;                  // �����ڸǿ��أ�0x00����ʹ���ڸ�,0x01�����ڸ��豸����Ԥ��,0x10�����ڸ�¼������Ԥ��,0x11�����ڸ�
    BYTE                byBlindMask;                    // �����ڸ����룻��һλ���豸����Ԥ�����ڶ�λ��¼��(������Ԥ��) */
    BYTE                bVolume;                        // ������ֵ(0~100�ɵ�)
    BYTE                bVolumeEnable;                  // ������ֵʹ��
} DHDEV_CHANNEL_CFG, *LPDHDEV_CHANNEL_CFG;

// Ԥ��ͼ�����
typedef struct 
{
    DWORD               dwSize;
    DH_VIDEOENC_OPT     stPreView;
    DH_COLOR_CFG        stColorCfg[DH_N_COL_TSECT];
}DHDEV_PREVIEW_CFG;

// ץͼ��������
typedef struct _config_snap_control
{
    BYTE                bySnapState[32];                // ÿ��ͨ����Ӧץͼ���� 0:�Զ�(���ʾ�Ƿ�ץͼ,���������ú��¼�����); 1:ץͼ����; 2:ץͼ�ر�
    BYTE                byReserved[480];
}DHDEV_SNAP_CONTROL_CFG;

enum _gps_mode
{
    GPS_OR_GLONASS_MODE,            // GPS��GLONASS���ģʽ(ģ�鶨λ���ݴ�GPS��GLONASS�����л�ȡ,��������Դ���ĸ�ϵͳ����ȷ��,����ģ���ڲ��Զ��ᴦ��)
    GLONASS_MODE,                   // GLONASSģʽ(��ģ��Ķ�λ���ݴӶ���˹��GLONASS��λϵͳ�л�ȡ)
    GPS_MODE,                       // GPSģʽ(��ģ��Ķ�λ���ݴ�������GPSϵͳ�л�ȡ) 
};
// DH_DEV_GPS_MODE_CFG ���ýṹ
typedef struct tagDHDEV_GPS_MODE_CFG
{
    BYTE                byGPSMode;                      // GPS��λģʽ,��
    BYTE                byRev[255];
}DHDEV_GPS_MODE_CFG;

// ͼƬ�ϴ�������Ϣ DH_DEV_SNAP_UPLOAD_CFG ���ýṹ
typedef struct tagDHDEV_SNAP_UPLOAD_CFG
{
    int                 nUploadInterval;                //��ʱץͼͼƬ�ϴ����,��λ��
    BYTE                byReserved[252];    
}DHDEV_SNAP_UPLOAD_CFG;


// DHDEV_SPEED_LIMIT_CFG ���ýṹ
typedef struct tagDHDEV_SPEED_LIMIT_CFG
{
    BYTE                byEnable;                       // ����ʹ��1��ʹ�ܣ�0����ʹ�ܡ�
    BYTE                byReserved1;                    // �����ֶ�
    WORD                wMaxSpeed;                      // �ٶ�����ֵ����λKM/H 0��ʾ������,����0��ʾ����
    WORD                wMinSpeed;                      // �ٶ�����ֵ����λKM/H 0��ʾ������,����0��ʾ����
    BYTE                byReserved2[122];               // �����ֶ�
}DHDEV_SPEED_LIMIT_CFG;

// ����·������
typedef struct
{
    BOOL                bEnable;                        // ʹ��
    char                szSSID[36];                     // SSID����
    BOOL                bHideSSID;                      // �Ƿ�����SSID
    char                szIP[DH_MAX_IPADDR_LEN];        // IP
    char                szSubMark[DH_MAX_IPADDR_LEN];   // ��������
    char                szGateWay[DH_MAX_IPADDR_LEN];   // ����
    char                szCountry[32];                  // ����, DefaultĬ�ϲ�ָ�������������б�ο�����·��������Ϣ
    int                 nSafeType;                      // ��Ȩģʽ: 1-������; 2-WEPģʽ; 2-WPA-PSKģʽ; 3-WPA2-PSKģʽ
    int                 nEncryption;                    // ���ܷ�ʽ: WEPģʽ(1-�Զ� 2-���� 3-����); WPA-PSKģʽ/WPA2-PSKģʽ(4-TKIP 5-AES)
    char                szKey[32];                      // ������Կ
    int                 nChannel;                       // �ŵ�, ��Ч�ŵ��б�ο�����·��������Ϣ
    BOOL                bAutoChannelSelect;             // �Զ�ѡ���ŵ�    
}DHDEV_WIRELESS_ROUTING_CFG;

//-------------------------------��������---------------------------------

// ���ڻ�������
typedef struct
{
    BYTE                byDataBit;                      // ����λ��0��5,1��6,2��7,3��8
    BYTE                byStopBit;                      // ֹͣλ��0��1λ,1��1.5λ,2��2λ
    BYTE                byParity;                       // У��λ��0����У��,1����У�飻2��żУ��; 3:��־У��; 4:��У��
    BYTE                byBaudRate;                     // �����ʣ�0��300,1��600,2��1200,3��2400,4��4800,
                                                        // 5��9600,6��19200,7��38400,8��57600,9��115200
} DH_COMM_PROP;

// 485����������
typedef struct
{ 
    DH_COMM_PROP        struComm;
    BYTE                wProtocol;                      // Э������,��Ӧ"Э�����б�"�±�
    BYTE                bPTZType;                       // 0-����,������̨ 1-Զ��������̨,ͨ��������ѯ(��DEV_ENCODER_CFG)��
    BYTE                wDecoderAddress;                // ��������ַ��0 - 255
    BYTE                byMartixID;                     // �����
} DH_485_CFG;

// 232��������
typedef struct
{
    DH_COMM_PROP        struComm;
    BYTE                byFunction;                     // ���ڹ���,��Ӧ"�������б�"�±�
    BYTE                byReserved[3];
} DH_RS232_CFG;

// �������ýṹ��
typedef struct
{
    DWORD               dwSize;

    DWORD               dwDecProListNum;                                        // ������Э�����
    char                DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];   // Э�����б�
    DH_485_CFG          stDecoder[DH_MAX_DECODER_NUM];                          // ����������ǰ����

    DWORD               dw232FuncNameNum;                                       // 232���ܸ���
    char                s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];         // �������б�
    DH_RS232_CFG        st232[DH_MAX_232_NUM];                                  // ��232���ڵ�ǰ����
} DHDEV_COMM_CFG;

// ��չ�������ýṹ��
typedef struct
{
    DWORD               dwSize;
    
    DWORD               dwDecProListNum;                                        // ������Э�����
    char                DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];   // Э�����б�
    DH_485_CFG          stDecoder[DH_MAX_DECODER_NUM];                          // ����������ǰ����
    
    DWORD               dw232FuncNameNum;                                       // 232���ܸ���
    char                s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];         // �������б�
    DWORD               dw232ComNum;                                            // 232���ڸ���   
    DH_RS232_CFG        st232[DH_MAX_232_NUM_EX];                               // ��232���ڵ�ǰ����
} DHDEV_COMM_CFG_EX;

// ����״̬
typedef struct
{
    unsigned int        uBeOpened;
    unsigned int        uBaudRate;
    unsigned int        uDataBites;
    unsigned int        uStopBits;
    unsigned int        uParity;
    BYTE                bReserved[32];
} DH_COMM_STATE;

//-------------------------------¼������---------------------------------

// ��ʱ¼��
typedef struct 
{
    DWORD               dwSize;
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    BYTE                byPreRecordLen;                     // Ԥ¼ʱ��,��λ��s,0��ʾ��Ԥ¼
    BYTE                byRedundancyEn;                     // ¼�����࿪��
    BYTE                byRecordType;                       // ¼���������ͣ�0-������ 1-������1 2-������2 3-������3
    BYTE                byReserved;
} DHDEV_RECORD_CFG, *LPDH_RECORD_CFG;

// NTP����
typedef struct  
{
    BOOL                bEnable;                            // �Ƿ�����
    int                 nHostPort;                          // NTP������Ĭ�϶˿�Ϊ123
    char                szHostIp[32];                       // ����IP
    char                szDomainName[128];                  // ����
    int                 nType;                              // ��������,0����ʾIP,1����ʾ����,2����ʾIP������
    int                 nUpdateInterval;                    // ����ʱ��(����)
    int                 nTimeZone;                          // ��DH_TIME_ZONE_TYPE
    char                reserved[128];
} DHDEV_NTP_CFG;

// FTP�ϴ�����
typedef struct
{
    struct
    {
        DH_TSECT        struSect;                           // ��ʱ����ڵġ�ʹ�ܡ���Ч,�ɺ���
        BOOL            bMdEn;                              // �ϴ���̬���¼��
        BOOL            bAlarmEn;                           // �ϴ��ⲿ����¼��
        BOOL            bTimerEn;                           // �ϴ���ͨ��ʱ¼��
        DWORD           dwRev[4];
    } struPeriod[DH_TIME_SECTION];
} DH_FTP_UPLOAD_CFG;

typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;                            // �Ƿ�����
    char                szHostIp[DH_MAX_IPADDR_LEN];        // ����IP
    WORD                wHostPort;                          // �����˿�
    char                szDirName[DH_FTP_MAX_PATH];         // FTPĿ¼·��
    char                szUserName[DH_FTP_USERNAME_LEN];    // �û���
    char                szPassword[DH_FTP_PASSWORD_LEN];    // ����
    int                 iFileLen;                           // �ļ�����
    int                 iInterval;                          // �����ļ�ʱ����(1~600),��λ�� 
    DH_FTP_UPLOAD_CFG   struUploadCfg[DH_MAX_CHANNUM][DH_N_WEEKS];
    char                protocol;                           // 0-FTP 1-SMB 2-NFS,3-ISCSI
    char                NASVer;                             // ����洢�������汾0=�ϵ�FTP(��������ʾʱ���),1=NAS�洢(����������ʱ���)
    DWORD               dwFunctionMask;                     // ������������,��λ��ʾ,��16λ(����洢)���α�ʾFTP,SMB,NFS,ISCSI, ��16λ(���ش洢)����ΪDISK,U
    BYTE                bDataType;                          // ��������, 0-��������, 1-��Ƶ, 2-ͼƬ
    BYTE                reserved[123];
} DHDEV_FTP_PROTO_CFG;

// FTP�ϴ���չ����(֧��ͨ����������FTP�洢·��,���洢ͼƬ����)
typedef struct 
{
    int            nMaxPictures;                             // �ܴ洢����,ÿһ��ͨ���ļ����е�ͼƬ������������,
                                                             // �������ƾ͸����ϵ��ļ�,0:��ʾ������,д��Ϊֹ
    char           szPreChannelName[DH_FTP_MAX_SUB_PATH];    // ͼƬ�ļ���
    char           szFTPChannelPath[DH_FTP_MAX_SUB_PATH];    // ftp�洢·��(�洢��Ŀ¼)
    char           szRev[128];                               // �����ֶ�
}DHDEV_FTP_CHANNEL_CFG; 


typedef struct 
{ 
    DHDEV_FTP_PROTO_CFG       stuFtpNormalSet;                     // FTPԭ�й���,��չͨ����
    DHDEV_FTP_CHANNEL_CFG     stuFtpChannelSet[DH_MAX_CHANNUM];    // FTP��չ����
    char                      szRev[128];                          // �����ֶ�
}DHDEV_FTP_PROTO_CFG_EX;

//-------------------------------��������---------------------------------

// ��̫������
typedef struct 
{
    char                sDevIPAddr[DH_MAX_IPADDR_LEN];      // DVR IP ��ַ
    char                sDevIPMask[DH_MAX_IPADDR_LEN];      // DVR IP ��ַ����
    char                sGatewayIP[DH_MAX_IPADDR_LEN];      // ���ص�ַ

    /*
     * 1��10Mbps ȫ˫��
     * 2��10Mbps ����Ӧ
     * 3��10Mbps ��˫��
     * 4��100Mbps ȫ˫��
     * 5��100Mbps ����Ӧ
     * 6��100Mbps ��˫��
     * 7������Ӧ
     */
    // Ϊ����չ��DWORD����ĸ�
    BYTE                dwNetInterface;                     // NSP
    BYTE                bTranMedia;                         // 0������,1������
    BYTE                bValid;                             // ��λ��ʾ,��һλ��1����Ч 0����Ч���ڶ�λ��0��DHCP�ر� 1��DHCPʹ�ܣ�����λ��0����֧��DHCP 1��֧��DHCP
    BYTE                bDefaultEth;                        // �Ƿ���ΪĬ�ϵ����� 1��Ĭ�� 0����Ĭ��
    char                byMACAddr[DH_MACADDR_LEN];          // MAC��ַ,ֻ��
} DH_ETHERNET; 

// Զ����������
typedef struct 
{
    BYTE                byEnable;                           // ����ʹ��
    BYTE                byAssistant;                        // Ŀǰֻ����PPPoE����������,0���������������ţ�1�������������ϲ���
    WORD                wHostPort;                          // Զ������ �˿�
    char                sHostIPAddr[DH_MAX_IPADDR_LEN];     // Զ������ IP ��ַ        
    char                sHostUser[DH_MAX_HOST_NAMELEN];     // Զ������ �û���
    char                sHostPassword[DH_MAX_HOST_PSWLEN];  // Զ������ ����
} DH_REMOTE_HOST;

// �ʼ�����
typedef struct 
{
    char                sMailIPAddr[DH_MAX_IPADDR_LEN];     // �ʼ�������IP��ַ
    WORD                wMailPort;                          // �ʼ��������˿�
    WORD                wReserved;                          // ����
    char                sSenderAddr[DH_MAX_MAIL_ADDR_LEN];  // ���͵�ַ
    char                sUserName[DH_MAX_NAME_LEN];         // �û���
    char                sUserPsw[DH_MAX_NAME_LEN];          // �û�����
    char                sDestAddr[DH_MAX_MAIL_ADDR_LEN];    // Ŀ�ĵ�ַ
    char                sCcAddr[DH_MAX_MAIL_ADDR_LEN];      // ���͵�ַ
    char                sBccAddr[DH_MAX_MAIL_ADDR_LEN];     // ������ַ
    char                sSubject[DH_MAX_MAIL_SUBJECT_LEN];  // ����
} DH_MAIL_CFG;

// �������ýṹ��
typedef struct
{ 
    DWORD               dwSize; 
    char                sDevName[DH_MAX_NAME_LEN];          // �豸������
    WORD                wTcpMaxConnectNum;                  // TCP���������
    WORD                wTcpPort;                           // TCP֡���˿�
    WORD                wUdpPort;                           // UDP�����˿�
    WORD                wHttpPort;                          // HTTP�˿ں�
    WORD                wHttpsPort;                         // HTTPS�˿ں�
    WORD                wSslPort;                           // SSL�˿ں�
    DH_ETHERNET         stEtherNet[DH_MAX_ETHERNET_NUM];    // ��̫����
    DH_REMOTE_HOST      struAlarmHost;                      // ����������
    DH_REMOTE_HOST      struLogHost;                        // ��־������
    DH_REMOTE_HOST      struSmtpHost;                       // SMTP������
    DH_REMOTE_HOST      struMultiCast;                      // �ಥ��
    DH_REMOTE_HOST      struNfs;                            // NFS������
    DH_REMOTE_HOST      struPppoe;                          // PPPoE������
    char                sPppoeIP[DH_MAX_IPADDR_LEN];        // PPPoEע�᷵�ص�IP
    DH_REMOTE_HOST      struDdns;                           // DDNS������
    char                sDdnsHostName[DH_MAX_HOST_NAMELEN]; // DDNS������
    DH_REMOTE_HOST      struDns;                            // DNS������
    DH_MAIL_CFG         struMail;                           // �ʼ�����
} DHDEV_NET_CFG;

// ��̫����չ����
typedef struct 
{
    char                sDevIPAddr[DH_MAX_IPADDR_LEN];      // DVR IP ��ַ
    char                sDevIPMask[DH_MAX_IPADDR_LEN];      // DVR IP ��ַ����
    char                sGatewayIP[DH_MAX_IPADDR_LEN];      // ���ص�ַ

    /*
     * 1��10Mbps ȫ˫��
     * 2��10Mbps ����Ӧ
     * 3��10Mbps ��˫��
     * 4��100Mbps ȫ˫��
     * 5��100Mbps ����Ӧ
     * 6��100Mbps ��˫��
     * 7������Ӧ
     */
    // Ϊ����չ��DWORD����ĸ�
    BYTE                dwNetInterface;                     // NSP
    BYTE                bTranMedia;                         // 0������,1������
    BYTE                bValid;                             // ��λ��ʾ,��һλ��1����Ч 0����Ч���ڶ�λ��0��DHCP�ر� 1��DHCPʹ�ܣ�����λ��0����֧��DHCP 1��֧��DHCP
    BYTE                bDefaultEth;                        // �Ƿ���ΪĬ�ϵ����� 1��Ĭ�� 0����Ĭ��
    char                byMACAddr[DH_MACADDR_LEN];          // MAC��ַ,ֻ��
    BYTE                bMode;                              // ��������ģʽ, 0:��ģʽ, 1:���ؾ���ģʽ, 2:��ַģʽ, 3:�ݴ�ģʽ
    BYTE                bReserved1[3];                      // �ֽڶ���
    char                szEthernetName[DH_MAX_NAME_LEN];    // ������,ֻ��
    BYTE                bReserved[12];                      // �����ֽ�   
} DH_ETHERNET_EX; 

// ��չ�������ýṹ��
typedef struct
{ 
    DWORD               dwSize; 
    char                sDevName[DH_MAX_NAME_LEN];          // �豸������
    WORD                wTcpMaxConnectNum;                  // TCP���������
    WORD                wTcpPort;                           // TCP֡���˿�
    WORD                wUdpPort;                           // UDP�����˿�
    WORD                wHttpPort;                          // HTTP�˿ں�
    WORD                wHttpsPort;                         // HTTPS�˿ں�
    WORD                wSslPort;                           // SSL�˿ں�
    int                 nEtherNetNum;                       // ��̫������
    DH_ETHERNET_EX      stEtherNet[DH_MAX_ETHERNET_NUM_EX]; // ��̫����
    DH_REMOTE_HOST      struAlarmHost;                      // ����������
    DH_REMOTE_HOST      struLogHost;                        // ��־������
    DH_REMOTE_HOST      struSmtpHost;                       // SMTP������
    DH_REMOTE_HOST      struMultiCast;                      // �ಥ��
    DH_REMOTE_HOST      struNfs;                            // NFS������
    DH_REMOTE_HOST      struPppoe;                          // PPPoE������
    char                sPppoeIP[DH_MAX_IPADDR_LEN];        // PPPoEע�᷵�ص�IP
    DH_REMOTE_HOST      struDdns;                           // DDNS������
    char                sDdnsHostName[DH_MAX_HOST_NAMELEN]; // DDNS������
    DH_REMOTE_HOST      struDns;                            // DNS������
    DH_MAIL_CFG         struMail;                           // �ʼ�����
    BYTE                bReserved[128];                     // �����ֽ�
} DHDEV_NET_CFG_EX;

// ��ddns���ýṹ��
typedef struct
{
    DWORD               dwId;                                           // ddns������id��
    BOOL                bEnable;                                        // ʹ��,ͬһʱ��ֻ����һ��ddns����������ʹ��״̬
    char                szServerType[DH_MAX_SERVER_TYPE_LEN];           // ����������,ϣ��..
    char                szServerIp[DH_MAX_DOMAIN_NAME_LEN];             // ������ip��������
    DWORD               dwServerPort;                                   // �������˿�
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];           // dvr����,��jeckean.3322.org
    char                szUserName[DH_MAX_HOST_NAMELEN];                // �û���
    char                szUserPsw[DH_MAX_HOST_PSWLEN];                  // ����
    char                szAlias[DH_MAX_DDNS_ALIAS_LEN];                 // ����������
    DWORD               dwAlivePeriod;                                  // DDNS ����ʱ��
    BYTE                ByMode;                                         // ����ģʽ:0-�ֶ���������,szDomainName��Ч; 1-Ĭ������szDefaultDomainName��Ч��
    char                szDefaultDomainName[DH_MAX_DEFAULT_DOMAIN_LEN]; // Ĭ������,ֻ��
    BYTE                bReserved[3];                                   // �ֽڶ���
    char                szEmailUserName[DH_MAX_MAIL_NAME_LEN];          // �����û���
    char                reserved[128];
} DH_DDNS_SERVER_CFG;

typedef struct
{
    DWORD                dwSize;
    DWORD                dwDdnsServerNum;    
    DH_DDNS_SERVER_CFG   struDdnsServer[DH_MAX_DDNS_NUM];    
} DHDEV_MULTI_DDNS_CFG;

// �ʼ����ýṹ��
typedef struct 
{
    char                sMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];    // �ʼ���������ַ(IP��������)
    char                sSubMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];
    WORD                wMailPort;                              // �ʼ��������˿�
    WORD                wSubMailPort;
    WORD                wReserved;                              // ����
    char                sSenderAddr[DH_MAX_MAIL_ADDR_LEN];      // ���͵�ַ
    char                sUserName[DH_MAX_MAIL_NAME_LEN];        // �û���
    char                sUserPsw[DH_MAX_MAIL_NAME_LEN];         // �û�����
    char                sDestAddr[DH_MAX_MAIL_ADDR_LEN];        // Ŀ�ĵ�ַ
    char                sCcAddr[DH_MAX_MAIL_ADDR_LEN];          // ���͵�ַ
    char                sBccAddr[DH_MAX_MAIL_ADDR_LEN];         // ������ַ
    char                sSubject[DH_MAX_MAIL_SUBJECT_LEN];      // ����
    BYTE                bEnable;                                // ʹ��0:false,    1:true
    BYTE                bSSLEnable;                             // SSLʹ��
    WORD                wSendInterval;                          // ����ʱ����,[0,3600]��
    BYTE                bAnonymous;                             // ����ѡ��[0,1], 0��ʾFALSE,1��ʾTRUE.
    BYTE                bAttachEnable;                          // ����ʹ��[0,1], 0��ʾFALSE,1��ʾTRUE.
    char                reserved[154];
} DHDEV_MAIL_CFG;

// DNS����������
typedef struct  
{
    char                szPrimaryIp[DH_MAX_IPADDR_LEN];
    char                szSecondaryIp[DH_MAX_IPADDR_LEN];
    char                reserved[256];
} DHDEV_DNS_CFG;

// ¼�����ز�������
typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;                                // TRUE����������,FALSE����ͨ����
}DHDEV_DOWNLOAD_STRATEGY_CFG;

// ���紫���������
typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;
    int                 iStrategy;                              // 0����������,1������������,2���Զ�
}DHDEV_TRANSFER_STRATEGY_CFG;

// ���õ���ʱ����ز���
typedef struct  
{
    int                 nWaittime;                              // �ȴ���ʱʱ��(����Ϊ��λ),Ϊ0Ĭ��5000ms
    int                 nConnectTime;                           // ���ӳ�ʱʱ��(����Ϊ��λ),Ϊ0Ĭ��1500ms
    int                 nConnectTryNum;                         // ���ӳ��Դ���,Ϊ0Ĭ��1��
    int                 nSubConnectSpaceTime;                   // ������֮��ĵȴ�ʱ��(����Ϊ��λ),Ϊ0Ĭ��10ms
    int                 nGetDevInfoTime;                        // ��ȡ�豸��Ϣ��ʱʱ��,Ϊ0Ĭ��1000ms
    int                 nConnectBufSize;                        // ÿ�����ӽ������ݻ����С(�ֽ�Ϊ��λ),Ϊ0Ĭ��250*1024
    int                 nGetConnInfoTime;                       // ��ȡ��������Ϣ��ʱʱ��(����Ϊ��λ),Ϊ0Ĭ��1000ms
    int                 nSearchRecordTime;                      // ��ʱ���ѯ¼���ļ��ĳ�ʱʱ��(����Ϊ��λ),Ϊ0Ĭ��Ϊ3000ms
    int                 nsubDisconnetTime;                      // ��������Ӷ��ߵȴ�ʱ��(����Ϊ��λ),Ϊ0Ĭ��Ϊ60000ms
    BYTE                byNetType;                              // ��������, 0-LAN, 1-WAN
    BYTE                byPlaybackBufSize;                      // �ط����ݽ��ջ����С��MΪ��λ��,Ϊ0Ĭ��Ϊ4M
    BYTE                bDetectDisconnTime;                     // ����������ʱ��(��λΪ��),Ϊ0Ĭ��Ϊ60s,��Сʱ��Ϊ2s
    BYTE                bKeepLifeInterval;                      // ���������ͼ��(��λΪ��),Ϊ0Ĭ��Ϊ10s,��С���Ϊ2s
    int                 nPicBufSize;                            // ʵʱͼƬ���ջ����С���ֽ�Ϊ��λ��,Ϊ0Ĭ��Ϊ2*1024*1024
    BYTE                bReserved[4];                           // �����ֶ��ֶ�
} NET_PARAM;

// ��ӦCLIENT_SearchDevices�ӿ�
typedef struct 
{
    char                szIP[DH_MAX_IPADDR_LEN];                // IP
    int                 nPort;                                  // tcp�˿�
    char                szSubmask[DH_MAX_IPADDR_LEN];           // ��������
    char                szGateway[DH_MAX_IPADDR_LEN];           // ����
    char                szMac[DH_MACADDR_LEN];                  // MAC��ַ
    char                szDeviceType[DH_DEV_TYPE_LEN];          // �豸����
    BYTE                byManuFactory;                          // Ŀ���豸����������,����ο�EM_IPC_TYPE��
    BYTE                byIPVersion;                            // 4: IPv4, szXXXΪ����ַ�����ʽ;  6:IPv6, szXXXΪ128λ(16�ֽ�)��ֵ��ʽ
	BYTE				byInitStatus;							// �豸��ʼ��״̬����λȷ����ʼ��״̬
																// bit0~1��0-���豸��û�г�ʼ������ 1-δ��ʼ���˺� 2-�ѳ�ʼ���˻�
																// bit2~3��0-���豸������ 1-��������δʹ�� 2-����������ʹ��
																// bit4~5��0-���豸������ 1-�ֻ�ֱ��δʹ�� 2-�ֻ�ֱ��ʹ��
	
	BYTE				byPwdResetWay;							// ֧���������÷�ʽ����λȷ���������÷�ʽ��ֻ���豸�г�ʼ���˺�ʱ������															
																// bit0-֧��Ԥ���ֻ��� bit1-֧��Ԥ������ bit2-֧���ļ�����
	BYTE				bySpecialAbility;						// �豸��ʼ����������λȷ����ʼ��״̬,bit0-2D Code�޸�IP: 0 ��֧�� 1 ֧��,bit1-PN��:0 ��֧�� 1 ֧��
    BYTE                bReserved[27];                          // �����ֽ�
} DEVICE_NET_INFO;

// ��ӦCLIENT_StartSearchDevices�ӿ�
typedef struct 
{
    int                 iIPVersion;                             // 4 for IPV4, 6 for IPV6
    char                szIP[64];                               // IP IPV4����"192.168.0.1" IPV6����"2008::1/64"
    int                 nPort;                                  // tcp�˿�
    char                szSubmask[64];                          // �������� IPV6����������
    char                szGateway[64];                          // ����
    char                szMac[DH_MACADDR_LEN];                  // MAC��ַ
    char                szDeviceType[DH_DEV_TYPE_LEN];          // �豸����
    BYTE                byManuFactory;                          // Ŀ���豸����������,����ο�EM_IPC_TYPE��    
    BYTE                byDefinition;                           // 1-���� 2-����
    bool                bDhcpEn;                                // Dhcpʹ��״̬, true-��, false-��
    BYTE                byReserved1;                            // �ֽڶ���
    char                verifyData[88];                         // У������ ͨ���첽�����ص���ȡ(���޸��豸IPʱ���ô���Ϣ����У��)
    char                szSerialNo[DH_DEV_SERIALNO_LEN];        // ���к�
    char                szDevSoftVersion[DH_MAX_URL_LEN];       // �豸����汾��    
    char                szDetailType[DH_DEV_TYPE_LEN];          // �豸�ͺ�
    char                szVendor[DH_MAX_STRING_LEN];            // OEM�ͻ�����
    char                szDevName[DH_MACHINE_NAME_NUM];         // �豸����
    char                szUserName[DH_USER_NAME_LENGTH_EX];     // ��½�豸�û��������޸��豸IPʱ��Ҫ��д��
    char                szPassWord[DH_USER_NAME_LENGTH_EX];     // ��½�豸���루���޸��豸IPʱ��Ҫ��д��
    unsigned short      nHttpPort;                              // HTTP����˿ں�
    WORD                wVideoInputCh;                          // ��Ƶ����ͨ����
    WORD                wRemoteVideoInputCh;                    // Զ����Ƶ����ͨ����
    WORD                wVideoOutputCh;                         // ��Ƶ���ͨ����
    WORD                wAlarmInputCh;                          // ��������ͨ����
    WORD                wAlarmOutputCh;                         // �������ͨ������
    BOOL                bNewWordLen;                            // TRUEʹ���������ֶ�szNewPassWord
    char                szNewPassWord[DH_COMMON_STRING_64];     // ��½�豸���루���޸��豸IPʱ��Ҫ��д��
    BYTE				byInitStatus;							// �豸��ʼ��״̬����λȷ����ʼ��״̬
																// bit0~1��0-���豸��û�г�ʼ������ 1-δ��ʼ���˺� 2-�ѳ�ʼ���˻�
																// bit2~3��0-���豸������ 1-��������δʹ�� 2-����������ʹ��
																// bit4~5��0-���豸������ 1-�ֻ�ֱ��δʹ�� 2-�ֻ�ֱ��ʹ��

	BYTE				byPwdResetWay;							// ֧���������÷�ʽ����λȷ���������÷�ʽ��ֻ���豸�г�ʼ���˺�ʱ������															
																// bit0-֧��Ԥ���ֻ��� bit1-֧��Ԥ������ bit2-֧���ļ�����
	BYTE				bySpecialAbility;						// �豸��ʼ����������λȷ����ʼ������,�߰�λ bit0-2D Code�޸�IP: 0 ��֧�� 1 ֧��, bit1-PN��:0 ��֧�� 1֧��

    char                szNewDetailType[DH_COMMON_STRING_64];   // �豸�ͺ� 
	BOOL				bNewUserName;							// TRUE��ʾʹ�����û���(szNewUserName)�ֶ�
	char				szNewUserName[DH_COMMON_STRING_64];		// ��½�豸�û��������޸��豸IPʱ��Ҫ��д��
	char                cReserved[41];
}DEVICE_NET_INFO_EX;

// ��ӦCLIENT_SearchDevicesByIPs�ӿ�
typedef struct
{
    DWORD               dwSize;                                 // �ṹ���С
    int                 nIpNum;                                 // ��ǰ������IP����
    char                szIP[DH_MAX_SAERCH_IP_NUM][64];         // �����������IP��Ϣ
}DEVICE_IP_SEARCH_INFO;

// �豸�豸����
typedef struct tagNET_DEVICE_SEARCH_PARAM
{
    DWORD       dwSize;
    BOOL        bUseDefault;
    WORD        wBroadcastLocalPort;
    WORD        wBroadcastRemotePort;
    WORD        wMulticastRemotePort;
}NET_DEVICE_SEARCH_PARAM;

// struct SNMP���ýṹ
typedef struct
{
    BOOL                bEnable;                                // SNMPʹ��
    int                 iSNMPPort;                              // SNMP�˿�
    char                szReadCommon[DH_MAX_SNMP_COMMON_LEN];   // ����ͬ��
    char                szWriteCommon[DH_MAX_SNMP_COMMON_LEN];  // д��ͬ��
    char                szTrapServer[64];                       // trap��ַ
    int                 iTrapPort;                              // trap�˿�
    BYTE                bSNMPV1;                                // �豸�Ƿ���֧�ְ汾1��ʽ,0��ʹ�ܣ�1ʹ��
    BYTE                bSNMPV2;                                // �豸�Ƿ���֧�ְ汾2��ʽ,0��ʹ�ܣ�1ʹ��
    BYTE                bSNMPV3;                                // �豸�Ƿ���֧�ְ汾3��ʽ,0��ʹ�ܣ�1ʹ��
    char                szReserve[125];
}DHDEV_NET_SNMP_CFG;

// ISCSI�������ṹ����
typedef struct
{
    char                szServerName[32];                       // ����
    union
    { 
        BYTE            c[4];
        WORD            s[2];
        DWORD           l;
    }                   stuIP;                                  // IP��ַ
    int                 nPort;                                  // �˿ں�
    char                szUserName[32];                         // �û���
    char                szPassword[32];                         // ����
    BOOL                bAnonymous;                             // �Ƿ�������¼
}DHDEV_ISCSI_SERVER;

// ISCSI���ýṹ
typedef struct
{
    BOOL                bEnable;                                // ʹ��
    DHDEV_ISCSI_SERVER  stuServer;                              // ������
    char                szRemotePath[240];                      // Զ��Ŀ¼
    BYTE                reserved[256];
}DHDEV_ISCSI_CFG;

//-------------------------------��������---------------------------------

// ��̨����
typedef struct 
{
    int                 iType;                                  // 0-None,1-Preset,2-Tour,3-Pattern
    int                 iValue;
} DH_PTZ_LINK, *LPDH_PTZ_LINK;

// ���������ṹ��
typedef struct 
{
    /* ��Ϣ����ʽ,����ͬʱ���ִ���ʽ,����
     * 0x00000001 - �����ϴ�
     * 0x00000002 - ����¼��
     * 0x00000004 - ��̨����
     * 0x00000008 - �����ʼ�
     * 0x00000010 - ������Ѳ
     * 0x00000020 - ������ʾ
     * 0x00000040 - �������
     * 0x00000080 - Ftp�ϴ�
     * 0x00000100 - ����
     * 0x00000200 - ������ʾ
     * 0x00000400 - ץͼ
    */


    DWORD               dwActionMask;                           // ��ǰ������֧�ֵĴ���ʽ,��λ�����ʾ 
    DWORD               dwActionFlag;                           // ��������,��λ�����ʾ,���嶯������Ҫ�Ĳ����ڸ��Ե����������� 
    BYTE                byRelAlarmOut[DH_MAX_ALARMOUT_NUM];     // �������������ͨ��,�������������,Ϊ1��ʾ��������� 
    DWORD               dwDuration;                             // ��������ʱ�� 
    BYTE                byRecordChannel[DH_MAX_VIDEO_IN_NUM];   // ����������¼��ͨ��,Ϊ1��ʾ������ͨ�� 
    DWORD               dwRecLatch;                             // ¼�����ʱ�� 
    BYTE                bySnap[DH_MAX_VIDEO_IN_NUM];            // ץͼͨ�� 
    BYTE                byTour[DH_MAX_VIDEO_IN_NUM];            // ��Ѳͨ�� 
    DH_PTZ_LINK         struPtzLink[DH_MAX_VIDEO_IN_NUM];       // ��̨���� 
    DWORD               dwEventLatch;                           // ������ʼ��ʱʱ��,sΪ��λ,��Χ��0~15,Ĭ��ֵ��0 
    BYTE                byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM];   // �����������������ͨ��,�������������,Ϊ1��ʾ��������� 
    BYTE                bMessageToNet;
    BYTE                bMMSEn;                                 // ���ű���ʹ��
    BYTE                bySnapshotTimes;                        // ���ŷ���ץͼ���� 
    BYTE                bMatrixEn;                              // ����ʹ�� 
    DWORD               dwMatrix;                               // ��������           
    BYTE                bLog;                                   // ��־ʹ��,Ŀǰֻ����WTN��̬�����ʹ�� 
    BYTE                bSnapshotPeriod;                        // ץͼ֡���,ÿ�����֡ץһ��ͼƬ,һ��ʱ����ץ�ĵ���������ץͼ֡���йء�0��ʾ����֡,����ץ��
    BYTE                byEmailType;                            // 0,ͼƬ����,1,¼�񸽼�
    BYTE                byEmailMaxLength;                       // ����¼��ʱ����󳤶�,��λMB
    BYTE                byEmailMaxTime;                         // ������¼��ʱ���ʱ�䳤��,��λ��
    BYTE                byReserved[99];   
} DH_MSG_HANDLE;

// �ⲿ����
typedef struct
{
    BYTE                byAlarmType;                            // ����������,0������,1������
    BYTE                byAlarmEn;                              // ����ʹ��
    BYTE                byReserved[2];                        
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             // ����ʽ
} DH_ALARMIN_CFG, *LPDHDEV_ALARMIN_CFG; 

// ��̬��ⱨ��
typedef struct 
{
    BYTE                byMotionEn;                             // ��̬��ⱨ��ʹ��
    BYTE                byReserved;
    WORD                wSenseLevel;                            // �����
    WORD                wMotionRow;                             // ��̬������������
    WORD                wMotionCol;                             // ��̬������������
    BYTE                byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // �������,���32*32������
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             //����ʽ
} DH_MOTION_DETECT_CFG;

// ��Ƶ��ʧ����
typedef struct
{
    BYTE                byAlarmEn;                              // ��Ƶ��ʧ����ʹ��
    BYTE                byReserved[3];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             // ����ʽ
} DH_VIDEO_LOST_CFG;

// ͼ���ڵ�����
typedef struct
{
    BYTE                byBlindEnable;                          // ʹ��
    BYTE                byBlindLevel;                           // �����1-6
    BYTE                byReserved[2];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     // NSP
    DH_MSG_HANDLE       struHandle;                             // ����ʽ
} DH_BLIND_CFG;

// Ӳ����Ϣ(�ڲ�����)
typedef struct 
{
    BYTE                byNoDiskEn;                             // ��Ӳ��ʱ����
    BYTE                byReserved_1[3];
    DH_TSECT            stNDSect[DH_N_WEEKS][DH_N_REC_TSECT];   // NSP
    DH_MSG_HANDLE       struNDHandle;                           // ����ʽ
    BYTE                byLowCapEn;                             // Ӳ�̵�����ʱ����
    BYTE                byLowerLimit;                           // ������ֵ,0-99
    BYTE                byReserved_2[2];
    DH_TSECT            stLCSect[DH_N_WEEKS][DH_N_REC_TSECT];   // NSP
    DH_MSG_HANDLE       struLCHandle;                           // ����ʽ
    BYTE                byDiskErrEn;                            // Ӳ�̹��ϱ���
    BYTE                bDiskNum;
    BYTE                byReserved_3[2];
    DH_TSECT            stEDSect[DH_N_WEEKS][DH_N_REC_TSECT];   //NSP
    DH_MSG_HANDLE       struEDHandle;                           // ����ʽ
} DH_DISK_ALARM_CFG;

typedef struct
{
    BYTE                byEnable;
    BYTE                byReserved[3];
    DH_MSG_HANDLE       struHandle;
} DH_NETBROKEN_ALARM_CFG;

// ��������
typedef struct
{
    DWORD dwSize;
    DH_ALARMIN_CFG          struLocalAlmIn[DH_MAX_ALARM_IN_NUM];
    DH_ALARMIN_CFG          struNetAlmIn[DH_MAX_ALARM_IN_NUM];
    DH_MOTION_DETECT_CFG    struMotion[DH_MAX_VIDEO_IN_NUM];
    DH_VIDEO_LOST_CFG       struVideoLost[DH_MAX_VIDEO_IN_NUM];
    DH_BLIND_CFG            struBlind[DH_MAX_VIDEO_IN_NUM];
    DH_DISK_ALARM_CFG       struDiskAlarm;
    DH_NETBROKEN_ALARM_CFG  struNetBrokenAlarm;
} DHDEV_ALARM_SCHEDULE;

#define DECODER_OUT_SLOTS_MAX_NUM        16
#define DECODER_IN_SLOTS_MAX_NUM         16

// ��������������
typedef struct  
{
    DWORD               dwAddr;                                     // ������������ַ
    BOOL                bEnable;                                    // ����������ʹ��
    DWORD               dwOutSlots[DECODER_OUT_SLOTS_MAX_NUM];      // ����ֻ֧��8��.
    int                 nOutSlotNum;                                // dwOutSlots������ЧԪ�ظ���.
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle[DECODER_IN_SLOTS_MAX_NUM];       // ����ֻ֧��8��.
    int                 nMsgHandleNum;                              // stuHandle������ЧԪ�ظ���.
    BYTE                bReserved[120];
} DH_ALARMDEC_CFG;

// �����ϴ�������
typedef struct  
{
    BYTE                byEnable;                                   // �ϴ�ʹ��
    BYTE                bReserverd;                                 // ����
    WORD                wHostPort;                                  // �������������˿�
    char                sHostIPAddr[DH_MAX_IPADDR_LEN];             // ��������IP
    int                 nByTimeEn;                                  // ��ʱ�ϴ�ʹ��,���������������ϴ�IP��������
    int                 nUploadDay;                                 /* �����ϴ�����    
                                                                       "Never = 0", "Everyday = 1", "Sunday = 2", 
                                                                       "Monday = 3", Tuesday = 4", "Wednesday = 5",
                                                                       "Thursday = 6", "Friday = 7", "Saturday = 8"*/    
    int                 nUploadHour;                                // �����ϴ�ʱ�� ,[0~23]��
    DWORD               dwReserved[300];                            // �������չ��
} ALARMCENTER_UP_CFG;

// ȫ���л���������
typedef struct __DH_PANORAMA_SWITCH_CFG 
{
    BOOL                bEnable;                                    // ʹ��
    int                 nReserved[5];                               // ����
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                                 // ��������
} DH_PANORAMA_SWITCH_CFG;

typedef struct __ALARM_PANORAMA_SWITCH_CFG 
{
    int                    nAlarmChnNum;                            // ����ͨ������
    DH_PANORAMA_SWITCH_CFG stuPanoramaSwitch[DH_MAX_VIDEO_IN_NUM];
} ALARM_PANORAMA_SWITCH_CFG;

// ʧȥ���㱨������
typedef struct __DH_LOST_FOCUS_CFG
{
    BOOL                bEnable;                                    // ʹ��
    int                 nReserved[5];                               // ����
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                                 // ��������
} DH_LOST_FOCUS_CFG;

typedef struct __ALARM_LOST_FOCUS_CFG 
{
    int                 nAlarmChnNum;                               // ����ͨ������
    DH_LOST_FOCUS_CFG   stuLostFocus[DH_MAX_VIDEO_IN_NUM];
} ALARM_LOST_FOCUS_CFG;

// IP��ͻ��ⱨ������
typedef struct __ALARM_IP_COLLISION_CFG
{
    BOOL                bEnable;                                    // ʹ��
    DH_MSG_HANDLE       struHandle;                                 // ��������
    int                 nReserved[300];                             // ����
} ALARM_IP_COLLISION_CFG;

// MAC��ͻ�������
typedef struct __ALARM_MAC_COLLISION_CFG
{
    BOOL                bEnable;                                    // ʹ��
    DH_MSG_HANDLE       struHandle;                                 // ��������
    int                 nReserved[300];                             // ����
} ALARM_MAC_COLLISION_CFG;

// 232���ڿ����źš�485���ڿ����ź��¼�����
typedef struct __COM_CARD_SIGNAL_INFO
{
    WORD                wCardStartPose;                             // ������ʼλ
    WORD                wCardLenth;                                 // ���ų���
    char                cStartCharacter[32];                        // ��ʼ��
    char                cEndCharacter[32];                          // ������
    BYTE                byReserved[28];                             // �����ֶ� 
}COM_CARD_SIGNAL_INFO;

// 232���ڿ����źš�485���ڿ����ź���������(�ڴ��ڷ������Ŀ�����Ϣ�������õĿ�����Ϣ��,�������豸ץͼ)
typedef struct __COM_CARD_SIGNAL_LINK_CFG
{
    COM_CARD_SIGNAL_INFO  struCardInfo;                             // ������Ϣ
    DH_MSG_HANDLE         struHandle;                               // �¼�����
    BYTE                  byReserved[24];                           // �����ֶ�

}COM_CARD_SIGNAL_LINK_CFG;

//------------------------------�������ڵ�--------------------------------

// �ڵ���Ϣ
typedef struct __VIDEO_COVER_ATTR
{
    DH_RECT             rcBlock;                                    // ���ǵ���������
    int                 nColor;                                     // ���ǵ���ɫ
    BYTE                bBlockType;                                 // ���Ƿ�ʽ��0���ڿ�,1��������
    BYTE                bEncode;                                    // ���뼶�ڵ���1����Ч,0������Ч
    BYTE                bPriview;                                   // Ԥ���ڵ��� 1����Ч,0������Ч
    char                reserved[29];                               // ����
} VIDEO_COVER_ATTR;

// �������ڵ�����
typedef struct __DHDEV_VIDEOCOVER_CFG 
{
    DWORD               dwSize;
    char                szChannelName[DH_CHAN_NAME_LEN];            // ֻ��
    BYTE                bTotalBlocks;                               // ֧�ֵ��ڵ�����
    BYTE                bCoverCount;                                // �����õ��ڵ�����
    VIDEO_COVER_ATTR    CoverBlock[DH_MAX_VIDEO_COVER_NUM];         // ���ǵ�����    
    char                reserved[30];                               // ����
}DHDEV_VIDEOCOVER_CFG;

// �豸�Ľ����������
typedef struct __DHDEV_DECODEPOLICY_CFG 
{
    int                 nMinTime;                                   // �뻺��ʱ�䷶Χ(ֻ��)����С����ʱ��(��λ��ms)
    int                 nMaxTime;                                   // �뻺��ʱ�䷶Χ(ֻ��)����󻺳�ʱ��(��λ��ms)
    int                 nDeocdeBufTime;                             // Ŀ���豸���뻺��ʱ��(��λ��ms)
    char                reserved[128];                              // ����
}DHDEV_DECODEPOLICY_CFG;

// ������ص�����
typedef struct __DHDEV_MACHINE_CFG 
{
    char                szMachineName[DH_MACHINE_NAME_NUM];         // �������ƻ���
    char                szMachineAddress[DH_MACHINE_NAME_NUM];      // ��������ص�
    char                reserved[128];                              // ����
}DHDEV_MACHINE_CFG;

////////////////////////////////IPC��Ʒ֧��////////////////////////////////

// ��������������Ϣ
typedef struct 
{
    int                 nEnable;                    // ����ʹ��, 0: ʹ��, 1: �ر�
    char                szSSID[36];                 // SSID
    int                 nLinkMode;                  // ����ģʽ��0��auto,1��adhoc,2��Infrastructure
    int                 nEncryption;                // ���ܣ�0��off,2��WEP64bit,3��WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP
    int                 nKeyType;                   // 0��Hex,1��ASCII
    int                 nKeyID;                     // ���
    union
    {
        char            szKeys[4][32];              // ��������
        char            szWPAKeys[128];             // nEncryptionΪ4��5ʱʹ��,��128����,���ý�������
    };
    int                 nKeyFlag;
    BYTE                byConnectedFlag;            // 0: ������, 1: ���� 
    char                reserved[11];
} DHDEV_WLAN_INFO;

// ѡ��ʹ��ĳ�������豸
typedef struct  
{
    char                szSSID[36];
    int                 nLinkMode;                  // ����ģʽ��0��adhoc,1��Infrastructure
    int                 nEncryption;                // ���ܣ�0��off,2��WEP64bit,3��WEP128bit
    char                reserved[48];
} DHDEV_WLAN_DEVICE;

// �������������豸�б�
typedef struct  
{
    DWORD               dwSize;
    BYTE                bWlanDevCount;              // �������������豸����
    DHDEV_WLAN_DEVICE   lstWlanDev[DH_MAX_WLANDEVICE_NUM];
    char                reserved[255];
} DHDEV_WLAN_DEVICE_LIST;

// �����豸��չ����
typedef struct
{
    char                szSSID[36];                         // ��������
    char                szMacAddr[18];                      // mac��ַ
    BYTE                byApConnected;                      // �Ƿ����ӳɹ� 0:û��,1: ���ӳɹ�
    BYTE                byLinkMode;                         // ����ģʽ 0:adhoc 1:Infrastructure;
    int                 nRSSIQuality;                       // �ź�ǿ��(dbm)
    unsigned int        unApMaxBitRate;                     // վ������������
    BYTE                byAuthMode;                         // ��֤ģʽ0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
                                                            // 6:WPA-NONE(����adhoc����ģʽ),
                                                            // 7-11�ǻ��ģʽ,ѡ�������κ�һ�ֶ����Խ������� 
                                                            // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
                                                            // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
    BYTE                byEncrAlgr;                         // ����ģʽ0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
                                                            // 7: TKIP+AES(���ģʽ) 8: UnKnown
    BYTE                byLinkQuality;                      // ����ǿ�� 0~100(%)
    BYTE                byReserved[129];                    // Reserved 
}DHDEV_WLAN_DEVICE_EX;

// �������������豸��չ�����б�
typedef struct  
{
    DWORD               dwSize;
    BYTE                bWlanDevCount;            // �������������豸����
    DHDEV_WLAN_DEVICE_EX  lstWlanDev[DH_MAX_WLANDEVICE_NUM_EX];
    char                reserved[255];
} DHDEV_WLAN_DEVICE_LIST_EX;

//����������Ч��
typedef struct
{
    int                 nResult;                  // 0����ʾ���óɹ�,1����ʾ����ʧ��
    BYTE                reserved[32];
} DHDEV_FUNC_TEST;

// FTP��������Ϣ
typedef struct
{
    char                szServerName[32];          // ��������
    char                szIp[16];                  // IP��ַ
    int                 nPort;                     // �˿ں�
    char                szUserName[32];            // �û���
    char                szPassword[32];            // ����
    BOOL                bAnonymity;                // �Ƿ�������¼
    BYTE                byReserved[256];           // �����ֽ�
}FTP_SERVER_CFG;

// ftp���������Ӳ���
typedef struct
{
    FTP_SERVER_CFG     stuFtpServerInfo;           // ftp��������Ϣ�����û���д��
    DHDEV_FUNC_TEST    stuTestResult;              // ftp����������״̬(���豸����)
    BYTE               byReserved[64];
}DHDEV_FTP_SERVER_TEST;

// DDNS������Ϣ
typedef struct
{

    char                szServerType[DH_MAX_SERVER_TYPE_LEN];   // ����������,ϣ��..
    char                szServerIp[DH_MAX_DOMAIN_NAME_LEN];     // ������ip��������
    DWORD               dwServerPort;                           // �������˿�
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];   // dvr����,��jeckean.3322.org
    char                szUserName[DH_MAX_HOST_NAMELEN];        // �û���
    char                szUserPsw[DH_MAX_HOST_PSWLEN];          // ����
    BYTE                byReserved[256];                        // �����ֽ�
}DDNS_DOMAIN_INFO;


// DDNS�����Ƿ���ò���
typedef struct
{
    DDNS_DOMAIN_INFO   stuDomainInfo;                           // DDNS������Ϣ�����û���д��
    DHDEV_FUNC_TEST    stuTestResult;                           // ���Խ��
    char               szMemo[128];                             // ���Խ������
    BYTE               byReserved[64];
}DHDEV_DDNS_DOMAIN_TEST;


//��ʾӲ�̵Ļ�����Ϣ
typedef struct 
{
    BYTE                byModle[32];                  // �ͺ�
    BYTE                bySerialNumber[32];           // ���к�
    BYTE                byFirmWare[32];               // �̼���
    int                 nAtaVersion;                  // ATAЭ��汾��
    int                 nSmartNum ;                   // smart ��Ϣ��
    INT64               Sectors;    
    int                 nStatus;                      // ����״̬ 0-���� 1-�쳣
    int                 nReserved[33];                // �����ֽ�
} DHDEV_DEVICE_INFO;

//Ӳ�̵�smart��Ϣ,���ܻ��кܶ���,��಻����30������
typedef struct
{
    BYTE    byId;               // ID
    BYTE    byCurrent;          // ����ֵ
    BYTE    byWorst;            // ������ֵ
    BYTE    byThreshold;        // ��ֵ
    char    szName[64];         // ������
    char    szRaw[8];           // ʵ��ֵ
    int     nPredict;           // ״̬
    char    reserved[128];
} DHDEV_SMART_VALUE;

//Ӳ��smart��Ϣ��ѯ
typedef struct
{
    BYTE                nDiskNum;                       // Ӳ�̺�
    BYTE                byRaidNO;                       // Raid����,0��ʾ����
    BYTE                byReserved[2];                  // �����ֽ�
    DHDEV_DEVICE_INFO   deviceInfo;
    DHDEV_SMART_VALUE   smartValue[MAX_SMART_VALUE_NUM];
} DHDEV_SMART_HARDDISK;

// ����ģ����Ϣ
typedef struct
{
    char               szModuleName[64];      //  ��ģ������
    char               szHardWareVersion[32]; //  ��ģ��Ӳ���汾��
    char               szSoftwareVersion[32]; //  ��ģ������汾��
    BYTE               reserved[128]; 
} DHDEV_SUBMODELE_VALUE;

// ��ѯ�豸��ģ����Ϣ
typedef struct
{
    int                    nSubModuleNum;                         //  ������ģ������
    DHDEV_SUBMODELE_VALUE  stuSubmoduleValue[MAX_SUBMODULE_NUM];  //  ��ģ����ϸ��Ϣ
    BYTE                   bReserved[256];
} DHDEV_SUBMODULE_INFO;

// ��ѯӲ�̻�������
typedef struct
{
    BYTE                bDiskDamageLevel[DH_MAX_DISK_NUM];  //�����̻����ȼ�
    BYTE                bReserved[128];
} DHDEV_DISKDAMAGE_INFO;


// syslog��Զ�̷���������
typedef struct 
{
    char    szServerIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];    //��������ַ
    int     nServerPort;                                //�������˿�
    BYTE    bEnable;                                    //������ʹ��
    BYTE    bReserved[255];                             //�����ֽ�
}DHDEV_SYSLOG_REMOTE_SERVER;

// ��Ƶ��������
typedef struct
{
    BYTE    backupVideoFormat;                  // �����ļ�����, 0:dav, 1:asf
    BYTE    password[6];                        // ��������
    BYTE    reversed[505];
}DHDEV_BACKUP_VIDEO_FORMAT;


// ����ע���������
typedef struct  
{
    char                szServerIp[32];             // ע�������IP
    int                 nServerPort;                // �˿ں�
    BYTE                byReserved[3];              // ����
    BYTE                bServerIpExEn;              // ע�������IP��չʹ��,0-��ʾ��Ч, 1-��ʾ��Ч
    char                szServerIpEx[60];           // ע�������IP��չ,֧��ipv4,ipv6,���������͵�IP
} DHDEV_SERVER_INFO;

typedef struct  
{
    DWORD               dwSize;
    BYTE                bServerNum;                 // ֧�ֵ����ip��
    DHDEV_SERVER_INFO   lstServer[DH_MAX_REGISTER_SERVER_NUM];
    BYTE                bEnable;                    // ʹ��
    char                szDeviceID[32];             // �豸id
    char                reserved[94];
} DHDEV_REGISTER_SERVER;

// ����ͷ����
typedef struct __DHDEV_CAMERA_INFO
{
    BYTE                bBrightnessEn;              // ���ȿɵ���1����,0������
    BYTE                bContrastEn;                // �Աȶȿɵ�
    BYTE                bColorEn;                   // ɫ�ȿɵ�
    BYTE                bGainEn;                    // ����ɵ�
    BYTE                bSaturationEn;              // ���Ͷȿɵ�
    BYTE                bBacklightEn;               // ���ⲹ�� 0��ʾ��֧�ֱ��ⲹ��,1��ʾ֧��һ����������,�أ�,2��ʾ֧��������������,��,�ͣ�,3��ʾ֧��������������,��,��,�ͣ�
    BYTE                bExposureEn;                // �ع�ѡ��: 0:��ʾ��֧���ع���� 1:��ʾֻ֧���Զ��ع� n:�ع�ĵȼ���(1��ʾ֧���Զ��ع� 2~n��ʾ֧�ֵ��ֶ������ع�ĵȼ�)
    BYTE                bColorConvEn;               // �Զ��ʺ�ת���ɵ�
    BYTE                bAttrEn;                    // ����ѡ�1����,0������
    BYTE                bMirrorEn;                  // ����1��֧��,0����֧��
    BYTE                bFlipEn;                    // ��ת��1��֧��,0����֧��
    BYTE                iWhiteBalance;              // ��ƽ�� 0-��֧�ְ�ƽ��,1-֧���Զ���ƽ��,2-֧��Ԥ�ð�ƽ�⣨���龰ģʽ�� 3-֧���Զ����ƽ��
    BYTE                iSignalFormatMask;          // �źŸ�ʽ����,��λ�ӵ͵���λ�ֱ�Ϊ��0-Inside(�ڲ�����) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
    BYTE                bRotate90;                  // 90����ת 0-��֧�� 1-֧��
    BYTE                bLimitedAutoExposure;       // �Ƿ�֧�ִ�ʱ�������޵��Զ��ع�
    BYTE                bCustomManualExposure;      // �Ƿ�֧���û��Զ����ֶ��ع�ʱ��
    BYTE                bFlashAdjustEn;             // �Ƿ�֧������Ƶ���
    BYTE                bNightOptions;              // �Ƿ�֧��ҹ��ѡ��
    BYTE                iReferenceLevel;            // �Ƿ�֧�ֲο���ƽ����
    BYTE                bExternalSyncInput;         // �Ƿ�֧���ⲿͬ���ź�����,0-��֧��,1-֧��
    unsigned short      usMaxExposureTime;          // �Զ����ع���������ع�ʱ��,��λ����         
    unsigned short      usMinExposureTime;          // �Զ����ع�������С�ع�ʱ��,��λ����
    BYTE                bWideDynamicRange;          // ��̬������Χ,0-��ʾ��֧��,2~n��ʾ���ķ�Χֵ
    BYTE                bDoubleShutter;             // ˫����0��֧��,1-֧��˫����ȫ֡��,��ͼ�����Ƶֻ�п��Ų�����ͬ,2-֧��˫���Ű�֡��,��ͼ�����Ƶ���ż���ƽ���������ͬ,3-֧��˫����ȫ֡�ʺͰ�֡��
    BYTE                byExposureCompensation;     // 1֧��, 0 ��֧��
    BYTE                bRev[109];                  // ����
} DHDEV_CAMERA_INFO;

//ҹ����������ѡ��,�����Ϲ��߽ϰ�ʱ�Զ��л���ҹ������ò���
typedef struct __DHDEV_NIGHTOPTIONS 
{
    BYTE  bEnable;                                  // 0-���л�,1-�л� 
                                                    // �����ճ�������ʱ��,����֮���ճ�֮ǰ,������ҹ����������á�
                                                    // 00:00:00 ~23:59:59
    BYTE  bSunriseHour;
    BYTE  bSunriseMinute;
    BYTE  bSunriseSecond;
    BYTE  bSunsetHour;
    BYTE  bSunsetMinute;
    BYTE  bSunsetSecond;  
    BYTE  bWhiteBalance ;                           // ��ƽ�� 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
    BYTE  bGainRed;                                 // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE  bGainBlue;                                // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE  bGainGreen;                               // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE  bGain;                                    // 0~100
    BYTE  bGainAuto;                                // 0-���Զ����� 1-�Զ�����
    BYTE  bBrightnessThreshold ;                    // ����ֵ 0~100
    BYTE  ReferenceLevel;                           // ��ƽ�ο�ֵ 0~100   
    BYTE  bExposureSpeed;                           // ȡֵ��Χȡ�����豸��������0-�Զ��ع� 1~n-1-�ֶ��ع�ȼ� n-��ʱ�������޵��Զ��ع� n+1-�Զ���ʱ���ֶ��ع� (n��ʾ֧�ֵ��ع�ȼ�����
    float ExposureValue1;                           // �Զ��ع�ʱ�����޻����ֶ��ع��Զ���ʱ��,����Ϊ��λ,ȡֵ0.1ms~80ms
    float ExposureValue2;                           // �Զ��ع�ʱ������,����Ϊ��λ,ȡֵ0.1ms~80ms
    BYTE  bAutoApertureEnable;                      // �Զ���Ȧʹ��,1����,0�ر�
    BYTE  bWideDynamicRange;                        // ��ֵ̬     ȡֵ��Χ����������
    WORD  wNightSyncValue;                          // ҹ����λ 0~360
    WORD  wNightSyncValueMillValue;                 // ҹ����λ0~999(ǧ��֮һ��),��wNightSyncValue��Ϲ���ҹ����λֵ
    BYTE res[10];                                   // ����
} DHDEV_NIGHTOPTIONS;

// ����ͷ��������
typedef struct __DHDEV_CAMERA_CFG 
{
    DWORD                dwSize;
    BYTE                bExposure;                  // �ع�ģʽ��ȡֵ��Χȡ�����豸��������0-�Զ��ع�,1-�ع�ȼ�1,2-�ع�ȼ�2��n-1����ع�ȼ��� n��ʱ�������޵��Զ��ع� n+1�Զ���ʱ���ֶ��ع� (n==bExposureEn��
    BYTE                bBacklight;                 // ���ⲹ�������ⲹ���ȼ�ȡֵ��Χȡ�����豸������,0-�ر�,1-���ⲹ��ǿ��1,2-���ⲹ��ǿ��2��n-��󱳹ⲹ���ȼ��� 
    BYTE                bAutoColor2BW;              // ��/ҹģʽ��3-����ʱ���Զ��л� 2����(�ڰ�),1�������������л�,0����(��ɫ)
    BYTE                bMirror;                    // ����1����,0����
    BYTE                bFlip;                      // ��ת��1����,0����
    BYTE                bLensEn;                    // �Զ���Ȧ��������: 1��֧�֣�0 ����֧��
    BYTE                bLensFunction;              // �Զ���Ȧ����: 1:�����Զ���Ȧ��0: �ر��Զ���Ȧ
    BYTE                bWhiteBalance;              // ��ƽ�� 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
    BYTE                bSignalFormat;              // �źŸ�ʽ0-Inside(�ڲ�����) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
    BYTE                bRotate90;                  // 0-����ת,1-˳ʱ��90��,2-��ʱ��90��
    BYTE                bReferenceLevel;            // ��ƽ�ο�ֵ 0~100  
    BYTE                byReserve;                  // ����
    float               ExposureValue1;             // �Զ��ع�ʱ�����޻����ֶ��ع��Զ���ʱ��,����Ϊ��λ,ȡֵ0.1ms~80ms
    float               ExposureValue2;             // �Զ��ع�ʱ������,����Ϊ��λ,ȡֵ0.1ms~80ms    
    DHDEV_NIGHTOPTIONS  stuNightOptions;            // ҹ�����ò���ѡ�� 
    BYTE                bGainRed;                   // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE                bGainBlue;                  // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE                bGainGreen;                 // ��ɫ�������,��ƽ��Ϊ"Custom"ģʽ����Ч 0~100
    BYTE                bFlashMode;                 // ����ƹ���ģʽ,0-�ر�,1-ʼ��,2-�Զ�
    BYTE                bFlashValue;                // ����ƹ���ֵ, 0-0us, 1-64us, 2-128us,...15-960us
    BYTE                bFlashPole;                 // ����ƴ���ģʽ0-�͵�ƽ 1-�ߵ�ƽ
    BYTE                bExternalSyncPhase;         // �ⲿͬ���ź�����,0-�ڲ�ͬ�� 1-�ⲿͬ��
    BYTE                bFlashInitValue;            // ���������Ԥ��ֵ  ����0~100
    WORD                wExternalSyncValue ;        // ��ͬ������λ���� 0~360(С�����3λ������Ч)
    WORD                wExternalSyncValueMillValue;//  ��ͬ������λ����0~999(ǧ��֮һ��),��wExternalSyncValue��Ϲ�����ͬ������λֵ
    BYTE                bWideDynamicRange;          //��ֵ̬     ȡֵ��Χ����������
    BYTE                byExposureCompensation;     // �عⲹ��ֵ,Ĭ��Ϊ7,��Χ0~14
    char                bRev[54];                   // ����
} DHDEV_CAMERA_CFG;

#define ALARM_MAX_NAME 64
// (����)���ⱨ������
typedef struct
{
    BOOL                bEnable;                            // ��������ʹ��
    char                szAlarmName[DH_MAX_ALARM_NAME];     // ������������
    int                 nAlarmInPattern;                    // ���������벨��
    int                 nAlarmOutPattern;                   // �����������
    char                szAlarmInAddress[DH_MAX_ALARM_NAME];// ���������ַ
    int                 nSensorType;                        // �ⲿ�豸���������ͳ��� or ����
    int                 nDefendEfectTime;                   // ��������ʱʱ��,�ڴ�ʱ���ñ���������Ч
    int                 nDefendAreaType;                    // �������� 
    int                 nAlarmSmoothTime;                   // ����ƽ��ʱ��,���ڴ�ʱ�������ֻ��һ��������������������������Ե����һ��
    char                reserved[128];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                         // ����ʽ
} DH_INFRARED_INFO;

// ����ң��������
typedef struct 
{
    BYTE                address[ALARM_MAX_NAME];        // ң������ַ
    BYTE                name[ALARM_MAX_NAME];           // ң��������
    BYTE                reserved[32];                   // �����ֶ�
} DH_WI_CONFIG_ROBOT;

// ���߱����������
typedef struct 
{
    BYTE                address[ALARM_MAX_NAME];        // ���������ַ
    BYTE                name[ALARM_MAX_NAME];           // �����������
    BYTE                reserved[32];                   // �����ֶ�
} DH_WI_CONFIG_ALARM_OUT;

typedef struct  
{
    DWORD                   dwSize;
    BYTE                    bAlarmInNum;                // ���߱���������
    BYTE                    bAlarmOutNum;               // ���߱��������
    DH_WI_CONFIG_ALARM_OUT  AlarmOutAddr[16];           // ���������ַ
    BYTE                    bRobotNum;                  // ң��������
    DH_WI_CONFIG_ROBOT      RobotAddr[16];              // ң������ַ
    DH_INFRARED_INFO        InfraredAlarm[16];
    char                    reserved[256];
} DH_INFRARED_CFG;

// ����Ƶ��ⱨ����Ϣ
typedef struct
{
    int                 channel;                        // ����ͨ����
    int                 alarmType;                      // �������ͣ�0����Ƶֵ����,1����Ƶֵ����
    unsigned int        volume;                         // ����ֵ
    BYTE                byState;                        // ��Ƶ����״̬, 0: ��Ƶ��������, 1: ��Ƶ������ʧ
    char                reserved[255];
} NET_NEW_SOUND_ALARM_STATE;

typedef struct  
{
    int                         channelcount;           // ������ͨ������
    NET_NEW_SOUND_ALARM_STATE   SoundAlarmInfo[DH_MAX_ALARM_IN_NUM];
} DH_NEW_SOUND_ALARM_STATE;

// ץͼ�������Խṹ��
typedef struct 
{
    int                 nChannelNum;                // ͨ����
    DWORD               dwVideoStandardMask;        // �ֱ���(��λ),����鿴ö�� CAPTURE_SIZE                        
    int                 nFramesCount;               // Frequence[128]�������Ч����
    char                Frames[128];                // ֡��(����ֵ)
                                                    // -25��25��1֡��-24��24��1֡��-23��23��1֡��-22��22��1֡
                                                    // ����
                                                    // 0����Ч��1��1��1֡��2��1��2֡��3��1��3֡
                                                    // 4��1��4֡��5��1��5֡��17��1��17֡��18��1��18֡
                                                    // 19��1��19֡��20��1��20֡
                                                    // ����
                                                    // 25: 1��25֡
    int                 nSnapModeCount;             // SnapMode[16]�������Ч����
    char                SnapMode[16];               // (����ֵ)0����ʱ����ץͼ,1���ֶ�����ץͼ
    int                 nPicFormatCount;            // Format[16]�������Ч����
    char                PictureFormat[16];          // (����ֵ)0��BMP��ʽ,1��JPG��ʽ
    int                 nPicQualityCount;           // Quality[32]�������Ч����
    char                PictureQuality[32];         // ����ֵ
                                                    // 100��ͼ������100%��80:ͼ������80%��60:ͼ������60%
                                                    // 50:ͼ������50%��30:ͼ������30%��10:ͼ������10%
    char                nReserved[128];             // ����
} DH_QUERY_SNAP_INFO;

typedef struct 
{
    int                 nChannelCount;              // ͨ������
    DH_QUERY_SNAP_INFO  stuSnap[DH_MAX_CHANNUM];
} DH_SNAP_ATTR_EN;


/* IP���˹������� */
#define DH_IPIFILTER_NUM            200             // IP
#define DH_IPIFILTER_NUM_EX         512             // IP

// IP��Ϣ
typedef struct 
{
    DWORD               dwIPNum;                                    // IP����
    char                SZIP[DH_IPIFILTER_NUM][DH_MAX_IPADDR_LEN];  // IP
    char                byReserve[32];                              // ����
} IPIFILTER_INFO;

// IP�������ýṹ��
typedef struct
{
    DWORD               dwSize;
    DWORD               dwEnable;                   // ʹ��
    DWORD               dwType;                     // ��ǰ�������ͣ�0�������� 1�����������豸ֻ��ʹһ��������Ч,�����ǰ����������Ǻ�������
    IPIFILTER_INFO      BannedIP;                   // ������
    IPIFILTER_INFO      TrustIP;                    // ������
    char                byReserve[256];             // ����
} DHDEV_IPIFILTER_CFG;

// IP��Ϣ��չ
typedef struct 
{
    DWORD               dwIPNum;                                        // IP����
    char                SZIP[DH_IPIFILTER_NUM_EX][DH_MAX_IPADDR_LEN];   // IP
    char                byReserve[32];                                  // ����
} IPIFILTER_INFO_EX;

// IP�������ýṹ����չ
typedef struct
{
    DWORD                dwSize;
    DWORD                dwEnable;                  // ʹ��
    DWORD                dwType;                    // ��ǰ�������ͣ�0�������� 1�����������豸ֻ��ʹһ��������Ч,�����ǰ����������Ǻ�������
    IPIFILTER_INFO_EX    BannedIP;                  // ������
    IPIFILTER_INFO_EX    TrustIP;                   // ������
    char                 byReserve[256];            // ����
} DHDEV_IPIFILTER_CFG_EX;

/* MAC�������� */
#define DH_MACFILTER_NUM            512             // MAC

// MAC��Ϣ
typedef struct 
{
    DWORD                dwSize;                                    // ʹ��ʱ,�ó�ʼ��Ϊ���ṹ���С
    DWORD                dwMacNum;                                  // MAC����
    char                 szMac[DH_MACFILTER_NUM][DH_MACADDR_LEN];   // MAC
} MACFILTER_INFO;

// MAC�������ýṹ��
typedef struct
{
    DWORD                 dwSize;                   // ʹ��ʱ,�ó�ʼ��Ϊ���ṹ���С
    DWORD                 dwEnable;                 // ʹ��
    DWORD                 dwType;                   // ��ǰ�������ͣ�0�������� 1�����������豸ֻ��ʹһ��������Ч,�����ǰ����������Ǻ�������
    MACFILTER_INFO        stuBannedMac;             // ������Mac
    MACFILTER_INFO        stuTrustMac;              // ������Mac
} DHDEV_MACFILTER_CFG;

/* MAC,IP�������� */
#define DH_MACIPFILTER_NUM           512            // MAC,IP

// MAC,IP������Ϣ
typedef struct
{
    DWORD       dwSize;                             // ʹ��ʱ,�ó�ʼ��Ϊ���ṹ���С
    char        szMac[DH_MACADDR_LEN];              // mac
    char        szIp[DH_MAX_IPADDR_LEN];            // ip
}MACIP_INFO;

// MAC,IP�������ýṹ��
typedef struct
{
    DWORD                    dwSize;                                // ʹ��ʱ,�ó�ʼ��Ϊ���ṹ���С
    DWORD                    dwEnable;                              // ʹ��
    DWORD                    dwType;                                // ��ǰ�������ͣ�0�������� 1�����������豸ֻ��ʹһ��������Ч,�����ǰ����������Ǻ�������
    DWORD                    dwBannedMacIpNum;                      // ������MAC,IP����(MAC,IPһһ��Ӧ)
    MACIP_INFO               stuBannedMacIp[DH_MACIPFILTER_NUM];    // ������Mac,IP
    DWORD                    dwTrustMacIpNum;                       // ������MAC,IP����(MAC,IPһһ��Ӧ)
    MACIP_INFO               stuTrustMacIp[DH_MACIPFILTER_NUM];     // ������Mac,IP
} DHDEV_MACIPFILTER_CFG;

typedef struct
{
    int                nCardNum;                                        // ��Ч������
    char               cardInfo [DH_MAX_CARD_NUM][DH_MAX_CARDINFO_LEN]; // ������Ϣ�ַ��� 
    BYTE               byReserve[32];                                   // �����ֶ�
}DHDEV_NETCARD_CFG;

// RTSP ����
typedef struct
{
    WORD               wPort;                  // �˿ں�
    BYTE               byReserved[62];         // �����ֶ�
}DHDEV_RTSP_CFG;

//-------------------------������������---------
// ������Կ��Ϣ36���ֽ�
typedef struct _ENCRYPT_KEY_INFO
{
    BYTE        byEncryptEnable;       //  �Ƿ����0:������, 1:����
    BYTE        byReserved[3]; 
    union
    {
        BYTE    byDesKey[8];           // des��Կ
        BYTE    by3DesKey[3][8];       // 3des��Կ
        BYTE    byAesKey[32];          // aes��Կ

    };
}ENCRYPT_KEY_INFO;

// �����㷨����
typedef struct _ALGO_PARAM_INFO
{
    WORD       wEncryptLenth;       // ��Կ����,��ǰΪAES�㷨����ʱ,��ʾ��Կλ��(Ŀǰ֧��128,192,256λ����, ��: wEncryptLenthΪ128,����Կ��ϢENCRYPT_KEY_INFO���byAesKey[0]~[15])
                                    // ΪDES�㷨����ʱ,��Կ���ȹ̶�Ϊ64λ
                                    // Ϊ3DES�㷨����ʱ,��ʾ��Կ�ĸ���(2��3����Կ)
    BYTE       byAlgoWorkMode ;     // ����ģʽ,�ο�ö������ EM_ENCRYPT_ALOG_WORKMODE 
    BYTE       reserved[13];        // �����ֶ�
}ALGO_PARAM_INFO;

// ��������������Ϣ
typedef struct _DHEDV_STREAM_ENCRYPT
{
    BYTE                    byEncrptAlgoType;           // �����㷨���ͣ�00: AES��01:DES��02: 3DES
    BYTE                    byReserved1[3];
    ALGO_PARAM_INFO         stuEncrptAlgoparam;         // �����㷨����
    ENCRYPT_KEY_INFO        stuEncryptKeys[32];         // ��ͨ������Կ��Ϣ 
    BYTE                    byEncrptPlanEnable;         // ���ܼƻ�ʹ��
    BYTE                    byReserved3[3];
    NET_TIME                stuPreTime;                 // ���ܼƻ��Ŀ�ʼʱ��
    BYTE                    reserved2[1360];
}DHEDV_STREAM_ENCRYPT;

// ����������
typedef struct _DHDEV_BIT_RATE
{
    DWORD                   nExpectCodeRate;          // ��������,��λkps
    BYTE                    byReserved[64];           // �����ֽ�
}DHDEV_LIMIT_BIT_RATE;

// �û��Զ�������
typedef struct _DHDEV_CUSTOM_CFG
{
    char                   szData[1024];            // �û��Զ���������Ϣ
    char                   reserved[3072];          // �����ֶ�
}DHDEV_CUSTOM_CFG;

/*����Խ���������*/
typedef struct
{
    DWORD               dwSize;
    int                 nCompression;               // ѹ����ʽ,ö��ֵ,���DH_TALK_CODING_TYPE,������豸֧�ֵ�����Խ���������ѹ����ʽ��
    int                 nMode;                      // ����ģʽ,ö��ֵ,Ϊ0ʱ��ʾ��ѹ����ʽ��֧�ֱ���ģʽ��
                                                    // ����ѹ����ʽ�������ö�Ӧ�ı����ʽ,��
                                                    // AMR���EM_ARM_ENCODE_MODE
    char                 byReserve[256];            // ����
} DHDEV_TALK_ENCODE_CFG;

// ������mobile�������
// (�¼�������ý�����/���ŷ���)MMS���ýṹ��
typedef struct
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // ʹ��
    DWORD               dwReceiverNum;                          // ���Ž����߸���
    char                SZReceiver[DH_MMS_RECEIVER_NUM][32];    // ���Ž�����,һ��Ϊ�ֻ�����
    BYTE                byType;                                 // ������Ϣ���� 0:MMS��1:SMS
    char                SZTitle[32];                            // ������Ϣ����
    char                byReserve[223];                         // ����
} DHDEV_MMS_CFG;

// (���ż���������������)
typedef struct  
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // ʹ��
    DWORD               dwSenderNum;                            // ���ŷ����߸���
    char                SZSender[DH_MMS_SMSACTIVATION_NUM][32]; // ���ŷ�����,һ��Ϊ�ֻ�����
     char               byReserve[256];                         // ����
}DHDEV_SMSACTIVATION_CFG;

// (���ż���������������)
typedef struct  
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // ʹ��
    DWORD               dwCallerNum;                            // �����߸���
    char                SZCaller[DH_MMS_DIALINACTIVATION_NUM][32];// ������, һ��Ϊ�ֻ�����
    char                byReserve[256];                         // ����
}DHDEV_DIALINACTIVATION_CFG;
// ������mobile�������


// ���������ź�ǿ�Ƚṹ��
typedef struct
{
    DWORD               dwSize;
    DWORD               dwTDSCDMA;                  // TD-SCDMAǿ��,��Χ��0��100
    DWORD               dwWCDMA;                    // WCDMAǿ��,��Χ��0��100
    DWORD               dwCDMA1x;                   // CDMA1xǿ��,��Χ��0��100
    DWORD               dwEDGE;                     // EDGEǿ��,��Χ��0��100
    DWORD               dwEVDO;                     // EVDOǿ��,��Χ��0��100
    int                 nCurrentType;               // ��ǰ����
                                                    // 0 �豸��֧����һ��
                                                    // 1 TD-SCDMA
                                                    // 2 WCDMA
                                                    // 3 CDMA_1x
                                                    // 4 EDGE
                                                    // 5 EVDO
                                                    // 6 TD-LTE
    DWORD               dwTDLTE;                    // TD-LTEǿ��,��Χ��0��100
    char                byReserve[248];             // ����
} DHDEV_WIRELESS_RSS_INFO;

typedef struct _DHDEV_SIP_CFG
{
    BOOL        bUnregOnBoot;                       //Unregister on Reboot
    char        szAccoutName[64];                   //Account Name
    char        szSIPServer[128];                   //SIP Server
    char        szOutBoundProxy[128];               //Outbound Proxy
    DWORD       dwSIPUsrID;                         //SIP User ID
    DWORD       dwAuthID;                           //Authenticate ID
    char        szAuthPsw[64];                      //Authenticate Password
    char        szSTUNServer[128];                  //STUN Server
    DWORD       dwRegExp;                           //Registration Expiration
    DWORD       dwLocalSIPPort;                     //Local SIP Port
    DWORD       dwLocalRTPPort;                     //Local RTP Port
    BOOL        bEnable;                            // ʹ��
    char        szNotifyID[128];                    // ����ID
    NET_TIME    stuRegTime;                         // ע��ɹ���ʱ�䣻ֻ���ֶ�,�豸ָ����   
    BYTE        bReserved[868];                     //reserved
} DHDEV_SIP_CFG;

typedef struct _DHDEV_SIP_STATE
{
    int         nStatusNum;                         //״̬��Ϣ�ܵĸ���
    BYTE        byStatus[64];                       //0:ע��ɹ�,1:δע��,2:��Ч,3:ע����,4:ͨ����
    BYTE        bReserved[64];                      //����
}DHDEV_SIP_STATE;

typedef struct _DHDEV_HARDKEY_STATE
{
    BOOL        bState;                             // 0:δ����HardKey, 1:�Ѳ���HardKey
    BYTE        bReserved[64];                      // ����
}DHDEV_HARDKEY_STATE;

typedef struct _DHDEV_ISCSI_PATHLIST
{
    int         nCount;
    char        szPaths[DH_MAX_ISCSI_PATH_NUM][MAX_PATH_STOR];    // Զ��Ŀ¼����
} DHDEV_ISCSI_PATHLIST;

// ����·��������Ϣ
typedef struct _DHDEV_WIFI_ROUTE_CAP_COUNTRY
{
    char        szCountry[32];                      // ����
    int         nValidChnNum;                       // ��Чͨ������
    int         nValideChannels[32];                // ��Чͨ���б�
    char        reserved[64];                       // ����
} DHDEV_WIFI_ROUTE_CAP_COUNTRY;

typedef struct _DHDEV_WIFI_ROUTE_CAP
{
    int         nCountryNum;                        // ��������
    DHDEV_WIFI_ROUTE_CAP_COUNTRY stuCountry[256];   // ��ͬ���ҵ�������Ϣ
    char        reserved[256];                      // ����
} DHDEV_WIFI_ROUTE_CAP;

//  �����ظ�����Ϣ
typedef struct _MONITOR_INFO
{
    int         nPresetObjectNum;                   // Ԥ��Ӧ��Ŀ����Ŀ
    int         nActualObjectNum;                   // �ֳ�ʵ��Ŀ����Ŀ 
    char        reserved[64]; 
}MONITOR_INFO;

typedef struct _DHDEV_MONITOR_INFO
{
    int              nChannelNumber;
    MONITOR_INFO     stMonitorInfo[64];             //  �����ظ�����Ϣ
    char             reserved[128];
}DHDEV_MONITOR_INFO;

// ��ͨ��Ԥ���طŷָ�����
typedef struct tagNET_MULTIPLAYBACK_SPLIT_CAP
{
    DWORD            dwSize;
    int              nSliptMode[DH_MAX_MULTIPLAYBACK_SPLIT_NUM]; // ֧�ֵķָ�ģʽ,  
    int              nModeNumber;       
}NET_MULTIPLAYBACK_SPLIT_CAP;

/***************************** ��̨Ԥ�Ƶ����� ***********************************/
typedef struct _POINTEANBLE
{
    BYTE             bPoint;                        //Ԥ�Ƶ����Ч��Χ������[1,80],��Ч����Ϊ0��
    BYTE             bEnable;                       //�Ƿ���Ч,0��Ч,1��Ч
    BYTE             bReserved[2];
} POINTEANBLE;

typedef struct _POINTCFG
{
    char             szIP[DH_MAX_IPADDR_LEN];       // ip
    int              nPort;                         // �˿�    
    POINTEANBLE      stuPointEnable[80];            // Ԥ�Ƶ�ʹ��
    BYTE             bReserved[256];
}POINTCFG;

typedef struct _DHDEV_POINT_CFG
{
    int              nSupportNum;                   // ֻ������,���õ�ʱ����Ҫ���ظ�sdk,��ʾ֧�ֵ�Ԥ�Ƶ���
    POINTCFG         stuPointCfg[16];               // ��ά�±��ʾͨ���š�Ҫ���õĵ���ֵ����ǰnSupportNum���±����档
    BYTE             bReserved[256];                // ����
}DHDEV_POINT_CFG;
////////////////////////////////����DVR֧��////////////////////////////////

// GPS��Ϣ(�����豸)
typedef struct _GPS_Info
{
    NET_TIME         revTime;                       // ��λʱ��
    char             DvrSerial[50];                 // �豸���к�
    double           longitude;                     // ����(��λ�ǰ����֮��,��Χ0-360��)
    double           latidude;                      // γ��(��λ�ǰ����֮��,��Χ0-180��)
    double           height;                        // �߶�(��)
    double           angle;                         // �����(��������Ϊԭ��,˳ʱ��Ϊ��)
    double           speed;                         // �ٶ�(��λ�Ǻ���,speed/1000*1.852����/Сʱ)
    WORD             starCount;                     // ��λ����
    BOOL             antennaState;                  // ����״̬(true ��,false ��)
    BOOL             orientationState;              // ��λ״̬(true ��λ,false ����λ)
} GPS_Info,*LPGPS_Info;

// ����״̬��Ϣ
typedef struct 
{
    int              nAlarmCount;                   // �����ı����¼�����
    int              nAlarmState[128];              // �����ı����¼�����
    BYTE             byRserved[128];                // �����ֽ�
}ALARM_STATE_INFO;

// Gps��λ��Ϣ
typedef struct tagNET_GPS_LOCATION_INFO
{
	GPS_Info	        stuGpsInfo;               // GPS��Ϣ
	ALARM_STATE_INFO    stuAlarmStateInfo;        // ����״̬��Ϣ
	int				    nTemperature;		      // �¶�(��λ:0.1���϶�)
	int					nHumidity;				  // ʪ��(��λ:0.1%)
	unsigned int		nIdleTime;				  // ����ʱ��(��λ:��)
	unsigned int        nMileage;				  // ���(��λ:0.1km)
	int					nVoltage;				  // ���õ�ѹֵ(��λ:0.1��)
	BYTE			    byReserved[1024];  
}NET_GPS_LOCATION_INFO, *LPNET_GPS_LOCATION_INFO;

// ץͼ�����ṹ��
typedef struct _snap_param
{
    unsigned int     Channel;                       // ץͼ��ͨ��
    unsigned int     Quality;                       // ���ʣ�1~6
    unsigned int     ImageSize;                     // �����С��0��QCIF,1��CIF,2��D1
    unsigned int     mode;                          // ץͼģʽ��-1:��ʾֹͣץͼ, 0����ʾ����һ֡, 1����ʾ��ʱ��������, 2����ʾ��������
    unsigned int     InterSnap;                     // ʱ�䵥λ�룻��mode=1��ʾ��ʱ��������ʱ
													// ֻ�в��������豸(�磺�����豸)֧��ͨ�����ֶ�ʵ�ֶ�ʱץͼʱ���������
													// ����ͨ�� CFG_CMD_ENCODE ���õ�stuSnapFormat[nSnapMode].stuVideoFormat.nFrameRate�ֶ�ʵ����ع���
    unsigned int     CmdSerial;                     // �������кţ���Чֵ��Χ 0~65535��������Χ�ᱻ�ض�Ϊ unsigned short
    unsigned int     Reserved[4];
} SNAP_PARAMS, *LPSNAP_PARAMS;

// ץͼ��������
typedef struct 
{
    DWORD            dwSize;
    BYTE             bTimingEnable;                 // ��ʱץͼ����(����ץͼ�����ڸ�������������������)
    BYTE             bPicIntervalHour;              // ��ʱץͼʱ����Сʱ��
    short            PicTimeInterval;               // ��ʱץͼʱ����,��λΪ��,Ŀǰ�豸֧������ץͼʱ����Ϊ30����                           
    DH_VIDEOENC_OPT  struSnapEnc[SNAP_TYP_NUM];     // ץͼ��������,��֧�����еķֱ��ʡ����ʡ�֡������,֡���������Ǹ���,��ʾһ��ץͼ�Ĵ�����
} DHDEV_SNAP_CFG;

// ץͼ����������չ
typedef struct 
{
    DWORD            dwSize;
    BYTE             bTimingEnable;                 // ��ʱץͼ����(����ץͼ�����ڸ�������������������)
    BYTE             bPicIntervalHour;              // ��ʱץͼʱ����Сʱ��
    short            PicTimeInterval;               // ��ʱץͼʱ����,��λΪ��,Ŀǰ�豸֧������ץͼʱ����Ϊ30����                           
    DH_VIDEOENC_OPT  struSnapEnc[SNAP_TYP_NUM];     // ץͼ��������,��֧�����еķֱ��ʡ����ʡ�֡������,֡���������Ǹ���,��ʾһ��ץͼ�Ĵ�����
    DWORD            dwTrigPicIntervalSecond;       // ����������ÿ��ץͼʱ����ʱ�� ��λ��
    BYTE             byRserved[256];                // �����ֽ�
} DHDEV_SNAP_CFG_EX;


//����wifi״̬
typedef struct  
{
    char            szSSID[128];                    //SSID
    BOOL            bEnable;                        //�Ƿ�����wifi����, 0:��ʹ�� 1:ʹ��
    int             nSafeType;                      //У������
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int             nEncryprion;                    //���ܷ�ʽ
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(��У��)
                                                    //5:AUTO
                                                    //6:SHARED
    int             nStrength;                      //APվ���ź�
    char            szHostIP[128];                  //������ַ
    char            szHostNetmask[128];             //��������
    char            szHostGateway[128];             //��������
    int             nPriority;                      //���ȼ�,(1-32)
    int             nEnDHCP;                        //0����ʹ��; 1��ʹ��(ɨ�赽��dhcpĬ��ʹ�ܴ�)
    BYTE            bReserved[1016];
} DHDEV_VEHICLE_WIFI_STATE;

typedef struct
{
    char            szSSID[128];                    //SSID
    int             nPriority;                      //���ȼ�,(1-32)
    int             nSafeType;                      //У������
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int             nEncryprion;                    //���ܷ�ʽ
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(��У��)
                                                    //5:AUTO
                                                    //6:SHARED
    char            szKey[128];                     //������Կ
    char            szHostIP[128];                  //������ַ
    char            szHostNetmask[128];             //��������
    char            szHostGateway[128];             //��������
    int             nEnDHCP;                        //0����ʹ��; 1��ʹ��(ɨ�赽��dhcpĬ��ʹ�ܴ�)
    BYTE            byKeyIndex;                     //WEPУ�������µ���Կ����,0����֧����Կ���� >0:��Կ����ֵ,��Χ1-4
    BYTE            bReserved[1019];
} DHDEV_VEHICLE_WIFI_CONFIG;

typedef struct
{
    char    szSSID[128];                            // SSID   
    BYTE    bReserved[256];                         // �����ֽ�
}WIFI_CONNECT;

// IP�޸�����
typedef struct __DHCTRL_IPMODIFY_PARAM
{
    int             nStructSize;
    char            szRemoteIP[DH_MAX_IPADDR_OR_DOMAIN_LEN];        // ǰ���豸IP
    char            szSubmask[DH_MAX_IPADDR_LEN];                   // ��������
    char            szGateway[DH_MAX_IPADDR_OR_DOMAIN_LEN];         // ����
    char            szMac[DH_MACADDR_LEN];                          // MAC��ַ
    char            szDeviceType[DH_DEV_TYPE_LEN];                  // �豸����
}DHCTRL_IPMODIFY_PARAM;

typedef struct 
{
    BOOL        bIsScan;                            //0:��ɨ��wifi (�ֶ���ӵ�), 1ɨ�赽��wifi
    char        szSSID[128];                        //SSID
    int         nSafeType;                          //У������
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int        nEncryprion;                         //���ܷ�ʽ
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(��У��)
                                                    //5:AUTO
                                                    //6:SHARED
    char        szKey[128];                         //������Կ
    int         nStrength;                          //APվ���ź�
    int         nMaxBitRate;                        //APվ������������,����λ ֻ��
    int         nIsCnnted;                          //�Ƿ����ӳɹ�ֻ��
    int         nIsSaved;                           //�Ƿ��Ѿ�����ֻ��
    int         nPriority;                          //���ȼ�,(1-32)
    char        szHostIP[128];                      //������ַ
    char        szHostNetmask[128];                 //��������
    char        szHostGateway[128];                 //��������
    int         nWifiFreq;                          //����Ƶ��,����ͨ����ʶ
    int         nEnDHCP;                            //0����ʹ�� 1��ʹ��(ɨ�赽��dhcpĬ��ʹ�ܴ�)
    BYTE        byKeyIndex;                         //WEPУ�������µ���Կ����,0����֧����Կ���� >0:��Կ����ֵ,��Χ1-4
    BYTE        bReserved[1019];
}DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG;

typedef struct 
{
    BOOL        bEnable;                            //�Ƿ�����wifi����, 0:��ʹ�� 1:ʹ��
    int         nWifiApNum;                         //DHDEV_VEHICLE_WIFI_AP_CFG�ṹ����Ч����
    DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG struWifiAp[64];//����WIFI AP����
    int         nReserved[512];                     //����
}DHDEV_VEHICLE_WIFI_AP_CFG;

typedef struct  
{    
    BOOL        bEnable;                            //�Ƿ�����wifi����, 0:��ʹ�� 1:ʹ��
    int         nRetWifiApNum;                      //�����õ���DHDEV_VEHICLE_WIFI_AP_CFG�ṹ����Ч����
    int         nMaxWifiApNum;                      //�����DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG����
    DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG* pWifiAp;      //����WIFI AP����
    int         nReserved[512];                     //����
}DHDEV_VEHICLE_WIFI_AP_CFG_EX;

// GPS��־��Ϣ�ṹ��
typedef struct _DH_DEVICE_GPS_LOG_ITEM
{
    DHDEVTIME       stuDevTime;             // �豸ʱ��  
    DWORD           dwLatidude;             // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
    DWORD           dwLongitude;            // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
                                            // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    DWORD           dwSpeed;                // �ٶ�,��λ�Ǻ���,speed/1000*1.852����/Сʱ
    DWORD           dwHight;                // �߶�,��
    DWORD           dwAngle;                // ����,�Ƕ�0~360,��������Ϊԭ��,˳ʱ��Ϊ��
    DHDEVTIME       stuGpsTime;             // GPSʱ��
    BYTE            bAntStatus;             // GPS����״̬,Ϊ0��ʾ��;��Ϊ0��ʾ�쳣 
    BYTE            bOriStatus;             // ��λ״̬,��Ϊ0��ʾ��λ�ɹ�
    BYTE            bSatCount;              // ��������
    BYTE            bGPSStatus;             // GPS״̬,0,δ��λ 1,�޲�ֶ�λ��Ϣ 2,����ֶ�λ��Ϣ
    DWORD           dwTemp;                 // �¶�ֵ(���϶�),ʵ��ֵ��1000��,��30.0���϶ȱ�ʾΪ30000
    DWORD           dwHumidity;             // ʪ��ֵ(%),ʵ��ֵ��1000��,��30.0%��ʾΪ30000
    BYTE            bReserved[24];          // �����ֽ�
    
}DH_DEVICE_GPS_LOG_ITEM;

// GPS ��־��ѯ�����ṹ��
typedef struct _QUERY_GPS_LOG_PARAM
{
    NET_TIME            stuStartTime;               // ��ѯ��־�Ŀ�ʼʱ��
    NET_TIME            stuEndTime;                 // ��ѯ��־�Ľ���ʱ��
    int                 nStartNum;                  // ��ʱ����дӵڼ�����־��ʼ��ѯ,��ʼ��һ�β�ѯ����Ϊ0
    BYTE                bReserved[20];
} QUERY_GPS_LOG_PARAM;

typedef struct _GPS_TEMP_HUMIDITY_INFO
{
    double              dTemperature;               // �¶�ֵ(���϶�),ʵ��ֵ��1000��,��30.0���϶ȱ�ʾΪ30000
    double              dHumidity;                  // ʪ��ֵ(%),ʵ��ֵ��1000��,��30.0%��ʾΪ30000
    BYTE                bReserved[128];             // �����ֽ�
}GPS_TEMP_HUMIDITY_INFO;

// ����Χ������ö��
typedef enum
{
    ENCLOSURE_LIMITSPEED = 0x01,                    // ������
    ENCLOSURE_DRIVEALLOW = 0x02,                    // ��ʻ��
    ENCLOSURE_FORBIDDRIVE = 0x04,                   // ��ֹ��
    ENCLOSURE_LOADGOODS = 0x08,                     // װ����
    ENCLOSURE_UPLOADGOODS = 0x10,                   // ж����
    ENCLOSURE_FLYALLOW = 0x20,                      // ������
    ENCLOSURE_MANUALFORBIDFLY = 0x40,               // ������(�ֶ�����)
    ENCLOSURE_FIXEDFORBIDFLY = 0x80,                // ������(����) - ��������
    ENCLOSURE_FiXEDLIMITFLY = 0x100,                // ���Ʒ��� - ��������
}ENCLOSURE_TYPE;

typedef enum
{
     ENCLOSURE_ALARM_DRIVEIN ,                      // ʻ��
     ENCLOSURE_ALARM_DRIVEOUT,                      // ʻ��
     ENCLOSURE_ALARM_OVERSPEED,                     // ����
     ENCLOSURE_ALARM_SPEEDCLEAR,                    // ������ʧ
     ENCLOSURE_ALARM_FLYNEAR,                       // ���п���
}ENCLOSURE_ALARM_TYPE;

typedef struct 
{
    DWORD         dwLongitude;                      // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
    DWORD         dwLatidude;                       // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
                                                    // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
}GPS_POINT;

// ����Χ������
typedef struct _DHDEV_ENCLOSURE_CFG
{
    UINT          unType;                              // ����Χ����������,�� ENCLOSURE_TYPE 
    BYTE          bRegion[8];                          // ǰ��λ�ֱ������ҡ�ʡ���л�������(0-255),��4bytes����
    UINT          unId;                                // һ��������һ��ID��ʶ
    UINT          unSpeedLimit;                        // ����,��λkm/h
    UINT          unPointNum;                          // ����Χ�����򶥵���
    GPS_POINT     stPoints[128];                       // ����Χ��������Ϣ
    char          szStationName[DH_STATION_NAME_LEN];  // ����Χ����Χ�ĳ�վվ������
    BYTE          bDisenable;                          // ȥʹ�ܡ� 0 ���� ;1 ������
    BYTE          bShape;                              // Χ����״ 0 ����� 1 Բ�Σ�
    BYTE          bLimitType;                          // Χ���������� 0 ��; 1 �޸�; 2 �ް뾶; 3 �޸��ް뾶
    BYTE          bAction;                             // ����Χ�����豸�Ķ�����0 ��,������ǰ; 1 ֻ����; 2 ��ͣ; 3 ����;
    int           nLimitAltitude;                      // �߶� ��λ�����ס� 0 ��Ч
    int           nAlarmAltitude;                      // Ԥ���߶ȵ�λ�����ס� 0 ��Ч
    UINT          unLimitRadius;                       // �뾶��λ�����ס�0 ��Ч
    UINT          unAlarmRadius;                       // Ԥ���뾶�����ס�0 ��Ч
    BYTE          reserved[12];                        // ����
}DHDEV_ENCLOSURE_CFG;

// ����Χ���汾������
typedef struct _DHDEV_ENCLOSURE_VERSION_CFG
{
    UINT          unType;                              // Χ����������,��LIMITSPEED | DRIVEALLOW
    UINT          unVersion[32];                       // ÿ������һ���汾��,����ͳһƽ̨���豸�ϵ�Χ������
    int           nReserved;                           // ����    
}DHDEV_ENCLOSURE_VERSION_CFG;

// ����Χ������
typedef struct __ALARM_ENCLOSURE_INFO
{
    int           nTypeNumber;                          // ��Ч����Χ�����͸���
    BYTE          bType[16];                            // ����Χ������, ��ENCLOSURE_TYPE
    int           nAlarmTypeNumber;                     // ��Ч�������͸���
    BYTE          bAlarmType[16];                       // ��������,��ENCLOSURE_ALARM_TYPE
    char          szDriverId[DH_VEHICLE_DRIVERNO_LEN];  // ˾������
    UINT          unEnclosureId;                        // ����Χ��ID
    UINT          unLimitSpeed;                         // ����,��λkm/h
    UINT          unCurrentSpeed;                       // ��ǰ�ٶ�
    NET_TIME      stAlarmTime;                          // ��������ʱ��
    DWORD         dwLongitude;                          // ����(��λ�ǰ����֮��,��Χ0-360��)�綫��120.178274�ȱ�ʾΪ300178274
    DWORD         dwLatidude;                           // γ��(��λ�ǰ����֮��,��Χ0-180��)�籱γ30.183382�ȱ�ʾΪ120183382
                                                        // ��γ�ȵľ���ת����ʽ���Բο��ṹ�� NET_WIFI_GPS_INFO �е�ע��
    BYTE          bOffline;                             // 0-ʵʱ 1-���� 
    UINT          unTriggerCount;                       // Χ����������
    BYTE          byReserved[115];                      // �����ֽ�
}ALARM_ENCLOSURE_INFO;

// RAID�쳣��Ϣ
#define DH_MAX_RAID_NUM  16
#define DH_MAX_RAID_DEVICE_NAME 16
typedef struct __RAID_STATE_INFO
{
    char          szName[16];                           // Raid����
    BYTE          byType;                               // ���� 1:Jbod     2:Raid0      3:Raid1     4:Raid5
    BYTE          byStatus;                             // ״̬ 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
    BYTE          byReserved[2];
    int           nCntMem;                              // nMember�������Ч���ݸ���
    int           nMember[32];                          // 1,2,3,... ��ɴ���ͨ��,�Ǹ�����
    int           nCapacity;                            // ����,��λG
    int           nRemainSpace;                         // ʣ������,��λM
    int           nTank;                                // ��չ�� 0:����,1:��չ��1,2:��չ��2,����
    char          reserved[32];
}RAID_STATE_INFO;

typedef struct __ALARM_RAID_INFO
{
    int              nRaidNumber;                       // �ϱ���RAID����   
    RAID_STATE_INFO  stuRaidInfo[DH_MAX_RAID_NUM];      // �쳣��RAID��Ϣ
    char             reserved[128];
}ALARM_RAID_INFO;

// RAID��������
typedef enum tagEM_RAID_ERROR
{
	EM_RAID_ERROR_UNKNOW,                                        // δ֪
	EM_RAID_ERROR_FAILED,                                        // RAID����
	EM_RAID_ERROR_DEGRADED,                                      // RAID����
} EM_RAID_ERROR;

// ��RAID�쳣��Ϣ ��ӦDH_ALARM_RAID_STATE_EX����
typedef struct tagALARM_RAID_INFO_EX
{
	DWORD                nAction;                               // 0-��ʼ, 1-ֹͣ
	char                 szDevice[DH_MAX_RAID_DEVICE_NAME];     // �豸����
	EM_RAID_ERROR        emErrorType;                           // ��������
	BYTE                 byReserved[1024];                      // ����
}ALARM_RAID_INFO_EX;

// IPC�Ĵ洢���ʹ����¼�(SD���쳣)�ṹ�� ��Ӧ DH_ALARM_STORAGE_IPC_FAILURE ����
typedef struct tagALARM_STORAGE_IPC_FAILURE_INFO
{
    int                  nAction;                               // 0:��ʼ 1:ֹͣ
    int                  nChannelID;                            // ����������ͨ����
    BYTE                 byReserved[1024];                      // �����ֽ�
}ALARM_STORAGE_IPC_FAILURE_INFO;

// ��ֹ����,����豸������ָ��ʱ����û�б仯��������ֹ������Ϣ��Ӧ DH_ALARM_DEVICE_STAY
typedef struct tagALARM_DEVICE_STAY_INFO
{
	int					nAction;								// 0:��ʼ 1:ֹͣ
	int					nChannelID;								// ����������ͨ����
	BYTE				byReserved[1024];						// �����ֽ�
}ALARM_DEVICE_STAY_INFO;

// ����������״̬����
typedef enum tagEM_SUB_WAY_DOOR_STATE_TYPE
{
    EM_SUB_WAY_DOOR_STATE_TYPE_UNKNOWN,     // δ֪��
    EM_SUB_WAY_DOOR_STATE_TYPE_LOST,        // ״̬��ʧ
    EM_SUB_WAY_DOOR_STATE_TYPE_ISOLATION,   // ����
    EM_SUB_WAY_DOOR_STATE_TYPE_UNLOCK,      // ����
    EM_SUB_WAY_DOOR_STATE_TYPE_NORMAL,      // ����
}EM_SUB_WAY_DOOR_STATE_TYPE;

// �������������
typedef enum tagEM_SUB_WAY_CARRIAGE_NUMBER_TYPE
{
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_UNKNOWN, // δ֪��
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC1,     // TC1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M1,      // M1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M2,      // M2
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC2,     // TC2
}EM_SUB_WAY_CARRIAGE_NUMBER_TYPE;

// ����������״̬ ��Ӧ DH_ALARM_SUB_WAY_DOOR_STATE ����
typedef struct tagALARM_SUB_WAY_DOOR_STATE_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nDoorNumber;         // �ź�   
    EM_SUB_WAY_DOOR_STATE_TYPE          emDoorState;         // ״̬
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_DOOR_STATE_INFO;

// ����PECE����״̬ ��Ӧ DH_ALARM_SUB_WAY_PECE_SWITCH ����
typedef struct tagALARM_SUB_WAY_PECE_SWITCH_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nDoorNumber;         // �ź�
    int                                 nState;              // ״̬��1��ʾ�򿪣�0��ʾ�ر�,����ֵ��ʾδ֪
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_PECE_SWITCH_INFO;

// �������¼� ��Ӧ DH_ALARM_SUB_WAY_FIRE_ALARM ����
typedef struct tagALARM_SUB_WAY_FIRE_ALARM_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nSourceNumber;       // ��Դ��
    BOOL                                bState;              // ״̬��TRUE��ʾ�л𾯣�FALSE��ʾ�޻�    
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_FIRE_ALARM_INFO;

// �����˿ͽ��ֱ����� ��Ӧ DH_ALARM_SUB_WAY_EMER_HANDLE ����
typedef struct tagALARM_SUB_WAY_EMER_HANDLE_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    BOOL                                bState;              // ״̬��TRUE��ʾ�ж�����FALSE��ʾ�޶���
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_EMER_HANDLE_INFO;

// ����˾���Ҹǰ�״̬ ��Ӧ DH_ALARM_SUB_WAY_CAB_COVER ����
typedef struct tagALARM_SUB_WAY_CAB_COVER_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nState;              // ״̬��1��ʾ�򿪣�0��ʾ�ر�,����ֵ��ʾδ֪
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_CAB_COVER_INFO;

// ������⵽�ϰ�����ѹ� ��Ӧ DH_ALARM_SUB_WAY_DERA_OBST ����
typedef struct tagALARM_SUB_WAY_DERA_OBST_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    BOOL                                bState;              // ״̬��TRUE��ʾ��⵽�ϰ�����ѹ죬FALSE��ʾδ��⵽�ϰ�����ѹ�
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_DERA_OBST_INFO;

// �������ұ�����״̬ ��Ӧ DH_ALARM_SUB_WAY_PECU_CALL ����
typedef struct tagALARM_SUB_WAY_PECU_CALL_INFO
{
    int                                 nAction;             // �¼�������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nCallNumber;         // ��������
    BOOL                                bState;              // ״̬��TRUE��ʾ������FALSE��ʾ�ޱ���
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // �����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_SUB_WAY_PECU_CALL_INFO;

// ��Ϊ���Žṹ���Ӧ DH_ALARM_DOOR_CLOSEDMANUALLY ����
typedef struct tagALARM_DOOR_CLOSEDMANUALLY_INFO
{
    int                                 nAction;             // �¼�������-1δ֪1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nDoor;               // ��ͨ����
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; // �Ž�����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_DOOR_CLOSEDMANUALLY_INFO;

// �ų���ʱ��δ�ض�Ӧ DH_ALARM_DOOR_NOTCLOSED_LONGTIME ����
typedef struct tagALARM_DOOR_NOTCLOSED_LONGTIME_INFO
{
    int                                 nAction;             // �¼�������-1δ֪1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    int                                 nDoor;               // ��ͨ����
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; // �Ž�����
    BYTE                                byReserved[1024];    // �����ֽ�
}ALARM_DOOR_NOTCLOSED_LONGTIME_INFO;

// ��ϱ�����Ϣ����ӦDH_ALARM_CUT_LINE����
typedef struct tagALARM_CUT_LINE_INFO
{
	int									nChannel;			 // ͨ����
	int                                 nAction;             // �¼�������-1��ʾδ֪������0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    BYTE                                byReserved[1024];    // �����ֽ�
} ALARM_CUT_LINE_INFO;

// ���˱�����Ϣ����Ӧ DH_ALARM_FIBRE_OPTIC_ABORT ����     
typedef struct tagALARM_FIBRE_OPTIC_ABORT       
{     
	int                                 nAlarmIn;            // ���������           
	int                                 nAction;             // �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;       
	NET_TIME_EX                         UTC;                 // �¼�������ʱ��       
	BYTE                                byReserved[1024];    // �����ֽ�       
}ALARM_FIBRE_OPTIC_ABORT; 

//β�汨���¼���Ϣ����Ӧ DH_ALARM_TAIL_DETECTION ����
typedef struct tagALARM_TAIL_DETECTION_INFO       
{     
	int									nAction;						// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int									nChannelID;						// ͨ����
    double								dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX							stuTime;						// �¼�������ʱ��
    int									nEventID;						// �¼�ID
	BYTE                				byReserved[1024];   			// �����ֽ�     
}ALARM_TAIL_DETECTION_INFO; 

// ������Ӵ�������Ϣ����ӦDH_ALARM_NEAR_DISTANCE_DETECTION ����
typedef struct tagALARM_NEAR_DISTANCE_INFO
{
	int									nChannel;			 // ͨ����
	int                                 nAction;             // �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;       
	int					                nEventID;			 // �¼�ID
    double				                dbPTS;			     // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			                stuTime;			 // �¼�������ʱ��
    BYTE                                byReserved[1024];    // �����ֽ�
} ALARM_NEAR_DISTANCE_INFO; 


// �����Ӿ�վ���¼���������Ա�б�
typedef struct tagMAN_STAND_LIST_INFO
{
	DH_POINT			stuCenter;			// վ����Ա����λ��,8192����ϵ
	char                szReversed[128];    // �����ֽ�
} MAN_STAND_LIST_INFO;

// �����Ӿ�վ��������Ϣ����ӦDH_ALARM_MAN_STAND_DETECTION ����
typedef struct tagALARM_MAN_STAND_INFO
{
	int							nChannel;			 		// ͨ����
	int                         nAction;             		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;       
	int					        nEventID;			 		// �¼�ID
    double				        dbPTS;			     		// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			        stuTime;			 		// �¼�������ʱ��

	int							nManListCount;				// ������Ա�б�����
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// ��������Ա�б�
    BYTE                        byReserved[1024];    		// �����ֽ�
} ALARM_MAN_STAND_INFO;

// �����Ӿ�����������ͳ���¼�������Ա�б�
typedef struct tagMAN_NUM_LIST_INFO
{
	DH_RECT				stuBoudingBox;			// ��Ա��Χ��,8192����ϵ
	int					nStature;				// ��Ա��ߣ���λcm
	char                szReversed[128];    	// �����ֽ�
} MAN_NUM_LIST_INFO;


// �����Ӿ�����������ͳ�Ʊ�������ӦDH_ALARM_MAN_NUM_DETECTION ����
typedef struct tagALARM_MAN_NUM_INFO
{
	int							nChannel;			 		// ͨ����
	int                         nAction;             		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;       
	int					        nEventID;			 		// �¼�ID
    double				        dbPTS;			     		// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			        stuTime;			 		// �¼�������ʱ��
    int							nManListCount;				// ������Ա�б�����
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// ��������Ա�б�
    BYTE                        byReserved[1024];    		// �����ֽ�
} ALARM_MAN_NUM_INFO;
//�����������ͨ�������񱨾���Ϣ����ӦDH_ALARM_BITRATES_OVERLIMIT ���� 
typedef struct tagALARM_BITRATES_OVERLIMIT_INFO        
{      
	int                                 nChannel;                       // ��Ƶͨ����            
	int                                 nAction;                        // �¼�����,1��ʾ������ʼ,2��ʾ��������;   
	int                                 nLimitBps;                      // �������ʣ���λKbps 
	int                                 nCurrentBps;                    // ��ǰ���ʣ���λKbps  
	BYTE                                byReserved[1024];               // �����ֽ�    
}ALARM_BITRATES_OVERLIMIT_INFO;  

//����߷ֱ���ⱨ����Ϣ����Ӧ DH_ALARM_HIGH_DECIBEL ����
typedef struct tagALARM_HIGH_DECIBEL_INFO
{
	int                                 nAudioChannel;                  // ��Ƶͨ���� 
	int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;
	NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    BYTE                                byReserved[1024];               // �����ֽ�
}ALARM_HIGH_DECIBEL_INFO;

//ҡ�μ�ⱨ����Ϣ����Ӧ DH_ALARM_SHAKE_DETECTION ����
typedef struct tagALARM_SHAKE_DETECTION_INFO
{          
	int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;   
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
	BYTE                                byReserved[1024];               // �����ֽ�    
}ALARM_SHAKE_DETECTION_INFO;

// ���Ʒ�ʽ
typedef enum tagNET_ACCESS_METHOD
{
    NET_ACCESS_METHOD_UNKNOWN,                                          // δ֪
    NET_ACCESS_METHOD_CARD,                                             // ��
    NET_ACCESS_METHOD_PASSWORD,                                         // ����
    NET_ACCESS_METHOD_FINGERPRINT,                                      // ָ�� 
} NET_ACCESS_METHOD;

//���⿪���¼��� ��Ӧ DH_ALARM_ACCESS_CTL_MALICIOUS
typedef struct tagALARM_ACCESS_CTL_MALICIOUS
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;   
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    NET_ACCESS_METHOD                   emMethod;                       // ���ŷ�ʽ
    char                                szSerialNum[MAX_COMMON_STRING_32];     // ����������к�
	BYTE                                byReserved[1024];               // �����ֽ�  
}ALARM_ACCESS_CTL_MALICIOUS;

// �û���ע���¼�, ��Ӧ DH_ALARM_ACCESS_CTL_USERID_REGISTER
typedef struct tagALARM_ACCESS_CTL_USERID_REGISTER
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;   
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    char                                UserID[DH_USER_NAME_LEN_EX];    // �û���
    NET_ACCESS_METHOD                   emMethod;                       // ע�᷽ʽ
    char                                szSerialNum[MAX_COMMON_STRING_32];  // ���������к�
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_ACCESS_CTL_USERID_REGISTER;

// ������ʽ
typedef enum tagNET_ACCESS_CTL_LOCKTYPE
{
    NET_ACCESS_CTL_LOCKTYPE_UNKNOWN,                                    // δ֪
    NET_ACCESS_CTL_LOCKTYPE_DEADBOLT,                                   // ����
    NET_ACCESS_CTL_LOCKTYPE_STAYBOLT,                                   // ����
}NET_ACCESS_CTL_LOCKTYPE;

// ������Ϣ�ϱ��¼�, ��Ӧ DH_ALARM_ACCESS_CTL_REVERSELOCK
typedef struct tagALARM_ACCESS_CTL_REVERSELOCK
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;   
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    BOOL                                bStatus;                        // �������
    NET_ACCESS_CTL_LOCKTYPE             emMethod;                       // ������ʽ
    char                                szSerialNum[MAX_COMMON_STRING_32];     // ���������к�
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_ACCESS_CTL_REVERSELOCK;

// ɾ���û��ϱ��¼�, ��Ӧ DH_ALARM_ACCESS_CTL_USERID_DELETE
typedef struct tagALARM_ACCESS_CTL_USERID_DELETE
{
    int                                 nAction;                        // �¼�����,0��ʾ�����¼�,1��ʾ������ʼ,2��ʾ��������;   
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    NET_ACCESS_METHOD                   emMethod;                       // ע�᷽ʽ
    char                                szSerialNum[MAX_COMMON_STRING_32];     // ���������к�
	BYTE                                byReserved[1024];               // �����ֽ� 
}ALARM_ACCESS_CTL_USERID_DELETE;

//�¼�����DH_ALARM_ACCESS_DOOR_BELL(�����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_ACCESS_DOOR_BELL_INFO
{
	int 					nChannelID; 								// ͨ����
	NET_TIME_EX       		stuTime;									// �¼�������UTC ʱ��
	char                    szName[DH_MAX_NAME_LEN];     				// �Ž�����
	char                    szWirelessDevSN[DH_MAX_ACCESS_NAME_LEN];	// �����豸���к�
	BYTE			        bReserved[512];				        		// �����ֽ�
}ALARM_ACCESS_DOOR_BELL_INFO;

//�¼�����DH_ALARM_ACCESS_FACTORY_RESET(�����ָ���������)��Ӧ��������Ϣ
typedef struct tagALARM_ACCESS_FACTORY_RESET_INFO
{					
	NET_TIME_EX   		    stuTime;								// �¼�������UTC ʱ��
	char                    szSmartLockSN[DH_MAX_ACCESS_NAME_LEN];	// ���������к�
	BYTE			        bReserved[512];				        	// �����ֽ�
}ALARM_ACCESS_FACTORY_RESET_INFO;


// ���ſ��ض�������
typedef enum tagEM_NET_CABINET_SWITCH_ACTION_TYPE
{
    NET_CABINET_SWITCH_ACTION_TYPE_UNKNOWN,							// δ֪
	NET_CABINET_SWITCH_ACTION_TYPE_OPEN,							// ������
	NET_CABINET_SWITCH_ACTION_TYPE_CLOSE,							// �ع���
} EM_NET_CABINET_SWITCH_ACTION_TYPE;

// ����豸��������Ƶ���ͨ���������
#define MAX_LINK_CHANNEL_NUMBER		16

// �ƹ��豸���͵���Ʒ��ŵ�����Ϣʵʱ�ϱ��¼�(DH_ALARM_CABINET)
typedef struct tagALARM_CABINET_INFO
{
    int									nAction;                                // 0:Pulse,1:Start,2:Stop,3:State
	NET_TIME_EX							stuTime;								// �¼�������ʱ��
	EM_NET_CABINET_SWITCH_ACTION_TYPE	emType;									// ���ſ��ض�������
	char								szSerialNo[MAX_COMMON_STRING_32];		// ��Ʒ���к�
	int									nLinkChannelNum;						// ����豸��������Ƶ���ͨ������
	int									nLinkChannel[MAX_LINK_CHANNEL_NUMBER];	// ����豸��������Ƶ���ͨ��
    BYTE								byReserved[1024];                       // ���� 
} ALARM_CABINET_INFO;

//�¼�����DH_SWITCH_SCREEN (�л���Ļ�¼� )��Ӧ��������Ϣ
typedef struct tagDH_SWITCH_SCREEN_INFO
{
	
	int              nChannelID;                                    //ͨ����
	
	BYTE             bReserved[512];                               
	
}DH_SWITCH_SCREEN_INFO;

#define MAX_EVENT_INFO_LEN			128          // �¼���ϸ��Ϣ��󳤶�

// ΢�Ƴ��������¼���Ϣ, ��Ӧ DH_MCS_GENERAL_CAPACITY_LOW
typedef struct tagALARM_MCS_GENERAL_CAPACITY_LOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_GENERAL_CAPACITY_LOW_INFO;

// ΢�ƴ洢�ڵ������¼���Ϣ, ��Ӧ DH_MCS_DATA_NODE_OFFLINE
typedef struct tagALARM_MCS_DATA_NODE_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DATA_NODE_OFFLINE_INFO;

// ΢�ƴ��������¼���Ϣ, ��Ӧ DH_MCS_DISK_OFFLINE
typedef struct tagALARM_MCS_DISK_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DISK_OFFLINE_INFO;

// ΢�ƴ��̱����¼���Ϣ, ��Ӧ DH_MCS_DISK_SLOW
typedef struct tagALARM_MCS_DISK_SLOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DISK_SLOW_INFO;

// ΢�ƴ������¼���Ϣ, ��Ӧ DH_MCS_DISK_BROKEN
typedef struct tagALARM_MCS_DISK_BROKEN_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DISK_BROKEN_INFO;

// ΢�ƴ���δ֪�����¼���Ϣ, ��Ӧ DH_MCS_DISK_UNKNOW_ERROR
typedef struct tagALARM_MCS_DISK_UNKNOW_ERROR_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DISK_UNKNOW_ERROR_INFO;

// ΢��Ԫ���ݷ������쳣�¼���Ϣ, ��Ӧ DH_MCS_METADATA_SERVER_ABNORMAL
typedef struct tagALARM_MCS_METADATA_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO;

// ΢��Ŀ¼�������쳣�¼���Ϣ, ��Ӧ DH_MCS_CATALOG_SERVER_ABNORMAL
typedef struct tagALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO;

// ΢�Ƴ��������ָ��¼���Ϣ��Ϣ, ��Ӧ DH_MCS_GENERAL_CAPACITY_RESUME
typedef struct tagALARM_MCS_GENERAL_CAPACITY_RESUME_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO;

// ΢�ƴ洢�ڵ������¼���Ϣ, ��Ӧ DH_MCS_DATA_NODE_ONLINE
typedef struct tagALARM_MCS_DATA_NODE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DATA_NODE_ONLINE_INFO;

// ΢�ƴ��������¼���Ϣ, ��Ӧ DH_MCS_DISK_ONLINE
typedef struct tagALARM_MCS_DISK_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_DISK_ONLINE_INFO;

// ΢��Ԫ���ݱ��������¼���Ϣ, ��Ӧ DH_MCS_METADATA_SLAVE_ONLINE
typedef struct tagALARM_MCS_METADATA_SLAVE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_METADATA_SLAVE_ONLINE_INFO;

// ΢��Ŀ¼�����������¼�, ��Ӧ DH_MCS_CATALOG_SERVER_ONLINE
typedef struct tagALARM_MCS_CATALOG_SERVER_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// �¼���ϸ��Ϣ 
	BYTE		byReserved[1024];							// �����ֽ�
}ALARM_MCS_CATALOG_SERVER_ONLINE_INFO;

//////////////////////////////////ATM֧��//////////////////////////////////

typedef struct
{
    int           Offset;                               // ��־λ��λƫ��
    int           Length;                               // ��־λ�ĳ���
    char          Key[16];                              // ��־λ��ֵ
} DH_SNIFFER_FRAMEID;

typedef struct 
{
    int           Offset;                       // ��־λ��λƫ��
    int           Offset2;                      // Ŀǰû��Ӧ��
    int           Length;                       // ��־λ�ĳ���
    int           Length2;                      // Ŀǰû��Ӧ��
    char          Title[12];                    // �����ֵ
    char          Key[12];                      // �ؼ��ֵ�ֵ
} DH_SNIFFER_CONTENT;

// ����ץ������
typedef struct 
{
    DH_SNIFFER_FRAMEID    snifferFrameId;                           // ÿ��FRAME ID ѡ��
    DH_SNIFFER_CONTENT    snifferContent[DH_SNIFFER_CONTENT_NUM];   // ÿ��FRAME��Ӧ��4��ץ������
} DH_SNIFFER_FRAME;

// ÿ��ץ����Ӧ�����ýṹ
typedef struct
{
    char                SnifferSrcIP[DH_MAX_IPADDR_LEN];        // ץ��Դ��ַ        
    int                 SnifferSrcPort;                         // ץ��Դ�˿�
    char                SnifferDestIP[DH_MAX_IPADDR_LEN];       // ץ��Ŀ���ַ
    int                 SnifferDestPort;                        // ץ��Ŀ��˿�
    char                reserved[28];                           // �����ֶ�
    DH_SNIFFER_FRAME    snifferFrame[DH_SNIFFER_FRAMEID_NUM];   // 6��FRAME ѡ��
    int                 displayPosition;                        // ��ʾλ��
    int                 recdChannelMask;                        // ͨ������
} DH_ATM_SNIFFER_CFG;

typedef struct  
{
    DWORD               dwSize;
    DH_ATM_SNIFFER_CFG  SnifferConfig[4];
    char                reserved[256];                          // �����ֶ�
} DHDEV_SNIFFER_CFG;

typedef DH_SNIFFER_FRAMEID DH_SNIFFER_FRAMEID_EX;
typedef DH_SNIFFER_CONTENT DH_SNIFFER_CONTENT_EX;

// ����ץ������
typedef struct  
{
    DH_SNIFFER_FRAMEID    snifferFrameId;                               // ÿ��FRAME ID ѡ��
    DH_SNIFFER_CONTENT    snifferContent[DH_SNIFFER_CONTENT_NUM_EX];    // ÿ��FRAME��Ӧ��8��ץ������    
} DH_SNIFFER_FRAME_EX;

// ÿ��ץ����Ӧ�����ýṹ
typedef struct
{
    char                SnifferSrcIP[DH_MAX_IPADDR_LEN];                // ץ��Դ��ַ        
    int                 SnifferSrcPort;                                 // ץ��Դ�˿�
    char                SnifferDestIP[DH_MAX_IPADDR_LEN];               // ץ��Ŀ���ַ
    int                 SnifferDestPort;                                // ץ��Ŀ��˿�
    DH_SNIFFER_FRAME_EX snifferFrame[DH_SNIFFER_FRAMEID_NUM];           // 6��FRAME ѡ��
    int                 displayPosition;                                // ��ʾλ��
    int                 recdChannelMask;                                // ͨ������  0  ~ 31 ͨ��
    BOOL                bDateScopeEnable;                               // ������Դʹ��
    BOOL                bProtocolEnable;                                // Э��ʹ��
    char                szProtocolName[DH_SNIFFER_PROTOCOL_SIZE];       // Э������
    int                 nSnifferMode;                                   // ץ����ʽ,0:net,1:232.
    int                 recdChannelMask1;                               // ͨ������  32 ~ 63 ͨ��
    char                reserved[252];
} DH_ATM_SNIFFER_CFG_EX;

// Atm�������Ͳ�ѯ���ؽṹ��
#define ATM_MAX_TRADE_TYPE_NAME    64
#define ATM_MAX_TRADE_NUM        1024

typedef struct __DH_ATM_QUERY_TRADE   
{
    int  nTradeTypeNum;                                                     // ʵ�ʽ�����������
    int  nExceptionTypeNum;                                                 // ʵ���쳣�¼�����
    char szSupportTradeType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];    // �����¼�������
    char szSupportExceptionType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];// �쳣�¼�������
} DH_ATM_QUERY_TRADE, *LPDH_ATM_QUERY_TRADE;

/////////////////////////////////������֧��/////////////////////////////////
#define nEncoderID nDecoderID
#define byEncoderID byDecoderID

// ��������Ϣ
typedef struct __DEV_DECODER_INFO 
{
    char            szDecType[64];                      // ����
    int             nMonitorNum;                        // TV����
    int             nEncoderNum;                        // ����ͨ������
    BYTE            szSplitMode[16];                    // ֧�ֵ�TV����ָ���,��������ʽ��ʾ,0Ϊ��β
    BYTE            bMonitorEnable[16];                 // ��TVʹ��
    BYTE            bTVTipDisplay;                      // ָʾ�Ƿ�֧��TV��ʾ��Ϣ��������, 0:��֧�� 1:֧��.
    BYTE            reserved1[3];
    BYTE            byLayoutEnable[48];                 // ������ͨ����ʾ������Ϣʹ��
    DWORD           dwLayoutEnMask[2];                  // ������ͨ����ʾ������Ϣʹ������,�ӵ�λ����λ֧��64��ͨ��,����dwLayoutEnMask[0]�ǵ�32λ
    char            reserved[4];
} DEV_DECODER_INFO, *LPDEV_DECODER_INFO;

//#define NANJINGDITIE_NVD
#ifndef NANJINGDITIE_NVD
// ���ӵı�������Ϣ
typedef struct __DEV_ENCODER_INFO 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];             // ǰ��DVR��IP��ַ
    WORD            wDevPort;                               // ǰ��DVR�Ķ˿ں�
    BYTE            bDevChnEnable;                          // ����ͨ��ʹ��
    BYTE            byDecoderID;                            // ���ֶ��ѷ���,������������ dwDecoderID
    char            szDevUser[DH_USER_NAME_LENGTH_EX];      // �û���
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];        // ����
    int             nDevChannel;                            // ͨ����
    int             nStreamType;                            // ��������,0����������1��������1; 2:snap; 3: ������2
    BYTE            byConnType;                             // -1: auto, 0��TCP��1��UDP��2���鲥
    BYTE            byWorkMode;                             // 0��ֱ����1��ת��
    WORD            wListenPort;                            // ָʾ��������Ķ˿�,ת��ʱ��Ч
    DWORD           dwProtoType;                            // Э������,
                                                            // 0:������ǰ
                                                            // 1:�󻪶���Э��
                                                            // 2:��ϵͳ����Э��
                                                            // 3:��DSSЭ��
                                                            // 4:��rtspЭ��
    char            szDevName[64];                          // ǰ���豸����
    BYTE            byVideoInType;                          // �ý���ͨ����ǰ��ƵԴ����:0-����(SD),1-����(HD),ע:�豸֧�ָ���ͨ������Ч        
    char            szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp��չ,ǰ��DVR��IP��ַ(������������)
    BYTE            bySnapMode;                             // ץͼģʽ(nStreamType==2ʱ��Ч) 0����ʾ����һ֡,1����ʾ��ʱ��������
    BYTE            byManuFactory;                          // Ŀ���豸����������,����ο�EM_IPC_TYPE��
    BYTE            byDeviceType;                           // Ŀ���豸���豸����,0:IPC
    BYTE            byDecodePolicy;                         // Ŀ���豸�Ľ������,0:������ǰ
                                                            // 1:ʵʱ�ȼ��� 2:ʵʱ�ȼ���
                                                            // 3:ʵʱ�ȼ��� 4:Ĭ�ϵȼ�
                                                            // 5:�����ȼ��� 6:�����ȼ���
                                                            // 7:�����ȼ���
    BYTE            bReserved[3];                           // �����ֽ�
    DWORD           dwHttpPort;                             // Http�˿ں�,0-65535
    DWORD           dwRtspPort;                             // Rtsp�˿ں�,0-65535
    char            szChnName[32];                          // Զ��ͨ������, ֻ�ж�ȡ�������Ʋ�Ϊ��ʱ�ſ����޸ĸ�ͨ��������
    DWORD           dwDecoderID;                            // ��Ӧ����ͨ����
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#else

// ���ӵı�������Ϣ
typedef struct __DEV_ENCODER_INFO 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];             // ǰ��DVR��IP��ַ
    WORD            wDevPort;                               // ǰ��DVR�Ķ˿ں�
    BYTE            bDevChnEnable;                          // ����ͨ��ʹ��
    BYTE            byDecoderID;                            // ���ֶ��ѷ���,������������ dwDecoderID
    char            szDevUser[DH_USER_NAME_LENGTH_EX];      // �û���
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];        // ����
    int             nDevChannel;                            // ͨ����
    int             nStreamType;                            // ��������,0����������1��������1; 2:snap; 3: ������2
    BYTE            byConnType;                             // -1: auto, 0��TCP��1��UDP��2���鲥
    BYTE            byWorkMode;                             // 0��ֱ����1��ת��
    WORD            wListenPort;                            // ָʾ��������Ķ˿�,ת��ʱ��Ч;byConnTypeΪ�鲥ʱ,����Ϊ�ಥ�˿�
    DWORD           dwProtoType;                            // Э������,
                                                            // 0:������ǰ
                                                            // 1:�󻪶���Э��
                                                            // 2:��ϵͳ����Э��
                                                            // 3:��DSSЭ��
                                                            // 4:��rtspЭ��
                                                            // 5:��׼TS��
    char            szDevName[32];                          // ǰ���豸����
    BYTE            byVideoInType;                          // �ý���ͨ����ǰ��ƵԴ����:0-����(SD),1-����(HD),ע:�豸֧�ָ���ͨ������Ч        
    char            szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp��չ,ǰ��DVR��IP��ַ(������������)
    BYTE            bySnapMode;                             // ץͼģʽ(nStreamType==2ʱ��Ч) 0����ʾ����һ֡,1����ʾ��ʱ��������
    BYTE            byManuFactory;                          // Ŀ���豸����������,����ο�EM_IPC_TYPE��
    BYTE            byDeviceType;                           // Ŀ���豸���豸����,0:IPC
    BYTE            byDecodePolicy;                         // Ŀ���豸�Ľ������,0:������ǰ
                                                            // 1:ʵʱ�ȼ��� 2:ʵʱ�ȼ���
                                                            // 3:ʵʱ�ȼ��� 4:Ĭ�ϵȼ�
                                                            // 5:�����ȼ��� 6:�����ȼ���
                                                            // 7:�����ȼ���
    BYTE            bReserved[3];                           // �����ֽ�
    DWORD           dwHttpPort;                             // Http�˿ں�,0-65535
    DWORD           dwRtspPort;                             // Rtsp�˿ں�,0-65535
    char            szChnName[32];                          // Զ��ͨ������, ֻ�ж�ȡ�������Ʋ�Ϊ��ʱ�ſ����޸ĸ�ͨ��������
    char            szMcastIP[DH_MAX_IPADDR_LEN];           // �ಥIP��ַ,byConnTypeΪ�鲥ʱ��Ч
    DWORD           dwDecoderID;                            // ��Ӧ����ͨ����
    char            reserved[124];
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#endif

// ������rtsp url����
typedef struct __DHDEV_DECODER_URL_CFG
{
    DWORD           dwSize;
    char            szMainStreamUrl[MAX_PATH];          // ������url
    char            szExtraStreamUrl[MAX_PATH];         // ������url
} DHDEV_DECODER_URL_CFG;

typedef enum tagDH_SPLIT_DISPLAY_TYPE
{
    DH_SPLIT_DISPLAY_TYPE_GENERAL=1,          // ��ͨ��ʾ����
    DH_SPLIT_DISPLAY_TYPE_PIP=2,              // ���л���ʾ����
    DH_SPLIT_DISPLAY_TYPE_CUSTOM=3,           // ������Ϸָ�ģʽ
} DH_SPLIT_DISPLAY_TYPE;

// CLIENT_CtrlDecTVScreen �ӿڲ���
typedef struct tagDH_CTRL_DECTV_SCREEN
{
    DWORD           dwSize;                             // �ṹ���С
    int             nSplitType;                         // �ָ�ģʽ
    BYTE *          pEncoderChannel;                    // ��ʾͨ��,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_GENERALʱ��Ч,���û������ڴ棬�����߷�����ڴ泤�Ȳ���С��nSplitType�Ĵ�С
    BYTE            byGroupNo;                          // ����ͨ�����,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_PIPʱ��ʾ���л���ʾ��������Ч��
    char            reserved[3];                        // �����ֽ�
    DWORD           dwDisplayType;                      // ��ʾ���ͣ������DH_SPLIT_DISPLAY_TYPE��ע�͸�ģʽ����ʾ������"PicInPic"����, ��ģʽ����ʾ���ݰ�NVD���й����������DisChn�ֶξ�����������,û����һ����ʱ,Ĭ��Ϊ��ͨ��ʾ����,��"General"��
}DH_CTRL_DECTV_SCREEN;

// TV������Ϣ
typedef struct __DEV_DECODER_TV 
{
    int                 nID;                            // TV��
    BOOL                bEnable;                        // ʹ��,�����ر�
    int                 nSplitType;                     // ����ָ���
    DEV_ENCODER_INFO    stuDevInfo[16];                 // �������������ϢdwDisplayType=DH_SPLIT_DISPLAY_TYPE_GENERALʱ��Ч
    BYTE                bySupportSplit[10];             // ֧�ֵķָ�ģʽ
    BYTE                byGroupNo;                      // ����ͨ�����,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_PIPʱ��ʾ���л���ʾ��������Ч��
    char                reserved[1];                    // �����ֽ�
    DWORD               dwDisplayType;                  // ��ʾ���ͣ������DH_SPLIT_DISPLAY_TYPE��ע�͸�ģʽ����ʾ������"PicInPic"����, ��ģʽ����ʾ���ݰ�NVD���й����������DisChn�ֶξ�����������,û����һ����ʱ,Ĭ��Ϊ��ͨ��ʾ����,��"General"��
} DEV_DECODER_TV, *LPDEV_DECODER_TV;

// ���������������Ϣ
typedef struct __DEC_COMBIN_INFO
{
    int             nCombinID;                          // ���ID
    int             nSplitType;                         // ����ָ��� 
    BYTE            bDisChn[16];                        // ��ʾͨ��
    char            reserved[16];
} DEC_COMBIN_INFO, *LPDEC_COMBIN_INFO;

// ��������Ѳ��Ϣ
#define DEC_COMBIN_NUM             32                   // ��Ѳ��ϸ���
typedef struct __DEC_TOUR_COMBIN 
{
    int             nTourTime;                          // ��Ѳ���(��)
    int             nCombinNum;                         // ��ϸ���
    BYTE            bCombinID[DEC_COMBIN_NUM];          // ��ϱ�
    char            reserved1[32];
    BYTE            bCombinState[DEC_COMBIN_NUM];       // ������ʹ��״̬,0���أ�1����
    char            reserved2[32];
} DEC_TOUR_COMBIN, *LPDEC_TOUR_COMBIN;

// �������ط�����
typedef enum __DEC_PLAYBACK_MODE
{
    Dec_By_Device_File = 0,                             // ǰ���豸�����ļ���ʽ
    Dec_By_Device_Time,                                 // ǰ���豸����ʱ�䷽ʽ
} DEC_PLAYBACK_MODE;

// �������طſ�������
typedef enum __DEC_CTRL_PLAYBACK_TYPE
{
    Dec_Playback_Seek = 0,                              // �϶�
    Dec_Playback_Play,                                  // ����
    Dec_Playback_Pause,                                 // ��ͣ
    Dec_Playback_Stop,                                  // ֹͣ
} DEC_CTRL_PLAYBACK_TYPE;

//��Ѳ��������
typedef enum __DEC_CTRL_TOUR_TYPE
{
    Dec_Tour_Stop = 0,                                  // ֹͣ
    Dec_Tour_Start,                                     // ��ʼ
    Dec_Tour_Pause,                                     // ��ͣ
    Dec_Tour_Resume,                                    // �ָ�
} DEC_CTRL_TOUR_TYPE;

// ���ļ��ط�ǰ���豸����
typedef struct __DEC_PLAYBACK_FILE_PARAM 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];         // ǰ��DVR��IP��ַ
    WORD            wDevPort;                           // ǰ��DVR�Ķ˿ں�
    BYTE            bDevChnEnable;                      // ����ͨ��ʹ��
    BYTE            byDecoderID;                        // ��Ӧ����ͨ����
    char            szDevUser[DH_USER_NAME_LENGTH_EX];  // �û���
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];    // ����
    NET_RECORDFILE_INFO stuRecordInfo;                  // ¼���ļ���Ϣ
    char            reserved[12];
} DEC_PLAYBACK_FILE_PARAM, *LPDEC_PLAYBACK_FILE_PARAM;

// ��ʱ��ط�ǰ���豸����
typedef struct __DEC_PLAYBACK_TIME_PARAM 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];         // ǰ��DVR��IP��ַ
    WORD            wDevPort;                           // ǰ��DVR�Ķ˿ں�
    BYTE            bDevChnEnable;                      // ����ͨ��ʹ��
    BYTE            byDecoderID;                        // ��Ӧ����ͨ����
    char            szDevUser[DH_USER_NAME_LENGTH_EX];  // �û���
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];    // ����
    int             nChannelID;
    NET_TIME        startTime;
    NET_TIME        endTime;
    char            reserved[12];
} DEC_PLAYBACK_TIME_PARAM, *LPDEC_PLAYBACK_TIME_PARAM;

// ��ǰ����ͨ��״̬��Ϣ(����ͨ��״̬,��������Ϣ��)
typedef struct __DEV_DECCHANNEL_STATE
{
    BYTE            byDecoderID;                        // ��Ӧ����ͨ����
    BYTE            byChnState;                         // ��ǰ����ͨ�����ڲ���״̬:0������,1��ʵʱ����,2���ط� 3 - ��Ѳ
    BYTE            byFrame;                            // ��ǰ����֡��
    BYTE            byReserved;                         // ����
    int             nChannelFLux;                       // ����ͨ����������
    int             nDecodeFlux;                        // ����������
    char            szResolution[16];                   // ��ǰ���ݷֱ���
    char            reserved[256];
} DEV_DECCHANNEL_STATE, *LPDEV_DECCHANNEL_STATE;

// �豸TV���������Ϣ
typedef struct __DEV_VIDEOOUT_INFO
{
    DWORD           dwVideoStandardMask;            // NSP,��Ƶ��ʽ����,��λ��ʾ�豸�ܹ�֧�ֵ���Ƶ��ʽ(�ݲ�֧��)
    int             nVideoStandard;                 // NSP,��ǰ����ʽ(�ݲ�֧��,��ʹ��DHDEV_SYSTEM_ATTR_CFG��byVideoStandard����ʽ��ȡ������)
    DWORD           dwImageSizeMask;                // �ֱ�������,��λ��ʾ�豸�ܹ�֧�ֵķֱ���
    int             nImageSize;                     // ��ǰ�ķֱ���
    char            reserved[256];
}DEV_VIDEOOUT_INFO, *LPDEV_VIDEOOUT_INFO;

// ����TV���
typedef struct __DEV_TVADJUST_CFG
{
    int             nTop;                           // �ϲ�߾ࣨ0��100��
    int             nBotton;                        // �²�߾ࣨ0��100��
    int             nLeft;                          // ���߾ࣨ0��100��
    int             nRight;                         // �Ҳ�߾ࣨ0��100��
    int             reserved[32];
}DHDEV_TVADJUST_CFG, *LPDHDEV_TVADJUST_CFG;

//��̨�������굥Ԫ
typedef struct tagPTZ_SPEED_UNIT
{
    float                  fPositionX;           //��̨ˮƽ��������,��һ����-1~1
    float                  fPositionY;           //��̨��ֱ��������,��һ����-1~1
    float                  fZoom;                //��̨��Ȧ�Ŵ���,��һ���� 0~1
    char                   szReserve[32];        //Ԥ��32�ֽ�
}PTZ_SPEED_UNIT;

//��̨�������굥Ԫ
typedef struct tagPTZ_SPACE_UNIT
{
    int                    nPositionX;           //��̨ˮƽ�˶�λ��,��Ч��Χ��[0,3600]
    int                    nPositionY;           //��̨��ֱ�˶�λ��,��Ч��Χ��[-1800,1800]
    int                    nZoom;                //��̨��Ȧ�䶯λ��,��Ч��Χ��[0,128]
    char                   szReserve[32];        //Ԥ��32�ֽ�
}PTZ_SPACE_UNIT;

// ������Ѳ����
typedef struct __DEV_DECODER_TOUR_SINGLE_CFG
{
    char        szIP[128];                          // ǰ���豸ip.����"10.7.5.21". �����������֧��.��Ҫ��'\0'����.
    int         nPort;                              // ǰ���豸�˿�.(0, 65535).
    int         nPlayChn;                           // ����ǰ���豸ͨ��[1, 16].
    int         nPlayType;                          // ����ǰ����������, 0:������; 1:������.
    char        szUserName[32];                     // ��½ǰ���豸���û���,��Ҫ��'\0'����.
    char        szPassword[32];                     // ��½ǰ���豸������,��Ҫ��'\0'����.
    int         nInterval;                          // ��Ѳ���ʱ��[10, 120],��λ��.
    DWORD       nManuFactory;                       // Ŀ���豸����(ö�� ���IPC_TYPE)
    UINT        nHttpPport;                         // Ŀ���豸�Ķ˿�(Http�˿�)
    UINT        nRtspPort;                          // Ŀ���豸�Ķ˿�(Rtsp�˿�)
    BYTE        byServiceType;                      // ��������, -1: auto, 0��TCP��1��UDP��2���鲥
    BYTE        bReserved[51];                      // �����ֽ�,�����չ.
}DHDEV_DECODER_TOUR_SINGLE_CFG;

typedef struct __DEV_DECODER_TOUR_CFG
{
    int                             nCfgNum;        // ���ýṹ����Ŀ. �������֧��32��.����֧����Ŀ����ͨ��������ѯ.
    DHDEV_DECODER_TOUR_SINGLE_CFG   tourCfg[64];    // ��ѯ��������,��Ч�ṹ������ɳ�Ա"nCfgNum"ָ��. ����32�������չ.
    BYTE                            bReserved[256]; // �����ֽ�,�����չ.
}DHDEV_DECODER_TOUR_CFG;

/////////////////////////////////����֧��/////////////////////////////////
// �����ӦͼƬ�ļ���Ϣ
typedef struct  
{
    DWORD           dwOffSet;                       // �ļ��ڶ��������ݿ��е�ƫ��λ��, ��λ:�ֽ�
    DWORD           dwFileLenth;                    // �ļ���С, ��λ:�ֽ�
    WORD            wWidth;                         // ͼƬ���, ��λ:����
    WORD            wHeight;                        // ͼƬ�߶�, ��λ:����
    char*           pszFilePath;                    // ������ʷԭ��,�ó�Աֻ���¼��ϱ�ʱ��Ч
                                                    // �ļ�·��
                                                    // �û�ʹ�ø��ֶ�ʱ��Ҫ��������ռ���п�������
    BYTE            bIsDetected;                    //ͼƬ�Ƿ��㷨�������ļ������ύʶ�������ʱ,
								                    //����Ҫ��ʱ��ⶨλ��ͼ,1:������,0:û�м���
	
	BYTE            bReserved[7];                   // 12<--16
	DH_POINT		stuPoint;						// Сͼ���Ͻ��ڴ�ͼ��λ�ã�ʹ�þ�������ϵ				
}DH_PIC_INFO;

// �����ӦͼƬ�ļ���Ϣ(����ͼƬ·��)
typedef struct tagDH_PIC_INFO_EXX
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];   // ������ʷԭ��,�ó�Ա������/��ȡʱ��Ч
                                                        // �ļ�·��
    DH_PIC_INFO     stuPicInfo;                         // ͼƬ��Ϣ
}DH_PIC_INFO_EX2;

// �����ӦͼƬ�ļ���Ϣ(����ͼƬ·��)
typedef struct
{
    DWORD           dwOffSet;                       // �ļ��ڶ��������ݿ��е�ƫ��λ��, ��λ:�ֽ�
    DWORD           dwFileLenth;                    // �ļ���С, ��λ:�ֽ�
    WORD            wWidth;                         // ͼƬ���, ��λ:����
    WORD            wHeight;                        // ͼƬ�߶�, ��λ:����
	char            szFilePath[64];                 // �ļ�·��
    BYTE            bIsDetected;                    // ͼƬ�Ƿ��㷨�������ļ������ύʶ�������ʱ,
	                                                // ����Ҫ��ʱ��ⶨλ��ͼ,1:������,0:û�м���
    BYTE            bReserved[11];                  // ����
}DH_PIC_INFO_EX3;

// ��չ�ֶ��м�����int64, ǿ��4�ֽڶ���
#pragma pack(push)
#pragma pack(4)
// ��Ƶ����������Ϣ�ṹ��
typedef struct 
{
    int                 nObjectID;                          // ����ID,ÿ��ID��ʾһ��Ψһ������
    char                szObjectType[128];                  // ��������
    int                 nConfidence;                        // ���Ŷ�(0~255),ֵԽ���ʾ���Ŷ�Խ��
    int                 nAction;                            // ���嶯��:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // ��Χ��
    DH_POINT            Center;                             // ��������
    int                 nPolygonNum;                        // ����ζ������
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // �Ͼ�ȷ�����������
    DWORD               rgbaMainColor;                      // ��ʾ���ơ������������Ҫ��ɫ�����ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����,����:RGBֵΪ(0,255,0),͸����Ϊ0ʱ, ��ֵΪ0x00ff0000.
    char                szText[128];                        // ��������صĴ�0�������ı�,���糵��,��װ��ŵȵ�
                                                            // "ObjectType"Ϊ"Vehicle"����"Logo"ʱ������ʹ��Logo��Vehicle��Ϊ�˼����ϲ�Ʒ����ʾ����,֧�֣�
                                                            // "Unknown"δ֪ 
                                                            // "Audi" �µ�
                                                            // "Honda" ����
                                                            // "Buick" ���
                                                            // "Volkswagen" ����
                                                            // "Toyota" ����
                                                            // "BMW" ����
                                                            // "Peugeot" ����
                                                            // "Ford" ����
                                                            // "Mazda" ���Դ�
                                                            // "Nissan" ��ɣ(�ղ�)
                                                            // "Hyundai" �ִ�
                                                            // "Suzuki" ��ľ
                                                            // "Citroen" ѩ����
                                                            // "Benz" ����
                                                            // "BYD" ���ǵ�
                                                            // "Geely" ����
                                                            // "Lexus" �׿���˹
                                                            // "Chevrolet" ѩ����
                                                            // "Chery" ����
                                                            // "Kia" ����
                                                            // "Charade" ����
                                                            // "DF" ����
                                                            // "Naveco" ��ά��
                                                            // "SGMW" ����
                                                            // "Jinbei" ��
                                                            
                                                            // "JAC" ����
                                                            // "Emgrand" �ۺ�
                                                            // "ChangAn" ����
                                                            // "Great Wall" ����
                                                            // "Skoda" ˹�´�
                                                            // "BaoJun" ����
                                                            // "Subaru" ˹��³
                                                            // "LandWind" ½��
                                                            // "Luxgen" ���ǽ�
                                                            // "Renault" ��ŵ
                                                            // "Mitsubishi" ����
                                                            // "Roewe" ����
                                                            // "Cadillac" ��������
                                                            // "MG" ����
                                                            // "Zotye" ��̩
                                                            // "ZhongHua" �л�
                                                            // "Foton" ����
                                                            // "SongHuaJiang" �ɻ���
                                                            // "Opel" ŷ��
                                                            // "HongQi" һ������
                                                            // "Fiat" ������
                                                            // "Jaguar" �ݱ�
                                                            // "Volvo" �ֶ���
                                                            // "Acura" ک��
                                                            // "Porsche" ��ʱ��
                                                            
                                                            // "Jeep" ����
                                                            // "Bentley" ����
                                                            // "Bugatti" ���ӵ�
                                                            // "ChuanQi" ����
                                                            // "Daewoo" ����
                                                            // "DongNan" ����
                                                            // "Ferrari" ������
                                                            // "Fudi" ����
                                                            // "Huapu" ����
                                                            // "HawTai" ��̩
                                                            // "JMC" ����
                                                            // "JingLong" �����ͳ�
                                                            // "JoyLong" ����
                                                            // "Karry" ����
                                                            // "Chrysler" ����˹��
                                                            // "Lamborghini" ��������
                                                            // "RollsRoyce" ��˹��˹
                                                            // "Linian" ����
                                                            // "LiFan" ����
                                                            // "LieBao" �Ա�
                                                            // "Lincoln" �ֿ�
                                                            // "LandRover" ·��
                                                            // "Lotus" ·��˹
                                                            // "Maserati" ��ɯ����
                                                            // "Maybach" ���ͺ�

                                                            // "Mclaren" ������
                                                            // "Youngman" ����ͳ�
                                                            // "Tesla" ��˹��
                                                            // "Rely" ����
                                                            // "Lsuzu" ��ʮ��
                                                            // "Yiqi" һ��
                                                            // "Infiniti" Ӣ�����
                                                            // "YuTong" ��ͨ�ͳ�
                                                            // "AnKai" �����ͳ�
                                                            // "Canghe" ����
                                                            // "HaiMa" ����
                                                            // "Crown" ����ʹ�
                                                            // "HuangHai" �ƺ�
                                                            // "JinLv" ���ÿͳ�
                                                            // "JinNing" ����
                                                            // "KuBo" �Ჩ
                                                            // "Europestar" ����
                                                            // "MINI" ����
                                                            // "Gleagle" ȫ��ӥ
                                                            // "ShiDai" ʱ��
                                                            // "ShuangHuan" ˫��
                                                            // "TianYe" ��Ұ
                                                            // "WeiZi" ����
                                                            // "Englon" Ӣ��
                                                            // "ZhongTong" ��ͨ�ͳ�

                                                            // "Changan" �����γ�
                                                            // "Yuejin" Ծ��
                                                            // "Taurus" ��ţ��
                                                            // "Alto" ����
                                                            // "Weiwang" ����
                                                            // "Chenglong" ����
                                                            // "Haige" ����
                                                            // "Shaolin" ���ֿͳ�
                                                            // "Beifang" �����ͳ�
                                                            // "Beijing" ��������
                                                            // "Hafu" ����

															// "BeijingTruck" ��������
															// "Besturn" ����
															// "ChanganBus" �����ͳ�
															// "Dodge" ����
															// "DongFangHong" ������
															// "DongFengTruck" �������
                                                            // "DongFengBus" ����ͳ�
															// "MultiBrand" ��Ʒ��
															// "FotonTruck" �������
															// "FotonBus" ����ͳ�
															// "GagcTruck" ��������
															// "HaFei" ����
															// "HowoBus" ���ֿͳ�
															// "JACTruck" ��������
															// "JACBus" �����ͳ�
															// "JMCTruck" �������
															// "JieFangTruck" ��Ż���
															// "JinBeiTruck" �𱭻���
															// "KaiMaTruck" �������
															// "CoasterBus" ��˹��ͳ�
															// "MudanBus" ĵ���ͳ�
															// "NanJunTruck" �Ͽ�����
															// "QingLing" ����
															// "NissanCivilian" �ղ������ͳ�
															// "NissanTruck" �ղ�����
															// "MitsubishiFuso" �����ɣ
															// "SanyTruck" ��һ����
															// "ShanQiTruck" ��������
															// "ShenLongBus" �����ͳ�
															// "TangJunTruck" �ƿ�����
															// "MicroTruck" ΢����
															// "VolvoBus" �ֶ��ֿͳ�
															// "LsuzuTruck" ��ʮ�����
															// "WuZhengTruck" ��������
															// "Seat" ������
															// "YangZiBus" ���ӿͳ�
															// "YiqiBus" һ���ͳ�
															// "YingTianTruck" Ӣ�����
															// "YueJinTruck" Ծ������
															// "ZhongDaBus" �д�ͳ�
															// "ZxAuto" ����

															// "ZhongQiWangPai" ��������
															// "WAW" �³�
															// "BeiQiWeiWang" ��������
															// "BYDDaimler"	���ǵϴ�ķ��
															// "ChunLan" ����
															// "DaYun" ����
															// "DFFengDu" ������
															// "DFFengGuang" ������
															// "DFFengShen" �������
															// "DFFengXing" �������
															// "DFLiuQi" ��������
															// "DFXiaoKang" ����С��
															// "FeiChi" �ɳ�
															// "FordMustang" ����Ұ��
															// "GuangQi" ����
															// "GuangTong" ��ͨ
															// "HuiZhongTruck" �����ؿ�
															// "JiangHuai" ����
															// "SunWin" ����
															// "ShiFeng" ʱ��
															// "TongXin" ͬ��
															// "WZL" ������
															// "XiWo" ����
															// "XuGong" �칤
															// "JingGong" ����
															// "SAAB" ����
															// "SanHuanShiTong" ����ʮͨ
															// "KangDi" ����
															// "YaoLong" ҫ¡


    char                szObjectSubType[64];                // ���������,���ݲ�ͬ����������,����ȡ���������ͣ�
                                                            // Vehicle Category:"Unknown"  δ֪,"Motor" ������,"Non-Motor":�ǻ�����,"Bus": ������,"Bicycle" ���г�,"Motorcycle":Ħ�г�,"PassengerCar":�ͳ�,
                                                            // "LargeTruck":�����,    "MidTruck":�л���,"SaloonCar":�γ�,"Microbus":�����,"MicroTruck":С����,"Tricycle":���ֳ�,    "Passerby":����                                                    
                                                            //  Plate Category��"Unknown" δ֪,"Normal" ���ƺ���,"Yellow" ����,"DoubleYellow" ˫���β��,"Police" ����"Armed" �侯��,
                                                            // "Military" ���Ӻ���,"DoubleMilitary" ����˫��,"SAR" �۰���������,"Trainning" ����������
                                                            // "Personal" ���Ժ���,"Agri" ũ����,"Embassy" ʹ�ݺ���,"Moto" Ħ�г�����,"Tractor" ����������,"Other" ��������
															// "Civilaviation"�񺽺���,"Black"����
															// "PureNewEnergyMicroCar"���綯����ԴС��,"MixedNewEnergyMicroCar,"�������ԴС��,"PureNewEnergyLargeCar",���綯����Դ��
															// "MixedNewEnergyLargeCar"�������Դ��
                                                            // HumanFace Category:"Normal" ��ͨ����,"HideEye" �۲��ڵ�,"HideNose" �����ڵ�,"HideMouth" �첿�ڵ�,"TankCar"�۹޳�(װ��ѧҩƷ��Σ��Ʒ)

    WORD                wSubBrand;                          // ������Ʒ�� ��Ҫͨ��ӳ���õ���������Ʒ�� ӳ�����������ֲ�
    BYTE                byReserved1;                     
    bool                bPicEnble;                          // �Ƿ��������ӦͼƬ�ļ���Ϣ
    DH_PIC_INFO         stPicInfo;                          // �����ӦͼƬ��Ϣ
    bool                bShotFrame;                         // �Ƿ���ץ���ŵ�ʶ����
    bool                bColor;                             // ������ɫ(rgbaMainColor)�Ƿ����
    BYTE                byReserved2;
    BYTE                byTimeType;                         // ʱ���ʾ����,���EM_TIME_TYPE˵��
    NET_TIME_EX         stuCurrentTime;                     // �����ƵŨ��,��ǰʱ���������ץ�Ļ�ʶ��ʱ,�Ὣ��ʶ������֡����һ����Ƶ֡��jpegͼƬ��,��֡����ԭʼ��Ƶ�еĳ���ʱ�䣩
    NET_TIME_EX         stuStartTime;                       // ��ʼʱ��������忪ʼ����ʱ��
    NET_TIME_EX         stuEndTime;                         // ����ʱ���������������ʱ��
    DH_RECT             stuOriginalBoundingBox;             // ��Χ��(��������)
    DH_RECT             stuSignBoundingBox;                 // ���������Χ��
    DWORD               dwCurrentSequence;                  // ��ǰ֡��ţ�ץ���������ʱ��֡��
    DWORD               dwBeginSequence;                    // ��ʼ֡��ţ����忪ʼ����ʱ��֡��ţ�
    DWORD               dwEndSequence;                      // ����֡��ţ���������ʱ��֡��ţ�
    INT64               nBeginFileOffset;                   // ��ʼʱ�ļ�ƫ��, ��λ: �ֽڣ����忪ʼ����ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    INT64               nEndFileOffset;                     // ����ʱ�ļ�ƫ��, ��λ: �ֽڣ���������ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // ������ɫ���ƶ�,ȡֵ��Χ��0-100,�����±�ֵ����ĳ����ɫ,���EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �ϰ���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �°���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    int                 nRelativeID;                        // �������ID
    char                szSubText[20];                      // "ObjectType"Ϊ"Vehicle"����"Logo"ʱ,��ʾ�����µ�ĳһ��ϵ,����µ�A6L,���ڳ�ϵ�϶�,SDKʵ��ʱ͸�����ֶ�,�豸��ʵ��д��
    WORD                wBrandYear;                         // ����Ʒ����� ��Ҫͨ��ӳ���õ���������� ӳ�����������ֲ�
} DH_MSG_OBJECT;

// ���ַ���
typedef enum tagEM_MSG_OBJ_PERSON_DIRECTION
{
    EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN,         // δ֪����
    EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT,  // ��������
    EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT   // ��������
}EM_MSG_OBJ_PERSON_DIRECTION;

// ��Ƶ����������Ϣ��չ�ṹ��
typedef struct tagDH_MSG_OBJECT_EX
{
    DWORD               dwSize;
    int                 nObjectID;                          // ����ID,ÿ��ID��ʾһ��Ψһ������
    char                szObjectType[128];                  // ��������
    int                 nConfidence;                        // ���Ŷ�(0~255),ֵԽ���ʾ���Ŷ�Խ��
    int                 nAction;                            // ���嶯��:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // ��Χ��
    DH_POINT            Center;                             // ��������
    int                 nPolygonNum;                        // ����ζ������
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // �Ͼ�ȷ�����������
    DWORD               rgbaMainColor;                      // ��ʾ���ơ������������Ҫ��ɫ�����ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����,����:RGBֵΪ(0,255,0),͸����Ϊ0ʱ, ��ֵΪ0x00ff0000.
    char                szText[128];                        // ͬDH_MSG_OBJECT��Ӧ�ֶ�   
    char                szObjectSubType[64];                // ���������,���ݲ�ͬ����������,����ȡ���������ͣ�
                                                            // ͬDH_MSG_OBJECT��Ӧ�ֶ�
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // �Ƿ��������ӦͼƬ�ļ���Ϣ
    DH_PIC_INFO         stPicInfo;                          // �����ӦͼƬ��Ϣ
    bool                bShotFrame;                         // �Ƿ���ץ���ŵ�ʶ����
    bool                bColor;                             // ������ɫ(rgbaMainColor)�Ƿ����
    BYTE                bLowerBodyColor;                    // �°�����ɫ(rgbaLowerBodyColor)�Ƿ����
    BYTE                byTimeType;                         // ʱ���ʾ����,���EM_TIME_TYPE˵��
    NET_TIME_EX         stuCurrentTime;                     // �����ƵŨ��,��ǰʱ���������ץ�Ļ�ʶ��ʱ,�Ὣ��ʶ������֡����һ����Ƶ֡��jpegͼƬ��,��֡����ԭʼ��Ƶ�еĳ���ʱ�䣩
    NET_TIME_EX         stuStartTime;                       // ��ʼʱ��������忪ʼ����ʱ��
    NET_TIME_EX         stuEndTime;                         // ����ʱ���������������ʱ��
    DH_RECT             stuOriginalBoundingBox;             // ��Χ��(��������)
    DH_RECT             stuSignBoundingBox;                 // ���������Χ��
    DWORD               dwCurrentSequence;                  // ��ǰ֡��ţ�ץ���������ʱ��֡��
    DWORD               dwBeginSequence;                    // ��ʼ֡��ţ����忪ʼ����ʱ��֡��ţ�
    DWORD               dwEndSequence;                      // ����֡��ţ���������ʱ��֡��ţ�
    INT64               nBeginFileOffset;                   // ��ʼʱ�ļ�ƫ��, ��λ: �ֽڣ����忪ʼ����ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    INT64               nEndFileOffset;                     // ����ʱ�ļ�ƫ��, ��λ: �ֽڣ���������ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // ������ɫ���ƶ�,ȡֵ��Χ��0-100,�����±�ֵ����ĳ����ɫ,���EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �ϰ���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �°���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    int                 nRelativeID;                        // �������ID
    char                szSubText[20];                      // "ObjectType"Ϊ"Vehicle"����"Logo"ʱ,��ʾ�����µ�ĳһ��ϵ,����µ�A6L,���ڳ�ϵ�϶�,SDKʵ��ʱ͸�����ֶ�,�豸��ʵ��д��

    int                 nPersonStature;                     // ������Ա���,��λcm
    EM_MSG_OBJ_PERSON_DIRECTION emPersonDirection;          // ��Ա���ַ���
    DWORD               rgbaLowerBodyColor;                 // ʹ�÷���ͬrgbaMainColor,��������Ϊ��ʱ��Ч 
} DH_MSG_OBJECT_EX;


// ��Ƶ����������Ϣ��չ�ṹ��,��չ�汾2
typedef struct tagDH_MSG_OBJECT_EX2
{
    DWORD				dwSize;
    int                 nObjectID;                          // ����ID,ÿ��ID��ʾһ��Ψһ������
    char                szObjectType[128];                  // ��������
    int                 nConfidence;                        // ���Ŷ�(0~255),ֵԽ���ʾ���Ŷ�Խ��
    int                 nAction;                            // ���嶯��:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // ��Χ��
    DH_POINT            Center;                             // ��������
    int                 nPolygonNum;                        // ����ζ������
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // �Ͼ�ȷ�����������
    DWORD               rgbaMainColor;                      // ��ʾ���ơ������������Ҫ��ɫ�����ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����,����:RGBֵΪ(0,255,0),͸����Ϊ0ʱ, ��ֵΪ0x00ff0000.
    char                szText[128];                        // ͬDH_MSG_OBJECT��Ӧ�ֶ�	
    char                szObjectSubType[64];                // ���������,���ݲ�ͬ����������,����ȡ���������ͣ�
    // ͬDH_MSG_OBJECT��Ӧ�ֶ�
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // �Ƿ��������ӦͼƬ�ļ���Ϣ
    DH_PIC_INFO         stPicInfo;                          // �����ӦͼƬ��Ϣ
    bool                bShotFrame;                         // �Ƿ���ץ���ŵ�ʶ����
    bool                bColor;                             // ������ɫ(rgbaMainColor)�Ƿ����
    BYTE                bLowerBodyColor;                    // �°�����ɫ(rgbaLowerBodyColor)�Ƿ����
    BYTE                byTimeType;                         // ʱ���ʾ����,���EM_TIME_TYPE˵��
    NET_TIME_EX         stuCurrentTime;                     // �����ƵŨ��,��ǰʱ���������ץ�Ļ�ʶ��ʱ,�Ὣ��ʶ������֡����һ����Ƶ֡��jpegͼƬ��,��֡����ԭʼ��Ƶ�еĳ���ʱ�䣩
    NET_TIME_EX         stuStartTime;                       // ��ʼʱ��������忪ʼ����ʱ��
    NET_TIME_EX         stuEndTime;                         // ����ʱ���������������ʱ��
    DH_RECT             stuOriginalBoundingBox;             // ��Χ��(��������)
    DH_RECT             stuSignBoundingBox;                 // ���������Χ��
    DWORD               dwCurrentSequence;                  // ��ǰ֡��ţ�ץ���������ʱ��֡��
    DWORD               dwBeginSequence;                    // ��ʼ֡��ţ����忪ʼ����ʱ��֡��ţ�
    DWORD               dwEndSequence;                      // ����֡��ţ���������ʱ��֡��ţ�
    INT64               nBeginFileOffset;                   // ��ʼʱ�ļ�ƫ��, ��λ: �ֽڣ����忪ʼ����ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    INT64               nEndFileOffset;                     // ����ʱ�ļ�ƫ��, ��λ: �ֽڣ���������ʱ,��Ƶ֡��ԭʼ��Ƶ�ļ���������ļ���ʼ����ƫ�ƣ�
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // ������ɫ���ƶ�,ȡֵ��Χ��0-100,�����±�ֵ����ĳ����ɫ,���EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �ϰ���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // �°���������ɫ���ƶ�(��������Ϊ��ʱ��Ч)
    int                 nRelativeID;                        // �������ID
    char				szSubText[20];						// "ObjectType"Ϊ"Vehicle"����"Logo"ʱ,��ʾ�����µ�ĳһ��ϵ,����µ�A6L,���ڳ�ϵ�϶�,SDKʵ��ʱ͸�����ֶ�,�豸��ʵ��д��
    
    int					nPersonStature;						// ������Ա���,��λcm
    EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;			// ��Ա���ַ���
    DWORD               rgbaLowerBodyColor;                 // ʹ�÷���ͬrgbaMainColor,��������Ϊ��ʱ��Ч

    //��ƵŨ��������Ϣ
    int                 nSynopsisSpeed;                             // Ũ���ٶ���ֵ,����1~10��ʮ����λ,5��ʾŨ����ֻ����5�����ٶȵ����塣�Ǹ���Ե�λ
                                                                    // Ϊ0ʱ,���ֶ���Ч
    int                 nSynopsisSize;                              // Ũ���ߴ���ֵ,����1~10��ʮ����λ,3��ʾŨ����ֻ����3���ϴ�С�����塣�Ǹ���Ե�λ
                                                                    // Ϊ0ʱ,���ֶ���Ч
    BOOL                bEnableDirection;                           // ΪTrueʱ,�������˶�����������
                                                                    // ΪFalseʱ,���������˶�����������,
    DH_POINT            stuSynopsisStartLocation;                   // Ũ���˶�����,��ʼ�����,��������һ����[0,8192)����,bEnableDirectionΪTrueʱ��Ч
    DH_POINT            stuSynopsisEndLocation;                     // Ũ���˶�����,��ֹ�����,��������һ����[0,8192)����,bEnableDirectionΪTrueʱ��Ч
    BYTE                byReserved[2048];                           // ��չ�ֽ�
} DH_MSG_OBJECT_EX2;
#pragma pack(pop)

// ץ����Ϣ
typedef struct
{
    short              snSpeed;                         // ��ǰ�����ٶ�,km/h
    short              snCarLength;                     // ��ǰ����,����Ϊ��λ
    float              fRedTime;                        // ��ǰ�������ʱ��,��.����
    float              fCapTime;                        // ��ǰ����ץ��ʱ��,��.���� 
    BYTE               bSigSequence;                    // ��ǰץ�����
    BYTE               bType;                           // ��ǰ������ץ������
                                                        // 0: �״������;1: �״������;2: ������������;3:������������
                                                        // 4: ����;5: �����;6: �����;7: �����;8: ȫ��ץ�Ļ��߿���
    BYTE               bDirection;                      // ���������:01:��ת���;02:ֱ�к��;03:��ת���
    BYTE               bLightColor;                     // ��ǰ�����ĺ��̵�״̬,0: �̵�, 1: ���, 2: �Ƶ�
    BYTE               bSnapFlag[16];                   // �豸������ץ�ı�ʶ
}DH_SIG_CARWAY_INFO;

// ������������Ϣ
typedef struct
{
    BYTE                byRedundance[8];                // �ɳ���������ץ���ź�������Ϣ
    BYTE                bReserved[120];                 // �����ֶ�
}DH_SIG_CARWAY_INFO_EX;

// ÿ�������������Ϣ
typedef struct  
{
    BYTE                bCarWayID;                           // ��ǰ������ 
    BYTE                bReserve[2];                         // �����ֶ�
    BYTE                bSigCount;                           // ������ץ�ĵĸ���
    DH_SIG_CARWAY_INFO  stuSigInfo[DH_MAX_SNAP_SIGNAL_NUM];  // ��ǰ������,������ץ�Ķ�Ӧ��ץ����Ϣ    
    BYTE                bReserved[12];                       // �����ֶ�
}DH_CARWAY_INFO;

// �¼���Ӧ�ļ���Ϣ
typedef struct
{
    BYTE               bCount;                               // ��ǰ�ļ������ļ����е��ļ�����
    BYTE               bIndex;                               // ��ǰ�ļ����ļ����е��ļ����(���1��ʼ)
    BYTE               bFileTag;                             // �ļ���ǩ, EM_EVENT_FILETAG
    BYTE               bFileType;                            // �ļ�����,0-��ͨ 1-�ϳ� 2-��ͼ
    NET_TIME_EX        stuFileTime;                          // �ļ�ʱ��
    DWORD              nGroupId;                             // ͬһ��ץ���ļ���Ψһ��ʶ
}DH_EVENT_FILE_INFO;

// ͼƬ�ֱ���
typedef struct
{
    unsigned short   snWidth;    // ��
    unsigned short   snHight;    // ��
}DH_RESOLUTION_INFO;

// ��ɫRGBA
typedef struct tagDH_COLOR_RGBA
{
    int                 nRed;                       // ��
    int                 nGreen;                     // ��
    int                 nBlue;                      // ��
    int                 nAlpha;                     // ͸��
} DH_COLOR_RGBA, NET_COLOR_RGBA;

#define	NET_COUNTRY_LENGTH		3		// ������д����
#define NET_COMMENT_LENGTH		100		// ��ע��Ϣ����
#define NET_GROUPID_LENGTH		64		// group id ��Ϣ����
#define NET_GROUPNAME_LENGTH	128		// group name ��Ϣ����
#define NET_FEATUREVALUE_LENGTH	128		// �������� ��Ϣ����


// ��Ա��Ϣ (��MEDIAFILE_FACERECOGNITION_INFO, DEV_EVENT_FACERECOGNITION_INFO�ṹ����pszCommentָ����SDK�ڲ������ͷ��ڴ�, �����ṹ�������û������ͷ��ڴ� )
typedef struct tagFACERECOGNITION_PERSON_INFO
{
    char                szPersonName[DH_MAX_NAME_LEN];                  // ����,�˲�������                 
    WORD                wYear;                                          // ������,��Ϊ��ѯ����ʱ,�˲�����0,���ʾ�˲�����Ч
    BYTE                byMonth;                                        // ������,��Ϊ��ѯ����ʱ,�˲�����0,���ʾ�˲�����Ч
    BYTE                byDay;                                          // ������,��Ϊ��ѯ����ʱ,�˲�����0,���ʾ�˲�����Ч
    char                szID[DH_MAX_PERSON_ID_LEN];                     // ��ԱΨһ��ʾ(���֤����,����,���������)
    BYTE                bImportantRank;                                 // ��Ա��Ҫ�ȼ�,1~10,��ֵԽ��Խ��Ҫ,��Ϊ��ѯ����ʱ,�˲�����0,���ʾ�˲�����Ч
    BYTE                bySex;                                          // �Ա�,1-��,2-Ů,��Ϊ��ѯ����ʱ,�˲�����0,���ʾ�˲�����Ч
    WORD                wFacePicNum;                                    // ͼƬ����
    DH_PIC_INFO         szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];         // ��ǰ��Ա��Ӧ��ͼƬ��Ϣ
    BYTE                byType;                                         // ��Ա����,��� EM_PERSON_TYPE
    BYTE                byIDType;                                       // ֤������,��� EM_CERTIFICATE_TYPE
    BYTE                bReserved1[2];                                  // �ֽڶ���  
    char                szProvince[DH_MAX_PROVINCE_NAME_LEN];           // ʡ��
    char                szCity[DH_MAX_CITY_NAME_LEN];                   // ����
    char                szPersonNameEx[DH_MAX_PERSON_NAME_LEN];         // ����,�������������,16�ֽ��޷��������,�����Ӵ˲���, 
    char                szUID[DH_MAX_PERSON_ID_LEN];                    // ��ԱΨһ��ʶ��,�״��ɷ��������,������ID�ֶ�
                                                                        // �޸�,ɾ������ʱ����
	char				szCountry[NET_COUNTRY_LENGTH];					// ����,����ISO3166�淶
	BYTE				byIsCustomType;									// ��Ա�����Ƿ�Ϊ�Զ���: 0 ʹ��Type�涨������ 1 �Զ���,ʹ��szPersonName�ֶ�
	char				*pszComment;									// ��ע��Ϣ
	char				*pszGroupID;									// ��Ա������ID
	char				*pszGroupName;									// ��Ա��������
	char				*pszFeatureValue;								// ��������
	BYTE				bGroupIdLen;									// pszGroupID�ĳ���
	BYTE				bGroupNameLen;									// pszGroupName�ĳ���
	BYTE				bFeatureValueLen;								// pszFeatureValue�ĳ���
	BYTE                bReserved[5];
}FACERECOGNITION_PERSON_INFO;

// ��ѡ��Ա��Ϣ
typedef struct tagCANDIDATE_INFO
{
    FACERECOGNITION_PERSON_INFO  stPersonInfo;            // ��Ա��Ϣ
                                                          // ���أ�����������,ָ���ؿ�����Ա��Ϣ��
                                                          // ��ʷ��,ָ��ʷ������Ա��Ϣ
                                                          // ������,ָ���ؿ����Ա��Ϣ

    BYTE                         bySimilarity;            // �Ͳ�ѯͼƬ�����ƶ�,�ٷֱȱ�ʾ,1~100
    BYTE                         byRange;                 // ��Ա�������ݿⷶΧ,���EM_FACE_DB_TYPE
    BYTE                         byReserved1[2];
    NET_TIME                     stTime;                  // ��byRangeΪ��ʷ���ݿ�ʱ��Ч,��ʾ��ѯ��Ա���ֵ�ʱ��
    char                         szAddress[MAX_PATH];     // ��byRangeΪ��ʷ���ݿ�ʱ��Ч,��ʾ��ѯ��Ա���ֵĵص�  
	BOOL                         bIsHit;                  // �Ƿ���ʶ����,ָ��������������ڿ�����û�бȶԽ��
	DH_PIC_INFO_EX3              stuSceneImage;           // ����ȫ��ͼ
	int							 nChannelID;			  // ͨ����
    BYTE                         byReserved[32];          // �����ֽ�
}CANDIDATE_INFO;


// ����ҵ�񷽰�       
typedef enum tagEM_CLASS_TYPE        
{
	EM_CLASS_UNKNOWN                	= 0,    // δ֪ҵ��       
    EM_CLASS_VIDEO_SYNOPSIS            	= 1,    // ��ƵŨ��       
    EM_CLASS_TRAFFIV_GATE            	= 2,    //����       
    EM_CLASS_ELECTRONIC_POLICE        	= 3,    // �羯       
    EM_CLASS_SINGLE_PTZ_PARKING        	= 4,    // ����Υͣ       
    EM_CLASS_PTZ_PARKINBG            	= 5,    // ����Υͣ       
    EM_CLASS_TRAFFIC                	= 6,    // ��ͨ�¼�"Traffic"       
    EM_CLASS_NORMAL                    	= 7,    // ͨ����Ϊ����"Normal"       
    EM_CLASS_PRISON                    	= 8,    // ������Ϊ����"Prison"       
    EM_CLASS_ATM                    	= 9,    // ������Ϊ����"ATM"       
    EM_CLASS_METRO                    	= 10,   // ������Ϊ����       
    EM_CLASS_FACE_DETECTION            	= 11,   // �������"FaceDetection"       
    EM_CLASS_FACE_RECOGNITION        	= 12,   // ����ʶ��"FaceRecognition"       
    EM_CLASS_NUMBER_STAT            	= 13,   // ����ͳ��"NumberStat"       
    EM_CLASS_HEAT_MAP                	= 14,   // �ȶ�ͼ"HeatMap"       
    EM_CLASS_VIDEO_DIAGNOSIS        	= 15,   // ��Ƶ���"VideoDiagnosis"       
    EM_CLASS_VIDEO_ENHANCE            	= 16,   // ��Ƶ��ǿ       
    EM_CLASS_SMOKEFIRE_DETECT        	= 17,   // �̻���       
    EM_CLASS_VEHICLE_ANALYSE        	= 18,   // ��������ʶ��"VehicleAnalyse"       
    EM_CLASS_PERSON_FEATURE            	= 19,   // ��Ա����ʶ��     
    EM_CLASS_SDFACEDETECTION			= 20,	// ��Ԥ�õ��������"SDFaceDetect"  
    											//����һ�����򵫿����ڲ�ͬԤ�õ�����Ч
	EM_CLASS_HEAT_MAP_PLAN				= 21,	// ����ȶ�ͼ�ƻ�"HeatMapPlan" 
	EM_CLASS_NUMBERSTAT_PLAN			= 22,	// ���������ͳ�Ƽƻ� "NumberStatPlan"
	EM_CLASS_ATMFD						= 23,	// ����������⣬���������������쳣����������������ͷ�����������ATM���������Ż�
	EM_CLASS_HIGHWAY					= 24,	// ���ٽ�ͨ�¼����"Highway"
	EM_CLASS_CITY						= 25,	// ���н�ͨ�¼���� "City"
	EM_CLASS_LETRACK					= 26,	// ���ü��׸���"LeTrack"
	EM_CLASS_SCR						= 27,	// ������"SCR"
	EM_CLASS_STEREO_VISION              = 28,   // �����Ӿ�(˫Ŀ)"StereoVision"
	EM_CLASS_HUMANDETECT                = 29,   // ������"HumanDetect"
	EM_CLASS_FACE_ANALYSIS				= 30,	// �������� "FaceAnalysis"
} EM_CLASS_TYPE; 


//����ҵ�񷽰���������EM_SCENE_TYPEһ��
typedef enum tagEM_SCENE_CLASS_TYPE
{
	EM_SCENE_CLASS_UNKNOW,			// δ֪
	EM_SCENE_CLASS_NORMAL,			// "Normal" ��ͨ����
	EM_SCENE_CLASS_TRAFFIC,			// "Traffic" ��ͨ����
	EM_SCENE_CLASS_TRAFFIC_PATROL,	// "TrafficPatrol" ��ͨѲ��
	EM_SCENE_CLASS_FACEDETECTION,	// "FaceDetection" �������/����ʶ��
	EM_SCENE_CLASS_ATM,				// "ATM"
	EM_SENCE_CLASS_INDOOR,			// "Indoor"  ������Ϊ����������ͨ������ͬ�������ڳ������㷨�Ż���
	EM_SENCE_CLASS_FACERECOGNITION,	// "FaceRecognition" ����ʶ��
	EM_SENCE_CLASS_PRISON,			// "Prison" ����
	EM_SENCE_CLASS_NUMBERSTAT,		// "NumberStat" ������ͳ��
	EM_SENCE_CLASS_HEAT_MAP,		// "HeatMap" �ȶ�ͼ
	EM_SENCE_CLASS_VIDEODIAGNOSIS,	// "VideoDiagnosis" ��Ƶ���
	EM_SENCE_CLASS_VEHICLEANALYSE,	// "VehicleAnalyse" ��������������
	EM_SENCE_CLASS_COURSERECORD,	// "CourseRecord" �Զ�¼��
	EM_SENCE_CLASS_VEHICLE,			// "Vehicle" ���س���(������ҵ�ã���ͬ�����ܽ�ͨ��Traffic)
	EM_SENCE_CLASS_STANDUPDETECTION,// "StandUpDetection" �������
	EM_SCENE_CLASS_GATE,			// "Gate" ����
	EM_SCENE_CLASS_SDFACEDETECTION,	// "SDFaceDetect"  ��Ԥ�õ�������⣬����һ�����򵫿����ڲ�ͬԤ�õ�����Ч
	EM_SCENE_CLASS_HEAT_MAP_PLAN,	// "HeatMapPlan" ����ȶ�ͼ�ƻ�
	EM_SCENE_CLASS_NUMBERSTAT_PLAN,	// "NumberStatPlan"	���������ͳ�Ƽƻ�
	EM_SCENE_CLASS_ATMFD,			// "ATMFD"����������⣬���������������쳣����������������ͷ�����������ATM���������Ż�
	EM_SCENE_CLASS_HIGHWAY,			// "Highway" ���ٽ�ͨ�¼����
	EM_SCENE_CLASS_CITY,			// "City" ���н�ͨ�¼����
	EM_SCENE_CLASS_LETRACK,			// "LeTrack" ���ü��׸���
	EM_SCENE_CLASS_SCR,				// "SCR" ������
	EM_SCENE_CLASS_STEREO_VISION,   // "StereoVision" �����Ӿ�(˫Ŀ)
	EM_SCENE_CLASS_HUMANDETECT,		// "HumanDetect"������
	EM_SCENE_CLASS_FACEANALYSIS,	// "FaceAnalysis" ��������
} EM_SCENE_CLASS_TYPE;



// ���ܱ����¼�������Ϣ
typedef struct tagEVENT_INTELLI_COMM_INFO
{
	EM_CLASS_TYPE		emClassType;								// �����¼��������
	int					nPresetID;									// ���¼�������Ԥ�õ㣬��Ӧ�����ù����Ԥ�õ�
	BYTE                bReserved[124];                     		// �����ֽ�,�����չ.
} EVENT_INTELLI_COMM_INFO;

// ��ͨ����������Ϣ
typedef struct tagEVENT_TRAFFIC_CAR_PART_INFO
{
    char                szMachineName[128];                  // ���ػ�Զ���豸����    ��Դ����ͨ����General.MachineName    
    char                szRoadwayNo[32];                     // ��·���
    BYTE                bReserved[352];                      // �����ֽ�
}EVENT_TRAFFIC_CAR_PART_INFO;

// ��ͨ������ʻ��������
typedef enum tagEM_TRAFFICCAR_MOVE_DIRECTION
{
    EM_TRAFFICCAR_MOVE_DIRECTION_UNKNOWN,                           // δ֪��
    EM_TRAFFICCAR_MOVE_DIRECTION_STRAIGHT,                          // ֱ��
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_LEFT,                         // ��ת
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_RIGHT,                        // ��ת
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_AROUND,                       // ��ͷ
}EM_TRAFFICCAR_MOVE_DIRECTION;

// TrafficCar ��ͨ������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO
{
    char               szPlateNumber[32];                   // ���ƺ���
    char               szPlateType[32];                     // �������� "Unknown" δ֪; "Normal" ���ƺ���; "Yellow" ����; "DoubleYellow" ˫���β��
                                                            // "Police" ����; "Armed" �侯��; "Military" ���Ӻ���; "DoubleMilitary" ����˫��
                                                            // "SAR" �۰���������; "Trainning" ����������; "Personal" ���Ժ���; "Agri" ũ����
                                                            // "Embassy" ʹ�ݺ���; "Moto" Ħ�г�����; "Tractor" ����������; "Other" ��������
    char               szPlateColor[32];                    // ������ɫ    "Blue","Yellow", "White","Black","YellowbottomBlackText","BluebottomWhiteText","BlackBottomWhiteText","ShadowGreen","YellowGreen"
    char               szVehicleColor[32];                  // ������ɫ    "White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
    int                nSpeed;                              // �ٶ�    ��λKm/H
    char               szEvent[64];                         // ����������¼�    �μ��¼��б�Event List,ֻ������ͨ����¼���
    char               szViolationCode[32];                 // Υ�´���    ���TrafficGlobal.ViolationCode
    char               szViolationDesc[64];                 // Υ������
    int                nLowerSpeedLimit;                    // �ٶ�����
    int                nUpperSpeedLimit;                    // �ٶ�����
    int                nOverSpeedMargin;                    // �޸��ٿ���ֵ    ��λ��km/h 
    int                nUnderSpeedMargin;                   // �޵��ٿ���ֵ    ��λ��km/h 
    int                nLane;                               // ����    �μ��¼��б�Event List�п��ں�·���¼���
    int                nVehicleSize;                        // ������С,-1��ʾδ֪,����λ
                                                            // ��0λ:"Light-duty", С�ͳ�
                                                            // ��1λ:"Medium", ���ͳ�
                                                            // ��2λ:"Oversize", ���ͳ�
                                                            // ��3λ:"Minisize", ΢�ͳ�
                                                            // ��4λ:"Largesize", ����
    float              fVehicleLength;                      // ��������    ��λ��
    int                nSnapshotMode;                       // ץ�ķ�ʽ    0-δ����,1-ȫ��,2-����,4-ͬ��ץ��,8-����ץ��,16-����ͼ��
    char               szChannelName[32];                   // ���ػ�Զ�̵�ͨ������,�����ǵص���Ϣ    ��Դ��ͨ����������ChannelTitle.Name 
    char               szMachineName[256];                  // ���ػ�Զ���豸����    ��Դ����ͨ����General.MachineName
    char               szMachineGroup[256];                 // �����������豸����λ    Ĭ��Ϊ��,�û����Խ���ͬ���豸��Ϊһ��,���ڹ���,���ظ���
    char               szRoadwayNo[64];                     // ��·���
    char               szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION];      // 
                                                                            // ��ʻ���� , "DrivingDirection" : ["Approach", "�Ϻ�", "����"],
                                                                            // "Approach"-����,���������豸�����Խ��Խ����"Leave"-����,
                                                                            // ���������豸�����Խ��ԽԶ,�ڶ��͵����������ֱ�������к�
                                                                            // ���е������ص�
    char              *szDeviceAddress;                     // �豸��ַ,OSD���ӵ�ͼƬ�ϵ�,��Դ������TrafficSnapshot.DeviceAddress,'\0'����
    char               szVehicleSign[32];                   // ������ʶ, ���� "Unknown"-δ֪, "Audi"-�µ�, "Honda"-���� ...
    DH_SIG_CARWAY_INFO_EX stuSigInfo;                       // �ɳ���������ץ���ź�������Ϣ
    char              *szMachineAddr;                       // �豸����ص�
    float              fActualShutter;                      // ��ǰͼƬ�ع�ʱ��,��λΪ����
    BYTE               byActualGain;                        // ��ǰͼƬ����,��ΧΪ0~100
    BYTE               byDirection;                         // ��������,0-���� 1-�����򶫱� 2-���� 3-�������� 4-������ 5-���������� 6-������ 7-���������� 8-δ֪ 9-�Զ���
    BYTE               byReserved[2];
    char*              szDetailedAddress;                   // ��ϸ��ַ, ��ΪszDeviceAddress�Ĳ���
    char               szDefendCode[DH_COMMON_STRING_64];   // ͼƬ��α��  
    int                nTrafficBlackListID;                 // �������������ݿ��¼Ĭ������ID, 0,��Ч��> 0,���������ݼ�¼
    DH_COLOR_RGBA      stuRGBA;                             // ������ɫRGBA
    NET_TIME           stSnapTime;                          // ץ��ʱ��
    int                nRecNo;                              // ��¼���
    char               szCustomParkNo[DH_COMMON_STRING_32 + 1]; // �Զ��峵λ�ţ�ͣ�����ã�
    BYTE               byReserved1[3];
    int                nDeckNo;                             // ����λ��
    int                nFreeDeckCount;                      // ���г�������
    int                nFullDeckCount;                      // ռ�ó�������
    int                nTotalDeckCount;                     // �ܹ��������� 
    char               szViolationName[64];                 // Υ������
	unsigned int	   nWeight;								// ����(��λ Kg)
	char               szCustomRoadwayDirection[32];		// �Զ��峵������,byDirectionΪ9ʱ��Ч
    BYTE               byPhysicalLane;                      // ��������,ȡֵ0��5
    BYTE               byReserved2[3];
    EM_TRAFFICCAR_MOVE_DIRECTION emMovingDirection;         // ������ʻ����
    NET_TIME		   stuEleTagInfoUTC;					// ��Ӧ���ӳ��Ʊ�ǩ��Ϣ�еĹ���ʱ��(ThroughTime)
    BYTE               bReserved[552];                      // �����ֽ�,�����չ.
}DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO;

#pragma pack(push)
#pragma pack(4)
// GPS��Ϣ
typedef struct tagNET_GPS_INFO
{
    unsigned int                    nLongitude;         	// ����(��λ�ǰ����֮һ��)
                                                            // ������0 - 180000000				ʵ��ֵӦΪ: 180*1000000 �C dwLongitude
                                                            // ������180000000 - 360000000		ʵ��ֵӦΪ: dwLongitude �C 180*1000000
                                                            // ��: 300168866ӦΪ��300168866 - 180*1000000��/1000000 ������120.168866��
    unsigned int					nLatidude;              // γ��(��λ�ǰ����֮һ��)
                                                            // ��γ��0 - 90000000				ʵ��ֵӦΪ: 90*1000000 �C dwLatidude
                                                            // ��γ��90000000 �C 180000000		ʵ��ֵӦΪ: dwLatidude �C 90*1000000
															// ��: 120186268ӦΪ (120186268 - 90*1000000)/1000000 ����γ30. 186268��
    double                          dbAltitude;              // �߶�,��λΪ��
    double                          dbSpeed;                 // �ٶ�,��λkm/H
    double                          dbBearing;               // �����,��λ��
	BYTE                            bReserved[8];           // �����ֶ�
}NET_GPS_INFO;
#pragma pack(pop)

// �¼�����EVENT_IVS_CROSSLINEDETECTION(�������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_CROSSLINE_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // ��������
    int                 nDetectLineNum;                     // �������߶�����
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // �����˶��켣
    int                 nTrackLineNum;                      // �����˶��켣������
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bDirection;                         // ��ʾ���ַ���, 0-��������, 1-��������
    BYTE                byReserved[1];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[476];                     // �����ֽ�,�����չ.
} DEV_EVENT_CROSSLINE_INFO;

// �¼�����EVENT_IVS_CROSSLINEDETECTION_EX(�������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_CROSSLINE_INFO_EX 
{
    DWORD               dwSize;
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    float               PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT_EX    stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // ��������
    int                 nDetectLineNum;                     // �������߶�����
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // �����˶��켣
    int                 nTrackLineNum;                      // �����˶��켣������
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bDirection;                         // ��ʾ���ַ���, 0-��������, 1-��������
    BYTE                byReserved[1];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���

    int                 nMsgObjArrayCount;                  // ��⵽��������Ϣ����
    DH_MSG_OBJECT_EX*   pMsgObjArray;                       // ��⵽��������Ϣ����ָ��
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
} DEV_EVENT_CROSSLINE_INFO_EX;

// �¼�����EVENT_IVS_CROSSREGIONDETECTION(�������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_CROSSREGION_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved2[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // �����˶��켣
    int                 nTrackLineNum;                      // �����˶��켣������
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bDirection;                         // ��ʾ���ַ���, 0-����, 1-�뿪,2-����,3-��ʧ
    BYTE                bActionType;                        // ��ʾ��⶯������,0-���� 1-��ʧ 2-�������� 3-��Խ����
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    BYTE                bReserved[536];                     // �����ֽ�,�����չ.
    int                 nObjectNum;                         // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // ��⵽������
    int                 nTrackNum;                          // �켣��(���⵽�����������Ӧ)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];   // �켣��Ϣ(���⵽�������Ӧ)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
} DEV_EVENT_CROSSREGION_INFO;

//������������
typedef enum tagEM_SPECIAL_REGION_TYPE
{
    EM_SPEICAL_REGION_UNKNOW = 0        , // δ֪
    EM_SPEICAL_REGION_HIGH_LIGHT        , // ����;ATM������
    EM_SPEICAL_REGION_REGULAR_BLINK     , // ���ɵ���˸;ATM�忨��
    EM_SPEICAL_REGION_IRREGULAR_BLINK   , // �����ɵ���˸;ATM��Ļ��
}EM_SPECIAL_REGION_TYPE;

// �¼�����EVENT_IVS_PASTEDETECTION(�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_PASTE_INFO 
{
    int                     nChannelID;                         // ͨ����
    char                    szName[128];                        // �¼�����
    char                    bReserved1[4];                      // �ֽڶ���
    double                  PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                                // �¼�������ʱ��
    int                     nEventID;                           // �¼�ID
    DH_MSG_OBJECT           stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO      stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    int                     nDetectRegionNum;                   // ���������򶥵���
    DH_POINT                DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    BYTE                    bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                    byReserved[2];
    BYTE                    byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD                   dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    unsigned int            nOccurrenceCount;                   // �¼������ۼƴ���
    EM_SPECIAL_REGION_TYPE  emSpecialRegion;                    // ������������
    EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                    bReserved[748];                     // �����ֽ�,�����չ.
} DEV_EVENT_PASTE_INFO;

// �¼�����EVENT_IVS_LEFTDETECTION(��Ʒ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_LEFT_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
	short				nPreserID;							// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char				szPresetName[64];					// �¼�������Ԥ������
    BYTE                bReserved[422];                     // �����ֽ�,�����չ.
} DEV_EVENT_LEFT_INFO;

// �¼�����EVENT_IVS_PRESERVATION(��Ʒ��ȫ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_PRESERVATION_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[488];                     // �����ֽ�,�����չ.
} DEV_EVENT_PRESERVATION_INFO;

// �¼�����EVENT_IVS_STAYDETECTION(ͣ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_STAY_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[488];                     // �����ֽ�,�����չ.
} DEV_EVENT_STAY_INFO;

// �¼�����EVENT_IVS_WANDERDETECTION(�ǻ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_WANDER_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nObjectNum;                         // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // ��⵽������
    int                 nTrackNum;                          // �켣��(���⵽�����������Ӧ)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];   // �켣��Ϣ(���⵽�������Ӧ)
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
	short				nPreserID;							// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char				szPresetName[64];					// �¼�������Ԥ������
    BYTE                bReserved[558];                     // �����ֽ�,�����չ.
} DEV_EVENT_WANDER_INFO;

// �¼�����EVENT_IVS_MOVEDETECTION(�ƶ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_MOVE_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    int                 nTrackLineNum;                      // �����˶��켣������                 
    DH_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM];// �����˶��켣      
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[404];                     // �����ֽ�,�����չ.
} DEV_EVENT_MOVE_INFO;

// �¼�����EVENT_IVS_TAILDETECTION(β���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TAIL_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[488];                     // �����ֽ�,�����չ.
} DEV_EVENT_TAIL_INFO;

// �¼����� EVENT_IVS_RIOTERDETECTION (�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_RIOTER_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    int                 nObjectNum;                         // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // ��⵽�������б�
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������

    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[492];                     // �����ֽ�,�����չ.
} DEV_EVENT_RIOTERL_INFO;

// �¼�����EVENT_IVS_FIGHTDETECTION(��Ź�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FIGHT_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    int                 nObjectNum;                         // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // ��⵽�������б�
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������
    
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[492];                     // �����ֽ�,�����չ.
} DEV_EVENT_FIGHT_INFO;

// �¼�����EVENT_IVS_FIREDETECTION(���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FIRE_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // ����������
    
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[488];                     // �����ֽ�,�����չ.
} DEV_EVENT_FIRE_INFO;

// �¼�����EVENT_IVS_GETOUTBEDDETECTION(�������´��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_GETOUTBED_INFO 
{
    // �����ֶ�
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    // �¼���Ӧ�ֶ�
    DH_MSG_OBJECT       stuObject;                          // Object��ʾ�´���������Ϣ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // �����ֽ�,�����չ. 
} DEV_EVENT_GETOUTBED_INFO;

// �¼�����EVENT_IVS_PATROLDETECTION(Ѳ�߼���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_PATROL_INFO 
{
    // �����ֶ�
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    // �¼���Ӧ�ֶ�
    DH_MSG_OBJECT       stuObject;                          // Object��ʾѲ�ߵ�������Ϣ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // �����ֽ�,�����չ. 
} DEV_EVENT_PATROL_INFO;

// �¼����� EVENT_IVS_ONDUTYDETECTION(վ�ڼ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ONDUTY_INFO
{
    // �����ֶ�
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    // �¼���Ӧ�ֶ�
    DH_MSG_OBJECT       stuObject;                          // Object��ʾѲ�ߵ�������Ϣ
    int                 nDetectRegionNum;                   // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // �����ֽ�,�����չ. 
} DEV_EVENT_ONDUTY_INFO;

// �¼����� EVENT_IVS_ELECTROSPARKDETECTION(����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ELECTROSPARK_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[972];                     // �����ֽ�,�����չ.
    
} DEV_EVENT_ELECTROSPARK_INFO;

// �¼�����EVENT_IVS_SMOKEDETECTION(�������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_SMOKE_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_MSG_OBJECT       stuObject;                          // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON   
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
	PTZ_SPACE_UNIT		stuPtzPosition;						// ��̨������ͷŴ���
    BYTE                bReserved[792];                     // �����ֽ�,�����չ.
} DEV_EVENT_SMOKE_INFO;

// �¼�����EVENT_IVS_FLOWSTAT(����ͳ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FLOWSTAT_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    int                 nNumberLeft;                        // ����ߴ�Խ���˵ĸ���
    int                 nNumberRight;                       // ���ұߴ�Խ���˵ĸ���
    int                 nUpperLimit;                        // ���õ�����
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON  
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    BYTE                bReserved[972];                     // �����ֽ�,�����չ.

} DEV_EVENT_FLOWSTAT_INFO;

// �¼�����EVENT_IVS_NUMBERSTAT(����ͳ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_NUMBERSTAT_INFO 
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved2[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    int                 nNumber;                            // ����������ĸ���
    int                 nUpperLimit;                        // ���õ�����
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved1[2];                      // �ֽڶ���
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nEnteredNumber;                     // ��ʾ����������߳���ڵ�������ĸ���
    int                 nExitedNumber;                      // ��ʾ����������߳���ڵ�������ĸ���
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
    BYTE                bReserved[828];                     // �����ֽ�,�����չ.
} DEV_EVENT_NUMBERSTAT_INFO;

// �¼�����EVENT_IVS_CROSSFENCEDETECTION(��ԽΧ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_CROSSFENCEDETECTION_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nUpstairsLinePointNumber;                   // Χ���ϱ��߶�����
    DH_POINT            stuUpstairsLine[DH_MAX_DETECT_LINE_NUM];    // Χ���ϱ�����Ϣ
    int                 nDownstairsLinePointNumber;                 // Χ���±��߶�����
    DH_POINT            stuDownstairsLine[DH_MAX_DETECT_LINE_NUM];  // Χ���±�����Ϣ  
    int                 nTrackLineNum;                              // �����˶��켣������                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // �����˶��켣
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bDirection;                                 // ��ʾ���ַ���, 0-��������, 1-��������
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[616];                             // �����ֽ�,�����չ.    
} DEV_EVENT_CROSSFENCEDETECTION_INFO;

// �¼�����EVENT_IVS_INREGIONDETECTION(�����ڼ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_INREGIONDETECTION_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nObjectNum;                                 // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // ��⵽������
    int                 nTrackNum;                                  // �켣��(���⵽�����������Ӧ)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];           // �켣��Ϣ(���⵽�������Ӧ)
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[1016];                            // �����ֽ�,�����չ.
    
} DEV_EVENT_INREGIONDETECTION_INFO;

// �¼�����EVENT_IVS_TAKENAWAYDETECTION(��Ʒ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TAKENAWAYDETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
	short				nPreserID;									// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char				szPresetName[64];							// �¼�������Ԥ������
	BYTE                bReserved[550];                             // �����ֽ�,�����չ.
} DEV_EVENT_TAKENAWAYDETECTION_INFO;

// �¼����� EVENT_IVS_VIDEOABNORMALDETECTION(��Ƶ�쳣�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_VIDEOABNORMALDETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bType;                                      // �쳣����, 255-�����壨ͨ�����豸�˷��ش���ֵ��0-��Ƶ��ʧ, 1-��Ƶ����, 2-����ͷ�ڵ�, 3-����ͷ�ƶ�, 4-����, 5-����, 6-ͼ��ƫɫ, 7-��������
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[620];                             // �����ֽ�,�����չ.
} DEV_EVENT_VIDEOABNORMALDETECTION_INFO;

// �¼�����EVENT_IVS_PARKINGDETECTION(�Ƿ�ͣ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_PARKINGDETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[616];                             // �����ֽ�,�����չ.
} DEV_EVENT_PARKINGDETECTION_INFO;

// �¼�����EVENT_IVS_ABNORMALRUNDETECTION(�쳣�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ABNORMALRUNDETECTION 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    double              dbSpeed;                                    // �����˶��ٶ�,km/h
    double              dbTriggerSpeed;                             // �����ٶ�,km/h
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    int                 nTrackLineNum;                              // �����˶��켣������                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // �����˶��켣
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bRunType;                                   // �쳣��������, 0-���ٱ���, 1-ͻȻ����, 2-ͻȻ����
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[616];                             // �����ֽ�,�����չ.
} DEV_EVENT_ABNORMALRUNDETECTION_INFO;

// �¼�����EVENT_IVS_RETROGRADEDETECTION(��Ա�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_RETROGRADEDETECTION_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nTrackLineNum;                              // �����˶��켣������                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // �����˶��켣
    int                 nDirectionPointNum;                         // ������涨�ķ��򶥵���
    DH_POINT            stuDirections[DH_MAX_DETECT_LINE_NUM];      // ������涨�ķ���
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[616];                             // �����ֽ�,�����չ.
} DEV_EVENT_RETROGRADEDETECTION_INFO;

//��������Ӧ�Ա�����
typedef enum tagEM_DEV_EVENT_FACEDETECT_SEX_TYPE
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN,                   // δ֪
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN,                       // ����
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN,                     // Ů��
}EM_DEV_EVENT_FACEDETECT_SEX_TYPE;

//��������Ӧ������������
typedef enum tagEM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
{
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN,               // δ֪
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES,          // ���۾�
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE,                 // ΢Ц
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER,                 // ��ŭ
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS,               // ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST,               // ���
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR,                  // ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE,              // ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL,               // ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH,                 // ��Ц
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NOGLASSES,				// û���۾�
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_HAPPY,					// ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_CONFUSED,				// ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SCREAM,				// ���
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_SUNGLASSES,       // ��̫���۾�
}EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE;

// ��������
typedef enum tagEM_RACE_TYPE
{
	EM_RACE_UNKNOWN,			// δ֪
	EM_RACE_NODISTI,			// δʶ��
	EM_RACE_YELLOW,				// ������
	EM_RACE_BLACK,				// ����
	EM_RACE_WHITE,				// ����
} EM_RACE_TYPE;

// �۾�״̬
typedef enum tagEM_EYE_STATE_TYPE
{
	EM_EYE_STATE_UNKNOWN,		// δ֪
	EM_EYE_STATE_NODISTI,		// δʶ��
	EM_EYE_STATE_CLOSE,			// ����
	EM_EYE_STATE_OPEN,			// ����
} EM_EYE_STATE_TYPE;

// ���״̬
typedef enum tagEM_MOUTH_STATE_TYPE
{
	EM_MOUTH_STATE_UNKNOWN,		// δ֪
	EM_MOUTH_STATE_NODISTI,		// δʶ��
	EM_MOUTH_STATE_CLOSE,		// ����
	EM_MOUTH_STATE_OPEN,		// ����
} EM_MOUTH_STATE_TYPE;

// ����״̬
typedef enum tagEM_MASK_STATE_TYPE
{
	EM_MASK_STATE_UNKNOWN,		// δ֪
	EM_MASK_STATE_NODISTI,		// δʶ��
	EM_MASK_STATE_NOMASK,		// û������
	EM_MASK_STATE_WEAR,			// ������
} EM_MASK_STATE_TYPE;

// ����״̬
typedef enum tagEM_BEARD_STATE_TYPE
{
	EM_BEARD_STATE_UNKNOWN,		// δ֪
	EM_BEARD_STATE__NODISTI,	// δʶ��
	EM_BEARD_STATE_NOBEARD,		// û����
	EM_BEARD_STATE_HAVEBEARD,	// �к���
} EM_BEARD_STATE_TYPE;

#define DH_MAX_FACEDETECT_FEATURE_NUM          32                      // ��������������


// ��������
typedef struct tagNET_FACE_DATA
{
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE 		emSex;						// �Ա�
	int        								nAge;						// ����,-1��ʾ���ֶ�������Ч
    unsigned int        					nFeatureValidNum;           // ��������������Ч����,�� emFeature ���ʹ��
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // ������������,�� nFeatureValidNum ���ʹ��
	EM_RACE_TYPE							emRace;						// ����
	EM_EYE_STATE_TYPE						emEye;						// �۾�״̬
	EM_MOUTH_STATE_TYPE						emMouth;					// ���״̬
	EM_MASK_STATE_TYPE 						emMask;						// ����״̬
	EM_BEARD_STATE_TYPE						emBeard;					// ����״̬
	int										nAttractive;				// ����ֵ, -1��ʾ��Ч, 0δʶ��ʶ��ʱ��Χ1-100,�÷ָ�������
    BYTE                					bReserved[128];             // �����ֽ�,�����չ.
} NET_FACE_DATA;

// �¼�����EVENT_IVS_FACERECOGNITION(����ʶ��)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FACERECOGNITION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    int                 nEventID;                                   // �¼�ID
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nCandidateNum;                              // ��ǰ����ƥ�䵽�ĺ�ѡ��������
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM];        // ��ǰ����ƥ�䵽�ĺ�ѡ������Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];                             // ����
    BOOL                bGlobalScenePic;                            // ȫ��ͼ�Ƿ����
    DH_PIC_INFO         stuGlobalScenePicInfo;                      // ȫ��ͼƬ��Ϣ
    char                szSnapDevAddress[MAX_PATH];                 // ץ�ĵ�ǰ�������豸��ַ,�磺����·37��  
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
	NET_FACE_DATA		stuFaceData;								// ��������
	BYTE                bReserved[300];                             // �����ֽ�,�����չ.
}DEV_EVENT_FACERECOGNITION_INFO;

// �¼�����EVENT_IVS_DENSITYDETECTION(��Ա�ܶȼ��)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_DENSITYDETECTTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nObjectNum;                                 // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // ��⵽�������б�
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                              // �����ֽ�
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������

    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// �����¼�������Ϣ
    int					nUnit;										// �ܶȼ����ֵ��λ
	int					nValue;										// �ܶ�ֵ����λΪLevelʱ��ȡֵ0~3���ֱ��ʾ(��ϡ�裬ϡ�裬�ܼ������ܼ�)��λΪPercentʱ��ȡֵ0~100
	BYTE                bReserved[612];                             // �����ֽ�,�����չ.
}DEV_EVENT_DENSITYDETECTION_INFO;

// �¼����� EVENT_IVS_QUEUEDETECTION(�ŶӼ�ⱨ���¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_QUEUEDETECTION_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved2[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved1[2];                              // �����ֽ�,�����չ.
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DH_POINT            stuDetectLine[2];                           // ��������
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    BYTE                bReserved[1012];                            // �����ֽ�,�����չ.
}DEV_EVENT_QUEUEDETECTION_INFO;

// �¼�����EVENT_IVS_TRAFFICCONTROL(��ͨ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFICCONTROL_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[932];                             // �����ֽ�,�����չ.

} DEV_EVENT_TRAFFICCONTROL_INFO;


// �¼�����EVENT_IVS_TRAFFICACCIDENT(��ͨ�¹��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFICACCIDENT_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nObjectNum;                                 // ��⵽���������
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // ��⵽�������б�
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // ��ͨ����������Ϣ
    BYTE                bReserved[464];                             // �����ֽ�,�����չ.

} DEV_EVENT_TRAFFICACCIDENT_INFO;

#define DH_EVENT_MAX_CARD_NUM       16      // �¼��ϱ���Ϣ�������Ƭ����
#define DH_EVENT_CARD_LEN           36      // ��Ƭ���Ƴ���

// �¼��ϱ�Я����Ƭ��Ϣ
typedef struct tagEVENT_CARD_INFO
{
    char szCardNumber[DH_EVENT_CARD_LEN];           // ��Ƭ����ַ���
    BYTE bReserved[32];                             // �����ֽ�,�����չ.
}EVENT_CARD_INFO;

typedef enum tagEM_OPEN_STROBE_STATE
{
    NET_OPEN_STROBE_STATE_UNKOWN,                   // δ֪״̬
    NET_OPEN_STROBE_STATE_CLOSE,                    // ��բ
    NET_OPEN_STROBE_STATE_AUTO,                     // �Զ���բ    
    NET_OPEN_STROBE_STATE_MANUAL,                   // �ֶ���բ
}EM_OPEN_STROBE_STATE;

typedef enum tagEM_VEHICLE_DIRECTION
{
    NET_VEHICLE_DIRECTION_UNKOWN,                   // δ֪
    NET_VEHICLE_DIRECTION_HEAD,                     // ��ͷ    
    NET_VEHICLE_DIRECTION_TAIL,                     // ��β  
}EM_VEHICLE_DIRECTION;

//NTPУʱ״̬
typedef enum  tagEM_NTP_STATUS
{
    NET_NTP_STATUS_UNKNOWN = 0 ,
    NET_NTP_STATUS_DISABLE , 
    NET_NTP_STATUS_SUCCESSFUL , 
    NET_NTP_STATUS_FAILED , 
}EM_NTP_STATUS;

#define COMMON_SEAT_MAX_NUMBER        8             // Ĭ�ϼ��������ݸ���

typedef enum tagEM_COMMON_SEAT_TYPE
{
    COMMON_SEAT_TYPE_UNKNOWN    = 0,                // δʶ��
    COMMON_SEAT_TYPE_MAIN       = 1,                // ����ʻ
    COMMON_SEAT_TYPE_SLAVE      = 2,                // ����ʻ
}EM_COMMON_SEAT_TYPE;

// Υ��״̬
typedef struct tagEVENT_COMM_STATUS                 
{
    BYTE bySmoking;                                 // �Ƿ����
    BYTE byCalling;                                 // �Ƿ��绰
    char szReserved[14];                            // Ԥ���ֶ�
}EVENT_COMM_STATUS;

typedef enum tagNET_SAFEBELT_STATE
{
    SS_NUKNOW   = 0 ,				//δ֪
	SS_WITH_SAFE_BELT ,				                //��ϵ��ȫ��  
	SS_WITHOUT_SAFE_BELT ,			                //δϵ��ȫ��
}NET_SAFEBELT_STATE;

//�����״̬
typedef enum tagNET_SUNSHADE_STATE
{
    SS_NUKNOW_SUN_SHADE	= 0 ,		// δ֪
	SS_WITH_SUN_SHADE,				                // �������  
	SS_WITHOUT_SUN_SHADE,			                // �������
}NET_SUNSHADE_STATE;
// ��ʻλΥ����Ϣ
typedef struct tagEVENT_COMM_SEAT
{
    BOOL                    bEnable;                // �Ƿ��⵽������Ϣ
    EM_COMMON_SEAT_TYPE     emSeatType;             // ��������, 0:δʶ��; 1:����ʻ; 2:����ʻ
    EVENT_COMM_STATUS       stStatus;               // Υ��״̬
	NET_SAFEBELT_STATE      emSafeBeltStatus;       // ��ȫ��״̬
    NET_SUNSHADE_STATE      emSunShadeStatus;       // �����״̬
    char                    szReserved[24];         // Ԥ���ֽ�
}EVENT_COMM_SEAT;

// �����������
typedef enum tagEM_COMM_ATTACHMENT_TYPE      
{       
	COMM_ATTACHMENT_TYPE_UNKNOWN    = 0,            // δ֪����       
    COMM_ATTACHMENT_TYPE_FURNITURE  = 1,            // �ڼ�       
    COMM_ATTACHMENT_TYPE_PENDANT    = 2,            // �Ҽ�       
    COMM_ATTACHMENT_TYPE_TISSUEBOX  = 3,            // ֽ���       
    COMM_ATTACHMENT_TYPE_DANGER     = 4,            // Σ��Ʒ  
    COMM_ATTACHMENT_TYPE_PERFUMEBOX = 5,			// ��ˮ
 }EM_COMM_ATTACHMENT_TYPE;

// �������
typedef struct tagEVENT_COMM_ATTACHMENT      
{       
	EM_COMM_ATTACHMENT_TYPE     emAttachmentType;       // �������       
	NET_RECT                    stuRect;                // ����   
    BYTE						bReserved[20];		    // Ԥ���ֽ�
 }EVENT_COMM_ATTACHMENT;

// ��ͨץͼͼƬ��Ϣ
typedef struct tagEVENT_PIC_INFO
{
    DWORD                       nOffset;                // ԭʼͼƬƫ�ƣ���λ�ֽ�
    DWORD                       nLength;                // ԭʼͼƬ���ȣ���λ�ֽ�
}EVENT_PIC_INFO;

typedef struct tagEVENT_COMM_INFO
{
    EM_NTP_STATUS				emNTPStatus;											// NTPУʱ״̬
    int							nDriversNum;											// ��ʻԱ��Ϣ��
    DH_MSG_OBJECT_EX			*pstDriversInfo;										// ��ʻԱ��Ϣ���� 
    char*						pszFilePath;											// ����Ӳ�̻���sd���ɹ�д��·��,ΪNULLʱ,·��������
    char*						pszFTPPath;												// �豸�ɹ�д��ftp��������·��
    char*						pszVideoPath;											// ��ǰ������Ҫ��ȡ��ǰΥ�µĹ�����Ƶ��FTP�ϴ�·��
    EVENT_COMM_SEAT				stCommSeat[COMMON_SEAT_MAX_NUMBER];						// ��ʻλ��Ϣ
	int							nAttachmentNum;											// �����������
	EVENT_COMM_ATTACHMENT		stuAttachment[NET_MAX_ATTACHMENT_NUM];					// ���������Ϣ
	int							nAnnualInspectionNum;									// ����־����										
	NET_RECT					stuAnnualInspection[NET_MAX_ANNUUALINSPECTION_NUM];		// ����־
    float                       fHCRatio;                                               // HC��ռ��������λ��%/1000000 
    float                       fNORatio;                                               // NO��ռ��������λ��%/1000000 
    float                       fCOPercent;                                             // CO��ռ�ٷֱȣ���λ��% ȡֵ0~100
    float                       fCO2Percent;                                            // CO2��ռ�ٷֱȣ���λ��% ȡֵ0~100     
    float                       fLightObscuration;                                      // ��͸��ȣ���λ��% ȡֵ0~100
    int                         nPictureNum;                                            // ԭʼͼƬ����
    EVENT_PIC_INFO              stuPicInfos[NET_MAX_EVENT_PIC_NUM];                     // ԭʼͼƬ��Ϣ
    float                       fTemperature;                                           // �¶�ֵ,��λ���϶�
    int                         nHumidity;                                              // ���ʪ�Ȱٷֱ�ֵ   
    float                       fPressure;                                              // ��ѹֵ,��λKpa
    float                       fWindForce;                                             // ����ֵ,��λm/s
    UINT                        nWindDirection;                                         // ����,��λ��,��Χ:[0,360]
    float                       fRoadGradient;                                          // ��·�¶�ֵ,��λ��
    float                       fAcceleration;                                          // ���ٶ�ֵ,��λ:m/s2   
	NET_RFIDELETAG_INFO			stuRFIDEleTagInfo;										// RFID ���ӳ��Ʊ�ǩ��Ϣ
	BYTE						bReserved[704];											// Ԥ���ֽ� 
    char						szCountry[20];											// ����
}EVENT_COMM_INFO;

//��ί�ذ����Ƴ�����Ϣ
typedef struct tagEVENT_CUSTOM_WEIGHT_INFO
{
	DWORD        dwRoughWeight;                    // ë��,�������ػ�����������λKG
    DWORD        dwTareWeight;                     // Ƥ��,�ճ���������λKG
    DWORD        dwNetWeight;                      // ����,�ػ���������λKG
	BYTE		 bReserved[28];					   // Ԥ���ֽ� 
}EVENT_CUSTOM_WEIGHT_INFO;

//�����¼�ר�ö����ϱ����ݣ������������ӵ�Custom��
typedef struct tagEVENT_JUNCTION_CUSTOM_INFO
{
    EVENT_CUSTOM_WEIGHT_INFO    stuWeightInfo;      // ԭʼͼƬ��Ϣ
	BYTE						bReserved[60];		// Ԥ���ֽ� 
}EVENT_JUNCTION_CUSTOM_INFO;

// �¼�����EVENT_IVS_TRAFFICJUNCTION(��ͨ·���Ϲ����¼�/��Ƶ�羯�ϵĽ�ͨ�����Ϲ����¼�)��Ӧ�����ݿ�������Ϣ
// ������ʷԭ��,���Ҫ�������¼�,DEV_EVENT_TRAFFICJUNCTION_INFO��EVENT_IVS_TRAFFICGATEҪһ����,�Է�ֹ����Ƶ�羯����Ȧ�羯ͬʱ����ƽ̨���������
// ����EVENT_IVS_TRAFFIC_TOLLGATEֻ֧���¿����¼�������
typedef struct tagDEV_EVENT_TRAFFICJUNCTION_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    BYTE                byMainSeatBelt;                             // ����ʻ��,ϵ��ȫ��״̬,1-ϵ��ȫ��,2-δϵ��ȫ��
    BYTE                bySlaveSeatBelt;                            // ����ʻ��,ϵ��ȫ��״̬,1-ϵ��ȫ��,2-δϵ��ȫ��
    BYTE                byVehicleDirection;                         // ��ǰ��ץ�ĵ��ĳ����ǳ�ͷ���ǳ�β,������� EM_VEHICLE_DIRECTION
    BYTE                byOpenStrobeState;                          // ��բ״̬,������� EM_OPEN_STROBE_STATE 
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nLane;                                      // ��Ӧ������
    DWORD               dwBreakingRule;                             // Υ����������,��һλ:�����; 
                                                                    // �ڶ�λ:�����涨������ʻ;
                                                                    // ����λ:����; ����λ��Υ�µ�ͷ;
                                                                    // ����λ:��ͨ����; ����λ:��ͨ�쳣����
                                                                    // ����λ:ѹ����ʻ; ����Ĭ��Ϊ:��ͨ·���¼�

    NET_TIME_EX         RedLightUTC;                                // ��ƿ�ʼUTCʱ��
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�Km/h                 
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byDirection;                                // ·�ڷ���,1-��ʾ����,2-��ʾ����
    BYTE                byLightState;                               // LightState��ʾ���̵�״̬:0 δ֪,1 �̵�,2 ���,3 �Ƶ�
    BYTE                byReserved;                                 // �����ֽ�
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    char                szRecordFile[DH_COMMON_STRING_128];         // ������Ӧ��ԭʼ¼���ļ���Ϣ
	EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // �Զ�����Ϣ
    BYTE                byPlateTextSource;                          // ����ʶ����Դ, 0:�����㷨ʶ��,1:��˷������㷨ʶ��
	BYTE                bReserved1[3];                               // �����ֽ�,�����չ.
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[196];                             // �����ֽ�,�����չ.
    int                 nTriggerType;                               // TriggerType:��������,0������,1�״�,2��Ƶ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    DWORD               dwRetCardNumber;                            // ��Ƭ����
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // ��Ƭ��Ϣ   
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFICJUNCTION_INFO;


// �¼�����EVENT_IVS_TRAFFICGATE(��ͨ�����Ϲ����¼�/��Ȧ�羯�ϵĽ�ͨ�����Ϲ����¼�)��Ӧ�����ݿ�������Ϣ
// ������ʷԭ��,���Ҫ�������¼�,DEV_EVENT_TRAFFICJUNCTION_INFO��EVENT_IVS_TRAFFICGATEҪһ����,�Է�ֹ����Ƶ�羯����Ȧ�羯ͬʱ����ƽ̨���������
// ����EVENT_IVS_TRAFFIC_TOLLGATEֻ֧���¿����¼�������
typedef struct tagDEV_EVENT_TRAFFICGATE_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    BYTE                byOpenStrobeState;                          // ��բ״̬,�������EM_OPEN_STROBE_STATE
    char                bReserved1[3];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽�����壬����
    int                 nLane;                                      // ��Ӧ������
    int                 nSpeed;                                     // ����ʵ���ٶ�Km/h
    int                 nSpeedUpperLimit;                           // �ٶ����� ��λ��km/h
    int                 nSpeedLowerLimit;                           // �ٶ����� ��λ��km/h 
    DWORD               dwBreakingRule;                             // Υ����������,��һλ:����; 
                                                                    // �ڶ�λ:ѹ����ʻ; ����λ:������ʻ; 
                                                                    // ����λ��Ƿ����ʻ; ����λ:�����;����λ:����·��(�����¼�)
                                                                    // ����λ: ѹ����; �ڰ�λ: �г�ռ��; �ھ�λ: ����ռ��;����Ĭ��Ϊ:��ͨ�����¼�
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ    
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ���д�ų�����Ϣ
    BYTE                szManualSnapNo[64];                         // �ֶ�ץ�����                
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����; 
    BYTE                byReserved[3];                              // �����ֽ�
    BYTE                szSnapFlag[16];                             // �豸������ץ�ı�ʶ
    BYTE                bySnapMode;                                 // ץ�ķ�ʽ,0-δ���� 1-ȫ�� 2-���� 4-ͬ��ץ�� 8-����ץ�� 16-����ͼ��
    BYTE                byOverSpeedPercentage;                      // ���ٰٷֱ�
    BYTE                byUnderSpeedingPercentage;                  // Ƿ�ٰٷֱ�
    BYTE                byRedLightMargin;                           // ���������ʱ��,��λ����
    BYTE                byDriveDirection;                           // ��ʻ����,0-����(���������豸�����Խ��Խ��),1-����(���������豸�����Խ��ԽԶ)
    char                szRoadwayNo[32];                            // ��·���
    char                szViolationCode[16];                        // Υ�´���
    char                szViolationDesc[128];                       // Υ������
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    char                szVehicleType[32];                          // ������С���� Minisize"΢�ͳ�,"Light-duty"С�ͳ�,"Medium"���ͳ�,
                                                                    // "Oversize"���ͳ�,"Huge"����,"Largesize"���� "Unknown"δ֪
    BYTE                byVehicleLenth;                             // ��������, ��λ��
    BYTE                byLightState;                               // LightState��ʾ���̵�״̬:0 δ֪,1 �̵�,2 ���,3 �Ƶ�
    BYTE                byReserved1;                                // �����ֽ�,�����չ
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nOverSpeedMargin;                           // �޸��ٿ���ֵ    ��λ��km/h 
    int                 nUnderSpeedMargin;                          // �޵��ٿ���ֵ    ��λ��km/h 
    char                szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION]; //
                                                                    // "DrivingDirection" : ["Approach", "�Ϻ�", "����"],��ʻ����
                                                                    // "Approach"-����,���������豸�����Խ��Խ����"Leave"-����,
                                                                    // ���������豸�����Խ��ԽԶ,�ڶ��͵����������ֱ�������к�
                                                                    // ���е������ص�,UTF-8����
    char                szMachineName[256];                         // ���ػ�Զ���豸����
    char                szMachineAddress[256];                      // ��������ص㡢��·����
    char                szMachineGroup[256];                        // �������顢�豸����λ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_SIG_CARWAY_INFO_EX stuSigInfo;                               // �ɳ���������ץ���ź�������Ϣ
    char                szFilePath[MAX_PATH];                       // �ļ�·��
    NET_TIME_EX         RedLightUTC;                                // ��ƿ�ʼUTCʱ��
    char              * szDeviceAddress;                            // �豸��ַ,OSD���ӵ�ͼƬ�ϵ�,��Դ������TrafficSnapshot.DeviceAddress,'\0'����
    float               fActualShutter;                             // ��ǰͼƬ�ع�ʱ��,��λΪ����
    BYTE                byActualGain;                               // ��ǰͼƬ����,��ΧΪ0~100
    BYTE                byDirection;                                // 0-���� 1-�����򶫱� 2-���� 3-�������� 4-������ 5-���������� 6-������ 7-���������� 8-δ֪
    BYTE                bReserve;                                   // �����ֽ�, �ֽڶ���
    BYTE                bRetCardNumber;                             // ��Ƭ����
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // ��Ƭ��Ϣ
    char               szDefendCode[DH_COMMON_STRING_64];           // ͼƬ��α��
    int                nTrafficBlackListID;                         // �������������ݿ��¼Ĭ������ID, 0,��Ч��> 0,���������ݼ�¼
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
    BYTE                bReserved[452];                             // �����ֽ�,�����չ.
} DEV_EVENT_TRAFFICGATE_INFO;

//�¼�����EVENT_TRAFFICSNAPSHOT(��ͨץ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFICSNAPSHOT_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    BYTE                bReserv[3];                                 // �����ֽ� 
    BYTE                bCarWayCount;                               // ����ץ�ĵĳ�������
    DH_CARWAY_INFO      stuCarWayInfo[DH_MAX_CARWAY_NUM];           // ����ץ�ĵĳ��������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    BYTE                bReserved[344];                             // �����ֽ�,�����չ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFICSNAPSHOT_INFO;

//�¼�����EVENT_IVS_TRAFFIC_RUNREDLIGHT(��ͨ-������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ 
    int                 nLightState;                                // ���̵�״̬ 0:δ֪ 1���̵� 2:��� 3:�Ƶ�
    int                 nSpeed;                                     // ����,km/h
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    NET_TIME_EX         stRedLightUTC;                              // ��ƿ�ʼʱ��
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                byRedLightMargin;                           // ���������ʱ��,��λ����
    BYTE                byAlignment[3];                             // �ֽڶ���
    int                 nRedLightPeriod;                            // ��ʾ�������ʱ��,��λ����
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[928];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO;

//�¼�����EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT(��ͨ-���˴�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ 
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                bReserved[1024];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO;

//�¼�����EVENT_IVS_TRAFFIC_PASSNOTINORDER(��ͨ-δ���涨����ͨ��)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ 
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[984];                             // �����ֽ�
}DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO;

//�¼�����EVENT_IVS_TRAFFIC_OVERLINE(��ͨ-ѹ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_OVERLINE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�,Km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[968];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_OVERLINE_INFO;


//�¼�����EVENT_IVS_TRAFFIC_RETROGRADE(��ͨ-�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_RETROGRADE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�,Km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BOOL                bIsExistAlarmRecord;                        // rue:�ж�Ӧ�ı���¼��; false:�޶�Ӧ�ı���¼��
    DWORD               dwAlarmRecordSize;                          // ¼���С
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // ¼��·��
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[484];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    int                 nDetectNum;                                 // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_RETROGRADE_INFO;

//�¼�����EVENT_IVS_TRAFFIC_TURNLEFT(��ͨ-Υ����ת)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_TURNLEFT_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�,Km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[968];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_TURNLEFT_INFO;


//�¼����� EVENT_IVS_TRAFFIC_TURNRIGHT (��ͨ-Υ����ת)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_TURNRIGHT_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�,Km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[968];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_TURNRIGHT_INFO;

//�¼�����EVENT_IVS_TRAFFIC_UTURN(Υ�µ�ͷ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_UTURN_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    int                 nSpeed;                                     // ����ʵ���ٶ�,Km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[968];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_UTURN_INFO;

//�¼�����EVENT_IVS_TRAFFIC_OVERSPEED(��ͨ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_OVERSPEED_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSpeed;                                     // ����ʵ���ٶ�Km/h
    int                 nSpeedUpperLimit;                           // �ٶ����� ��λ��km/h
    int                 nSpeedLowerLimit;                           // �ٶ����� ��λ��km/h 
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    char                szFilePath[MAX_PATH];                       // �ļ�·��
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ  ���ض���
    BYTE                bReserved[576];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_OVERSPEED_INFO;

//�¼�����EVENT_IVS_TRAFFIC_UNDERSPEED(��ͨǷ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_UNDERSPEED_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved2[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nSpeed;                                     // ����ʵ���ٶ�Km/h
    int                 nSpeedUpperLimit;                           // �ٶ����� ��λ��km/h
    int                 nSpeedLowerLimit;                           // �ٶ����� ��λ��km/h 
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved1[2];                              // ����
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nUnderSpeedingPercentage;                   // Ƿ�ٰٷֱ�
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[832];                             // �����ֽ�
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_UNDERSPEED_INFO;

//�¼�����EVENT_IVS_TRAFFIC_JAM_FORBID_INTO(��ͨӵ�½����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_JAMFORBIDINTO_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ 
	int					nMark;										// �ײ�����Ĵ���ץ��֡���
	int					nSource;									// ��Ƶ����������Դ��ַ
	int					nSequence;									// ��ʾץ�����,��3-2-1/0,1��ʾץ����������,0��ʾץ���쳣����
	int					nFrameSequence;								// ֡���
	int					nLane;										// ������
	BYTE                byImageIndex;                   			// ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
	DH_MSG_OBJECT       stuObject;                      			// ��⵽������
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
	BYTE                bReserved[984];                             // �����ֽ�
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // ��ͨ������Ϣ
	EVENT_COMM_INFO     stCommInfo;                     			// ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
} DEV_EVENT_ALARM_JAMFORBIDINTO_INFO;

//��������Ϣ
typedef struct tagEVENT_PIC_ANALYSE_INFO
{
	DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
	EVENT_COMM_INFO     stuCommInfo;                     			// ������Ϣ
    BYTE                bReserved[1024];                            // Ԥ���ֽ�
}EVENT_PIC_ANAKYSE_INFO;

//�¼����� DH_ALARM_TRAFFIC_PIC_ANALYSE(ͼƬ���η����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_ALARM_PIC_ANALYSE_INFO
{
    int						nIndex;                                     // ͨ����
    char					szName[128];                                // �¼�����
    double					PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX				UTC;                                        // �¼�������ʱ��
    int						nEventID;                                   // �¼�ID
    DH_MSG_OBJECT			stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT			stuVehicle;                                 // ������Ϣ
    int						nGroupID;									// �¼���ID��ͬһ����ץ�Ĺ�����GroupID��ͬ
	int						nCountInGroup;								// һ���¼����ڵ�ץ������
	int						nIndexInGroup;								// һ���¼����ڵ�ץ�����
	char					szFilePath[MAX_PATH];						// ͼƬ·��
	EVENT_COMM_INFO			stuCommInfo;                     			// ������Ϣ
	EVENT_PIC_ANAKYSE_INFO	stuAnalyseInfo;								// ��������Ϣ
	BYTE					bReserved[1024];							// �����ֽ�
} ALARM_PIC_ANALYSE_INFO;
typedef struct tagNET_BULLET_HOLES_INFO
{
    int                 nObjectID;                          // ����ID,ÿ��ID��ʾһ��Ψһ������
    char                szObjectType[128];                  // ��������,֧������: "Unknown", "Human", "Vehicle",
    DH_RECT             stuBoundingBox;                     // ��Χ��
    DH_POINT            stuCenter;                          // ��������
	int				    nSequence;							// ���
	int                 nScore;							    // ����
    BYTE                byReserved[512];                    // �����ֽ�
}NET_BULLET_HOLES_INFO;
typedef struct tagDEV_ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO
{
    int						nIndex;                                     // ͨ����
    char					szName[128];                                // �¼�����
    double					dbPTS;                                      // ʱ���(��λ�Ǻ���)
    NET_TIME_EX				stuUTC;                                     // �¼�������ʱ��
    int						nEventID;                                   // �¼�ID
    int						nGroupID;									// �¼���ID��ͬһ����ץ�Ĺ�����GroupID��ͬ
	int						nCountInGroup;								// һ���¼����ڵ�ץ������
	int						nIndexInGroup;								// һ���¼����ڵ�ץ�����
	char					szFilePath[MAX_PATH];						// ͼƬ·��
	DH_POINT				stuDetectRegion;							// ����������
	int						nValidBulletHolesNum;						// ��⵽����Ч���׸���
	NET_BULLET_HOLES_INFO   stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// ��⵽�ĵ���
	BYTE					bReserved[1024];							// �����ֽ�
} ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO;


//4G����������ֵ�ı����¼�(��Ӧ�¼� DH_ALARM_OIL_4G_OVERFLOW)
typedef struct tagNET_ALARM_OIL_4G_OVERFLOW_INFO
{	
	int					            nChannelID;						// ͨ���Ŵ�0��ʼ	
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)    
    NET_TIME_EX			            stuTime;						// �¼�������ʱ�� 
	int								nFlowRateCur;					// ��ǰʹ���˵�����	��λMB	
	int								nFlowRateMax;					// ������������ֵ	��λMB
	BYTE                			byReserved[1024];   			// �����ֽ�
}NET_ALARM_OIL_4G_OVERFLOW_INFO;

//�����Դ����״̬�쳣�¼�
typedef struct tagDEV_ALARM_POWERSWITCHER_INFO
{
	int                     nEventAction;                       // �������¼�����, 1��ʾ��ʼ, 2��ʾֹͣ
	int                     nEventIndex;                        // �����Դ�������, ��PowerSwitcher�����±����һ��
	char					szName[128];                        // �����Դ��������, ��PowerSwitcher�������ƶ�Ӧ
	NET_TIME_EX				stuUTC;                             // �¼��ɼ�ʱ��
	int                     nPowerVoltage;                      // ��ѹֵ, ��λ��mV
	int                     nPowerCurrent;                      // ����ֵ, ��λ��mA
	int                     nPowerValue;                        // ����, ��λ��mW
	int						nSwitchOn;                          // ����ͨ��, 1Ϊ����0Ϊ��
	int                     nPowerState;                        // ����״̬����,ȫ0��ʾ����, bit0��ʾǷѹ, bit1��ʾ��ѹ, bit2��ʾǷ��, bit3��ʾ����, bit4��ʾ��״̬(��״̬��������ͬʱ��λ)
	BYTE					byReserved[1024];				    // �����ֽ�
}DEV_ALRAM_POWERSWITCHER_INFO;

//  ��������¼� StartListen(��Ӧ�¼� DH_ALARM_SCENNE_CHANGE_ALARM)
typedef struct tagDEV_ALARM_PIC_SCENECHANGE_INFO
{
    int						nChannelID;                                 // ͨ����
	int						nEventAction;								// �������¼�����,  1��ʾ��ʼ, 2��ʾֹͣ
    double					dbPTS;                                      // ʱ���(��λ�Ǻ���)
    NET_TIME_EX				stuUTC;                                     // �¼�������ʱ��
    int						nEventID;                                   // �¼�ID
	BYTE					bReserved[1024];							// �����ֽ�
} ALARM_PIC_SCENECHANGE_INFO;


//  ��������¼���ReloadPicture(��Ӧ�¼� EVENT_IVS_SCENE_CHANGE)
typedef struct tagDEV_ALRAM_SCENECHANGE_INFO
{
    int							nChannelID;									// ͨ����
	int                         nEventAction;								// �������¼�����, 1��ʾ��ʼ, 2��ʾֹͣ
    double						dbPTS;										// ʱ���(��λ�Ǻ���)
    NET_TIME_EX					stuUTC;										// �¼�������ʱ��
    int							nEventID;									// �¼�ID

    DH_EVENT_FILE_INFO			stuFileInfo;								// �¼���Ӧ�ļ���Ϣ
    BYTE						byImageIndex;								// ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD						dwSnapFlagMask;								// ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE						bReserved[1024];							// �����ֽ�,�����չ. 
} DEV_ALRAM_SCENECHANGE_INFO;

//�¼����� EVENT_IVS_SNAPMANUAL(SnapManual�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_SNAPMANUAL
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID
	
	DH_EVENT_FILE_INFO	stuFileInfo;								  // �¼���Ӧ�ļ���Ϣ
    BYTE				byImageIndex;								  // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD				dwSnapFlagMask;								  // ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
}DEV_EVENT_SNAPMANUAL;

// ��ʱδˢ���¼�
typedef struct tagALARM_SWIPE_OVERTIME_INFO
{                           
    NET_TIME_EX             stuTime;                            // �¼�������ʱ��
    BYTE					bReserved[1024];
}ALARM_SWIPE_OVERTIME_INFO;

// �޿���ʻ�¼�
typedef struct tagALARM_DRIVING_WITHOUTCARD_INFO
{
    NET_TIME_EX             stuTime;                            // �¼�������ʱ��
    BYTE					bReserved[1024];
}ALARM_DRIVING_WITHOUTCARD_INFO;


// �����������Ϣ
typedef struct tagNET_FACE_INFO
{
    int                 nObjectID;                          // ����ID,ÿ��ID��ʾһ��Ψһ������
    char                szObjectType[128];                  // ��������
    int                 nRelativeID;                        // ����������ͼ����Ĵ�ͼ��ID
    DH_RECT             BoundingBox;                        // ��Χ��
    DH_POINT            Center;                             // ��������
} NET_FACE_INFO;

//�¼�����EVENT_IVS_FACEDETECT(��������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FACEDETECT_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                reserved[2];                                // �����ֽ�
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON  
    char                szSnapDevAddress[MAX_PATH];                 // ץ�ĵ�ǰ�������豸��ַ,�磺����·37��
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // �Ա�
    int        nAge;                                                // ����,-1��ʾ���ֶ�������Ч
    unsigned int        nFeatureValidNum;                           // ��������������Ч����,�� emFeature ���ʹ��
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // ������������,�� nFeatureValidNum ���ʹ��
    int                 nFacesNum;                                  // ָʾstuFaces��Ч����
    NET_FACE_INFO       stuFaces[10];                               // ��������ʱʹ��,��ʱû��Object
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
	EM_RACE_TYPE				emRace;								// ����
	EM_EYE_STATE_TYPE			emEye;								// �۾�״̬
	EM_MOUTH_STATE_TYPE			emMouth;							// ���״̬
	EM_MASK_STATE_TYPE 			emMask;								// ����״̬
	EM_BEARD_STATE_TYPE			emBeard;							// ����״̬
	int							nAttractive;						// ����ֵ, -1��ʾ��Ч, 0δʶ��ʶ��ʱ��Χ1-100,�÷ָ�������
	BYTE                		bReserved[868];                     // �����ֽ�,�����չ
} DEV_EVENT_FACEDETECT_INFO;

// �¼�����EVENT_IVS_TRAFFICJAM(��ͨӵ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFICJAM_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bJamLenght;                                 // ��ʾӵ�³���(�ܳ������Ȱٷֱȣ�0-100
    BYTE                reserved;                                   // �����ֽ�
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    NET_TIME_EX         stuStartJamTime;                            // ��ʼͣ��ʱ��
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����(bEventAction=2ʱ�˲�����Ч)
    int                 nAlarmIntervalTime;                         // ����ʱ����,��λ:�롣(���¼�Ϊ�������¼�,���յ���һ�����¼�֮��,���ڳ������ʱ���δ�յ����¼��ĺ����¼�,����Ϊ���¼��쳣������)
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    int                 nJamRealLength;                             // ��ʵ�ʵ�ӵ�³���,��λ��
    BYTE                bReserved[1008];                            // �����ֽ�,�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ  
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFICJAM_INFO;

// �¼�����EVENT_IVS_TRAFFIC_PARKING(��ͨΥ��ͣ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PARKING_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                reserved[2];                                // �����ֽ�
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    NET_TIME_EX         stuStartParkingTime;                        // ��ʼͣ��ʱ��
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����(bEventAction=2ʱ�˲�����Ч)
    int                 nAlarmIntervalTime;                         // ����ʱ����,��λ:�롣(���¼�Ϊ�������¼�,���յ���һ�����¼�֮��,���ڳ������ʱ���δ�յ����¼��ĺ����¼�,����Ϊ���¼��쳣������)
    int                 nParkingAllowedTime;                        // ����ͣ��ʱ��,��λ���롣
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BOOL                bIsExistAlarmRecord;                        // rue:�ж�Ӧ�ı���¼��; false:�޶�Ӧ�ı���¼��
    DWORD               dwAlarmRecordSize;                          // ¼���С
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // ¼��·��
    char                szFTPPath[DH_COMMON_STRING_256];            // FTP·�� 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
	BYTE				byPreAlarm;									// �Ƿ�ΪΥ��Ԥ��ͼƬ,0 Υ��ͣ���¼�1 Ԥ���¼�(Ԥ��������һ��ʱ�䣬������û���뿪�����ж�ΪΥ��)���ڴ��ֶλᵼ���¼�����ı䣬�������ƽ̨ʶ��Ԥ���¼��󣬲����д��ֶ�, 
	BYTE                bReserved2[3];                              // �����ֽ�,�����չ.
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[228];                             // �����ֽ�,�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_PARKING_INFO;

//�¼�����EVENT_IVS_TRAFFIC_WRONGROUTE(��ͨΥ��-����������ʻ)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_WRONGROUTE_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];           
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nSpeed;                                     // ����ʵ���ٶ�,km/h
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[972];                             // �����ֽ�,�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_WRONGROUTE_INFO;

//�¼�����EVENT_IVS_TRAFFIC_CROSSLANE(��ͨΥ��-Υ�±��)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_CROSSLANE_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];       
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
     int                nSpeed;                                     // ����ʵ���ٶ�,km/h
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
	BYTE                bReserved[836];                             // �����ֽ�,�����չ.�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
} DEV_EVENT_TRAFFIC_CROSSLANE_INFO;

//�¼�����EVENT_IVS_TRAFFIC_OVERYELLOWLINE(��ͨΥ��-ѹ����)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];  
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nSpeed;                                     // ����ʵ���ٶ�,km/h
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BOOL                bIsExistAlarmRecord;                        // rue:�ж�Ӧ�ı���¼��; false:�޶�Ӧ�ı���¼��
    DWORD               dwAlarmRecordSize;                          // ¼���С
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // ¼��·��
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[532];                             // �����ֽ�,�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ

    int                 nDetectNum;                                 // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������    
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

} DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO;

//�¼�����EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER(��ͨΥ��-·����ʻ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];      
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nSpeed;                                     // ����ʵ���ٶ�,km/h
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
    
} DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO;

//�¼�����EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE(��ͨΥ��-���Ƴ�ռ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];     
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nSpeed;                                     // ����ʵ���ٶ�,km/h
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                bReserved[1016];                            // �����ֽ�,�����չ.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

} DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO;

//�¼�����EVENT_IVS_TRAFFIC_NOPASSING(��ͨΥ��-��ֹͨ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_NOPASSING_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    int                 nTriggerType;                               // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 UTCMS;                                      // 
    int                 nMark;                                      // �ײ�����Ĵ���ץ��֡���
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[3];
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nFrameSequence;                             // ��Ƶ����֡���
    int                 nSource;                                    // ��Ƶ����������Դ��ַ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                byReserved[984];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_NOPASSING_INFO;

typedef struct tagDH_TRAFFICFLOWSTAT
{
    char                szMachineAddress[256];                      // ͬDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineGroup
    char                szMachineName[256];                         // ͬDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineName
    char                szDrivingDirection[3][32];                  // ��ʻ����"Approach"-����,���������豸�����Խ��Խ����"Leave"-����,���������豸�����Խ��ԽԶ,�ڶ��͵����������ֱ�������к����е������ص�,UTF-8����
    int                 nLane;                                      // ������ ʹ���û����õĳ������
    NET_TIME_EX         UTC;                                        // ͳ��ʱ��,ת����UTC
    int                 nPeriod;                                    // ͳ������,��λ����
    int                 nVehicles;                                  // ͨ����������
    float               fAverageSpeed;                              // ƽ������,��λkm/h
    float               fAverageLength;                             // ƽ������,��λ��
    float               fTimeOccupyRatio;                           // ʱ��ռ����,����λʱ����ͨ������ĳ�������ʱ����ܺ�ռ��λʱ��ı���
    float               fSpaceOccupyRatio;                          // �ռ�ռ����,�����ٷ��ʼ����ĳ��������ܺͳ���ʱ�����ڳ���ƽ����ʻ����
    float               fSpaceHeadway;                              // ��ͷ���,���ڳ���֮��ľ���,��λ��/��
    float               fTimeHeadway;                               // ��ͷʱ��,��λ��/��
    float               fDensity;                                   // �����ܶ�,ÿ����ĳ�����,��λ��/km
    int                 nOverSpeedVehicles;                         // ���ٳ�����
    int                 nUnderSpeedVehicles;                        // ���ٳ�����
    int                 nLargeVehicles;                             // ������  ���������жϱ�׼�μ�TrafficSnapshot���ñ�
    int                 nMediumVehicles;                            // ���ͳ�����
    int                 nSmallVehicles;                             // С������
    int                 nMotoVehicles;                              // Ħ�г�����
    int                 nLongVehicles;                              // ����������
}DH_TRAFFICFLOWSTAT; 

// �¼����� TrafficFlowStat Info(��ͨ����ͳ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_FLOWSTAT_INFO
{
    char                szName[128];                                // �¼�����
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLaneCnt;                                   // ͨ������
    DH_TRAFFICFLOWSTAT  stTrafficFlowStats[DH_MAX_LANE_NUM];        // ����ͳ�Ƽ�¼,��һ������
    char                Reserved[4];                                // �����ֽڶ���
}DEV_EVENT_TRAFFIC_FLOWSTAT_INFO;

//�¼�����EVENT_IVS_TRAFFIC_MANUALSNAP(��ͨ�ֶ�ץ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_MANUALSNAP_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    BYTE                szManualSnapNo[64];                         // �ֶ�ץ����� 
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ��⵽�ĳ�����Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                bReserved[1016];                            // �����ֽ�,�����չ.
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_MANUALSNAP_INFO;

//�¼����� EVENT_IVS_TRAFFIC_STAY(��ͨ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_STAY_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ץ�����,��3-2-1/0,1��ʾץ����������,0��ʾץ���쳣����
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                byReserved[1012];         
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_STAY_INFO;

//�¼����� EVENT_IVS_TRAFFIC_VEHICLEINROUTE(�г�ռ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ץ�����,��3-2-1/0,1��ʾץ����������,0��ʾץ���쳣����
    int                 nSpeed;                                     // ����
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ               
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                byReserved[884];           
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO;

// �����¼����� EVENT_ALARM_LOCALALARM(�ⲿ����),EVENT_ALARM_MOTIONALARM(���챨��)����)
typedef struct tagDEV_EVENT_ALARM_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID  
    
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_ALARM_INFO;

// �����¼����� EVENT_ALARM_VIDEOBLIND(��Ƶ�ڵ�����)
typedef struct tagDEV_EVENT_ALARM_VIDEOBLIND
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID        
    
    NET_TIME_EX         stuTime;                                    // �¼�������ʱ��, (�豸ʱ��, ��һ����utcʱ��)

	BYTE                byReserved2[512];						    // �����ֽ�,�����չ
}DEV_EVENT_ALARM_VIDEOBLIND;

// �����¼����� EVENT_ALARM_ANALOGALARM(ģ��������ͨ������),
typedef struct tagDEV_EVENT_ALARM_ANALOGALRM_INFO 
{
    int                 nChannelID;                                 // (��Ƶ)ͨ����
    char                szName[DH_COMMON_STRING_128];               // ģ��������ͨ������
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ   
    int                 nIndex;                                     // ģ��������ͨ����
    NET_SENSE_METHOD    emSensor;                                   // ����������
    int                 nStatus;                                    // ����״̬, -1:δ֪,0:����,1:������Ч(��������),
                                                                    // 2:������ֵ1,3:������ֵ2,4:������ֵ3,5:������ֵ4,
                                                                    // 6:������ֵ1,7:������ֵ2,8:������ֵ3,9:������ֵ4
    float               fValue;                                     // ̽������ֵ
    NET_TIME            stuCollectTime;                             // ���ݲɼ�ʱ��(UTC)
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved2[1023];                          // �����ֽ�,�����չ
}DEV_EVENT_ALARM_ANALOGALRM_INFO;

//EVENT_ALARM_VEHICLEACC(ACC�ϵ籨��)
typedef struct tagDEV_EVENT_ALARM_VEHICLEACC_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_COMMON_STRING_128];               // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID      
    NET_GPS_STATUS_INFO stGPSStatusInfo;                            // GPS��Ϣ
    int                 nACCStatus;                                 // ACC״̬    0:��Ч(������) , 1:���� , 2:�ر�    
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bConstantElectricStatus;                    // ����״̬ , 0:��Ч(������) , 1:���� , 2:�Ͽ�                            
    BYTE                bReserved[1022];                            // �����ֽ�,�����չ.
}DEV_EVENT_ALARM_VEHICLEACC_INFO;


// �����¼����� EVENT_ALARM_VEHICLE_TURNOVER(�����෭) , EVENT_ALARM_VEHICLE_COLLISION(����ײ��)
typedef struct tagDEV_EVENT_VEHICEL_ALARM_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID  
    NET_GPS_STATUS_INFO stGPSStatusInfo;                            // GPS��Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                              // �ֽڶ�����
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                bReserved[1024];                            // �����ֽ�,�����չ.
}DEV_EVENT_VEHICEL_ALARM_INFO;

// �¼����� EVENT_IVS_PRISONERRISEDETECTION (�������������¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_PRISONERRISEDETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    double              dInitialUTC;                                // �¼���ʼUTCʱ��    UTCΪ�¼���UTC (1970-1-1 00:00:00)������
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[616];                             // �����ֽ�,�����չ.
}DEV_EVENT_PRISONERRISEDETECTION_INFO;

//�¼����� EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(���������������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nLane;                                      // ��Ӧ������
    double              dInitialUTC;                                // �¼���ʼUTCʱ��    UTCΪ�¼���UTC (1970-1-1 00:00:00)������
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[984];                             // �����ֽ�,�����չ.
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO;

//�¼����� EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(ռ�ù��������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ץ�����,��3-2-1/0,1��ʾץ����������,0��ʾץ���쳣����
    int                 nSpeed;                                     // ����,km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[980];                             // �����ֽ�,�����չ.
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO;

//�¼����� EVENT_IVS_TRAFFIC_BACKING(Υ�µ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_IVS_TRAFFIC_BACKING_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ץ�����,��3-2-1/0,1��ʾץ����������,0��ʾץ���쳣����
    int                 nSpeed;                                     // ����,km/h
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ʾ��ͨ���������ݿ��¼
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[848];                             // �����ֽ�,�����չ.
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_IVS_TRAFFIC_BACKING_INFO;

//�¼�����EVENT_IVS_AUDIO_ABNORMALDETECTION(�����쳣���)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    int                 nDecibel;                                   // ����ǿ��
    int                 nFrequency;                                 // ����Ƶ��
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    BYTE                bReserved[1024];                            // �����ֽ�,�����չ.
}DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO;

//�¼����� EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(��ͨΥ��-���Ƶ��¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ 
    int                 nLightState;                                // ���̵�״̬ 0:δ֪ 1���̵� 2:��� 3:�Ƶ�
    int                 nSpeed;                                     // ����,km/h
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    NET_TIME_EX         stYellowLightUTC;                           // �Ƶƿ�ʼʱ��
    unsigned int        nYellowLightPeriod;                         // �Ƶ����ڼ��ʱ��,��λ��
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
     BYTE               byRedLightMargin;                           // �Ƶ�������ʱ��,��λ����
    char                szSourceDevice[MAX_PATH];                   // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    BYTE                bReserved[1024];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

} DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO;

//�¼����� EVENT_IVS_LEAVEDETECTION(��ڼ���¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_IVS_LEAVE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    int                 nDetectRegionNum;                           // ���������򶥵���
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // ����������
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
	BYTE                bReserved[894];                            // �����ֽ�
} DEV_EVENT_IVS_LEAVE_INFO;

//�¼����� EVENT_IVS_CLIMBDETECTION(�ʸ߼���¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_IVS_CLIMB_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    int                 nDetectLineNum;                             // �������߶�����
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];         // ��������
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    unsigned int        nOccurrenceCount;                           // �¼������ۼƴ���
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[890];                            // �����ֽ�
}DEV_EVENT_IVS_CLIMB_INFO;

//�¼����� EVENT_IVS_MULTISCENESWITCH(�ೡ���л��¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    
    BYTE                bReserved[1027];                            // �����ֽ�
} DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO;

//�¼����� EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(��������ץ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ

    int                 nInterval1;                                 // �ڶ��ź͵�һ�ŵ���ʱʱ��,��λ��
    int                 nInterval2;                                 // �����ź͵ڶ��ŵ���ʱʱ��,��λ��
    int                 nFollowTime;                                // ����ʱ��,���һ������ǰһ��������������ʱ���С�ڴ�ֵ,����Ϊ�Ǹ�������,����������������ͣ������Υ��

    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[984];                             // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO;


//ͣ������Ϣ
typedef struct tagDEV_TRAFFIC_PARKING_INFO
{
    int           nFeaturePicAreaPointNum;                  // ����ͼƬ�������
    DH_POINT      stFeaturePicArea[DH_MAX_POLYGON_NUM];     // ����ͼƬ����Ϣ
    BYTE          bReserved[572];                           // �����ֽ�
}DEV_TRAFFIC_PARKING_INFO;

//�¼����� EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(��λ�г��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����    
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    int                 nParkingSpaceStatus;                        // ��λ�ۺϵ�״̬,0-ռ��,1-����,2-ѹ��
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // ͣ������Ϣ
    BYTE                byPlateTextSource;                          // ����ʶ����Դ, 0:�����㷨ʶ��,1:��˷������㷨ʶ��
    BYTE                bReserved[379];                        // �����ֽ� 
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO;

//�¼����� EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(��λ�޳��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // ͣ������Ϣ
    BYTE                byPlateTextSource;                          // ����ʶ����Դ, 0:�����㷨ʶ��,1:��˷������㷨ʶ��
    BYTE                bReserved[383];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO;

// �¼����� EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE (��λѹ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                byEventAction;                              // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // ��ͨ������Ϣ
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // ͣ������Ϣ
    BYTE                byReserved[384];                           // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO;


// �¼����� EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT (��תδ����ֱ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
	DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                byEventAction;                              // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                byReserved[984];                            // �����ֽ�
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO;

// �¼����� EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN (����Сת�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_BIGBENDSMALLTURN_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
	DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                byEventAction;                              // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
	BYTE                byReserved[1024];                           // �����ֽ�
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_BIGBENDSMALLTURN_INFO;

// �¼�����EVENT_IVS_ROAD_CONSTRUCTION (��·ʩ������¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ROAD_CONSTRUCTION_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
    int                 nEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	EM_CLASS_TYPE		emClassType;								// �����¼��������
	DH_RECT				stuBoudingBox;								// ʩ��λ�ð�Χ��,8192����ϵ
	BYTE                byReserved[512];                            // �����ֽ�
} DEV_EVENT_ROAD_CONSTRUCTION_INFO;


// �¼�����EVENT_IVS_ROAD_BLOCK (·�ϼ���¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ROAD_BLOCK_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
    int                	nEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	EM_CLASS_TYPE		emClassType;								// �����¼��������
	DH_RECT				stuBoudingBox;								// ·��λ�ð�Χ��,8192����ϵ
	BYTE                byReserved[512];                            // �����ֽ�
} DEV_EVENT_ROAD_BLOCK_INFO;

// �¼����� EVENT_IVS_INSTALL_CARDREADER (��װ�������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_INSTALL_CARDREADER_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID        
	BYTE                byReserved[1024];						    // �����ֽ�,�����չ
}DEV_EVENT_INSTALL_CARDREADER_INFO;

// �¼����� EVENT_IVS_TRAFFIC_QUEUEJUMP (���������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_QUEUEJUMP_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
	DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // ������Ϣ
    int                 nLane;                                      // ��Ӧ������
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                byEventAction;                              // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
	BYTE                byReserved[1024];                           // �����ֽ�
}DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO;

// �¼����� EVENT_IVS_VEHICLE_SUSPICIOUSCAR (���ɳ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                Reserved[4];                                // �����ֽڶ���    
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    DWORD               nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ    
    int                 nSequence;                                  // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                byEventAction;                              // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                byReserved[4096];                           // �����ֽ�
}DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO;

// ������Ϣ
typedef struct tagEVENT_VEHICLE_INFO
{
	char				szCategory[MAX_CATEGORY_LEN];				// �������ͣ�Passerby��ʾ����
	BYTE				byReserved[64];								// Ԥ���ֽ�				
}EVENT_VEHICLE_INFO;

//�¼����� EVENT_IVS_TRAFFIC_PEDESTRAIN(��ͨ�����¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAIN_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),0λ:"*",1λ:"Timing",2λ:"Manual",3λ:"Marked",4λ:"Event",5λ:"Mosaic",6λ:"Cutout" 
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // ��ͨ����������Ϣ
	EVENT_VEHICLE_INFO  stuVehicle;									// ������Ϣ
    BYTE                bReserved[252];                             // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO;

//�¼����� EVENT_IVS_TRAFFIC_THROW(��ͨ������Ʒ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_THROW_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),0λ:"*",1λ:"Timing",2λ:"Manual",3λ:"Marked",4λ:"Event",5λ:"Mosaic",6λ:"Cutout" 
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nLane;                                      // ��Ӧ������
    DH_MSG_OBJECT       stuObject;                                  // ��⵽������
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // ��ͨ����������Ϣ
    NET_GPS_INFO        stuGPSInfo;                                 // GPS��Ϣ ���ض���
    BYTE                bReserved[340];                             // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_THROW_INFO;

//�¼����� EVENT_IVS_TRAFFIC_IDLE(��ͨ�����¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_IDLE_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
    DH_RESOLUTION_INFO  stuResolution;                              // ��ӦͼƬ�ķֱ���
    DWORD               dwSnapFlagMask;                             // ץͼ��־(��λ),0λ:"*",1λ:"Timing",2λ:"Manual",3λ:"Marked",4λ:"Event",5λ:"Mosaic",6λ:"Cutout" 
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    int                 nLane;                                      // ��Ӧ������
    BYTE                bReserved[1024];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ

}DEV_EVENT_TRAFFIC_IDLE_INFO;

// �¼����� EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT(��ת�����ú���ֱ��)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO
{
    int                 nChannelID;                                  // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                   // �¼�����
    char                bReserved[4];                                // �ֽڱ���
    double              dPTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         stuUTC;                                      // �¼�������ʱ��
    int                 nEventID;                                    // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                 // �¼���Ӧ�ļ���Ϣ
    DH_MSG_OBJECT       stuObject;                                   // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                  // ������Ϣ    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;                // ������Ϣ
    int                 nLane;                                       // ������
    int                 nSequence;                                   // ץ�����, ��3, 2, 1, 1��ʾץ�Ľ���, 0��ʾ�쳣����
	BYTE				byReserved[1024];                            // �����ֽ�
    EVENT_COMM_INFO     stCommInfo;                                  // ������Ϣ
}DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO;

// �¼����� EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE(��ת������ֱ������)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO
{
	int					nChannelID;									// ͨ����
	char				szName[DH_EVENT_NAME_LEN];					// �¼�����
	char				bReserved[4];								// �ֽڱ���
	double				dPTS;										// ʱ���(��λ�Ǻ���)	
	NET_TIME_EX			stuUTC;										// �¼�������ʱ��
	int					nEventID;									// �¼�ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // �¼���Ӧ�ļ���Ϣ
	DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
	DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ    
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // ������Ϣ
	int					nLane;										// ������
	int					nSequence;									// ץ����ţ���3, 2, 1, 1��ʾץ������������0��ʾץ���쳣����
	BYTE				byReserved[1024];							// �����ֽ�
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
}DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO;

#define MAX_DRIVING_DIR_NUM          16                             //  ������ʻ����������

// ������ʻ����
typedef enum tagNET_FLOWSTAT_DIRECTION
{
    DRIVING_DIR_UNKNOW = 0 ,                                        //����֮ǰ
    DRIVING_DIR_APPROACH ,                                          //����,���������豸�����Խ��Խ��
    DRIVING_DIR_LEAVE ,                                             //����,���������豸�����Խ��ԽԶ
}NET_FLOWSTAT_DIRECTION;

// ��·����
typedef enum tagNET_ROAD_DIRECTION
{
    ROAD_DIR_UNKNOW,             // δ֪  
    ROAD_DIR_TURNLEFT,           // ��ת 
    ROAD_DIR_TURNRIGHT,          // ��ת
    ROAD_DIR_STRAIGHT,           // ֱ��
    ROAD_DIR_UTURU,              // ��ͷ
    ROAD_DIR_NUM,    
}NET_ROAD_DIRECTION;

//��������ͳ�Ƴ�����ʻ������Ϣ 
typedef struct tagNET_TRAFFIC_FLOWSTAT_INFO_DIR
{
    NET_FLOWSTAT_DIRECTION      emDrivingDir;                       //��ʻ����
    char                        szUpGoing[FLOWSTAT_ADDR_NAME];      //���еص� 
    char                        szDownGoing[FLOWSTAT_ADDR_NAME];    //���еص� 
    BYTE                        reserved[32];                       //�����ֽ�
    
}NET_TRAFFIC_FLOWSTAT_INFO_DIR;

//��·ӵ��״��
typedef enum tagNET_TRAFFIC_JAM_STATUS
{
    JAM_STATUS_UNKNOW   =0  ,   //δ֪
    JAM_STATUS_CLEAR        ,   //ͨ��
    JAM_STATUS_JAMMED       ,   //ӵ��
}NET_TRAFFIC_JAM_STATUS;

// ��·�ȼ�
typedef enum tagNET_TRAFFIC_ROAD_RANK
{
	ROAD_RANK_UNKNOWN	=0	,
	ROAD_RANK_RAPID		=1	,	//����·
	ROAD_RANK_TRUNK		=2	,	//����·
	ROAD_RANK_SUBTRUNK	=3	,	//�θ�·
	ROAD_RANK_BRANCH	=4	,	//֧·
}NET_TRAFFIC_ROAD_RANK;


typedef struct tagNET_TRAFFIC_FLOW_STATE 
{
    int                             nLane;                          // ������
    DWORD                           dwState;                        // ״ֵ̬
                                                                    // 1- ��������
                                                                    // 2- ��������ָ�
                                                                    // 3- ����
                                                                    // 4- ������С
                                                                    // 5- ������С�ָ�
    DWORD                           dwFlow;                         // ����ֵ, ��λ: ��
    DWORD                           dwPeriod;                       // ����ֵ��Ӧ��ͳ��ʱ��, ��λ:���ӡ���dwPeriodByMiliһ��ʹ�á�
    NET_TRAFFIC_FLOWSTAT_INFO_DIR   stTrafficFlowDir;               // ����������Ϣ
    int                             nVehicles;                      // ͨ����������
    float                           fAverageSpeed;                  // ƽ������,��λkm/h
    float                           fAverageLength;                 // ƽ������,��λ��
    float                           fTimeOccupyRatio;               // ʱ��ռ����,����λʱ����ͨ������ĳ�������ʱ����ܺ�ռ��λʱ��ı���
    float                           fSpaceOccupyRatio;              // �ռ�ռ����,�����ٷ��ʼ����ĳ��������ܺͳ���ʱ�����ڳ���ƽ����ʻ����
    float                           fSpaceHeadway;                  // ��ͷ���,���ڳ���֮��ľ���,��λ��/��
    float                           fTimeHeadway;                   // ��ͷʱ��,��λ��/��
    float                           fDensity;                       // �����ܶ�,ÿ����ĳ�����,��λ��/km
    int                             nOverSpeedVehicles;             // ���ٳ�����
    int                             nUnderSpeedVehicles;            // ���ٳ�����
    int                             nLargeVehicles;                 // �󳵽�ͨ��(9��<����<12��),��/��λʱ��
    int                             nMediumVehicles;                // ���ͳ���ͨ��(6��<����<9��),��/��λʱ��
    int                             nSmallVehicles;                 // С����ͨ��(4��<����<6��),��/��λʱ��,
    int                             nMotoVehicles;                  // Ħ�н�ͨ��(΢�ͳ�,����<4��),��/��λʱ��,
    int                             nLongVehicles;                  // ������ͨ��(����>=12��),��/��λʱ��,
    int                             nVolume;                        // ��ͨ��, ��/��λʱ��, ĳʱ����ͨ����������·������ͨ����һ��ĳ�����,����1Сʱ��, 
    int                             nFlowRate;                      // ����С������,��/Сʱ, ����ͨ����������·ĳһ�����ĳһ·�εĵ���Сʱ����
    int                             nBackOfQueue;                   // �Ŷӳ���,��λ����, ���źŽ����ͣ���ߵ������Ŷӳ���ĩ��֮��ľ���(����ϵ� ����dBackOfQueue����)
    int                             nTravelTime;                    // ����ʱ��,��λ����, ����ͨ��ĳһ����·����ʱ�䡣��������ͣ������
    int                             nDelay;                         // ����,��λ����,��ʻԱ���˿ͻ����˻��ѵĶ�����г�ʱ��
    BYTE                            byDirection[MAX_DRIVING_DIR_NUM]; // ��������,���NET_ROAD_DIRECTION
    BYTE                            byDirectionNum;                 // ������ʻ�������
    BYTE                            reserved1[3];                    // �ֽڶ���
    NET_TRAFFIC_JAM_STATUS          emJamState;                     // ��·ӵ��״��
    //  ����������ͳ�ƽ�ͨ��
    int                             nPassengerCarVehicles;                      // �ͳ���ͨ��(��/��λʱ��)
    int                             nLargeTruckVehicles;                        // �������ͨ��(��/��λʱ��)
    int                             nMidTruckVehicles;                          // �л�����ͨ��(��/��λʱ��)
    int                             nSaloonCarVehicles;                         // �γ���ͨ��(��/��λʱ��)
    int                             nMicrobusVehicles;                          // �������ͨ��(��/��λʱ��)
    int                             nMicroTruckVehicles;                        // С������ͨ��(��/��λʱ��)
    int                             nTricycleVehicles;                          // ���ֳ���ͨ��(��/��λʱ��)
    int                             nMotorcycleVehicles;                        // Ħ�г���ͨ��(��/��λʱ��)
    int                             nPasserbyVehicles;                          // ���˽�ͨ��(��/��λʱ��)
	NET_TRAFFIC_ROAD_RANK			emRank;										// ��·�ȼ�
	int								nState;										// ����״̬
																				// 1- ��������(ӵ��)
																				// 2- ��������ָ�(�Զ�)
																				// 3- ����
																				// 4- ������С(ͨ��)
																				// 5- ������С�ָ�(����)
    BOOL                            bOccupyHeadCoil;                            // ��ͷ������Ȧ�Ƿ�ռ�� TURE��ʾռ�ã�FALSE��ʾδռ��
    BOOL                            bOccupyTailCoil;                            // ��β������Ȧ�Ƿ�ռ�� TURE��ʾռ�ã�FALSE��ʾδռ��
    BOOL                            bStatistics;                                // ���������Ƿ���Ч TURE��ʾ��Ч��FALSE��ʾ��Ч

	int								nLeftVehicles;								// ��ת��������,��λ:����
	int								nRightVehicles;								// ��ת��������,��λ:����
	int								nStraightVehicles;							// ֱ�г�������,��λ:����
	int								nUTurnVehicles;								// ��ͷ��������,��λ:����
    DH_POINT                        stQueueEnd;                                 // ÿ�����������һ��������,����8192����ϵ
	double							dBackOfQueue;								// �Ŷӳ���,��λ����, ���źŽ����ͣ���ߵ������Ŷӳ���ĩ��֮��ľ���
	DWORD							dwPeriodByMili;								// ����ֵ�ĺ���ʱ��,ֵ������60000,��dwPeriodһ��ʹ��,����ֵ��ʱ��:dwPeriod*60*1000+dwPeriodByMili(��λ������)
    int								nBusVehicles;								// ��������ͨ��(��/��λʱ��)
	int								nMPVVehicles;								// MPV��ͨ��(��/��λʱ��)
	int								nMidPassengerCarVehicles;					// �пͳ���ͨ��(��/��λʱ��)
	int								nMiniCarriageVehicles;						// ΢�ͽγ���ͨ��(��/��λʱ��)
	int								nOilTankTruckVehicles;						// �͹޳���ͨ��(��/��λʱ��)
	int								nPickupVehicles;							// Ƥ������ͨ��(��/��λʱ��)
	int								nSUVVehicles;								// SUV��ͨ��(��/��λʱ��)
	int								nSUVorMPVVehicles;							// SUV����MPV��ͨ��(��/��λʱ��)
	int								nTankCarVehicles;							// �۹޳���ͨ��(��/��λʱ��)
	int								nUnknownVehicles;							// δ֪������ͨ��(��/��λʱ��)
	BYTE                            reserved[724];                              // �����ֽ�
}NET_TRAFFIC_FLOW_STATE;

// ��ͨ�����¼���Ϣtrafficflowstatinfo ��Ӧ�ṹ�� 
typedef struct tagNET_TRAFFICFLOWSTATINFO
{
    DH_TRAFFICFLOWSTAT				stuTrafficFlowStat;				// ��ͨ����״̬
	
	double							dbBackOfQueue;					// �Ŷӳ���
	NET_TRAFFIC_ROAD_RANK			emRank;							// ��·�ȼ�
	int								nState;							// ����״̬
																	// 1- ��������(ӵ��)
																	// 2- ��������ָ�(�Զ�)
																	// 3- ����
																	// 4- ������С(ͨ��)
																	// 5- ������С�ָ�(����)
    BYTE                            reserved[1024];                 // �����ֽ�
}NET_TRAFFICFLOWSTATINFO; 


//�¼����� EVENT_IVS_TRAFFIC_FLOWSTATE(��ͨ�����¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_FLOW_STATE
{
    int                     nChannelID;                             // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];              // �¼�����
    char                    bReserved1[8];                          // �ֽڶ���
    DWORD                   PTS;                                    // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                                    // �¼�������ʱ��
    int                     nEventID;                               // �¼�ID
    int                     nSequence;                              // ���
    int                     nStateNum;                              // ����״̬����
    NET_TRAFFIC_FLOW_STATE  stuStates[DH_MAX_LANE_NUM];             // ����״̬, ÿ��������Ӧ������һ��Ԫ��
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;                 	// �����¼�������Ϣ
	BYTE                    bReserved[892];                        // �����ֽ�
}DEV_EVENT_TRAFFIC_FLOW_STATE;

// �¼�����EVENT_IVS_VIDEOSTATIC(��Ƶ��̬����¼�)��Ӧ���ݿ�������Ϣ, 
typedef struct tagDEV_EVENT_ALARM_VIDEOSTATIC_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                             // �豸������ģʽ
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved[1027];                            // �����ֽ�
}DEV_EVENT_ALARM_VIDEOSTATIC_INFO;

// �¼�����EVENT_IVS_VIDEOTIMING(��Ƶ��ʱ���ʱ��)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_VIDEOTIMING_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                bReserved[1027];                            // �����ֽ�
}DEV_EVENT_ALARM_VIDEOTIMING_INFO;


//�¼�Դ��Ϣ�ṹ
typedef struct tagDEV_SRC_INFO
{
    char          szSrcEvent[DH_COMMON_STRING_32];// �¼�Դ
    NET_TIME_EX   stSrcTime;                      // �¼�Դ������ʱ��
    int           iSrcChannel;                    // �¼�Դ������ͨ����
    BYTE          reserved[512];                  // �����ֽ�
}DEV_SRC_INFO;

//�¼�����EVENT_IVS_LINKSD(LinkSD�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_LINK_SD
{
    //�����ֶ�
    int                 nChannelID;                         // ͨ����
    char                szName[DH_EVENT_NAME_LEN];          // �¼�����
    char                bReserved1[8];                     // �ֽڶ���
    DWORD               PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID

    //�¼���Ӧ�ֶ�
    DEV_SRC_INFO       *pstSrcInfo;                         // �¼�Դ��Ϣ
    NET_TIME_EX         stStartTime;                        // Ԥ�õ㵽���ʱ��
    NET_TIME_EX         stEndTime;                          //Ԥ�õ������ʱ��
    int                 iPresetID;                          //�������ת���Ķ�ӦԤ�õ�
    BYTE                reserved[512];                      //�����ֽ�
    
}DEV_EVENT_LINK_SD;

// �¼�����EVENT_IVS_FLOWRATE(����ʹ������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_FLOWRATE_INFO
{
	//�����ֶ�
    int                 nChannelID;                         // ͨ����
    char                szName[DH_EVENT_NAME_LEN];          // �¼�����
    char                bReserved1[8];                     	// �ֽڶ���
    double              dbPTS;                              // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         stuTime;                            // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID

	//�¼���Ӧ�ֶ�
	unsigned int 		nFlowRate;							// ����������ֵ(MB)
	BYTE                reserved[1024];                     // �����ֽ�
} DEV_EVENT_FLOWRATE_INFO;

typedef enum tagEM_CITIZENIDCARD_SEX_TYPE
{
    EM_CITIZENIDCARD_SEX_TYPE_UNKNOWN,          // δ֪
    EM_CITIZENIDCARD_SEX_TYPE_MALE,             // ��
    EM_CITIZENIDCARD_SEX_TYPE_FEMALE,           // Ů
    EM_CITIZENIDCARD_SEX_TYPE_UNTOLD,           // δ˵��
}EM_CITIZENIDCARD_SEX_TYPE;

// �¼����� EVENT_IVS_CITIZENIDCARD(���֤��Ϣ��ȡ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_CITIZENIDCARD_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
    int                 nGroupID;                                   // nGroupID�¼���ID,ͬһ����ץ�Ĺ�����nGroupID��ͬ
    int                 nCountInGroup;                              // nCountInGroupһ���¼����ڵ�ץ������
    int                 nIndexInGroup;                              // IndexInGroupһ���¼����ڵ�ץ�����
    char                szCitizen[DH_COMMON_STRING_64];             // ����
    EM_CITIZENIDCARD_SEX_TYPE   emSex;                              // �Ա�
    int                 nEthnicity;                                 // ����
    // 0 ��Ч����
    // 1 ����
    // 2 �ɹ���
    // 3 ����
    // 4 ����
    // 5 ά�����
    // 6 ����
    // 7 ����
    // 8 ׳��
    // 9 ������
    // 10 ������
    // 11 ����
    // 12 ����
    // 13 ����
    // 14 ����
    // 15 ������
    // 16 ������
    // 17 ��������
    // 18 ����
    // 19 ����
    // 20 ������
    // 21 ����
    // 22 ���
    // 23 ��ɽ��
    // 24 ������
    // 25 ˮ��
    // 26 ������
    // 27 ������
    // 28 ������
    // 29 �¶�������
    // 30 ����
    // 31 ���Ӷ���
    // 32 ������
    // 33 Ǽ��
    // 34 ������
    // 35 ������
    // 36 ë����
    // 37 ������
    // 38 ������
    // 39 ������
    // 40 ������
    // 41 ��������
    // 42 ŭ��
    // 43 ���α����
    // 44 ����˹��
    // 45 ���¿���
    // 46 �°���
    // 47 ������
    // 48 ԣ����
    // 49 ����
    // 50 ��������
    // 51 ������
    // 52 ���״���
    // 53 ������
    // 54 �Ű���
    // 55 �����
    // 56 ��ŵ��
    NET_TIME            stuBirth;                                   // ��������
    char                szAddress[DH_COMMON_STRING_256];            // סַ
    char                szNumber[DH_COMMON_STRING_64];              // ���֤��
    char                szAuthority[DH_COMMON_STRING_256];          // ǩ������
    NET_TIME            stuStart;                                   // ��ʼ����
    BOOL                bLongTimeValidFlag;                         // ��ֵΪ TRUE, ��ֹ���� ��ʾ������Ч,��ʱ stuEnd ֵ������
    // ��ֵΪ FALSE, ��ʱ ��ֹ���� �鿴 stuEnd ֵ
    NET_TIME            stuEnd;                                     // ��ֹ����,bLongTimeValidFlag Ϊ FALSE ʱ��Ч
    char                szReversed[1024];                           // �����ֽ�
}DEV_EVENT_ALARM_CITIZENIDCARD_INFO;

// �¼����� EVENT_IVS_PICINFO(ͼƬ��Ϣ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_PIC_INFO 
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��(�����豸��֧��)
    int                 nEventID;                                   // �¼�ID
	///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
	NET_TIME_EX         stuTime;                                    // �¼�������ʱ��, (�豸ʱ��, ��һ����utcʱ��)
    DWORD               dwEventType;                                // �¼�����
    DWORD               dwSpeed;                                    // ����,��λkm/h
	DWORD               dwSpeedHighLine;                            // �������ޱ���ֵ, ��λkm/h
    DWORD               dwDisk;                                     // ���̺�
    DWORD               dwCluster;                                  // �غ�
    DWORD               dwPartition;                                // ������
    char                szSnapAddr[DH_COMMON_STRING_128];           // ץͼ�ص�, ��Ч64�ֽ�
    char                szPicID[DH_COMMON_STRING_32];               // ͼƬΨһID
    char                szPlate[DH_COMMON_STRING_16];               // ����
    char                szReversed[2000];                           // �����ֽ�
}DEV_EVENT_ALARM_PIC_INFO;

// �¼����� EVENT_IVS_ACCESS_CTL(�Ž��¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_ACCESS_CTL_INFO 
{
    int                         nChannelID;                         // ��ͨ����
    char                        szName[DH_EVENT_NAME_LEN];          // �¼�����
    char                		bReserved1[4];                      // �ֽڶ���
    double              		PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         		UTC;                                // �¼�������ʱ��
    int                 		nEventID;                           // �¼�ID        
    DH_MSG_OBJECT           	stuObject;                          // ��⵽������
	DH_EVENT_FILE_INFO			stuFileInfo;	                    // �¼���Ӧ�ļ���Ϣ
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // �Ž��¼�����
    BOOL                        bStatus;                            // ˢ�����,TRUE��ʾ�ɹ�,FALSE��ʾʧ��
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // ������
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // ���ŷ�ʽ
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // ����
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // ����
    char                        szReaderID[DH_COMMON_STRING_32];    // �Ŷ�����ID
    char                        szUserID[DH_COMMON_STRING_64];      // �����û�
    char                        szSnapURL[DH_COMMON_STRING_128];    // ץ����Ƭ�洢��ַ
    int                         nErrorCode;                         // ����ʧ�ܵ�ԭ��,����bStatusΪFALSEʱ��Ч
                                                                    // 0x00 û�д���
                                                                    // 0x10 δ��Ȩ
                                                                    // 0x11 ����ʧ��ע��
                                                                    // 0x12 û�и���Ȩ��
                                                                    // 0x13 ����ģʽ����
                                                                    // 0x14 ��Ч�ڴ���
                                                                    // 0x15 ����Ǳģʽ
                                                                    // 0x16 в�ȱ���δ��
                                                                    // 0x17 �ų���״̬
                                                                    // 0x18 AB����״̬
                                                                    // 0x19 Ѳ�߿�
                                                                    // 0x1A �豸���ڴ��뱨��״̬
                                                                    // 0x20 ʱ��δ���
                                                                    // 0x21 �����ڿ���ʱ��δ���
                                                                    // 0x30 ��Ҫ����֤���׿�Ȩ�޵Ŀ�Ƭ
                                                                    // 0x40 ��Ƭ��ȷ,�����������
                                                                    // 0x41 ��Ƭ��ȷ,�������볬ʱ
                                                                    // 0x42 ��Ƭ��ȷ,����ָ�ƴ���
                                                                    // 0x43 ��Ƭ��ȷ,����ָ�Ƴ�ʱ
                                                                    // 0x44 ָ����ȷ,�����������
                                                                    // 0x45 ָ����ȷ,�������볬ʱ
                                                                    // 0x50 ��Ͽ���˳�����
                                                                    // 0x51 ��Ͽ�����Ҫ������֤
                                                                    // 0x60 ��֤ͨ��,����̨δ��Ȩ
    int                         nPunchingRecNo;                     // ˢ����¼���еļ�¼���
	int							nNumbers;							// ץͼ����
    BYTE						byImageIndex;	                    // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ	
	BYTE                        byReserved[3];                      // �ֽڶ���
	DWORD						dwSnapFlagMask;						// ץͼ��־(��λ),����� NET_RESERVED_COMMON        
    NET_ATTENDANCESTATE         emAttendanceState;                  // ����״̬
    BYTE						bReserved[1020];					// �����ֽ�,�����չ. 
}DEV_EVENT_ACCESS_CTL_INFO;

//�¼����� EVENT_IVS_NETPALYCHECK(�����Ǽ��¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_NETPLAYCHECK_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[8];                              // �ֽڶ���
    DWORD               PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
	NET_TIME_EX         stuTime;                                    // �¼�������ʱ��, (�豸ʱ��, ��һ����utcʱ��)
	char				szIdentityCard[DH_COMMON_STRING_32];		//������Ա���֤
	char				szNetBarName[DH_COMMON_STRING_32];			//��������
	char				szNetBarID[DH_COMMON_STRING_32];			//���ɱ��
	char				szNetBarAddr[DH_COMMON_STRING_64];			//���ɵ�ַ
}DEV_EVENT_ALARM_NETPLAYCHECK_INFO;

//�¼����� EVENT_IVS_SNAPBYTIME(��ʱץͼ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_SNAPBYTIME
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID
    ///////////////////////////////����Ϊ�����ֶΣ���nChannelID��������ֶ���Ϊ��Ԥ����ֶοռ�//////////////////////////////
    NET_TIME_EX         stuSnapTime;                                  // ץͼʱ��
    char                szReversed[2048];                            // �����ֽ�
}DEV_EVENT_SNAPBYTIME;

// �¼�����EVENT_IVS_MAN_STAND_DETECTION(�����Ӿ�վ���¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_MANSTAND_DETECTION_INFO
{
	int                 		nChannelID;                 // ͨ����
    char                		szName[DH_EVENT_NAME_LEN];  // �¼�����
    char                		bReserved1[4];              // �ֽڶ���,�Ǳ����ֽ�
    double              		PTS;                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         		UTC;                        // �¼�������ʱ��
    int                 		nEventID;                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶΣ���nChannelID��������ֶ���Ϊ��Ԥ����ֶοռ�//////////////////////////////
	int                 		nAction;                    // 0:���� 1:��ʼ 2:ֹͣ
	int							nManListCount;				// ������Ա�б�����
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// ��������Ա�б�
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
	char                		szReversed[2048];           // �����ֽ�
} DEV_EVENT_MANSTAND_DETECTION_INFO;

// �¼�����EVENT_IVS_MAN_NUM_DETECTION(�����Ӿ�����������ͳ���¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_MANNUM_DETECTION_INFO
{
	int                 		nChannelID;                 // ͨ����
    char                		szName[DH_EVENT_NAME_LEN];  // �¼�����
    char                		bReserved1[4];              // �ֽڶ���, �Ǳ����ֽ�
    double              		PTS;                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         		UTC;                        // �¼�������ʱ��
    int                 		nEventID;                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶΣ���nChannelID��������ֶ���Ϊ��Ԥ����ֶοռ�//////////////////////////////
	int                 		nAction;                    // 0:���� 1:��ʼ 2:ֹͣ
	int							nManListCount;				// ������Ա�б�����
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// ��������Ա�б�
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // �����¼�������Ϣ
	char                		szReversed[2048];           // �����ֽ�
} DEV_EVENT_MANNUM_DETECTION_INFO;

// �¼�����EVENT_IVS_TIREDPHYSIOLOGICAL(����ƣ�ͼ�ʻ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TIREDPHYSIOLOGICAL_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	int                 nAction;                                      // 0:���� 1:��ʼ 2:ֹͣ
	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_TIREDPHYSIOLOGICAL_INFO;

// �¼�����EVENT_IVS_TRAFFIC_TIREDLOWERHEAD(������ͷ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TIREDLOWERHEAD_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_TIREDLOWERHEAD_INFO;

// �¼�����EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND(����������α����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_DRIVERLOOKAROUND_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_DRIVERLOOKAROUND_INFO;

// �¼�����EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST(������ڱ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_DRIVERLEAVEPOST_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_DRIVERLEAVEPOST_INFO;

// �¼����� EVENT_IVS_TRAFFIC_DRIVERYAWN (�������Ƿ�¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_DRIVERYAWN_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                szReserved1[4];                               // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				byReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_DRIVERYAWN_INFO;

// ��⵽���˵���Ϣ
typedef enum tagEM_DETECT_OBJECT
{
	EM_DETECT_OBJECT_UNKNOWN,					// δ֪��Ϣ
	EM_DETECT_OBJECT_HUMAN_BODY_AND_FACE,		// �������������
	EM_DETECT_OBJECT_HUMAN_BODY,				// ��������
	EM_DETECT_OBJECT_HUMAN_FACE,				// ��������
}EM_DETECT_OBJECT;

// ����ͼƬ��Ϣ
typedef struct tagHUMAN_IMAGE_INFO
{
	unsigned int       nOffSet;					// ƫ�� 		
	unsigned int	   nLength;					// ͼƬ��С,��λ�ֽ�
	BYTE			   byReserved[64];			// Ԥ���ֽ�
}HUMAN_IMAGE_INFO;

// ����ͼƬ��Ϣ
typedef struct tagFACE_IMAGE_INFO
{
	unsigned int	   nOffSet;					// ƫ��   
	unsigned int	   nLength;					// ͼƬ��С,��λ�ֽ�
	BYTE			   byReserved[64];			// Ԥ���ֽ�
}FACE_IMAGE_INFO;

// �¼����� EVENT_IVS_HUMANTRAIT(���������¼�)��Ӧ�����ݿ�������Ϣ 
typedef struct tagDEV_EVENT_HUMANTRAIT_INFO
{
	int					nChannelID;									  // ͨ����
	char				szName[DH_EVENT_NAME_LEN];					  // �¼�����
	int                 nEventID;                                     // �¼�ID
	double              PTS;                                          // ʱ���(��λ�Ǻ���)
	NET_TIME_EX         UTC;                                          // �¼�������ʱ��
	int                 nAction;                                      // 1:��ʼ 2:ֹͣ
	
	EM_CLASS_TYPE		emClassType;								  // �����¼��������
	int					nGroupID;									  // �¼���ID��һ�μ��Ķ����������nGroupID��ͬ
	int					nCountInGroup;								  // һ���¼����ڵ�ץ������(�������),һ�μ��Ķ����������nCountInGroup��ͬ
	int					nIndexInGroup;								  // һ���¼����ڵ�ץ����ţ���1��ʼ
	HUMAN_IMAGE_INFO	stuHumanImage;								  // ����ͼƬ��Ϣ
	FACE_IMAGE_INFO		stuFaceImage;								  // ����ͼƬ��Ϣ
	EM_DETECT_OBJECT	emDetectObject;								  // ��⵽���˵���Ϣ
	BYTE				byReserved[876];							  // �����ֽ�,�����չ.
}DEV_EVENT_HUMANTRAIT_INFO;

// �¼�����EVENT_IVS_BUSSHARPTURN(������ת�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_BUSSHARPTURN_INFO
{
	int                 nChannelID;                                   // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                    // �¼�����
    char                bReserved1[4];                                // �ֽڶ���
    double              PTS;                                          // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                          // �¼�������ʱ��
    int                 nEventID;                                     // �¼�ID

	int                 nAction;                                      // 0:���� 1:��ʼ 2:ֹͣ
	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS��Ϣ
    BYTE				bReserved[1024];							  // �����ֽ�,�����չ. 
} DEV_EVENT_BUSSHARPTURN_INFO;

// �¼����� EVENT_IVS_TRAFFIC_ELETAGINFO(RFID���ӳ��Ʊ�ǩ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_ELETAGINFO_INFO
{
	
	int                 nChannelID;							// ͨ����
    char                szName[DH_EVENT_NAME_LEN];			// �¼�����
    char                bReserved1[4];						// �ֽڶ���
    double              PTS;								// ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;								// �¼�������ʱ��
    int                 nEventID;							// �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
    int                 nAction;                            // 0:���� 1:��ʼ 2:ֹͣ
    NET_RFIDELETAG_INFO	stuRFIDEleTagInfo;					// RFID���ӳ��Ʊ�ǩ��Ϣ
	int					nRetChannelNum;						// ����ͨ����
	int					nLinkChannel[DH_MAX_CHANNUM];		// ���������ͨ��,ͨ���Ŵ�0��ʼ
	BYTE				bReserved[956];						// �����ֽ�,�����չ. 
} DEV_EVENT_TRAFFIC_ELETAGINFO_INFO;

// media�ļ���ѯ����
typedef enum __EM_FILE_QUERY_TYPE
{
    DH_FILE_QUERY_TRAFFICCAR,                           // ��ͨ������Ϣ,��Ӧ�ṹ��ΪMEDIA_QUERY_TRAFFICCAR_PARAM
    DH_FILE_QUERY_ATM,                                  // ATM��Ϣ
    DH_FILE_QUERY_ATMTXN,                               // ATM������Ϣ 
    DH_FILE_QUERY_FACE,                                 // ������Ϣ MEDIAFILE_FACERECOGNITION_PARAM �� MEDIAFILE_FACERECOGNITION_INFO  
    DH_FILE_QUERY_FILE,                                 // �ļ���Ϣ��Ӧ NET_IN_MEDIA_QUERY_FILE �� NET_OUT_MEDIA_QUERY_FILE
    DH_FILE_QUERY_TRAFFICCAR_EX,                        // ��ͨ������Ϣ, ��չDH_FILE_QUERY_TRAFFICCAR, ֧�ָ�����ֶΣ���Ӧ�ṹ��ΪMEDIA_QUERY_TRAFFICCAR_PARAM_EX
    DH_FILE_QUERY_FACE_DETECTION,                       // ��������¼���Ϣ MEDIAFILE_FACE_DETECTION_PARAM �� MEDIAFILE_FACE_DETECTION_INFO 
    DH_FILE_QUERY_IVS_EVENT,                            // �����¼���Ϣ MEDIAFILE_IVS_EVENT_PARAM �� MEDIAFILE_IVS_EVENT_INFO
    DH_FILE_QUERY_ANALYSE_OBJECT,                       // ���ܷ�����������(�˺ͳ�����) MEDIAFILE_ANALYSE_OBJECT_PARAM �� MEDIAFILE_ANALYSE_OBJECT_INFO
    DH_FILE_QUERY_MPT_RECORD_FILE,                      // MPT�豸��¼���ļ� MEDIAFILE_MPT_RECORD_FILE_PARAM �� MEDIAFILE_MPT_RECORD_FILE_INFO
} EM_FILE_QUERY_TYPE;

typedef enum _EM_RECORD_SNAP_FLAG_TYPE
{
    FLAG_TYPE_TIMING ,                  //��ʱ�ļ�
    FLAG_TYPE_MANUAL ,                  //�ֶ��ļ�
    FLAG_TYPE_MARKED ,                  //��Ҫ�ļ�
    FLAG_TYPE_EVENT  ,                  //�¼��ļ�
    FLAG_TYPE_MOSAIC ,                  //�ϳ�ͼƬ
    FLAG_TYPE_CUTOUT ,                  //��ͼͼƬ
    FLAG_TYPE_LEAVE_WORD ,              //�����ļ�
    FLAG_TYPE_TALKBACK_LOCAL_SIDE ,     //�Խ����ط��ļ�
    FLAG_TYPE_TALKBACK_REMOTE_SIDE ,    //�Խ�Զ�̷��ļ�
    FLAG_TYPE_SYNOPSIS_VIDEO ,          //Ũ����Ƶ
    FLAG_TYPE_ORIGINAL_VIDEO ,          //ԭʼ��Ƶ
    FLAG_TYPE_PRE_ORIGINAL_VIDEO ,      //�Ѿ�Ԥ�����ԭʼ��Ƶ
    FLAG_TYPE_BLACK_PLATE ,             //������ͼƬ
    FLAG_TYPE_ORIGINAL_PIC ,            //ԭʼͼƬ
    FLAG_TYPE_CARD,                     //����¼��
    FLAG_TYPE_MAX = 128, 
}EM_RECORD_SNAP_FLAG_TYPE;

// ATM��������
typedef enum
{
    ATM_TRADE_ALL,                      // ��������
    ATM_TRADE_ENQUIRY,                  // ��ѯ
    ATM_TRADE_WITHDRAW,                 // ȡ��
    ATM_TRADE_MODIFY_PASSWORD,          // �޸�����
    ATM_TRADE_TRANSFER,                 // ת��
    ATM_TRADE_DEPOSIT,                  // ���
    ATM_TRADE_CARDLESS_ENQUIRY,         // �޿���ѯ
    ATM_TRADE_CARDLESS_DEPOSIT,         // �޿����
    ATM_TRADE_OTHER,                    // ����
}EM_ATM_TRADE_TYPE;

// ����¼����Ϣ
typedef struct
{
    DWORD               dwSize;
    int                 nType;                                          // ����, 0-Card, 1-Field
    char                szCardNo[DH_MAX_CARD_INFO_LEN];                 // ����
    EM_ATM_TRADE_TYPE   emTradeType;                                    // ��������
    char                szAmount[DH_COMMON_STRING_64];                  // ���׽��, ���ַ�����ʾ���޽��
    int                 nError;                                         // ������, 0-���д���, 1-�̳�, 2-�̿�
    int                 nFieldCount;                                    // ������, �����ѯʱ��Ч
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256];   // ����Ϣ, �����ѯʱ��Ч
	char				szChange[DH_COMMON_STRING_32];		            // ��Ǯ
}NET_RECORD_CARD_INFO;

#define MAX_IVS_EVENT_NUM    256
#define MAX_QUERY_USER_NUM   4                  // ����ѯ�û�����

// ��ѯ�������ʽ
typedef enum tagEM_RESULT_ORDER_TYPE
{
    EM_RESULT_ORDER_UNKNOWN,                    // δ֪
    EM_RESULT_ORDER_ASCENT_BYTIME,              // ��ʱ����������
    EM_RESULT_ORDER_DESCENT_BYTIME,             // ��ʱ�併������   
}EM_RESULT_ORDER_TYPE;

// ¼����Ϣ��Ӧ CLIENT_FindFileEx�ӿڵ� DH_FILE_QUERY_FILE ���� ��ѯ����
// Ŀǰ֧��ͨ��·����ѯ
typedef struct  
{
    DWORD               dwSize;                 // �ṹ���С
    char*               szDirs;                 // ����Ŀ¼�б�,һ�οɲ�ѯ���Ŀ¼,Ϊ�ձ�ʾ��ѯ����Ŀ¼��Ŀ¼֮���Էֺŷָ�,�硰/mnt/dvr/sda0;/mnt/dvr/sda1��,szDirs==null ��"" ��ʾ��ѯ����
    int                 nMediaType;             // �ļ�����,0:��ѯ��������,1:��ѯjpgͼƬ,2:��ѯdav
    int                 nChannelID;             // ͨ���Ŵ�0��ʼ,-1��ʾ��ѯ����ͨ��
    NET_TIME            stuStartTime;           // ��ʼʱ��    
    NET_TIME            stuEndTime;             // ����ʱ��
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // �¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;            // �¼�����
    BYTE                byVideoStream;          // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3 
    BYTE                bReserved[3];           // �ֽڶ���
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־, �����ñ�־��ʾ��ѯ�����ļ�
    int                 nFalgCount;             // ��־����
    NET_RECORD_CARD_INFO stuCardInfo;           // ����¼����Ϣ, emFalgLists��������¼��ʱ��Ч
    int                 nUserCount;             // �û�����Ч����
    char                szUserName[MAX_QUERY_USER_NUM][DH_NEW_USER_NAME_LENGTH]; // �û���
    EM_RESULT_ORDER_TYPE emResultOrder;         // ��ѯ�������ʽ
}NET_IN_MEDIA_QUERY_FILE;

// �ļ�ժҪ��Ϣ
typedef struct 
{
    char szKey[DH_COMMON_STRING_64];           // ժҪ����
    char szValue[DH_COMMON_STRING_512];        // ժҪ����
    BYTE bReserved[256];                       // �����ֶ�   
}NET_FILE_SUMMARY_INFO;

// ¼����Ϣ��Ӧ CLIENT_FindFileEx�ӿڵ� DH_FILE_QUERY_FILE ���� ��ѯ���
typedef struct  
{
    DWORD               dwSize;                 // �ṹ���С
    int                 nChannelID;             // ͨ���Ŵ�0��ʼ,-1��ʾ��ѯ����ͨ��
    NET_TIME            stuStartTime;           // ��ʼʱ��    
    NET_TIME            stuEndTime;             // ����ʱ��
    unsigned int        nFileSize;              // �ļ�����
    BYTE                byFileType;             // �ļ����� 1:jpgͼƬ, 2: dav
    BYTE                byDriveNo;              // ���ֶ��ѷ���,��������ʹ�� nDriveNo��Ա
    BYTE                byPartition;            // ������
    BYTE                byVideoStream;          // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������ 4-������ 
    unsigned int        nCluster;               // �غ�
    char                szFilePath[MAX_PATH];   // �ļ�·��
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // �������¼��б�,�¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;            //�¼�����
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־ 
    int                 nFalgCount;             //��־����
    unsigned int        nDriveNo;               // ���̺�

    //ƵŨ���ļ������Ϣ
    char szSynopsisPicPath[DH_COMMON_STRING_512];              // Ԥ�����ļ���ȡ���Ŀ���	�ļ�·��
                                                               // ֧��HTTP URL��ʾ:"http://www.dahuate.com/1.jpg"
                                                               // ֧��FTP URL��ʾ: "ftp://ftp.dahuate.com/1.jpg"
                                                               // ֧�ַ���������·�� 
                                                               // a)"C:/pic/1.jpg" 
                                                               // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int                 nSynopsisMaxTime;                      // ֧��Ũ����Ƶ���ʱ�䳤��,��λ ��
    int                 nSynopsisMinTime;                      // ֧��Ũ����Ƶ��Сʱ�䳤��,��λ ��
   
    //�ļ�ժҪ��Ϣ
    int                     nFileSummaryNum;                                // �ļ�ժҪ��Ϣ��
    NET_FILE_SUMMARY_INFO   stFileSummaryInfo[MAX_FILE_SUMMARY_NUM];        // �ļ�ժҪ��Ϣ    
}NET_OUT_MEDIA_QUERY_FILE;

// DH_MEDIA_QUERY_TRAFFICCAR��Ӧ�Ĳ�ѯ����
typedef struct  
{
    int                 nChannelID;                     // ͨ���Ŵ�0��ʼ,-1��ʾ��ѯ����ͨ��
    NET_TIME            StartTime;                      // ��ʼʱ��    
    NET_TIME            EndTime;                        // ����ʱ��
    int                 nMediaType;                     // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    int                 nEventType;                     // �¼�����,���"���ܷ����¼�����", 0:��ʾ��ѯ�����¼�,�˲�������,��ʹ��pEventTypes
    char                szPlateNumber[32];              // ���ƺ�, "\0"���ʾ��ѯ���⳵�ƺ�
    int                 nSpeedUpperLimit;               // ��ѯ�ĳ��ٷ�Χ; �ٶ����� ��λ: km/h
    int                 nSpeedLowerLimit;               // ��ѯ�ĳ��ٷ�Χ; �ٶ����� ��λ: km/h 
    BOOL                bSpeedLimit;                    // �Ƿ��ٶȲ�ѯ; TRUE:���ٶȲ�ѯ,nSpeedUpperLimit��nSpeedLowerLimit��Ч��
    DWORD               dwBreakingRule;                 // Υ�����ͣ�
                                                        // ���¼�����Ϊ EVENT_IVS_TRAFFICGATEʱ
                                                        //        ��һλ:����;  �ڶ�λ:ѹ����ʻ; ����λ:������ʻ; 
                                                        //        ����λ��Ƿ����ʻ; ����λ:�����;
                                                        // ���¼�����Ϊ EVENT_IVS_TRAFFICJUNCTION
                                                        //        ��һλ:�����;  �ڶ�λ:�����涨������ʻ;  
                                                        //        ����λ:����; ����λ��Υ�µ�ͷ;
                                                        //        ����λ:ѹ����ʻ;

    char                szPlateType[32];                // ��������,"Unknown" δ֪,"Normal" ���ƺ���,"Yellow" ����,"DoubleYellow" ˫���β��,"Police" ����"Armed" �侯��,
                                                        // "Military" ���Ӻ���,"DoubleMilitary" ����˫��,"SAR" �۰���������,"Trainning" ����������
                                                        // "Personal" ���Ժ���,"Agri" ũ����,"Embassy" ʹ�ݺ���,"Moto" Ħ�г�����,"Tractor" ����������,"Other" ��������
														// "Civilaviation"�񺽺���,"Black"����
														// "PureNewEnergyMicroCar"���綯����ԴС��,"MixedNewEnergyMicroCar,"�������ԴС��,"PureNewEnergyLargeCar",���綯����Դ��
														// "MixedNewEnergyLargeCar"�������Դ��
    char                szPlateColor[16];               // ������ɫ, "Blue"��ɫ,"Yellow"��ɫ, "White"��ɫ,"Black"��ɫ
    char                szVehicleColor[16];             // ������ɫ:"White"��ɫ, "Black"��ɫ, "Red"��ɫ, "Yellow"��ɫ, "Gray"��ɫ, "Blue"��ɫ,"Green"��ɫ
    char                szVehicleSize[16];              // ������С����:"Light-duty":С�ͳ�;"Medium":���ͳ�; "Oversize":���ͳ�; "Unknown": δ֪
    int                 nGroupID;                       // �¼�����(��ֵ>=0ʱ��Ч)
    short               byLane;                         // ������(��ֵ>=0ʱ��ʾ���峵��,-1��ʾ���г���,�����·����ֶ�)
    BYTE                byFileFlag;                     // �ļ���־, 0xFF-ʹ��nFileFlagEx, 0-��ʾ����¼��, 1-��ʱ�ļ�, 2-�ֶ��ļ�, 3-�¼��ļ�, 4-��Ҫ�ļ�, 5-�ϳ��ļ�
    BYTE                byRandomAccess;                 // �Ƿ���Ҫ�ڲ�ѯ������������ת,0-����Ҫ,1-��Ҫ
    int                 nFileFlagEx;                    // �ļ���־, ��λ��ʾ: bit0-��ʱ�ļ�, bit1-�ֶ��ļ�, bit2-�¼��ļ�, bit3-��Ҫ�ļ�, bit4-�ϳ��ļ�, bit5-������ͼƬ 0xFFFFFFFF-����¼��
    int                 nDirection;                     // �������򣨳������ķ���    0-�� 1-���� 2-�� 3-���� 4-�� 5-���� 6-�� 7-���� 8-δ֪ -1-���з���
    char*               szDirs;                         // ����Ŀ¼�б�,һ�οɲ�ѯ���Ŀ¼,Ϊ�ձ�ʾ��ѯ����Ŀ¼��Ŀ¼֮���Էֺŷָ�,�硰/mnt/dvr/sda0;/mnt/dvr/sda1��,szDirs==null ��"" ��ʾ��ѯ����
    int*                pEventTypes;                    // ����ѯ���¼���������ָ��,�¼�����,���"���ܷ����¼�����",��ΪNULL����Ϊ��ѯ�����¼������������û����룩
    int                 nEventTypeNum;                  // �¼����������С
    char*               pszDeviceAddress;               // �豸��ַ, NULL��ʾ���ֶβ�������
    char*               pszMachineAddress;              // ��������ص�, NULL��ʾ���ֶβ�������
    char*               pszVehicleSign;                 // ������ʶ, ���� "Unknown"-δ֪, "Audi"-�µ�, "Honda"-����... NULL��ʾ���ֶβ�������
	WORD                wVehicleSubBrand;               // ������Ʒ�� ��Ҫͨ��ӳ���õ���������Ʒ�� ӳ�����������ֲ�
    WORD                wVehicleYearModel;              // ����Ʒ����� ��Ҫͨ��ӳ���õ���������� ӳ�����������ֲ�
    int                 bReserved[28];                  // �����ֶ�
} MEDIA_QUERY_TRAFFICCAR_PARAM;

// ��������
typedef enum tagEM_REFUEL_TYPE
{
        EM_REFUEL_TYPE_UNKNOWN = 0,							// unknown
		EM_REFUEL_TYPE_NINETY_EIGHT,						// "98#"
		EM_REFUEL_TYPE_NINETY_SEVEN,						// "97#"
		EM_REFUEL_TYPE_NINETY_FIVE,							// "95#"
		EM_REFUEL_TYPE_NINETY_THREE,                        // "93#"
		EM_REFUEL_TYPE_NINETY,								// "90#"
		EM_REFUEL_TYPE_TEN,									// "10#"
		EM_REFUEL_TYPE_FIVE,								// "5#"
		EM_REFUEL_TYPE_ZERO,								// "0#"
		EM_REFUEL_TYPE_NEGATIVE_TEN,						// "-10#"
		EM_REFUEL_TYPE_NEGATIVE_TWENTY,						// "-20#"
		EM_REFUEL_TYPE_NEGATIVE_THIRTY_FIVE,				// "-35#"
		EM_REFUEL_TYPE_NEGATIVE_FIFTY,						// "-50#"
}EM_REFUEL_TYPE;

// DH_MEDIA_QUERY_TRAFFICCAR��ѯ������media�ļ���Ϣ
typedef struct
{
    unsigned int        ch;                                 // ͨ����
    char                szFilePath[128];                    // �ļ�·��
    unsigned int        size;                               // �ļ�����
    NET_TIME            starttime;                          // ��ʼʱ��
    NET_TIME            endtime;                            // ����ʱ��
    unsigned int        nWorkDirSN;                         // ����Ŀ¼���                                    
    BYTE                nFileType;                          // �ļ�����  1:ͼƬ 2:��Ƶ
    BYTE                bHint;                              // �ļ���λ����
    BYTE                bDriveNo;                           // ���̺�
    BYTE                bReserved2;
    unsigned int        nCluster;                           // �غ�
    BYTE                byPictureType;                      // ͼƬ���ͻ��ļ����, 0-��ͨ, 1-�ϳ�, 2-��ͼ�������ļ������Ϣ��ο� MEDIAFILE_TRAFFICCAR_INFO_EX �� emFalgLists �ֶ�
	BYTE                byVideoStream;						// ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������
	BYTE                byPartition;						// ��ȷ��λ��
    BYTE                bReserved[1];                       // �����ֶ�

    //�����ǽ�ͨ������Ϣ
    char                szPlateNumber[32];                  // ���ƺ���
    char                szPlateType[32];                    // ��������"Unknown" δ֪; "Normal" ���ƺ���; "Yellow" ����; "DoubleYellow" ˫���β��
                                                            // "Police" ����; "Armed" �侯��; "Military" ���Ӻ���; "DoubleMilitary" ����˫��
                                                            // "SAR" �۰���������; "Trainning" ����������; "Personal" ���Ժ���; "Agri" ũ����
                                                            // "Embassy" ʹ�ݺ���; "Moto" Ħ�г�����; "Tractor" ����������; "Other" ��������
															// "Civilaviation"�񺽺���,"Black"����
															// "PureNewEnergyMicroCar"���綯����ԴС��,"MixedNewEnergyMicroCar,"�������ԴС��,"PureNewEnergyLargeCar",���綯����Դ��
															// "MixedNewEnergyLargeCar"�������Դ��
    char                szPlateColor[16];                   // ������ɫ:"Blue","Yellow", "White","Black"
    char                szVehicleColor[16];                 // ������ɫ:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
    int                 nSpeed;                             // ����,��λKm/H
    int                 nEventsNum;                         // �������¼�����
    int                 nEvents[32];                        // �������¼��б�,����ֵ��ʾ��Ӧ���¼�,���"���ܷ����¼�����"        
    DWORD               dwBreakingRule;                     // ����Υ����������,��һλ:�����; �ڶ�λ:�����涨������ʻ;
                                                            // ����λ:����; ����λ��Υ�µ�ͷ;����Ĭ��Ϊ:��ͨ·���¼�
    char                szVehicleSize[16];                  // ������С����:"Light-duty":С�ͳ�;"Medium":���ͳ�; "Oversize":���ͳ�
    char                szChannelName[DH_CHAN_NAME_LEN];    // ���ػ�Զ�̵�ͨ������
    char                szMachineName[DH_MAX_NAME_LEN];     // ���ػ�Զ���豸����

    int                 nSpeedUpperLimit;                   // �ٶ����� ��λ: km/h
    int                 nSpeedLowerLimit;                   // �ٶ����� ��λ: km/h    
    int                 nGroupID;                           // �¼��������
    BYTE                byCountInGroup;                     // һ���¼����ڵ�ץ������
    BYTE                byIndexInGroup;                     // һ���¼����ڵ�ץ�����
    BYTE                byLane;                             // ����,�μ�MEDIA_QUERY_TRAFFICCAR_PARAM
    BYTE                bReserved1[21];                     // ����
    NET_TIME            stSnapTime;                          // ץ��ʱ��
    int                 nDirection;                         // ��������,�μ�MEDIA_QUERY_TRAFFICCAR_PARAM
    char                szMachineAddress[MAX_PATH];         // ��������ص�
} MEDIAFILE_TRAFFICCAR_INFO, *LPMEDIAFILE_TRAFFICCAR_INFO;


// DH_MEDIA_QUERY_TRAFFICCAR_EX��Ӧ�Ĳ�ѯ����
typedef struct tagMEDIA_QUERY_TRAFFICCAR_PARAM_EX
{
    DWORD               dwSize;
    MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;                  // ������ѯ����
} MEDIA_QUERY_TRAFFICCAR_PARAM_EX;

// DH_MEDIA_QUERY_TRAFFICCAR_EX��ѯ�������ļ���Ϣ
typedef struct tagMEDIAFILE_TRAFFICCAR_INFO_EX
{
    DWORD               dwSize;
    MEDIAFILE_TRAFFICCAR_INFO stuInfo;                          // ������Ϣ
    char                szDeviceAddr[DH_COMMON_STRING_256];     // �豸��ַ
    char                szVehicleSign[DH_COMMON_STRING_32];     // ������ʶ, ���� "Unknown"-δ֪, "Audi"-�µ�, "Honda"-����...
    char                szCustomParkNo[DH_COMMON_STRING_64];    // �Զ��峵λ�ţ�ͣ�����ã�
    WORD                wVehicleSubBrand;                       // ������Ʒ�ƣ���Ҫͨ��ӳ���õ���������Ʒ��
    WORD                wVehicleYearModel;                      // ��������Ҫͨ��ӳ���õ����������
	NET_TIME			stuEleTagInfoUTC;						// ��Ӧ���ӳ��Ʊ�ǩ��Ϣ�еĹ���ʱ��(ThroughTime)
	EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX];		// ¼���ץͼ�ļ���־ 
    int                 nFalgCount;								// ��־���� 
} MEDIAFILE_TRAFFICCAR_INFO_EX;

// FINDNEXT��ѯ�������
typedef struct __NET_FINDNEXT_RESERVED
{
    DWORD               dwSize;                         // �ṹ���С
    
    unsigned int        nBeginNumber;                   // ��ѯ��ʼ���,��ʾ��beginNumber����¼��ʼ�� 0<=beginNumber<= totalCount-1
}NET_FINDNEXT_RESERVED;

// ��ѯ��ת����
typedef struct __NET_FINDING_JUMP_OPTION_INFO
{
    DWORD           dwSize;
    int             nOffset;                            // ��ѯ���ƫ����, ������ڵ�ǰ��ѯ�ĵ�һ����ѯ�����λ��ƫ��
}NET_FINDING_JUMP_OPTION_INFO;

// DH_FILE_QUERY_FACE��Ӧ������ʶ������ѯ����
typedef struct __MEDIAFILE_FACERECOGNITION_PARAM
{
    DWORD               dwSize;                         // �ṹ���С

    // ��ѯ��������
    NET_TIME            stStartTime;                    // ��ʼʱ��
    NET_TIME            stEndTime;                      // ����ʱ��
    char                szMachineAddress[MAX_PATH];     // �ص�,֧��ģ��ƥ��     
    int                 nAlarmType;                     // ����ѯ��������,��� EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // ��Ա��Ϣ�Ƿ���Ч
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // ��Ա��Ϣ
    int                 nChannelId;                     // ͨ����  
    int                 nGroupIdNum;                    // ��Ա����   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // ��Ա��ID 
}MEDIAFILE_FACERECOGNITION_PARAM;

typedef struct  tagDH_PIC_INFO_EX
{
    DWORD                dwSize;                        // �ṹ���С
    DWORD                dwFileLenth;                   // �ļ���С, ��λ:�ֽ�
    char                 szFilePath[MAX_PATH];          // �ļ�·��          
}DH_PIC_INFO_EX;

typedef struct  tagNET_PIC_INFO
{
    DWORD                dwFileLenth;                   // �ļ���С, ��λ:�ֽ�
    char                 szFilePath[MAX_PATH];          // �ļ�·��
	BYTE                 bReserved[256];                // �����ֶ�
}NET_PIC_INFO;

typedef struct __NET_CANDIDAT_PIC_PATHS
{
    DWORD                dwSize;                        // �ṹ���С
    int                  nFileCount;                    // ʵ���ļ�����
    DH_PIC_INFO_EX       stFiles[DH_MAX_PERSON_IMAGE_NUM];//�ļ���Ϣ
}NET_CANDIDAT_PIC_PATHS;

typedef struct tagNET_CANDIDAT_PIC_PATHS_EX
{
    int                  nFileCount;                      // ʵ���ļ�����
    NET_PIC_INFO	     stFiles[DH_MAX_PERSON_IMAGE_NUM];// �ļ���Ϣ
	BYTE                 bReserved[256];				  // �����ֶ�
}NET_CANDIDAT_PIC_PATHS_EX;

// DH_FILE_QUERY_FACE��Ӧ������ʶ�����FINDNEXT��ѯ���ز���
typedef struct __MEDIAFILE_FACERECOGNITION_INFO
{
    DWORD						dwSize;                                 // �ṹ���С
    BOOL						bGlobalScenePic;                        // ȫ��ͼ�Ƿ����
    DH_PIC_INFO_EX				stGlobalScenePic;                       // ȫ��ͼƬ�ļ�·��
    DH_MSG_OBJECT				stuObject;                              // Ŀ������������Ϣ
    DH_PIC_INFO_EX				stObjectPic;                            // Ŀ�������ļ�·��
    int							nCandidateNum;                          // ��ǰ����ƥ�䵽�ĺ�ѡ��������
    CANDIDATE_INFO				stuCandidates[DH_MAX_CANDIDATE_NUM];    // ��ǰ����ƥ�䵽�ĺ�ѡ������Ϣ
    NET_CANDIDAT_PIC_PATHS		stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // ��ǰ����ƥ�䵽�ĺ�ѡ����ͼƬ�ļ�·��
    NET_TIME					stTime;                                 // ��������ʱ��  
    char						szAddress[MAX_PATH];                    // ���������ص�
    int							nChannelId;                             // ͨ����   
}MEDIAFILE_FACERECOGNITION_INFO;

typedef enum __EM_FACEPIC_TYPE
{
    NET_FACEPIC_TYPE_UNKOWN,            // δ֪����
    NET_FACEPIC_TYPE_GLOBAL_SENCE,      // ����ȫ����ͼ
    NET_FACEPIC_TYPE_SMALL,             // ����Сͼ
}EM_FACEPIC_TYPE;

// ��������������۾���������
typedef enum tagEM_FACEDETECT_GLASSES_TYPE
{
    EM_FACEDETECT_GLASSES_UNKNOWN,      // δ֪
    EM_FACEDETECT_WITH_GLASSES,         // ���۾�
    EM_FACEDETECT_WITHOUT_GLASSES,      // �����۾�
}EM_FACEDETECT_GLASSES_TYPE;

#define  NET_MAX_FRAMESEQUENCE_NUM     2
#define  NET_MAX_TIMESTAMP_NUM         2

typedef struct __MEDIAFILE_FACE_DETECTION_DETAIL_PARAM
{
    DWORD               dwSize;
    DWORD               dwObjectId;                     // ����ID
    DWORD               dwFrameSequence;                // ֡���
    NET_TIME_EX         stTime;                         // ����ʱ��
}MEDIAFILE_FACE_DETECTION_DETAIL_PARAM;
 
// DH_FILE_QUERY_FACE_DETECTION ��Ӧ������ʶ������ѯ����
typedef struct __MEDIAFILE_FACE_DETECTION_PARAM
{
    DWORD               dwSize;                         // �ṹ���С
    
    // ��ѯ��������
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    EM_FACEPIC_TYPE     emPicType;                      // ͼƬ����,��� EM_FACEPIC_TYPE
    BOOL                bDetailEnable;                  // �Ƿ�����ϸ��Ϣ
    MEDIAFILE_FACE_DETECTION_DETAIL_PARAM stuDetail;    // ������ϸ��Ϣ
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;             // �Ա�����
    BOOL                bAgeEnable;                     // �Ƿ�ָ�������
    int                 nAgeRange[2];                   // ���䷶Χ
    int                 nEmotionValidNum;               // ��������������Ч����,�� emFeature ���ʹ��, ���Ϊ0���ʾ��ѯ���б���
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion[DH_MAX_FACEDETECT_FEATURE_NUM];   // ������������,�� byFeatureValidNum ���ʹ��
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;              // ����۾�
}MEDIAFILE_FACE_DETECTION_PARAM;

// DH_FILE_QUERY_FACE_DETECTION��Ӧ������ʶ�����FINDNEXT��ѯ���ز���
typedef struct __MEDIAFILE_FACE_DETECTION_INFO
{
    DWORD               dwSize;                                     // �ṹ���С

    unsigned int        ch;                                         // ͨ����
    char                szFilePath[128];                            // �ļ�·��
    unsigned int        size;                                       // �ļ�����
    NET_TIME            starttime;                                  // ��ʼʱ��
    NET_TIME            endtime;                                    // ����ʱ��
    unsigned int        nWorkDirSN;                                 // ����Ŀ¼���                                    
    BYTE                nFileType;                                  // �ļ�����  1��jpgͼƬ
    BYTE                bHint;                                      // �ļ���λ����
    BYTE                bDriveNo;                                   // ���̺�
    BYTE                byPictureType;                              // ͼƬ����, 0-��ͨ, 1-�ϳ�, 2-��ͼ
    unsigned int        nCluster;                                   // �غ�
    
    EM_FACEPIC_TYPE     emPicType;                                  // ͼƬ����,���EM_FACE_PIC_TYPE
    DWORD               dwObjectId;                                 // ����ID
    DWORD               dwFrameSequence[NET_MAX_FRAMESEQUENCE_NUM]; // ֡���,������2��Ԫ��ʱ,��һ����ʾСͼ,�ڶ�����ʾ��ͼ
    int                 nFrameSequenceNum;                          // ֡��Ÿ��� 
    NET_TIME_EX         stTimes[NET_MAX_TIMESTAMP_NUM];             // ����ʱ��,������2��Ԫ��ʱ,��һ����ʾСͼ,�ڶ�����ʾ��ͼ
    int                 nTimeStampNum;
    int                 nPicIndex;                                  // ��ʾ�ڴ��е�ͼƬ���
                                                                    // ����ͬһ�����д������ͼƬ,�ṩ������ʽ��λͼƬ
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // �Ա�����
    int                 nAge;                                       // ����
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;              // ��������
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;                          // ����۾�
}MEDIAFILE_FACE_DETECTION_INFO;

// �������¼�����
typedef enum tagNET_CROSSREGION_ACTION_INFO
{
    EM_CROSSREGION_ACTION_UNKNOW = 0    , 
    EM_CROSSREGION_ACTION_INSIDE        ,   //��������
    EM_CROSSREGION_ACTION_CROSS         ,   //��Խ����
    EM_CROSSREGION_ACTION_APPEAR        ,   //����
    EM_CROSSREGION_ACTION_DISAPPEAR     ,   //��ʧ
}NET_CROSSREGION_ACTION_INFO;

// DH_FILE_QUERY_IVS_EVENT ��Ӧ�������¼���ѯ����
typedef struct __MEDIAFILE_IVS_EVENT_PARAM
{
    DWORD               dwSize;                         // �ṹ���С
    // ��ѯ��������
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    int                 nMediaType;                     // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�

    int                 nVideoStream;                    // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // �¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;                     // �¼�����
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־, �����ñ�־��ʾ��ѯ�����ļ�
    int                 nFalgCount;                      // ��־����
    
    int                 nRuleType;                      // ���ܷ����¼���, �¼�����,���"���ܷ����¼�����"
    NET_CROSSREGION_ACTION_INFO emAction;               // �¼�����
}MEDIAFILE_IVS_EVENT_PARAM;

// DH_FILE_QUERY_IVS_EVENT ��ѯ������media�ļ���Ϣ 
typedef struct __MEDIAFILE_IVS_EVENT_INFO
{
    DWORD               dwSize;                          // �ṹ���С
    int                 nChannelID;                      // ͨ����
    NET_TIME            stuStartTime;                    // ��ʼʱ��
    NET_TIME            stuEndTime;                      // ����ʱ��
    char                szFilePath[128];                 // �ļ�·��
    int                 nMediaType;                      // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    unsigned int        nFileLength;                     // �ļ�����
    unsigned int        nCluster;                        // �غ�
    unsigned int        nHint;                           // �ļ���λ����
    unsigned int        nDriveNo;                        // ���̺�       

    int                 nVideoStream;                    // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // �¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;                     // �¼�����
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־, �����ñ�־��ʾ��ѯ�����ļ�
    int                 nFalgCount;                      // ��־����

    int                 nRuleType;                       // ���ܷ����¼���, �¼�����,���"���ܷ����¼�����"
    NET_CROSSREGION_ACTION_INFO emAction;                // �¼�����
}MEDIAFILE_IVS_EVENT_INFO;

// ��Ƶ����֧�ֵĶ�������
typedef enum tagEM_ANALYSE_OBJECT_TYPE
{
    EM_ANALYSE_OBJECT_TYPE_UNKNOWN,           // δ֪��
    EM_ANALYSE_OBJECT_TYPE_HUMAN,             // ��       
    EM_ANALYSE_OBJECT_TYPE_VEHICLE,           // ����
    EM_ANALYSE_OBJECT_TYPE_FIRE,              // ��
    EM_ANALYSE_OBJECT_TYPE_SMOKE,             // ����
    EM_ANALYSE_OBJECT_TYPE_PLATE,             // Ƭ״����             
    EM_ANALYSE_OBJECT_TYPE_HUMANFACE,         // ����
    EM_ANALYSE_OBJECT_TYPE_CONTAINER,         // ����
    EM_ANALYSE_OBJECT_TYPE_ANIMAL,            // ����
    EM_ANALYSE_OBJECT_TYPE_TRAFFICLIGHT,      // ���̵�
    EM_ANALYSE_OBJECT_TYPE_PASTEPAPER,        // ��ֽ ��Ƭ
    EM_ANALYSE_OBJECT_TYPE_HUMANHEAD,         // �˵�ͷ��
    EM_ANALYSE_OBJECT_TYPE_ENTITY,            // ��ͨ����
}EM_ANALYSE_OBJECT_TYPE;

// DH_FILE_QUERY_ANALYSE_OBJECT ��Ӧ�����ܷ��������������
typedef struct __MEDIAFILE_ANALYSE_OBJECT_PARAM
{
    DWORD               dwSize;                         // �ṹ���С
    // ��ѯ��������
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    int                 nMediaType;                     // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�    
    int                 nVideoStream;                   // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3 
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // �¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;                    // �¼�����
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־, �����ñ�־��ʾ��ѯ�����ļ�
    int                 nFalgCount;                     // ��־����

    EM_ANALYSE_OBJECT_TYPE emObject;                    // ���ҵ���������
}MEDIAFILE_ANALYSE_OBJECT_PARAM;

// DH_FILE_QUERY_ANALYSE_OBJECT ��ѯ������media�ļ���Ϣ 
typedef struct __MEDIAFILE_ANALYSE_OBJECT_INFO
{
    DWORD               dwSize;                          // �ṹ���С
    int                 nChannelID;                      // ͨ����
    NET_TIME            stuStartTime;                    // ��ʼʱ��
    NET_TIME            stuEndTime;                      // ����ʱ��
    char                szFilePath[128];                 // �ļ�·��
    int                 nMediaType;                      // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    unsigned int        nFileLength;                     // �ļ�����
    unsigned int        nCluster;                        // �غ�
    unsigned int        nHint;                           // �ļ���λ����
    unsigned int        nDriveNo;                        // ���̺� 

    int                 nVideoStream;                    // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // �¼������б�,�μ����ܷ����¼�����
    int                 nEventCount;                     // �¼�����
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // ¼���ץͼ�ļ���־, �����ñ�־��ʾ��ѯ�����ļ�
    int                 nFalgCount;                      // ��־����

    EM_ANALYSE_OBJECT_TYPE emObject;                     // ���ҵ���������
}MEDIAFILE_ANALYSE_OBJECT_INFO;

// DH_FILE_QUERY_MPT_RECORD_FILE ��Ӧ��¼���ļ���ѯ����
typedef struct __MEDIAFILE_MPT_RECORD_FILE_PARAM
{
    DWORD               dwSize;                                 // �ṹ���С
    // ��ѯ��������
    int                 nChannelID;                             // ͨ����
    NET_TIME            stuStartTime;                           // ��ʼʱ��
    NET_TIME            stuEndTime;                             // ����ʱ��
    int                 nMediaType;                             // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    int                 nVideoStream;                           // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3

    char                szPoliceID[DH_COMMON_STRING_32];        // ��ԱID,Ϊ��ʱ��ʾ���ֶ���Ч
    int                 nCrimeType;                             // ��������,ֵΪ0��ʾ���ֶ���Ч
    int                 nCrimeTag;                              // ������,ֵΪ0��ʾ���ֶ���Ч
    char                szSerialNumber[DH_COMMON_STRING_32];    // MPT�豸���к�,Ϊ��ʱ��ʾ���ֶ���Ч    
}MEDIAFILE_MPT_RECORD_FILE_PARAM;

// DH_FILE_QUERY_MPT_RECORD_FILE ��ѯ������media�ļ���Ϣ 
typedef struct __MEDIAFILE_MPT_RECORD_FILE_INFO
{
    DWORD               dwSize;                          // �ṹ���С
    int                 nChannelID;                      // ͨ����
    NET_TIME            stuStartTime;                    // ��ʼʱ��
    NET_TIME            stuEndTime;                      // ����ʱ��
    char                szFilePath[DH_COMMON_STRING_128];// �ļ�·��
    int                 nMediaType;                      // �ļ�����,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    int                 nVideoStream;                    // ��Ƶ���� 0-δ֪ 1-������ 2-������1 3-������2 4-������3
    unsigned int        nFileLength;                     // �ļ�����
    unsigned int        nCluster;                        // �غ�
    unsigned int        nHint;                           // �ļ���λ����
    unsigned int        nDriveNo;                        // ���̺� 

    int                 nCrimeType;                      // ��������
    int                 nCrimeTag;                       // ������
    char                szComment[DH_COMMON_STRING_256]; // �û����ļ����ı�ע
}MEDIAFILE_MPT_RECORD_FILE_INFO;

// ��ƵŨ������ļ���ѯ����
typedef struct __MEDIA_QUERY_VIDEOSYNOPSIS_PARAM
{
    DWORD               dwSize;
    NET_TIME            StartTime;                          // ��ʼʱ��    
    NET_TIME            EndTime;                            // ����ʱ��
    int                 nMediaType;                         // �ļ�����,0:��ѯ��������,1:ͼƬ,2:¼��
    int                 nQueryType;                         // ��ѯ����,1:ԭʼ��Ƶ�ļ� 2:Ũ�������Ƶ�ļ�
}MEDIA_QUERY_VIDEOSYNOPSIS_PARAM;

typedef struct __MEDIAFILE_VIDEOSYNOPSIS_INFO
{
    char                szFilePath[128];                    // �ļ�·��
    unsigned int        size;                               // �ļ�����
    NET_TIME            starttime;                          // ��ʼʱ��
    NET_TIME            endtime;                            // ����ʱ��
    unsigned int        nWorkDirSN;                         // ����Ŀ¼���                                    
    BYTE                nFileType;                          // �ļ�����  1��jpgͼƬ
    BYTE                bHint;                              // �ļ���λ����
    BYTE                bDriveNo;                           // ���̺�
    BYTE                bReserved2;
    unsigned int        nCluster;                           // �غ�
    BYTE                byPictureType;                      // ͼƬ����, 0-��ͨ, 1-�ϳ�, 2-��ͼ
    BYTE                bReserved[3];                       // �����ֶ�

    // ��ƵԴ�ļ������Ϣ
    int                 nTaskID;                            // ����ID
    char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // ��ƵŨ��״̬
    int                 nProgress;                          // ��ӦŨ��״̬
    int                 nObjectNum;                         // Ũ���õ����������

    // Ũ�������Ƶ�ļ������Ϣ
    int                 nDurationTime;                      // ����ʱ��,��λs
}MEDIAFILE_VIDEOSYNOPSIS_INFO;

// �ṹ��(NET_IN_SNAPSHOT)��Ա ���صƵ��ڿ���     ��һ������,ÿ��Ԫ�ض�Ӧһ�����������
typedef struct __NET_FLASHCONTROL
{
    DWORD               dwSize;                             // �˽ṹ���С
    int                 nMode;                              // ����ģʽ    0-��ֹ����,1-ʼ������,2-�Զ�����
}NET_FLASHCONTROL;

// ץ�Ŀͻ�������
typedef enum tagSNAP_CLIENT_TYPE
{
    SNAP_CLIENT_TYPE_COMMON,                // ��Ӧ"Common"����, Ĭ������
    SNAP_CLIENT_TYPE_PARKINGSPACE,          // ��Ӧ"ParkingSpace"����, ͣ����
}SNAP_CLIENT_TYPE;

#define DH_MAX_USER_DEFINE_INFO        1024

// nTriggerType==2ʱ �ͻ��˴���ץ�Ĳ���
typedef struct _NET_CLIENT_SNAP_INFO
{
    DWORD               dwSize;                                         // �˽ṹ���С
    unsigned int        nFrameSequence;                                 // ֡���
    double              PTS;                                            // ʱ���,64λ����ʱ���
    char                szUserDefinedInfo[DH_MAX_USER_DEFINE_INFO];     // �ַ���,�ͻ����Զ���,"\0"��β
    SNAP_CLIENT_TYPE    emSNAP_CLIENT_TYPE;                             // �ͻ�������
    DWORD               dwRetCardNumber;                                // ��Ƭ����
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];             // ��Ƭ��Ϣ     
}NET_CLIENT_SNAP_INFO;

// �ӿ�(CLIENT_TrafficSnapByNetwork)�������
typedef struct __NET_IN_SNAPSHOT
{
    DWORD                   dwSize;                     // �˽ṹ���С
    int                     nTriggerType;               // ��������    0-δ֪    1-�������紥�� 2-�ͻ��˴�������ʱֻ��Ҫ��дstClientInfo������
    int                     nLaneID;                    // ������
    int                     nGroupID;                   // �����
    int                     nGrabTimes;                 // ץ��ͼƬ����
    int                     nStartPicNum;               // ��һ��ͼƬ��ʼ���
    int                     nDirection;                 // �������򣨳������ķ���    0-�� 1-���� 2-�� 3-���� 4-�� 5-���� 6-�� 7-���� 8-δ֪
    //NET_GRAB_WAITTIME     stGrabWaitTime;             // ����ͼƬ֮��ץ�ļ��
    int                     nGrabWaitTime;              // pGrabWaitTime�����Ա����
    DWORD*                  pGrabWaitTime;              // ����ͼƬ֮��ץ�ļ��,���û������ڴ棬��СΪnGrabWaitTime
    int                     nLowerSpeedLimit;           // �ٶ�����,��λkm/h
    int                     nUpperSpeedLimit;           // �ٶ�����,��λkm/h
    int                     nSpeed;                     // ����,��λkm/h
    int                     nViolationNo;               // Υ�����    0-δΥ��
                                                        // 1-������
                                                        // 2-���ٲ�����50% 
                                                        // 3-������50%��100%֮��
                                                        // 4-���ٳ���100%
                                                        // 5-����
                                                        // 6-�����
                                                        // 7-��������
                                                        // 8-����,����������ʻ
    int                     nRedLightTime;              // ���ʱ��,����Ƶ�������ʱ��󴥷�ץ��,��λ��
    //NET_FLASHCONTROL      stFlashControl;             // ���صƵ��ڿ���
    int                     nFlashControl;              // pFlashControl�������
    NET_FLASHCONTROL*       pFlashControl;              // ���صƵ��ڿ���,���û������ڴ棬��СΪsizeof(NET_FLASHCONTROL)*nFlashControl
    DWORD                   dwUser;                     // �û����� NSP
    NET_CLIENT_SNAP_INFO    stClientInfo;               // �ͻ��˴���ʱ�����ץ�Ĳ���
}NET_IN_SNAPSHOT;

// �ӿ�(CLIENT_TrafficSnapByNetwork)�������
typedef struct __NET_OUT_SNAPSHOT
{
    DWORD                dwSize;                    // �˽ṹ���С
}NET_OUT_SNAPSHOT;

// �ӿ�(CLIENT_TrafficForceLightState)�������
typedef struct __NET_IN_FORCELIGHTSTATE
{
    DWORD               dwSize;                     // �˽ṹ���С
    unsigned int        nDirection;                 // ��λ��ʾ��0λ��"Straight",1λ��"TurnLeft",2λ��"TurnRight",3λ��"U-Turn"
}NET_IN_FORCELIGHTSTATE;

// �ӿ�(CLIENT_TrafficForceLightState)�������
typedef struct __NET_OUT_FORCELIGHTSTATE
{
    DWORD                dwSize;                    // �˽ṹ���С
}NET_OUT_FORCELIGHTSTATE;

// �ӿ�(CLIENT_StartTrafficFluxStat)�ص�
typedef int  (CALLBACK *fFluxStatDataCallBack)(LLONG lFluxStatHandle, DWORD dwEventType, void* pEventInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// �ӿ�(CLIENT_StartTrafficFluxStat)�������
typedef struct __NET_IN_TRAFFICFLUXSTAT
{
    DWORD                   dwSize;                 // �˽ṹ���С
    fFluxStatDataCallBack   cbData;                 // �ص�����ָ��
    LDWORD                  dwUser;                 // �û�����
}NET_IN_TRAFFICFLUXSTAT;

// �ӿ�(CLIENT_StartTrafficFluxStat)�������
typedef struct __NET_OUT_TRAFFICFLUXSTAT
{
    DWORD                dwSize;                    // �˽ṹ���С    
}NET_OUT_TRAFFICFLUXSTAT;

// �ӿ�(CLIENT_StartFindFluxStat)�������
typedef struct __NET_IN_TRAFFICSTARTFINDSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    NET_TIME            stStartTime;                // ��ʼʱ�� ��ʱ��ȷ��Сʱ
    NET_TIME            stEndTime;                  // ����ʱ�� ��ʱ��ȷ��Сʱ
    int                 nWaittime;                  // �ȴ��������ݵĳ�ʱʱ��
}NET_IN_TRAFFICSTARTFINDSTAT;

// �ӿ�(CLIENT_StartFindFluxStat)�������
typedef struct __NET_OUT_TRAFFICSTARTFINDSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    DWORD               dwTotalCount;               // ���ϴ˴β�ѯ�����Ľ��������                 
}NET_OUT_TRAFFICSTARTFINDSTAT;

// �ӿ�(CLIENT_DoFindFluxStat)�������
typedef struct __NET_IN_TRAFFICDOFINDSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    unsigned int        nCount;                     // ÿ�β�ѯ������ͳ������
    int                 nWaittime;                  // �ȴ��������ݵĳ�ʱʱ��
}NET_IN_TRAFFICDOFINDSTAT;

typedef struct
{
    DWORD               dwSize;                     // �˽ṹ���С
    int                 nStatInfo;                  // ͳ����Ϣ����
    DH_TRAFFICFLOWSTAT  *pStatInfo;                 // ͳ����Ϣָ��,���û������ڴ棬��СΪsizeof(DH_TRAFFICFLOWSTAT)*nStatInfo
}DH_TRAFFICFLOWSTAT_OUT;

// �ӿ�(CLIENT_DoFindFluxStat)�������
typedef struct __NET_OUT_TRAFFICDOFINDSTAT
{
    DWORD                   dwSize;                 // �˽ṹ���С
    DH_TRAFFICFLOWSTAT_OUT  stStatInfo;             // ͳ����Ϣָ��
}NET_OUT_TRAFFICDOFINDSTAT;

// �ӿ�(CLIENT_StartFindNumberStat)�������
typedef struct __NET_IN_FINDNUMBERSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    int                 nChannelID;                 // Ҫ���в�ѯ��ͨ����
    NET_TIME            stStartTime;                // ��ʼʱ�� ��ʱ��ȷ��Сʱ
    NET_TIME            stEndTime;                  // ����ʱ�� ��ʱ��ȷ��Сʱ
    int                 nGranularityType;           // ��ѯ����0:����,1:Сʱ,2:��,3:��,4:��,5:��,6:��
    int                 nWaittime;                  // �ȴ��������ݵĳ�ʱʱ��
    UINT                nPlanID;                    // �ƻ�ID,�������Ч,��1��ʼ
}NET_IN_FINDNUMBERSTAT;

// �ӿ�(CLIENT_StartFindNumberStat)�������
typedef struct __NET_OUT_FINDNUMBERSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    DWORD               dwTotalCount;               // ���ϴ˴β�ѯ�����Ľ��������
}NET_OUT_FINDNUMBERSTAT;

// �ӿ�(CLIENT_DoFindNumberStat)�������
typedef struct __NET_IN_DOFINDNUMBERSTAT
{
    DWORD               dwSize;                     // �˽ṹ���С
    unsigned int        nBeginNumber;               // [0, totalCount-1], ��ѯ��ʼ���,��ʾ��beginNumber����¼��ʼ,ȡcount����¼����; 
    unsigned int        nCount;                     // ÿ�β�ѯ������ͳ������
    int                 nWaittime;                  // �ȴ��������ݵĳ�ʱʱ��            
}NET_IN_DOFINDNUMBERSTAT;

typedef struct __DH_NUMBERSTAT
{
    DWORD    dwSize;
    int      nChannelID;                           //ͳ��ͨ����
    char     szRuleName[DH_CHAN_NAME_LEN];         //��������
    NET_TIME stuStartTime;                         //��ʼʱ��
    NET_TIME stuEndTime;                           //����ʱ��
    int      nEnteredSubTotal;                     //��������С��
    int      nExitedSubtotal;                      //��ȥ����С��
    int      nAvgInside;                           //ƽ����������(��ȥ��ֵ)
    int      nMaxInside;                           //���������
    int      nEnteredWithHelmet;                   //����ȫñ��������С��
    int      nEnteredWithoutHelmet;                //������ȫñ��������С��
    int      nExitedWithHelmet;                    //����ȫñ��ȥ����С��
    int      nExitedWithoutHelmet;                 //������ȫñ��ȥ����С��
}DH_NUMBERSTAT;

// �ӿ�(CLIENT_DoFindNumberStat)�������
typedef struct __NET_OUT_DOFINDNUMBERSTAT
{
    DWORD               dwSize;                          // �˽ṹ���С
    int                 nCount;                          // ��ѯ��������ͳ����Ϣ����
    DH_NUMBERSTAT       *pstuNumberStat;                 // ��������ͳ����Ϣ����
														 // ���û������ڴ棬��СΪnBufferLen
    int                 nBufferLen;                      // �û�������ڴ��С,��DH_NUMBERSTAT�е�dwsize��СΪ��λ
}NET_OUT_DOFINDNUMBERSTAT;

// ��Ƶͳ��С����Ϣ
typedef struct tagNET_VIDEOSTAT_SUBTOTAL 
{
    int                 nTotal;                         // �豸���к�����ͳ������
    int                 nHour;                          // Сʱ�ڵ�������
    int                 nToday;                         // �����������, �����ֶ����
    int                 nOSD;                           // ͳ������, ����OSD��ʾ, ���ֶ����
    char                reserved[252];
} NET_VIDEOSTAT_SUBTOTAL;

// ��Ƶͳ��ժҪ��Ϣ
typedef struct tagNET_VIDEOSTAT_SUMMARY
{
    int                     nChannelID;                 // ͨ����
    char                    szRuleName[32];             // ��������
    NET_TIME_EX             stuTime;                    // ͳ��ʱ��
    NET_VIDEOSTAT_SUBTOTAL  stuEnteredSubtotal;         // ����С��
    NET_VIDEOSTAT_SUBTOTAL  stuExitedSubtotal;          // ��ȥС��
    char                    reserved[512];
} NET_VIDEOSTAT_SUMMARY;

// ��Ƶͳ��ժҪ��Ϣ�ص�����ԭ�Σ�lAttachHandle �� CLIENT_AttachVideoStatSummary ����ֵ
typedef void (CALLBACK *fVideoStatSumCallBack) (LLONG lAttachHandle, NET_VIDEOSTAT_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachVideoStatSummary ���
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
    int                     nChannel;                    // ��Ƶͨ����         
    fVideoStatSumCallBack   cbVideoStatSum;              // ��Ƶͳ��ժҪ��Ϣ�ص�
    LDWORD                  dwUser;                      // �û�����                   
} NET_IN_ATTACH_VIDEOSTAT_SUM;

// CLIENT_AttachVideoStatSummary ����
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_VIDEOSTAT_SUM;

//// ���ܽ�ͨ��������ؽӿڲ���

// �ӿ� CLIENT_GetParkingSpaceStatus ���������
typedef struct tagNET_IN_GET_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    int                  nChannelID;                     // ͨ����
    int *                pLaneID;                        // ȡֵ��Χ[0,255], pLaneID==NULL��ʾ���г�λ,��λ�����ͬDH_PRODUCTION_DEFNITION.nMaxRoadWays
    int                  nLaneCount;                     // ������ڴ�Ϊsizeof(int)*nLaneCount
} NET_IN_GET_PARKINGSPACE_STATUS;

typedef struct tagNET_LANE_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nLaneID;                        // ��λ��
    unsigned int         nPictureId;                     // ͼƬID,���ڻ�ȡͼƬ����
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;      // ��ͨ������Ϣ
} NET_LANE_PARKINGSPACE_STATUS;

// �ӿ� CLIENT_GetParkingSpaceStatus ���������
typedef struct tagNET_OUT_GET_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    NET_LANE_PARKINGSPACE_STATUS* pStatus;               // ���صĳ�λ״̬,���û������ڴ�
    int                  nMaxStatus;                     // ��Ҫ����������ڴ�Ϊsizeof(NET_LANE_PARKINGSPACE_STATUS)*nMaxStatus,��nMaxStatus == DH_PRODUCTION_DEFNITION.nMaxRoadWays
    int                  nRetStatus;                     // ʵ�ʷ��صĳ�λ״̬��
} NET_OUT_GET_PARKINGSPACE_STATUS;

// �ӿ� CLIENT_AttachParkingSpaceData ���������
typedef struct tagNET_CB_PARKINGSPACE_DATA
{
    DWORD                dwSize;                         // �˽ṹ���С
    void*                pPicBuffer;                     // ͼƬ����������,���û������ڴ棬��СΪsizeof(unsigned int)*nPicLength
    unsigned int         nPicLength;                     // ͼƬ�ܳ���
} NET_CB_PARKINGSPACE_DATA;

// �ӿ� CLIENT_AttachParkingSpaceData �ص�����,pBuf��json��ͼƬ����,nBufLen��pBuf��Ӧ����,����ת������
typedef int (CALLBACK *fNotifySnapData)(LLONG lParkingHandle, NET_CB_PARKINGSPACE_DATA* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// �ӿ� CLIENT_AttachParkingSpaceData ���������
typedef struct tagNET_IN_ATTACH_PARKINGSPACE
{
    DWORD                dwSize;                         // �˽ṹ���С
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    int                  nChannelID;                     // ͨ����
    unsigned int         nPictureId;                     // ͼƬID,��NET_LANE_PARKINGSPACE_STATUS.nPictureId
    
    fNotifySnapData      cbNotifySnapData;               // �ص�����
    LDWORD               dwUser;                         // �û��Զ������
} NET_IN_ATTACH_PARKINGSPACE;

// ָ����Ϣ
typedef struct tagNET_CB_FINGERPRINT_INFO
{
	UINT 		nIndex;                                     // ָ�������ţ�������Сָ���ε�����СָΪ0��9 
	char        szFingerprintData[DH_COMMON_STRING_2048];   // ָ�����ݣ�����Base64����ַ���              
	BYTE        bReserved[256];                             // �����ֶ�
}NET_CB_FINGERPRINT_INFO;

// �ص�������������Ϣ
typedef struct tagNET_CB_PERSON_INFO
{
    UINT                 nSID;                           // ����������ID��
	UINT 	             nPicLength;                     // �ɼ�����ԱͼƬ����
	char                 szUserID[DH_MAX_USERID_LEN];    // �û�ID
	UINT                 nRetFaceDataNum;                // ���ص�����ģ�����ݸ���
    char                 szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];  // ��������
    char                 szPassword[DH_COMMON_STRING_64];//������
    char                 szCardNo[DH_MAX_CARDNO_LEN];    // ����
    char                 szCardName[DH_COMMON_STRING_32];//������
    UINT                 nFingerPrintNum;                // ����ָ�Ƹ���
    NET_CB_FINGERPRINT_INFO stuFingerPrintInfo[MAX_FINGERPRINT_NUM];//ָ����Ϣ
	BYTE                 bReserved[2048];                // �����ֶ�
}NET_CB_PERSON_INFO;

// ������Ϣ�ɼ��ص�����
typedef int (CALLBACK *fNotifyPersonInfo)(LLONG lLoginID, LLONG lPersonHandle, NET_CB_PERSON_INFO *pstuPersonInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, void *reserved);

// CLIENT_AttachPersonInfoCollect ���
typedef struct tagNET_IN_ATTACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                         // �ṹ���С
	DWORD               dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
	fNotifyPersonInfo   cbNotifyPersonInfo;             // �ص�����
	LDWORD              dwUser;                         // �û��Զ������
}NET_IN_ATTACH_PERSONINFOCOLLECT;

//CLIENT_AttachPersonInfoCollect ����
typedef struct tagNET_OUT_ATTACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                         // �ṹ���С
}NET_OUT_ATTACH_PERSONINFOCOLLECT;

// CLIENT_DetachPersonInfoColloect ���
typedef struct tagNET_IN_DETACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                        //�ṹ���С
	DWORD               dwWaitTime;                    // �ӿڳ�ʱ�ȴ�ʱ��
	LLONG               lPersonHandle;                 // CLIENT_AttachPersonInfoCollect ���صľ��
}NET_IN_DETACH_PERSONINFOCOLLECT;

//CLIENT_DetachPersonInfoColloect ����
typedef struct tagNET_OUT_DETACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                        // �ṹ���С
}NET_OUT_DETACH_PERSONINFOCOLLECT;

/******************************************************************************
��������	:	����������Ϣ�ɼ�
�������	:	
	lLoginID: ��½�ӿڷ��ؾ��
	pstuInParam:����������������ص���������Ϣ
�������	��pstuOutParam:�����������
�� �� ֵ	��	LLONG ���ض��ľ��������detach����
����˵��	��
******************************************************************************/
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPersonInfoCollect(LLONG lLoginID, NET_IN_ATTACH_PERSONINFOCOLLECT *pstuInParam, NET_OUT_ATTACH_PERSONINFOCOLLECT *pstuOutParam);

/******************************************************************************
��������	:	ȡ������������Ϣ�ɼ�
�������	:	
	lLoginID: ��½�ӿڷ��ؾ��
	pstuInParam: ȡ�������������������lPersonHandleΪCLIENT_AttachPersonInfoCollect���صľ��
�������	��pstuOutParam:ȡ�������������
�� �� ֵ	��	TRUE �ɹ�FALSE ʧ��
����˵��	��
******************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPersonInfoColloect(NET_IN_DETACH_PERSONINFOCOLLECT* pstuInParam, NET_OUT_DETACH_PERSONINFOCOLLECT* pstuOutParam);

//NET_CAR_PASS_INFOS ���ö������
typedef enum tagNET_CAR_SIZE
{
    CAR_SIZE_UNKNOWN  = 0 ,     //δ֪
    CAR_SIZE_SAMLL        ,     //С��
    CAR_SIZE_BIG          ,     //��
}NET_CAR_SIZE;

typedef enum tagNET_CAR_ACTION
{
    CAR_ACTION_UNKNOWN = 0 , 
    CAR_ACTION_ENTER       ,  //����������
    CAR_ACTION_LEAVE       ,  //�뿪�������
}NET_CAR_ACTION;


//CLIENT_AttachCarPassInfo �ص��������صĹ�����Ϣ�ṹ��
typedef struct tagNET_CAR_PASS_INFO
{
     DWORD                dwSize; 
       
     DWORD                nID;                              // ��������ID
     DWORD                nLaneNumber;                      // ��0��ʼ,��������3������,�򳵵��ŷֱ�Ϊ0 1 2
     DWORD                nRoadwayNumber;                   // �Զ��峵����,�û����õĳ�����,Ŀǰȡֵ��ΧΪ1-16
     DWORD                nSpeed;                           // ����,��λ(km/h)
     NET_CAR_SIZE         emCarSize;                        // ������С����
     NET_CAR_ACTION       emCarAction;                      // ������������
     NET_TIME_EX          stuTime;                          // ����������ʱ��,��ȷ������
}NET_CAR_PASS_INFO;

// �ӿ� CLIENT_AttachCarPassInfo �ص�����
// nInfoNum ������Ϣ��
// pstuCarPassInfos ������Ϣ����
typedef int (CALLBACK *fNotifyCarPassInfo)(LLONG lCarPassHandle, NET_CAR_PASS_INFO* pstuCarPassInfos,  int nInfoNum ,   LDWORD dwUser);

//�ӿ� CLIENT_AttachCarPassInfo ���������
typedef struct tagNET_IN_ATTACH_CAR_PASS_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С,���븳ֵ
    int                  nChannelID;                     // ͨ����

    fNotifyCarPassInfo   cbNotifyCarPassInfo;            // �ص�����,�й�����Ϣʱ,�ص����ϲ�
    LDWORD               dwUser;                         // �û��Զ������
}NET_IN_ATTACH_CAR_PASS_INFO;

//�ӿ� CLIENT_AttachCarPassInfo ���������
typedef struct tagNET_OUT_ATTACH_CAR_PASS_INFO
{
    DWORD       dwSize;         //�˽ṹ���С,���븳ֵ
}NET_OUT_ATTACH_CAR_PASS_INFO;

// �ӿ� CLIENT_AttachParkingSpaceData ���������
typedef struct tagNET_OUT_ATTACH_PARKINGSPACE
{
    DWORD                dwSize;                         // �˽ṹ���С
} NET_OUT_ATTACH_PARKINGSPACE;

// �ӿ� CLIENT_DetachParkingSpaceData ���������
typedef struct tagNET_IN_DETACH_PARKINGSPACE
{
    DWORD                dwSize;                         // �˽ṹ���С
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    LLONG                lParkingHandle;                 // CLIENT_AttachParkingSpaceData���صľ��
} NET_IN_DETACH_PARKINGSPACE;
// �ӿ� CLIENT_DetachParkingSpaceData ���������
typedef struct tagNET_OUT_DETACH_PARKINGSPACE
{
    DWORD                dwSize;                         // �˽ṹ���С
} NET_OUT_DETACH_PARKINGSPACE;

// �ļ���������

// ���ؽ��Ȼص�����ԭ��, nError��ʾ�����ع��̳��ֵĴ���,1-���治��,2-�Է������ݵ�У�����,3-���ص�ǰ�ļ�ʧ��,4-������Ӧ�����ļ�ʧ��
// ���ļ�����ʱ,IDΪ�û����õ�dwFileID,����������ʱ,IDΪ�û����õ�dwConditionID                    
typedef void (CALLBACK *fMultiFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

//�����ļ���ʽ
typedef enum tagEM_DOWNLOAD_FILE_TYPE
{
   EM_DOWNLOAD_BY_FILENAME = 0      ,       //���ļ�������
   EM_DOWNLOAD_BY_CONDITION         ,       //����������
}EM_DOWNLOAD_FILE_TYPE;

//����ʱ������
typedef enum tagEM_DOWNLOAD_TIME_TYPE
{
    EM_DOWNLOAD_TIME_SNAP = 0       ,         //ץ��ʱ��
    EM_DOWNLOAD_TIME_STORAGE        ,         //�洢ʱ��
}EM_DOWNLOAD_TIME_TYPE;

//������������
typedef enum tagEM_DOWNLOAD_DATA_TYPE
{
    EM_DOWNLOAD_DATA_RECORD = 0 ,               //¼��
    EM_DOWNLOAD_DATA_PICTURE ,                  //ͼƬ
}EM_DOWNLOAD_DATA_TYPE;

// CLIENT_DownLoadMultiFile �ӿڲ���
typedef struct tagNET_DOWNLOADFILE_INFO
{
    DWORD               dwSize;
    DWORD               dwFileID;                       // �ļ�ID, ���û��Լ�����
    int                 nFileSize;                      // ��ѯ�����ļ���С
    char                szSourceFilePath[MAX_PATH];     // ��ѯ�����ļ�·��
    char                szSavedFileName[MAX_PATH];      // �ļ�����·��
}NET_DOWNLOADFILE_INFO;

typedef struct tagNET_DOWNLOAD_CONDITION_INFO
{
    DWORD                   dwSize;
    DWORD                   dwConditionID;                  // ����ID, ���û��Լ�����
    int                     nChannel;                       // ͨ����
    NET_TIME                stuStartTime;                   // ��ʼʱ��
    NET_TIME                stuEndTime;                     // ����ʱ��
    EM_DOWNLOAD_TIME_TYPE   emTimeType;                     // ʱ������
    EM_DOWNLOAD_DATA_TYPE   emDataType;                     // �������� 
    char                    szSavedFileName[MAX_PATH];      // �ļ�����·��
}NET_DOWNLOAD_CONDITION_INFO;

typedef struct tagNET_IN_DOWNLOAD_MULTI_FILE
{
    DWORD                   dwSize;
    //���ļ�������
    int                             nFileCount;                 // �������ļ���,emDownloadTypeΪEM_DOWNLOAD_BY_FILENAME��Ч
    NET_DOWNLOADFILE_INFO*          pFileInfos;                 // �������ļ���Ϣ,emDownloadTypeΪEM_DOWNLOAD_BY_FILENAME��Ч
																// ���û������ڴ棬��СΪsizeof(NET_DOWNLOADFILE_INFO)*nFileCount
    fMultiFileDownLoadPosCB         cbPosCallBack;              // ���Ȼص�����
    LDWORD                          dwUserData;                 // �û�����
    EM_DOWNLOAD_FILE_TYPE           emDownloadType;             // ���ط�ʽ
    //����ѯ��������
    int                             nConditionCount;             // ����������,emDownloadTypeΪEM_DOWNLOAD_BY_CONDITION��Ч
    NET_DOWNLOAD_CONDITION_INFO*    pConditionInfos;             // ��������,emDownloadTypeΪEM_DOWNLOAD_BY_CONDITION��Ч    
															     // ���û������ڴ棬��СΪsizeof(NET_DOWNLOAD_CONDITION_INFO)*nConditionCount
}NET_IN_DOWNLOAD_MULTI_FILE;

typedef struct tagNET_OUT_DOWNLOAD_MULTI_FILE
{
    DWORD               dwSize;
    LLONG               lDownLoadHandle;                // ���ؾ��
}NET_OUT_DOWNLOAD_MULTI_FILE;

typedef struct __NET_VIDEOANALYSE_STATE
{
    DWORD            dwSize;
    DWORD            dwProgress;                        // ��������,0-100
    char             szState[DH_COMMON_STRING_64];      // ͨ��״̬,Running"������,"Stop"��ֹͣ,"NoStart"��δ��,"Failed"��ʧ��,"Successed"���ɹ�
    char             szFailedCode[DH_COMMON_STRING_64]; // ������
}NET_VIDEOANALYSE_STATE;

//��Ƶ��������״̬ʵʱ�ص�����
typedef int (CALLBACK *fVideoAnalyseState)(LLONG lAttachHandle, NET_VIDEOANALYSE_STATE* pAnalyseStateInfos, LDWORD dwUser, void* pReserved);

// CLIENT_AttachVideoAnalyseState�ӿ��������
typedef struct __NET_IN_ATTACH_VIDEOANALYSE_STATE 
{
    DWORD              dwSize;
    int                nChannleId;            // ͨ����
    fVideoAnalyseState cbVideoAnalyseState;   // ��Ƶ����״̬�ص�����
    LDWORD             dwUser;                // �û���Ϣ 
}NET_IN_ATTACH_VIDEOANALYSE_STATE;

// CLIENT_AttachVideoAnalyseState�ӿ��������
typedef struct __NET_OUT_ATTACH_VIDEOANALYSE_STATE 
{
    DWORD              dwSize;
    LLONG              lAttachHandle;         // �������Ⱦ��,Ψһ��ʶĳһͨ���ķ�������
}NET_OUT_ATTACH_VIDEOANALYSE_STATE;

// ����Խ�״̬
typedef enum tagEM_TALK_STATE
{
    EM_TALK_STATE_UNKNOWN,                 // δ֪
    EM_TALK_STATE_INVITING,                // ����
    EM_TALK_STATE_RINGING,                 // ����
    EM_TALK_STATE_ANSWER,                  // Ӧ��
    EM_TALK_STATE_REFUSE,                  // �ܾ�
    EM_TALK_STATE_HANGUP,                  // �Ҷ�
    EM_TALK_STATE_BUSYING,                 // æµ
    EM_TALK_STATE_CANCEL,                  // ȡ�����
} EM_TALK_STATE;

#define NET_CALL_NUM_MAX           128         // ���ͨ����������

// CLIENT_AttachTalkState �ص��������ص�����Խ�״̬
typedef struct tagNET_TALK_STATE
{
    DWORD                dwSize; 
    char                 szCallID[DH_COMMON_STRING_64];  // ���Ωһ��ʶ��
    int                  nAudioPort;                     // ��Ƶ�˿�
    int                  nVideoPort;                     // ��Ƶ�˿�
    char                 szMediaAddr[DH_MAX_IPADDR_LEN]; // ȡ����ַ
    EM_TALK_STATE        emState;                        // ״̬
    int                  nNumberCount;                   // ��к�����
    char                 szNumbers[NET_CALL_NUM_MAX][DH_COMMON_STRING_32]; // ��к����б�
} NET_TALK_STATE;

// �ӿ� CLIENT_AttachTalkState �Ļص�����
typedef void (CALLBACK *fNotifyTalkState)(LLONG lAttachHandle, NET_TALK_STATE* pstuState, int nLen, LDWORD dwUser);

// �ӿ� CLIENT_AttachTalkState ���������
typedef struct tagNET_IN_ATTACH_TALK_STATE
{
    DWORD                dwSize;                         // �˽ṹ���С,���븳ֵ
    int                  nChnId;                         // ͨ����,���ڱ�ʶ�Խ���Ԫ
    fNotifyTalkState     cbCallBack;                     // �ص�����,�жԽ�״̬ʱ,�ص����ϲ�
    LDWORD               dwUser;                         // �û��Զ������
}NET_IN_ATTACH_TALK_STATE;

// �ӿ� CLIENT_AttachTalkState ���������
typedef struct tagNET_OUT_ATTACH_TALK_STATE
{
    DWORD       dwSize;                                  // �˽ṹ���С,���븳ֵ
    char        szCallID[DH_COMMON_STRING_64];           // ���Ωһ��ʶ��
}NET_OUT_ATTACH_TALK_STATE;

///////////////////////////////// IVS ��������Ƶ���ģ�� /////////////////////////////////
// ��Ƶ����ϱ����������Ͷ���
#define NET_DIAGNOSIS_DITHER                    "VideoDitherDetection"                       // ��Ƶ������� ��Ӧ�ṹ��(NET_VIDEO_DITHER_DETECTIONRESULT)
#define NET_DIAGNOSIS_STRIATION                 "VideoStriationDetection"                    // ��Ƶ���Ƽ�� ��Ӧ�ṹ��(NET_VIDEO_STRIATION_DETECTIONRESULT)
#define NET_DIAGNOSIS_LOSS                      "VideoLossDetection"                         // ��Ƶ��ʧ��� ��Ӧ�ṹ��(NET_VIDEO_LOSS_DETECTIONRESULT)
#define NET_DIAGNOSIS_COVER                     "VideoCoverDetection"                        // ��Ƶ�ڵ���� ��Ӧ�ṹ��(NET_VIDEO_COVER_DETECTIONRESULT)
#define NET_DIAGNOSIS_FROZEN                    "VideoFrozenDetection"                       // ��Ƶ������ ��Ӧ�ṹ��(NET_VIDEO_FROZEN_DETECTIONRESULT)
#define NET_DIAGNOSIS_BRIGHTNESS                "VideoBrightnessDetection"                   // ��Ƶ�����쳣��� ��Ӧ�ṹ��(NET_VIDEO_BRIGHTNESS_DETECTIONRESULT)
#define NET_DIAGNOSIS_CONTRAST                  "VideoContrastDetection"                     // ��Ƶ�Աȶ��쳣��� ��Ӧ�ṹ��(NET_VIDEO_CONTRAST_DETECTIONRESULT)
#define NET_DIAGNOSIS_UNBALANCE                 "VideoUnbalanceDetection"                    // ��Ƶƫɫ��� ��Ӧ�ṹ��(NET_VIDEO_UNBALANCE_DETECTIONRESULT)
#define NET_DIAGNOSIS_NOISE                     "VideoNoiseDetection"                        // ��Ƶ������� ��Ӧ�ṹ��(NET_VIDEO_NOISE_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLUR                      "VideoBlurDetection"                         // ��Ƶģ����� ��Ӧ�ṹ��(NET_VIDEO_BLUR_DETECTIONRESULT)
#define NET_DIAGNOSIS_SCENECHANGE               "VideoSceneChangeDetection"                  // ��Ƶ�����仯��� ��Ӧ�ṹ��(NET_VIDEO_SCENECHANGE_DETECTIONRESULT)
#define NET_DIAGNOSIS_VIDEO_DELAY               "VideoDelay"                                 // ��Ƶ��ʱ��� ��Ӧ�ṹ��(NET_VIDEO_DELAY_DETECTIONRESUL)
#define NET_DIAGNOSIS_PTZ_MOVING                "PTZMoving"                                  // ��̨�ƶ���� ��Ӧ�ṹ��(NET_PTZ_MOVING_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLACK_WHITE				"VideoBlackAndWhite"						 // �ڰ�ͼ����, ��Ӧ�ṹ��(NET_BLACK_WHITE_DETECTIONRESULT)
#define NET_DIAGNOSIS_DRAMATIC_CHANGE			"VideoDramaticChange"						 // ���������, ��Ӧ�ṹ��(NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT)

typedef enum tagNET_STATE_TYPE
{
    NET_EM_STATE_ERR,        // ����
    NET_EM_STATE_NORMAL,     // "Normal" ���� 
    NET_EM_STATE_WARNING,    // "Warning" ����
    NET_EM_STATE_ABNORMAL,   // "Abnormal" �쳣
}NET_STATE_TYPE;
// ��Ƶ��������
typedef enum tagNET_STREAM_TYPE
{
    NET_EM_STREAM_ERR,                      // ����
    NET_EM_STREAM_MAIN,                     // "Main"-������
    NET_EM_STREAM_EXTRA_1,                  // "Extra1"-������1
    NET_EM_STREAM_EXTRA_2,                  // "Extra2"-������2
    NET_EM_STREAM_EXTRA_3,                  // "Extra3"-������3
    NET_EM_STREAM_SNAPSHOT,                 // "Snapshot"-ץͼ����
    NET_EM_STREAM_OBJECT,                   // "Object"-������
    NET_EM_STREAM_AUTO,                     // "Auto"-�Զ�ѡ���������
    NET_EM_STREAM_PREVIEW,                  // "Preview"-Ԥ������������
    NET_EM_STREAM_NONE,                     // ����Ƶ����(����Ƶ)
}NET_STREAM_TYPE;
// ��Ƶ��Ͻ������
typedef enum tagNET_VIDEODIAGNOSIS_RESULT_TYPE
{
    NET_EM_ROTATION,                        // "Rotation"    -��Ƶ��Ѳ�������
    NET_EM_REAL,                            // "Real" -ʵʱ��Ƶ�������
    NET_EM_NR_UNKNOW,                       // δ����
}NET_VIDEODIAGNOSIS_RESULT_TYPE;
//��Ƶ��ϴ���ԭ��
typedef enum tagNET_VIDEODIAGNOSIS_FAIL_TYPE
{
    NET_EM_NO_ERROR,                        // ��ϳɹ�
    NET_EM_DISCONNECT,                      // "Disconnect" - ĩ�������豸
    NET_EM_CH_NOT_EXIST,                    // "ChannelNotExist" - ͨ��������
    NET_EM_LOGIN_OVER_TIME,                 // "LoginOverTime" - ��¼��ʱ
    NET_EM_NO_VIDEO,                        // "NoVideo" - ��¼�ɹ�����Ƶ
    NET_EM_NO_RIGHT,                        // "NoRight" - �޲���Ȩ��
    NET_EM_PLATFROM_LOGIN_FAILED,           // "PlatformLoginFailed" - ƽ̨����ʧ��
    NET_EM_PLATFROM_DISCONNECT,             // "PlatformDisconnect" - ƽ̨�Ͽ�����
    NET_EM_GET_STREAM_OVER_TIME,            // "GetStreamOverTime" - ��ȡ������ʱ
    NET_EM_GET_NO_ENOUGH_STREAM,            // "NoEnoughStream" - ��������
    NET_EM_DECODE_STREAM_FAILED,            // "DecodeStreamFailed" - ����ʧ��
    NET_EM_GET_OFF_LINE,                    // "OffLine" - ǰ���豸����
    NET_EM_NF_UNKNOW,                       //  ����ԭ��,����ṹ�����ʧ��ԭ������
    NET_EM_NOT_SD,                          //  "NotSD" - �豸���������̨������Ч
}NET_VIDEODIAGNOSIS_FAIL_TYPE;

// ͨ�ñ䳤�ַ����ԡ�\0������
typedef struct tagNET_ARRAY
{
    DWORD          dwSize;                  // �˽ṹ���С
    char*          pArray;                  // ������ Ŀǰ��С260�ֽ�,�����������ڴ� ������ݱ�֤��'\0'����
    DWORD          dwArrayLen;              // ����ռ䳤��
}NET_ARRAY;

#define MAX_BACKPIC_COUNT	8	// ��󱳾�ͼƬ����

// ��Ƶ��Ͻ���ϱ�ͨ������
typedef struct tagNET_VIDEODIAGNOSIS_COMMON_INFO
{
    DWORD                           dwSize;                                 // �˽ṹ���С
    int                             nDiagnosisID;                           // ���ͨ��
    NET_ARRAY                       stProject;                              // �ƻ�����
    NET_ARRAY                       stTask;                                 // ��������
    NET_ARRAY                       stProfile;                              // ����������
    NET_ARRAY                       stDeviceID;                             // �豸Ψһ��־
    NET_TIME                        stStartTime;                            // ��ʼʱ��
    NET_TIME                        stEndTime;                              // ����ʱ��
    int                             nVideoChannelID;                        // ��Ƶͨ���� ǰ���豸����DVR,IPC��ͨ��
    NET_STREAM_TYPE                 emVideoStream;                          // ��Ƶ����
    NET_VIDEODIAGNOSIS_RESULT_TYPE  emResultType;                           // ��Ͻ������ 
    BOOL                            bCollectivityState;                     // ��Ͻ��
    NET_VIDEODIAGNOSIS_FAIL_TYPE    emFailedCause;                          // ʧ��ԭ��
    char                            szFailedCode[DH_COMMON_STRING_64];      // ʧ��ԭ������
    char                            szResultAddress[DH_COMMON_STRING_128];  // ��Ͻ����ŵ�ַ
    int                             nFrameRate;                             // ����	��λ kb/s, ÿ���ϱ�һ��
    int                             nFrameWidth;                            // ��	ÿ���ϱ�һ��
    int                             nFrameHeight;                           // ��	ÿ���ϱ�һ��
	int								nBackPic;								// ����ͼƬ����
	char							szBackPicAddress[MAX_BACKPIC_COUNT][DH_COMMON_STRING_128];	// ����ͼƬ·��
}NET_VIDEODIAGNOSIS_COMMON_INFO;

// ��Ӧ�������(NET_DIAGNOSIS_DITHER) ��Ƶ��������� -- ����仯 �紵,�ζ�,ת��������̨ת��
typedef struct tagNET_VIDEO_DITHER_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬  һ��С��������,�������쳣,�м��Ǿ���
    int                  nDuration;                      // ״̬����ʱ��  �����������ʱ�� ��ʱ����
}NET_VIDEO_DITHER_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_STRIATION)��Ƶ���Ƽ���� -- ����ܵ����ų����쳣����
typedef struct tagNET_VIDEO_STRIATION_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_STRIATION_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_LOSS)��Ƶ��ʧ����� -- �ϵ� ���ߵ���ɵ�
typedef struct tagNET_VIDEO_LOSS_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_LOSS_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_COVER)��Ƶ�ڵ������ -- ������ڵ���
typedef struct tagNET_VIDEO_COVER_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_COVER_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_FROZEN)��Ƶ�������� -- ���治�����Ϊ����
typedef struct tagNET_VIDEO_FROZEN_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_FROZEN_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_BRIGHTNESS)��Ƶ�����쳣����� --������������ò���ȷ��һЩ������
typedef struct tagNET_VIDEO_BRIGHTNESS_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_BRIGHTNESS_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_CONTRAST)��Ƶ�Աȶ��쳣�����
typedef struct tagNET_VIDEO_CONTRAST_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_CONTRAST_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_UNBALANCE)��Ƶƫɫ�쳣�����
typedef struct tagNET_VIDEO_UNBALANCE_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_UNBALANCE_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_NOISE)��Ƶ�����쳣�����
typedef struct tagNET_VIDEO_NOISE_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_NOISE_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_BLUR)��Ƶģ���쳣�����
typedef struct tagNET_VIDEO_BLUR_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_BLUR_DETECTIONRESULT;
// ��Ӧ�������(NET_DIAGNOSIS_SCENECHANGE)��Ƶ�����仯�����
typedef struct tagNET_VIDEO_SCENECHANGE_DETECTIONRESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nValue;                         // ���������ֵ
    NET_STATE_TYPE       emState;                        // �����״̬
    int                  nDuration;                      // ״̬����ʱ��
}NET_VIDEO_SCENECHANGE_DETECTIONRESULT;

// �˶��ƶ����������
typedef enum tagEM_PTZ_MOVING_RESULT_TYPE
{   
    EM_PTZ_MOVING_UNKNOWN ,          // δ֪
    EM_PTZ_MOVING_NORMAL  ,      // �������
    EM_PTZ_MOVING_NOTOBEY ,      // ����ָ���˶�
    EM_PTZ_MOVING_NOTMOVE ,      // �����˶�
    EM_PTZ_MOVING_NOTDETECT ,    // δ�����
}EM_PTZ_MOVING_RESULT_TYPE;

// ��Ӧ�������(NET_DIAGNOSIS_PTZ_MOVING)��̨�ƶ������
typedef struct tagNET_PTZ_MOVING_DETECTIONRESULT
{
    DWORD                       dwSize;                 // �˽ṹ���С
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingUp;          // �����˶������
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingDown;        // �����˶������
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingLeft;        // �����˶������
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingRight;       // �����˶������
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomWide;    // �䱶(��)�˶������
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomTele;    // �䱶(С)�˶������      
}NET_PTZ_MOVING_DETECTIONRESULT;

// ��Ӧ�������(NET_DIAGNOSIS_BLACK_WHITE) �ڰ�ͼ������
typedef struct tagNET_BLACK_WHITE_DETECTIONRESULT
{
	DWORD                dwSize;                 // �˽ṹ���С
	int                  nValue;                 // ���������ֵ
    NET_STATE_TYPE       emState;                // �����״̬
    int                  nDuration;              // ״̬����ʱ��
} NET_BLACK_WHITE_DETECTIONRESULT;

// ��Ӧ�������(NET_DIAGNOSIS_DRAMATIC_CHANGE) �����������
typedef struct tagNET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT
{
	DWORD                dwSize;                 // �˽ṹ���С
	int                  nValue;                 // ���������ֵ
    NET_STATE_TYPE       emState;                // �����״̬
    int                  nDuration;              // ״̬����ʱ��
} NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT;


// ��Ӧ�������(NET_DIAGNOSIS_VIDEO_DELAY)��Ƶ��ʱ�����
typedef struct tagNET_VIDEO_DELAY_DETECTIONRESUL
{
    DWORD       dwSize;             // �˽ṹ���С
    int         nSignalDelay;       // ������ʱ,-1��ʾ���ʧ��, ��λms
    int         nStreamDelay;       // ��Ƶ����ʱ,-1��ʾ���ʧ��, ��λms
    int         nIFrameDelay;       // I֡��ʱ,-1��ʾ���ʧ�� ��λms
}NET_VIDEO_DELAY_DETECTIONRESUL;

typedef struct tagNET_DIAGNOSIS_RESULT_HEADER
{
    DWORD                dwSize;                         // �˽ṹ���С

    char                 szDiagnosisType[MAX_PATH];      // �������,���dhnetsdk.h��"��Ƶ����ϱ����������Ͷ���" ��NET_DIAGNOSIS_DITHER
    int                  nDiagnosisTypeLen;              // ��������ͽṹ���С
}NET_DIAGNOSIS_RESULT_HEADER;

// cbVideoDiagnosis �ص���������
typedef struct tagNET_REAL_DIAGNOSIS_RESULT
{
    DWORD                dwSize;                         // �˽ṹ���С
    NET_VIDEODIAGNOSIS_COMMON_INFO* pstDiagnosisCommonInfo;  //��Ƶ���ͨ����Ϣ
    int                  nTypeCount;                     // ��Ͻ������������͸���
    void*                pDiagnosisResult;               // һ����Ͻ������,��ʽ��NET_DIAGNOSIS_RESULT_HEADER+�������1+NET_DIAGNOSIS_RESULT_HEADER+�������2+...
    DWORD                dwBufSize;                      // ���峤��
}NET_REAL_DIAGNOSIS_RESULT;

//��Ƶ��Ͻ���ϱ��ص�����
typedef int (CALLBACK *fRealVideoDiagnosis)(LLONG lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// �ӿ� CLIENT_StartVideoDiagnosis ���������
typedef struct tagNET_IN_VIDEODIAGNOSIS
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nDiagnosisID;                   // ��Ƶ���ID,��0��ʼ
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    fRealVideoDiagnosis  cbVideoDiagnosis;               // ��Ƶ��Ͻ���ص�����
    LDWORD               dwUser;                         // �û��Զ������
}NET_IN_VIDEODIAGNOSIS;

// �ӿ� CLIENT_StartVideoDiagnosis ���������
typedef struct tagNET_OUT_ATTACH_REALDIAGNOSIS
{
    DWORD                dwSize;                         // �˽ṹ���С
    LLONG                lDiagnosisHandle;               // ���ľ��
}NET_OUT_VIDEODIAGNOSIS;

// �ӿ� CLIENT_StartFindDiagnosisResult ���������
typedef struct tagNET_IN_FIND_DIAGNOSIS
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nDiagnosisID;                   // ��Ƶ���ID,��0��ʼ
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    NET_ARRAY            stuDeviceID;                    // �豸Ψһ��־,pArray:NULL��ʾ��ʹ���豸ID��ѯ
    NET_TIME             stuStartTime;                   // ��ʼʱ��
    NET_TIME             stuEndTime;                     // ����ʱ��
    int                  nVideoChannel;                  // ��Ƶͨ����,-1:����ͨ����
    int                  nTypeCount;                     // ������͸���,0:��ʹ��������Ͳ�ѯ
    NET_ARRAY*           pstDiagnosisTypes;              // �����������,��ʾ��Ҫ��ѯ���������
														 // ���û������ڴ棬��СΪsizeof(NET_ARRAY)*nTypeCount
    char                 szProjectName[MAX_PATH];        // �ƻ�����
} NET_IN_FIND_DIAGNOSIS;

// �ӿ� CLIENT_StartFindDiagnosisResult ���������
typedef struct tagNET_OUT_FIND_DIAGNOSIS
{
    DWORD                dwSize;                         // �˽ṹ���С
    LLONG                lFindHandle;                    // ��ѯ���
    DWORD                dwTotalCount;                   // �����������ܸ���
}NET_OUT_FIND_DIAGNOSIS;

// �ӿ� CLIENT_DoFindDiagnosisResult ���������
typedef struct tagNET_IN_DIAGNOSIS_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nDiagnosisID;                   // ��Ƶ���ID,��0��ʼ
    DWORD                dwWaitTime;                     // �ӿڳ�ʱ�ȴ�ʱ��
    int                  nFindCount;                     // ÿ�β�ѯ����Ƶ��Ͻ������
    int                  nBeginNumber;                   // ��ѯ��ʼ��� 0<=beginNumber<= totalCount-1
}NET_IN_DIAGNOSIS_INFO;

// CLIENT_StartRealTimeProject �ӿ��������
typedef struct tagNET_IN_START_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С
    char*                pszProjectInfo;                 // ʵʱ�ƻ���Ϣ,ͨ������dhconfigsdk.dll�нӿ�CLIENT_PacketData��װ�õ�
                                                         // ��Ӧ�ķ�װ����Ϊ CFG_CMD_VIDEODIAGNOSIS_REALPROJECT                      
}NET_IN_START_RT_PROJECT_INFO;

// CLIENT_StartRealTimeProject �ӿ��������
typedef struct tagNET_OUT_START_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С
}NET_OUT_START_RT_PROJECT_INFO;

// CLIENT_StopRealTimeProject �ӿ��������
typedef struct tagNET_IN_STOP_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С
    char*                pszProjectNames;                // �ƻ�����,��&&��Ϊ���ֵķָ��,ʾ����Project1&&Project2   
}NET_IN_STOP_RT_PROJECT_INFO; 

// CLIENT_StopRealTimeProject �ӿ��������
typedef struct tagNET_OUT_STOP_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С
}NET_OUT_STOP_RT_PROJECT_INFO;

// ��λ����Ϣ
typedef struct tagNET_CARPORTLIGHT_INFO
{
    DWORD               dwSize;  
    NET_CARPORTLIGHT_TYPE emType;                        // ��λ������
    NET_CARPORTLIGHT_MODE emMode;                        // ��λ�����Ʒ�ʽ
}NET_CARPORTLIGHT_INFO;

// ��λ��״̬
typedef struct tagNET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nLightNum;                      // ��λ���� 
    NET_CARPORTLIGHT_INFO stuLights[DH_MAX_CARPORTLIGHT_NUM]; // ��λ����Ϣ,������emType�����ظ�,һ����ƺ�һ���̵�
    int                  nFiringTime;                    // ״̬��ʱ��,��λ��
    int                  nHoldTime;                      // ״̬����ʱ��,��λ��,-1��ʾ���ޱ���,0��ʾ���п���
}NET_CARPORTLIGHT_STATUS;

// �ӿ�CLIENT_GetCarPortLightStatus���������
typedef struct tagNET_IN_GET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nChannelId;                     // ͨ����
}NET_IN_GET_CARPORTLIGHT_STATUS;

// �ӿ�CLIENT_GetCarPortLightStatus���������
typedef struct tagNET_OUT_GET_CARPORTLIGHT_STATUS
{
    DWORD                   dwSize;                      // �˽ṹ���С
    NET_CARPORTLIGHT_STATUS stuLightStatus;              // ��λ��״̬
}NET_OUT_GET_CARPORTLIGHT_STATUS;

// �ӿ� CLIENT_SetCarPortLightStatus ���������
typedef struct tagNET_IN_SET_CARPORTLIGHT_STATUS
{
    DWORD                   dwSize;                      // �˽ṹ���С
    int                     nChannelId;
    NET_CARPORTLIGHT_STATUS stuLightStatus;              // ��λ��״̬
}NET_IN_SET_CARPORTLIGHT_STATUS;

// �ӿ� CLIENT_SetCarPortLightStatus ���������
typedef struct tagNET_OUT_SET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // �˽ṹ���С
    
}NET_OUT_SET_CARPORTLIGHT_STATUS;


typedef struct tagNET_DEV_VIDEODIAGNOSIS_MULTI_INFO
{
    DWORD                dwSize;                                // �˽ṹ���С

    NET_VIDEODIAGNOSIS_COMMON_INFO*       pstDiagnosisCommonInfo;//��Ƶ���ͨ����Ϣ  ���½ṹ��ָ����Ҫ�����߷���
    BOOL                 abDither;                              // ���ڱ�ʾ�˴ν�������������Ƿ���Ч
    NET_VIDEO_DITHER_DETECTIONRESULT*     pstDither;            // ��Ƶ�������    
    BOOL                 abStration;
    NET_VIDEO_STRIATION_DETECTIONRESULT*  pstStration;          // ��Ƶ���Ƽ��    
    BOOL                 abLoss;
    NET_VIDEO_LOSS_DETECTIONRESULT*       pstLoss;              // ��Ƶ��ʧ���    
    BOOL                 abCover;
    NET_VIDEO_COVER_DETECTIONRESULT*      pstCover;             // ��Ƶ�ڵ����    
    BOOL                 abFrozen;
    NET_VIDEO_FROZEN_DETECTIONRESULT*     pstFrozen;            // ��Ƶ������   
    BOOL                 abBrightness;
    NET_VIDEO_BRIGHTNESS_DETECTIONRESULT* pstBrightness;        // ��Ƶ�����쳣���    
    BOOL                 abContrast;
    NET_VIDEO_CONTRAST_DETECTIONRESULT*   pstContrast;          // ��Ƶ�Աȶ��쳣���   
    BOOL                 abUnbalance;
    NET_VIDEO_UNBALANCE_DETECTIONRESULT*  pstUnbalance;         // ��Ƶƫɫ���    
    BOOL                 abNoise;
    NET_VIDEO_NOISE_DETECTIONRESULT*      pstNoise;             // ��Ƶ�������    
    BOOL                 abBlur;
    NET_VIDEO_BLUR_DETECTIONRESULT*       pstBlur;              // ��Ƶģ�����    
    BOOL                 abSceneChange;
    NET_VIDEO_SCENECHANGE_DETECTIONRESULT* pstSceneChange;      // ��Ƶ�����仯���
    BOOL                 abVideoDelay;
    NET_VIDEO_DELAY_DETECTIONRESUL*       pstVideoDelay;        // ��Ƶ�ӳټ��
    BOOL                abPTZMoving;
    NET_PTZ_MOVING_DETECTIONRESULT*       pstPTZMoving;         // ��̨�������
    BOOL				abBlackAndWhite;
	NET_BLACK_WHITE_DETECTIONRESULT*	  pstBlackAndWhite;		// �ڰ�ͼ����
	BOOL				abDramaticChange;
	NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT* pstDramaticChange;	// ���������
}NET_VIDEODIAGNOSIS_RESULT_INFO;

// �ӿ� CLIENT_DoFindDiagnosisResult ���������
typedef struct tagNET_OUT_DIAGNOSIS_INFO
{
    DWORD                dwSize;                         // �˽ṹ���С

    int                  nInputNum;                      // �û������NET_DEV_RESULT_VIDEODIAGNOSIS_INFO����
    int                  nReturnNum;                     // ���ؽ������
    NET_VIDEODIAGNOSIS_RESULT_INFO*  pstDiagnosisResult; // �������  �ṹ��ָ����Ҫ�����߷���
														 // �����ڴ��СΪsizeof(NET_VIDEODIAGNOSIS_RESULT_INFO)*nInputNum
}NET_OUT_DIAGNOSIS_INFO;

///////////////////////////////// ����ʽ�豸����ģ�� //////////////////////////////////////////////////////
///////////////////////////////// CLIENT_OperateMasterSlaveDevice�ӿڲ������� /////////////////////////////////
#define        MASTERSLAVE_CMD_START                   "masterSlaveTracker.start"                   // ��������ʽ����������
#define        MASTERSLAVE_CMD_STOP                    "masterSlaveTracker.stop"                    // ֹͣ����ʽ����������
#define        MASTERSLAVE_CMD_MANUALTRACK             "masterSlaveTracker.manualSelectObjectTrack" // �ֶ�ѡ��Ŀ�����
#define        MASTERSLAVE_CMD_POINTTRACK              "masterSlaveTracker.selectPointTrack"        // �������
#define        MASTERSLAVE_CMD_GETCALIBPOINTS          "masterSlaveTracker.getCalibratePoints"      // �õ����б궨��
#define        MASTERSLAVE_CMD_CALIBRATE               "masterSlaveTracker.calibrate"               // ����궨��
#define        MASTERSLAVE_CMD_ADDCALIBPOINT           "masterSlaveTracker.addCalibratePoint"       // ���ӱ궨��
#define        MASTERSLAVE_CMD_REMOVECALIBPOINT        "masterSlaveTracker.removeCalibratePoint"    // ɾ���궨��
#define        MASTERSLAVE_CMD_MARKMAXZOOM             "masterSlaveTracker.markSceneMaxZoom"        // �궨���������ٱ���, �ѵ�ǰ������Ϊ�����

// ����ʽ�豸���
typedef struct __NET_MS_PAIRPOINTS
{
    int                nStructSize;
    DH_POINT           stMasterPoint;    // ������궨��,��������һ����[0,8192]����
    DH_POINT           stSlavePoint;     // ������궨��,��������һ����[0,8192]����
}NET_MS_PAIRPOINTS;
//MASTERSLAVE_CMD_START���������ṹ��
typedef struct __NET_IN_MS_START
{
    int                nStructSize;
}NET_IN_MS_START;

//MASTERSLAVE_CMD_START���������ṹ��
typedef struct __NET_OUT_MS_START
{
    int                nStructSize;
}NET_OUT_MS_START;

//MASTERSLAVE_CMD_STOP���������ṹ��
typedef struct __NET_IN_MS_STOP
{
    int                nStructSize;
}NET_IN_MS_STOP;

//MASTERSLAVE_CMD_STOP���������ṹ��
typedef struct __NET_OUT_MS_STOP
{
    int                nStructSize;
}NET_OUT_MS_STOP;

//MASTERSLAVE_CMD_MANUALTRACK���������ṹ��
typedef struct __NET_IN_MS_MANUALTRACK
{
    int                nStructSize;
    DWORD              dwObject;          // -1 ��ʾ�������������λ������, >=0��ʾָ�������壨���Դ��豸��������֡�õ���
}NET_IN_MS_MANUALTRACK;

//MASTERSLAVE_CMD_MANUALTRACK���������ṹ��
typedef struct __NET_OUT_MS_MANUALTRACK
{
    int                nStructSize;
}NET_OUT_MS_MANUALTRACK;

//MASTERSLAVE_CMD_POINTTRACK���������ṹ��
typedef struct __NET_IN_MS_POINTTRACK
{
    int                nStructSize;
    DH_POINT           stTrackerPoint;    // ���ٵ�,��������һ����[0,8192]���� 
}NET_IN_MS_POINTTRACK;

//MASTERSLAVE_CMD_POINTTRACK���������ṹ��
typedef struct __NET_OUT_MS_POINTTRACK
{
    int                nStructSize;
}NET_OUT_MS_POINTTRACK;

//MASTERSLAVE_CMD_GETCALIBPOINTS���������ṹ��
typedef struct __NET_IN_MS_GETCALIBPOINTS
{
    int                nStructSize;
}NET_IN_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_GETCALIBPOINTS���������ṹ��
typedef struct __NET_OUT_MS_GETCALIBPOINTS
{
    int                        nStructSize;
    int                        nPointsNum;                           // ʵ�ʱ궨����
    NET_MS_PAIRPOINTS          stPairPoints[MAX_CALIBPOINTS_NUM];    // �궨�������
}NET_OUT_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_CALIBRATE���������ṹ��
typedef struct __NET_IN_MS_CALIBRATE
{
    int                nStructSize;
}NET_IN_MS_CALIBRATE;

//MASTERSLAVE_CMD_CALIBRATE���������ṹ��
typedef struct __NET_OUT_MS_CALIBRATE
{
    int                nStructSize;      
}NET_OUT_MS_CALIBRATE;

//MASTERSLAVE_CMD_ADDCALIBPOINT���������ṹ��
typedef struct __NET_IN_MS_ADDCALIBPOINT
{
    int                        nStructSize;
    BOOL                       bSlavePointEn;        // ������궨��ʹ��λ, TURE���ô�����궨����Ч��FASLE����Ч, �豸�Լ���ȡ��ǰ�Ĵ�����궨�㡣
    NET_MS_PAIRPOINTS          stPairPoints;         // �������������
}NET_IN_MS_ADDCALIBPOINT;

//MASTERSLAVE_CMD_ADDCALIBPOINT���������ṹ��
typedef struct __NET_OUT_MS_ADDCALIBPOINT
{
    int                nStructSize;
    DH_POINT           stPoint;      // �ӱ궨��
}NET_OUT_MS_ADDCALIBPOINT;


//MASTERSLAVE_CMD_REMOVECALIBPOINT���������ṹ��
typedef struct __NET_IN_MS_REMOVECALIBPOINT
{
    int                nStructSize;
    DH_POINT           stPoint;      // ���궨��
}NET_IN_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_REMOVECALIBPOINT���������ṹ��
typedef struct __NET_OUT_MS_REMOVECALIBPOINT
{
    int                nStructSize;      
}NET_OUT_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_MARKMAXZOOM��������ṹ��
typedef struct __NET_IN_MS_MARKMAXZOOM
{
    int                nStructSize; 
}NET_IN_MS_MARKMAXZOOM;

//MASTERSLAVE_CMD_MARKMAXZOOM��������ṹ��
typedef struct __NET_OUT_MS_MARKMAXZOOM
{
    int                nStructSize; 
}NET_OUT_MS_MARKMAXZOOM;

///////////////////////////////// CLIENT_OperateCommDevice �ӿڲ������� /////////////////////////////////
#define        COMMDEV_GET_EXTERNLDATA                            "devComm.getExternalData"        //��ȡ�����������    ���ڵ�����ͨ������

#define        MAX_EXTERN_DATA_LEN                2048

//COMMDEV_GET_EXTERNLDATA �������
typedef struct __COMMDEV_IN_GET_EXTERNDATA
{
    DWORD        dwSize;

}COMMDEV_IN_GET_EXTERNDATA;

//COMMDEV_GET_EXTERNLDATA �������
typedef struct __COMMDEV_OUT_GET_EXTERNDATA
{
    DWORD        dwSize;
    char         szGetData[MAX_EXTERN_DATA_LEN];                //��������豸�ɼ�����(���ݸ�ʽ������Ŀ�Զ���)
}COMMDEV_OUT_GET_EXTERNDATA;


///////////////////////////////// CLIENT_OperateVideoAnalyseDevice �ӿڲ������� /////////////////////////////////
#define     NET_SET_MODULESTATE                         "devVideoAnalyse.setModuleState"                        // ����ģ��״̬
#define     NET_TEST_WITH_SCREENPOINTS                  "devVideoAnalyse.testCalibrateWithScreenPoints"            // ������Ļ������Ծ������,�õ���������֮���ʵ�ʾ��롣�ڲ���֮ǰ,��Ҫ����ɲ������á�
#define     NET_TEST_WITH_METRICLENGTH                  "devVideoAnalyse.testCalibrateWithMetricLength"            // ����ʵ�ʳ��ȡ���ʼ�㼰���������,���Ծ������
#define     NET_GET_INTERNALOPTIONS                     "devVideoAnalyse.getInternalOptions"                    // ��ȡ�ڲ�ѡ��
#define     NET_TUNE_INTERNALOPTIONS                    "devVideoAnalyse.tuneInternalOptions"                    // �����ڲ�ѡ��
#define     NET_RESET_INTERNALOPTIONS                   "devVideoAnalyse.resetInternalOptions"                    // ��λ���е����ڲ�ѡ��
#define     NET_SET_PTZ_PRESET_STATUS                   "devVideoAnalyse.setPtzPresetStatus"                    // ��ȡԤ�õ���Ϣ

// �߶�����
typedef enum tagNET_EM_LINETYPE
{
    NET_EM_HORIZONTAL,
    NET_EM_VERTICAL,
}NET_EM_LINETYPE;

// Ԥ�õ�״̬ö��
typedef enum tagEM_DH_PTZ_PRESET_STATUS
{
    EM_DH_PTZ_PRESET_STATUS_UNKNOWN,        // δ֪
    EM_DH_PTZ_PRESET_STATUS_REACH,          // Ԥ�õ㵽��
    EM_DH_PTZ_PRESET_STATUS_UNREACH,        // Ԥ�õ�δ����
}EM_DH_PTZ_PRESET_STATUS;

//��̨��λ��Ϣ����
typedef struct
{
    int     nChannelID;                 // ͨ���� 
    int     nPTZPan;                    // ��̨ˮƽ�˶�λ��,��Ч��Χ��[0,3600]
    int     nPTZTilt;                   // ��̨��ֱ�˶�λ��,��Ч��Χ��[-1800,1800]
    int     nPTZZoom;                   // ��̨��Ȧ�䶯λ��,��Ч��Χ��[0,128]
    BYTE    bState;                     // ��̨�˶�״̬, 0-δ֪ 1-�˶� 2-���� 
    BYTE    bAction;                    // ��̨����,0-Ԥ�õ�,1-��ɨ,2-Ѳ��,3-Ѳ��,4-ˮƽ��ת
    BYTE    bFocusState;                // ��̨�۽�״̬, 0-δ֪, 1-�˶�״̬, 2-����
    BYTE    bEffectiveInTimeSection;    //��ʱ�����Ԥ�õ�״̬�Ƿ���Ч
                                        //�����ǰ�ϱ���Ԥ�õ���ʱ����ڵ�Ԥ�õ�,��Ϊ1,�������Ϊ0
    int     nPtzActionID;               // Ѳ��ID��
    DWORD   dwPresetID;                 // ��̨����Ԥ�õ���
    float   fFocusPosition;             // �۽�λ��
    BYTE    bZoomState;                 // ��̨ZOOM״̬,0-δ֪,1-ZOOM,2-����
    BYTE    bReserved[3];               // ����
    DWORD   dwSequence;                 // �����,����У���Ƿ񶪰�
    DWORD   dwUTC;                      // ��Ӧ��UTC(1970-1-1 00:00:00)������
    EM_DH_PTZ_PRESET_STATUS emPresetStatus; // Ԥ�õ�λ��
	int	    nZoomValue;				    // ��ʵ�䱶ֵ ��ǰ���ʣ�����100����ʾ��
    int     reserved[244];              // �����ֶ�
}DH_PTZ_LOCATION_INFO;

// NET_SET_PTZ_PRESET_STATUS
typedef struct __NET_IN_PTZ_PRESET_STATUS
{
    DWORD                    dwSize;
    DH_PTZ_LOCATION_INFO     stPTZStatus;
}NET_IN_PTZ_PRESET_STATUS;

typedef struct __NET_OUT_PTZ_PRESET_STATUS
{
    DWORD    dwSize;
}NET_OUT_PTZ_PRESET_STATUS;


// NET_TEST_WITH_SCREENPOINTS
typedef struct __NET_IN_CALIBRATE_BY_POINTS
{
    DWORD               dwSize;                 // �˽ṹ���С

    DH_POINT            stStartPoint;           // �߶��������    ������������һ����[0,8191]���䡣
    DH_POINT            stEndPoint;             // ��ֹ������    ������������һ����[0,8191]���䡣    
    NET_EM_LINETYPE     emType;                 // �߶�����    em_Horizontal("Horizontal") ˮƽ�߶� em_Vertical("Vertical")��ֱ�߶�
}NET_IN_CALIBRATE_BY_POINTS;
typedef struct __NET_OUT_CALIBRATE_BY_POINTS
{
    DWORD               dwSize;                 // �˽ṹ���С

    double              dlength;                // ����֮���ʵ�ʳ���    ��λΪ��
}NET_OUT_CALIBRATE_BY_POINTS;

// NET_TEST_WITH_METRICLENGTH
typedef struct __NET_IN_CALIBRATE_BY_LENGTH
{
    DWORD               dwSize;                 // �˽ṹ���С

    double              nLength;                // ����֮���ʵ�ʳ���,��Ϊ��λ
    DH_POINT            stStartPoint;           // �߶��������,������������һ����[0,8191]���䡣
    DH_POINT            stDirection;            // �߶η��������,ֻ�Դ�ֱ�߶���Ч��������������һ����[0,8191]���䡣
    NET_EM_LINETYPE     emType;                 // �߶�����,em_Horizontal("Horizontal") ˮƽ�߶� em_Vertical("Vertical")��ֱ�߶�                
}NET_IN_CALIBRATE_BY_LENGTH;

typedef struct __NET_OUT_CALIBRATE_BY_LENGTH
{
    DWORD               dwSize;                 // �˽ṹ���С
    
    DH_POINT            stEndPoint;             // �߶��յ���Ļ����    ������������һ����[0,8191]���䡣    
}NET_OUT_CALIBRATE_BY_LENGTH;

typedef struct __NET_INTERNAL_OPTION
{
    DWORD               dwSize;                 // �˽ṹ���С

    int                 nIndex;                 // ѡ�����
    NET_ARRAY           stKey;                  // ѡ������,������\0����256�ֽ�,��������
    int                 nValue;                 // ѡ��ȡֵ
    int                 nMinValue;              // ��Сֵ
    int                 nMaxValue;              // ���ֵ
}NET_INTERNAL_OPTION;

// �����ڲ�ѡ�� NET_GET_INTERNALOPTIONS
typedef struct __NET_IN_GETINTERNAL_OPTIONS
{
    DWORD               dwSize;                 // �˽ṹ���С
}NET_IN_GETINTERNAL_OPTIONS;

typedef struct __NET_OUT_GETINTERNAL_OPTIONS
{
    DWORD                dwSize;                // �˽ṹ���С

    int                  nTotalOptionNum;       // ѡ����� ���ֵ��ѯ����
    int                  nReturnOptionNum;      // ���ص�ʵ��ѡ�����
    NET_INTERNAL_OPTION* pstInternalOption;     // ѡ���б� �����߷����ַ
												// ���û������ڴ棬��СΪsizeof(NET_INTERNAL_OPTION)*nTotalOptionNum
}NET_OUT_GETINTERNAL_OPTIONS;

// NET_TUNE_INTERNALOPTIONS
typedef struct __NET_IN_TUNEINTERNAL_OPTION
{
    DWORD                dwSize;                // �˽ṹ���С
    int                  nOptionCount;          // ѡ�����
    NET_INTERNAL_OPTION* pstInternalOption;     // ѡ���б� ���������ָ���
												// ���û������ڴ棬��СΪsizeof(NET_INTERNAL_OPTION)*nOptionCount
}NET_IN_TUNEINTERNAL_OPTION;
typedef struct __NET_OUT_TUNEINTERNAL_OPTION
{
    DWORD               dwSize;                 // �˽ṹ���С
}NET_OUT_TUNEINTERNAL_OPTION;

// NET_RESET_INTERNALOPTIONS
typedef struct __NET_IN_RESETINTERNAL_OPTION
{
    DWORD               dwSize;                 // �˽ṹ���С
}NET_IN_RESETINTERNAL_OPTION;
typedef struct __NET_OUT_RESETINTERNAL_OPTION
{
    DWORD               dwSize;                 // �˽ṹ���С
}NET_OUT_RESETINTERNAL_OPTION;

// NET_SET_MODULESTATE
typedef enum tagNET_EM_MODULESTATE
{
    NET_EM_MODULESTATE_OK,
    NET_EM_MODULESTATE_PAUSE,
}NET_EM_MODULESTATE;
typedef struct __NET_IN_SETMODULESTATE
{
    DWORD               dwSize;                 // �˽ṹ���С
    NET_EM_MODULESTATE  emState;                // 0-��������,1-��ͣ,�ٴ��л���������������Ѿ������仯,��Ҫ�ؽ�������
    int                 nIndex;                 // ģ����    -1ָ����ģ��
}NET_IN_SETMODULESTATE;
typedef struct __NET_OUT_SETMODULESTATE
{
    DWORD               dwSize;                 // �˽ṹ���С
}NET_OUT_SETMODULESTATE;

/////////////////////////////////CLIENT_DeleteDevConfig �ӿڲ���/////////////////////////////////
/*
 * CLIENT_DeleteDevConfig �����������
 */

typedef enum tagNET_EM_CONFIGOPTION
{
    NET_EM_CONFIGOPTION_OK,
    NET_EM_CONFIGOPTION_NEEDRESTART,
    NET_EM_CONFIGOPTION_NEEDREBOOT=2,
    NET_EM_CONFIGOPTION_WRITEFILEERROR=4,
    NET_EM_CONFIGOPTION_CAPSNOTSUPPORT=8,
    NET_EM_CONFIGOPTION_VALIDATEFAILED=16,
}NET_EM_CONFIGOPTION;

typedef struct tagNET_IN_DELETECFG
{
    DWORD         dwSize;                       // �ṹ���С
    char*         szCommand;                    // ��������
}NET_IN_DELETECFG;
typedef struct tagNET_OUT_DELETECFG
{
    DWORD         dwSize;                       // �ṹ���С
    int           nError;                       // �豸���صĴ�����
    int           nRestart;                     // �豸�Ƿ�����
    DWORD         dwOptionMask;                 // ѡ�� �����ö��NET_EM_CONFIGOPTION
}NET_OUT_DELETECFG;

/////////////////////////////////CLIENT_GetMemberNames �ӿڲ���/////////////////////////////////
/*
 * CLIENT_GetMemberNames �����������
 */
typedef struct tagNET_IN_MEMBERNAME
{
    DWORD         dwSize;                       // �ṹ���С
    char*         szCommand;                    // ��������
}NET_IN_MEMBERNAME;
typedef struct tagNET_OUT_MEMBERNAME
{
    DWORD         dwSize;                       // �ṹ���С
    int           nError;                       // �豸���صĴ�����
    int           nRestart;                     // �豸�Ƿ�����
    int           nTotalNameCount;              // ���Ƹ��� ͨ���������õ�,��������д
    int           nRetNameCount;                // ���ص�ʵ�����Ƹ���
    NET_ARRAY*    pstNames;                     // �������� �����������ڴ�,������nTotalNameCount��
												// ���û������ڴ棬��СΪsizeof(NET_ARRAY)*nTotalNameCount
}NET_OUT_MEMBERNAME;

////////////////////////////////////��ƵŨ����ؽṹ��//////////////////////////////////////
// �������
typedef enum tagNET_EM_STAFF_TYPE
{
    NET_EM_STAFF_TYPE_ERR,
    NET_EM_STAFF_TYPE_HORIZONTAL,               // "Horizontal" ˮƽ�߶�
    NET_EM_STAFF_TYPE_VERTICAL,                 // "Vertical" ��ֱ�߶�
    NET_EM_STAFF_TYPE_ANY,                      // "Any" �����߶�
    NET_EM_STAFF_TYPE_CROSS,                    // "Cross" ��ֱ�潻�߶�
}NET_EM_STAFF_TYPE;

// ��������
typedef enum tagNET_EM_CALIBRATEAREA_TYPE
{
    NET_EM_CALIBRATEAREA_TYPE_ERR,
    NET_EM_CALIBRATEAREA_TYPE_GROUD,            // "Groud" : ����,��ҪN����ֱ�߶�+M��ˮƽ�߶Σ���N=3,M=1������N=2,M=2���������չ����
    NET_EM_CALIBRATEAREA_TYPE_HORIZONTAL,       // "Horizontal"  : ˮƽ��,��Ҫˮƽ����һ�㵽������ͶӰ��ֱ�߶Ρ�        
    NET_EM_CALIBRATEAREA_TYPE_VERTICAL,         // "Vertical" : ��ֱ��,��Ҫ��ֱ�������Ľ��ߡ�
    NET_EM_CALIBRATEAREA_TYPE_ANY,              // "Any" ����ƽ��,N����ֱ�߶�,��ÿ�����ȣ�N=3,�������չ����
}NET_EM_CALIBRATEAREA_TYPE;

// Ũ������������������
typedef enum tagNET_EM_OUTPUT_SUB_TYPE
{
    NET_EM_OUTPUT_SUB_TYPE_ERR,
    NET_EM_OUTPUT_SUB_TYPE_NORMAL,              // ��ͨ�����ٶȣ�������ΪŨ����Ƶʱ��Ч��
    NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS,            // ��Ũ����Ĳ����ٶȣ�������ΪŨ����Ƶʱ��Ч��,��û������ʱ���,���������ʱ�������ٶȲ���
}NET_EM_OUTPUT_SUB_TYPE;

// �����Ϣ
typedef struct tagNET_STAFF_INFO
{
    DH_POINT            stuStartLocation;       // ��ʼ�����
    DH_POINT            stuEndLocation;         // ��ֹ�����
    float               nLenth;                 // ʵ�ʳ���,��λ��
    NET_EM_STAFF_TYPE   emType;                 // �������
}NET_STAFF_INFO;

// �궨����,��ͨ����ʹ��
typedef struct tagNET_CALIBRATEAREA_INFO
{
    int                     nLinePoint;                         // ˮƽ�������߶�����
    DH_POINT                stuLine[DH_MAX_POLYLINE_NUM];       // ˮƽ��������
    float                   fLenth;                             // ʵ�ʳ���
    DH_POLY_POINTS          stuArea;                            // ����
    int                     nStaffNum;                          // ��ֱ�����
    NET_STAFF_INFO          stuStaffs[DH_MAX_STAFF_NUM];        // ��ֱ���         
    NET_EM_CALIBRATEAREA_TYPE emType;                           // ��������
}NET_CALIBRATEAREA_INFO;

typedef struct tagNET_LOCALFILE_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];               // �ļ�����·��
}NET_LOCALFILE_INFO;

typedef struct tagNET_REMOTEFILE_INFO
{
    DWORD               dwSize;
    char                szIP[MAX_PATH];                     // Զ���豸IP
    unsigned int        nPort;                              // Զ���豸�˿�
    char                szName[DH_MAX_NAME_LEN];            // ��½Զ���豸�û���
    char                szPassword[DH_MAX_NAME_LEN];        // ��½Զ���豸����
    BYTE                byProtocolType;                     // Զ���豸ʹ�õ�Э������,2-˽�ж���,3-˽������
    BYTE                byReserved[3];                      // �ֽڶ���
    char                szFilePath[MAX_PATH];               // �ļ�����·��,byProtocolTypeΪ3ʱ��Ч
    int                 nStartCluster;                      // ��ʼ�غ�,byProtocolTypeΪ2ʱ��Ч
    int                 nDriverNo;                          // �̺�,byProtocolTypeΪ2ʱ��Ч
}NET_REMOTEFILE_INFO;

// �ļ�λ����Ϣ
typedef struct tagNET_FILEPATH_INFO
{
    DWORD               dwSize;
    BOOL                bFileType;                          // TRUE: �����������ļ�; FALSE: Զ���豸�ļ�
    NET_LOCALFILE_INFO  stuLocalFile;                       // �����ļ���Ϣ, bFileType==TRUE��Ч
    NET_REMOTEFILE_INFO stuRemoteFile;                      // Զ���ļ���Ϣ, bFileType==FALSE��Ч
}NET_FILEPATH_INFO;

// ȫ�ֲ���
typedef struct tagNET_GLOBAL_INFO
{
    DWORD                   dwSize;
    char                    szSceneType[DH_MAX_NAME_LEN];           // Ӧ�ó���,ֻ֧��"Normal"
    int                     nStaffNum;                              // �����
    NET_STAFF_INFO          stuStaffs[DH_MAX_STAFF_NUM];            // ���    
    int                     nCalibrateAreaNum;                      // �궨������
    NET_CALIBRATEAREA_INFO  stuCalibrateArea[DH_MAX_CALIBRATEBOX_NUM]; // �궨����(����ֶβ�����,������������Ϊ�궨����)
    int                     nJitter;                                // ����������� : �����������,ȡֵ0-100,��Ӧ��ֹ����������̶�,����Խ����,ֵԽ��
    BOOL                    bDejitter;                              // �Ƿ���ȥ����ģ��
}NET_GLOBAL_INFO;

// ģ�����
typedef struct tagNET_MODULE_INFO
{
    DWORD               dwSize;                                     // �ýṹ���С
    BYTE                bSensitivity;                               // �����,ȡֵ1-10,ֵԽС�����Խ��
    BYTE                bReserved[3];
    int                 nDetectRegionPoint;                         // ������򶥵���
    DH_POINT            stuDetectRegion[DH_MAX_POLYGON_NUM];        // �������
    int                 nExcludeRegionNum;                          // �ų�������
    DH_POLY_POINTS      stuExcludeRegion[DH_MAX_EXCLUDEREGION_NUM]; // �ų�����
}NET_MODULE_INFO;

// ���������Ϣ
typedef struct tagNET_OBJFILTER_INFO
{
    DWORD               dwSize;                             // �ýṹ���С
    NET_TIME            stuStartTime;                       // ��ʼʱ��
    NET_TIME            stuEndTime;                         // ����ʱ��
    char                szObjectType[DH_MAX_NAME_LEN];      // ��������,֧������:
                                                            //"Unknown", "Human", "Vehicle",
                                                            //"Fire", "Smoke", "Plate", "HumanFace", "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "Entity"
    char                szObjectSubType[64];                // ���������,���ݲ�ͬ����������,����ȡ���������ͣ�
                                                            // Vehicle Category:"Unknown"  δ֪,"Motor" ������,"Non-Motor":�ǻ�����,"Bus": ������,"Bicycle" ���г�,"Motorcycle":Ħ�г�
                                                            // Plate Category��"Unknown" δ֪,"Normal" ���ƺ���,"Yellow" ����,"DoubleYellow" ˫���β��,"Police" ����"Armed" �侯��,
                                                            // "Military" ���Ӻ���,"DoubleMilitary" ����˫��,"SAR" �۰���������,"Trainning" ����������
                                                            // "Personal" ���Ժ���,"Agri" ũ����,"Embassy" ʹ�ݺ���,"Moto" Ħ�г�����,"Tractor" ����������,"Other" ��������
															// "Civilaviation"�񺽺���,"Black"����
															// "PureNewEnergyMicroCar"���綯����ԴС��,"MixedNewEnergyMicroCar,"�������ԴС��,"PureNewEnergyLargeCar",���綯����Դ��
															// "MixedNewEnergyLargeCar"�������Դ��
                                                            //  HumanFace Category:"Normal" ��ͨ����,"HideEye" �۲��ڵ�,"HideNose" �����ڵ�,"HideMouth" �첿�ڵ�
    DWORD               dwRGBMainColor[DH_MAX_COLOR_NUM];   // ������Ҫ��ɫ,����Ϊ��ʱ��ʾ�ϰ�����ɫ�����ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����,����:RGBֵΪ(0,255,0),͸����Ϊ0ʱ, ��ֵΪ0x00ff0000
    DWORD               dwLowerBodyColor[DH_MAX_COLOR_NUM]; // ����Ϊ��ʱ��ʾ�°�����ɫ�����ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����,����:RGBֵΪ(0,255,0),͸����Ϊ0ʱ, ��ֵΪ0x00ff0000
    int                 nMinSize;                           // ������С�ߴ�, m
    int                 nMaxSize;                           // �������ߴ�, m
    int                 nMinSpeed;                          // ��С�ٶ�, km/h
    int                 nMaxSpeed;                          // ����ٶ�, km/h
    DWORD               dwRGBMainColorNum;                  // ����������Ϊ��,��־dwRGBMainColor��Ч����ɫ������
    DWORD               dwLowerBodyColorNum;                // ����������Ϊ����bRGBMainColor==true,��־�°�����Ч����ɫ������
    BOOL                bRGBMainColor;                      // true-dwRGBMainColor��ʾ�ϰ�����ɫ,dwLowerBodyColor��ʾ�°�����ɫ; false-dwRGBMainColor��ʾ����Ҫ��ɫ,dwLowerBodyColor��Ч
}NET_OBJFILTER_INFO;

// �������
typedef struct tagNET_VIDEOSYNOPSISRULE_INFO
{
    DWORD               dwSize;                             // �ýṹ���С
    BYTE                byOutputType;                       // Ũ����������ϵ�����,1-��Ƶ���(һ�����);2-Ũ����Ƶ;3-���п���������Ƶ
    BYTE                byDensity;                          // �ܶ�, 1-10, ֵԽ��, Ũ���ܶ�Խ��
    bool                bShowTime;                          // Ũ������Ƿ���ʾʱ��
    bool                bShowBox;                           // Ũ������Ƿ���ʾ���
    bool                bEnableRecordResult;                // Ũ������Ƿ��¼�����ݿ�
    BYTE                byTime;                             // ��ƵŨ����ʱ��,��λ:����
    BYTE                byReserved[2];
    NET_OBJFILTER_INFO  stuFilter[MAX_OBJFILTER_NUM];       // ���������Ϣ
    DWORD               dwObjFilterNum;                     // ���������Ϣ��Ŀ

    // NET_OUT_QUERY_VIDEOSYNOPSIS��TYPE_CB_VIDEOSYNOPSIS_RULE�ص�����ʱ, ����CFG_CMD_ANALYSERULE�������dhconfigsdk.dll�нӿ�CLIENT_ParseData����,�õ���Ӧ�Ľṹ��,��ʱҪ�ȷ����㹻�ڴ�
    // NET_IN_ADD_VIDEOSYNOPSIS��,����CFG_CMD_ANALYSERULE�������dhconfigsdk.dll�нӿ�CLIENT_PacketData��װ,�õ�����Ϣ
    char*               szAnalyseRuleInfo;                  // JSON��װ������Ϣ
    int                 nBufferLen;                         // TYPE_CB_VIDEOSYNOPSIS_RULE, NET_OUT_QUERY_VIDEOSYNOPSIS��ʱ,�����szAnalyseRuleInfo����
    BOOL                bCustomResolution;                  // �Զ���ֱ���ʹ��, TRUE-�ֱ�����emResolutionȷ��, FALSE-����ԭʼ��Ƶ�ֱ�������Ũ����Ƶ
    CAPTURE_SIZE        emResolution;                       // �ֱ���, bCustomResolutionΪTRUE����Ч
    BOOL                bEnableMaxUsedCPU;                  // �Ƿ����ռ�������CPU��Դ
    BOOL                bEnableSmoothBorder;                // �Ƿ�ƽ��Ŀ��߿�
    NET_EM_OUTPUT_SUB_TYPE emOutputSubType;                 // Ũ����������ϵ�������,���NET_EM_OUTPUT_SUB_TYPE
    int                 nExtractFrameRate;                  // Ũ����Ƶ�ĳ�֡����    1-32,ֵԽ��,��֡����Խ��,�ͻ��˳��ֵĲ����ٶ�Խ��
                                                            // ���ֶν���Ũ������������������(emOutputSubType)��NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS��Ч 
    //��ƵŨ��������Ϣ
    int                 nSynopsisSpeed;                     // Ũ���ٶ���ֵ,����1~10��ʮ����λ,5��ʾŨ����ֻ����5�����ٶȵ����塣�Ǹ���Ե�λ
                                                            // Ϊ0ʱ,���ֶ���Ч
    int                 nSynopsisSize;                      // Ũ���ߴ���ֵ,����1~10��ʮ����λ,3��ʾŨ����ֻ����3���ϴ�С�����塣�Ǹ���Ե�λ
                                                            // Ϊ0ʱ,���ֶ���Ч
    BOOL                bEnableDirection;                   // ΪTrueʱ,�������˶�����������
                                                            // ΪFalseʱ,���������˶�����������,
    DH_POINT            stuSynopsisStartLocation;           // Ũ���˶�����,��ʼ�����,��������һ����[0,8192)����,bEnableDirectionΪTrueʱ��Ч
    DH_POINT            stuSynopsisEndLocation;             // Ũ���˶�����,��ֹ�����,��������һ����[0,8192)����,bEnableDirectionΪTrueʱ��Ч
}NET_VIDEOSYNOPSISRULE_INFO;

// ���Ũ����Ƶ�����������
typedef struct tagNET_IN_ADD_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // �ýṹ���С
    NET_FILEPATH_INFO*      pFilePathInfo;                  // �ļ�λ����Ϣ,�û�����ռ�
															// ���û������ڴ�,��СΪsizeof(NET_FILEPATH_INFO)*dwFileCount
    DWORD                   dwFileCount;                    // ��Ч�ļ�����
    NET_GLOBAL_INFO         stuGlobalInfo;                  // ȫ����Ϣ
    NET_MODULE_INFO         stuModuleInfo;                  // ģ����Ϣ
    NET_VIDEOSYNOPSISRULE_INFO stuRuleInfo;                 // ������Ϣ
    unsigned int        nWaitTime;                          // �ȴ���ʱʱ��,��λms
}NET_IN_ADD_VIDEOSYNOPSIS;

// ���Ũ����Ƶ�����������
typedef struct tagNET_OUT_ADD_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // �ýṹ���С
    DWORD*              pnTaskID;                           // TaskID����,�û�����ռ�.��˳��һһ��Ӧ���������ļ�;����0��ʾ��Ӧ�������ʧ��
    DWORD               nTaskIDCount;                       // TaskID����
}NET_OUT_ADD_VIDEOSYNOPSIS;

// Ũ����ƵԤ���������������
typedef struct tagNET_IN_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // �ýṹ���С
    NET_FILEPATH_INFO*      pFilePathInfo;                  // �ļ�λ����Ϣ,�û�����ռ�,��СΪsizeof(NET_FILEPATH_INFO)*dwFileCount
    DWORD                   dwFileCount;                    // ��Ч�ļ�����
    unsigned int            nWaitTime;                      // �ȴ���ʱʱ��,��λms
    char                    szTaskName[DH_COMMON_STRING_64];// Ũ����������,����Ϊ�� 
}NET_IN_PRE_HANDLE_VIDEOSYNOPSIS;

// Ũ����ƵԤ���������������
typedef struct tagNET_OUT_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // �ýṹ���С
    DWORD*              pnTaskID;                           // TaskID����,�û�����ռ�.��˳��һһ��Ӧ���������ļ�;����0��ʾ��Ӧ�������ʧ��
															// ���û������ڴ棬��СΪsizeof(DWORD)*nTaskIDCount
	DWORD               nTaskIDCount;                       // TaskID����
}NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS;

// ִ��Ũ����Ƶ�����������
typedef struct tagNET_IN_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD                       dwSize;                     // �ýṹ���С
    DWORD                       nTaskID;                    // ����ID,CLIENT_PreHandleVideoSynopsisTask�ӿ������������
    NET_GLOBAL_INFO             stuGlobalInfo;              // ȫ����Ϣ
    NET_MODULE_INFO             stuModuleInfo;              // ģ����Ϣ
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                // ������Ϣ
    unsigned int                nWaitTime;                  // �ȴ���ʱʱ��,��λms
}NET_IN_RUN_VIDEOSYNOPSIS_TASK;

//  ִ��Ũ����Ƶ�����������
typedef struct tagNET_OUT_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD               dwSize;                             // �ýṹ���С
    DWORD               nPlayID;                            // �ط�ID,����0��ʾ�ӿ�ʧ��,������CLIENT_PlayBackBySynopsisFile�ӿ����ڻط���Ƶ
    DWORD               nTime;                              // Ũ����Ƶʱ��,��λ:��
}NET_OUT_RUN_VIDEOSYNOPSIS_TASK;

// ��ͣ��ƵŨ�������������
typedef struct tagNET_IN_PAUSE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // �ýṹ���С
    BOOL                bPause;                             // TRUE-��ʾ��ͣ����   FALSE-��ʾ�ָ����� 
    DWORD*              pnTaskID;                           // TaskID����,�û�����ռ�,��СΪsizeof(DWORD)*nTaskIDCount
    DWORD               nTaskIDCount;                       // TaskID����
    DWORD               nWaitTime;                          // �ȴ���ʱʱ��,��λms
}NET_IN_PAUSE_VIDEOSYNOPSIS;

//Ҫ�Ƴ�����������
typedef enum tagNET_SYNOPSIS_REMOVE_TYPE
{
    EM_SYNOPSIS_REMOVE_UNKNOW =0 , // δ֪
    EM_SYNOPSIS_REMOVE_PRETASK   , // Ԥ��������
    EM_SYNOPSIS_REMOVE_SYNO      , // Ũ������
}NET_SYNOPSIS_REMOVE_TYPE;

// �Ƴ���ƵŨ�������������
typedef struct tagNET_IN_REMOVE_VIDEOSYNOPSIS
{
    DWORD                       dwSize;                            // �ýṹ���С
    DWORD*                      pnTaskID;                          // TaskID����,�û�����ռ�,��СΪsizeof(DWORD)*nTaskIDCount
    DWORD                       nTaskIDCount;                      // TaskID����
    DWORD                       nWaitTime;                         // �ȴ���ʱʱ��,��λms
    NET_SYNOPSIS_REMOVE_TYPE    emRemoveType;                      // Ҫ�Ƴ�����������
}NET_IN_REMOVE_VIDEOSYNOPSIS;

// ��ƵŨ�����ص�������Ϣ
typedef struct tagNET_REAL_SYNOPSIS_OBJECT_INFO
{
    DWORD               dwSize;
    
    DWORD               dwTaskID;                       // ��ǰ�����Ӧ������ID
    DH_MSG_OBJECT_EX2   stuObjectInfo;                  // ���������Ϣ
}NET_REAL_SYNOPSIS_OBJECT_INFO;

typedef struct tagNET_REAL_SYNOPSIS_STATE_INFO
{
    DWORD           dwSize;
    
    DWORD           dwTaskID;                           // ����ID   
    int             nObjectNum;                         // ĿǰŨ���������ѷ��ֵ���������
    int             nTaolProgress;                      // ��ǰŨ��Դ���������̵�,�����ء�׼����Ũ��������ɽ���,0~100
    char            szState[DH_MAX_SYNOPSIS_STATE_NAME];// ��Ӧ��ƵŨ��״̬,"Downloading"-��������","Synopsising"-����Ũ��",
                                                        // "DownloadFailed"-����ʧ��","DownloadSucceeded"-���سɹ�
                                                        // "SynopsisFailed"-Ũ��ʧ��","Succeeded"-Ũ���ɹ�
                                                        // "DownloadPause"-������ͣ,"SynopsisPause"-Ũ����ͣ
    int             nProgressOfCurrentState;            // ��ǰŨ�������Ӧ����ɽ���,0~100
    char            szFailedCode[DH_MAX_STRING_LEN];    // ʧ����,szState="SynopsisFailed"��Ч
                                                        // "OutOfMemory" �ڴ治��;
                                                        // "TooMany_TargetInVideo"  ������ƵĿ��������;
                                                        // "InvalidFilePointer" �ļ�ָ����Ч;
                                                        // "InvalidFilePath" �ļ�·����Ч;
                                                        // "CreateDirectoryFailed"  �����ļ���·��ʧ��;
                                                        // "WriteDataFailed" дTube�м��ļ�ʧ��
                                                        // "DataSizeTooLarge" Tube�ļ�̫��
                                                        // "Detect_Nothing" ���������˶�Ŀ��
                                                        // "OpenDataFailed" ���м��ļ�ʧ��
                                                        // "InvalidSynopsisBackgroud" Ũ��������Ч
                                                        // "ColorRetrieval" �������ɫ��������
                                                        // "UnsupportRuleType" ��֧�ֵĹ�������
                                                        // "RuleNumberExceedLimit" ����������
                                                        // "NoFunctionCfgInfo" ָ������Ӧ���ܵ�û��������Ϣ
                                                        // "FunctionNumberExceedLimit" ÿ������Ĺ�����Ŀ��������
                                                        // "PointsExceedLimit" �߻�������ĵ�������
                                                        // "BadFunctionType" ����Ĺ�������
                                                        // "RulePointNumber" �����������
                                                        // "MaskRegionNumberExceedLimit" ����������������
                                                        // "CameraSceneSwitch" ��������л�
                                                        // "TooManyTargeInFrame" ��֡��Ŀ��������
                                                        // "InalidSynopsisDesity" Ũ���ܶ���Ч
                                                        // "ExtrackColorFeatureFailed" ��ȡ��ɫ����ʧ��
                                                        // "JpegEncodeFrameFailed" Jpeg����ʧ��
                                                        // "JpegParamRestFailed" Jpeg���ñ������ʧ��
                                                        // "JpegDecodeFrameFailed" Jpeg����ʧ��
                                                        // "RetrieveObjectIdInvalid" ����Ŀ��ID��Ч
                                                        // "RetrieveImageInvalid" ����ͼ����Ч
                                                        // "NetworkAnomaly" ӳ���������쳣
                                                        // "ObjectNumberLimit" ��������Ŀ����Ŀ����
                                                        // "CreateChannelFailed" ����ͨ��ʧ��
                                                        // "ReadUGFileFailed" ��ȡUG�ļ�ʧ��
                                                        // "GetSynopsisInfoFailed" ��ȡŨ����Ƶ��Ϣʧ��
                                                        // "ObjectNumberExceedLimit" ������Ŀ����Ŀ��������
                                                        // "RebuildBackgroudFailed" �ؽ�����ʧ��
                                                        // "NotExistMiddleFile" �м��ļ�������
                                                        // "NotExistSourceFile" ԭʼ�ļ�������
                                                        // "NotDog" û�м��ܹ�
                                                        // "NotEnoughFreeDisk" ���̿ռ䲻��
                                                        // "StartDecodeFail" ��ʼ����ʧ��
                                                        // "DecodeTimeOut" ����ȴ���ʱ
                                                        // "EncodeTimeOut" ����ȴ���ʱ
                                                        // "ExactTimeOut" ��ȡ���յȴ���ʱ
                                                        // "ReadMidlleFileFail" ��ȡ�м��ļ�ʧ��
                                                        // "ExactPictureFail" ��ȡͼƬʧ��

     char szPicPath[DH_COMMON_STRING_512];              // Ԥ�����ļ���ȡ���Ŀ���	�ļ�·��
                                                        // ֧��HTTP URL��ʾ:"http://www.dahuate.com/1.jpg"
                                                        // ֧��FTP URL��ʾ: "ftp://ftp.dahuate.com/1.jpg"
                                                        // ֧�ַ���������·�� 
                                                        // a)"C:/pic/1.jpg" 
                                                        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int         nMaxTime;                               //֧��Ũ����Ƶ���ʱ�䳤��,��λ ��
    int         nMinTime;                               //֧��Ũ����Ƶ��Сʱ�䳤��,��λ ��
}NET_REAL_SYNOPSIS_STATE_INFO;

//��ƵŨ��������Ϣʵʱ�ص�����
typedef int (CALLBACK *fVideoSynopsisObjData)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_OBJECT_INFO* pSynopsisObjectInfo, void* pBuf, int nBufLen, LDWORD dwUser, void* pReserved);

//��ƵŨ������״̬ʵʱ�ص�����
typedef int (CALLBACK *fVideoSynopsisState)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_STATE_INFO* pSynopsisStateInfos, int nInfoCount, LDWORD dwUser, void* pReserved);

// CLIENT_RealLoadObjectData�ӿڲ�������
typedef struct tagNET_IN_REALLOAD_OBJECTDATA
{
    DWORD               dwSize;                         // �ṹ���С   
    int                 nTaskIDNum;                     // ����ID����
    DWORD               *pTaskIDs;                      // ��������ID,���û������ڴ棬��СΪsizeof(DWORD)*nTaskIDNum
    BOOL                bNeedPicFile;                   // �Ƿ����ض�Ӧ��ͼƬ�ļ� 
    int                 nWaitTime;                      // �ȴ�ʱ��,��λms
    fVideoSynopsisObjData cbVideoSynopsisObjData;       // ��ƵŨ��������Ϣʵʱ�ص�����ָ��
    LDWORD         dwUser;
}NET_IN_REALLOAD_OBJECTDATA;

typedef struct tagNET_OUT_REALLOAD_OBJECTDATA
{
    DWORD               dwSize;                         // �ṹ���С
    LLONG               lRealLoadHandle;                // �ӿڷ��صĶ��ľ��,��Ψһ��ʶĳ������
}NET_OUT_REALLOAD_OBJECTDATA;

// CLIENT_StopLoadObjectData�ӿڲ�������
typedef struct tagNET_IN_STOPLOAD_OBJECTDATA
{
    DWORD               dwSize;
    int                 nTackIDNum;                     // ����ID����
    DWORD               *pTaskIDs;                      // ��������ID, ���û������ڴ棬��СΪsizeof(DWORD)*nTaskIDNum 
}NET_IN_STOPLOAD_OBJECTDATA;

// CLIENT_RealLoadSynopsisState�ӿڲ�������
typedef struct tagNET_IN_REALLAOD_SYNOPSISSTATE
{
    DWORD               dwSize;                         // �ṹ���С  
    int                 nTaskIDNum;                     // ����ID����
    DWORD               *pTaskIDs;                      // ��������ID,���û������ڴ棬��СΪsizeof(DWORD)*nTaskIDNum 
    int                 nWaitTime;                      // �ȴ�ʱ��,��λms
    fVideoSynopsisState cbVideoSynopsisState;           // ��ƵŨ��������Ϣʵʱ�ص�����ָ��
    LDWORD         dwUser;
}NET_IN_REALLAOD_SYNOPSISSTATE;

typedef struct tagNET_OUT_REALLOAD_SYNOPSISSTATE
{
    DWORD               dwSize;                         // �ṹ���С    
    LLONG               lRealLoadHandle;                // �ӿڷ��ص����ؾ��,��Ψһ��ʶĳ������
}NET_OUT_REALLOAD_SYNOPSISSTATE;

// CLIENT_StopLoadSynopsisState�ӿڲ�������
typedef struct tagNET_IN_STOPLOAD_SYNOPSISSTATE
{
    DWORD               dwSize;   
    int                 nTackIDNum;                     // ����ID����
    DWORD               *pTaskIDs;                      // ��������ID,���û������ڴ棬��СΪsizeof(DWORD)*nTaskIDNum   
}NET_IN_STOPLOAD_SYNOPSISSTATE;

// Ũ����Ƶ��Ϣ�Ĳ�������
typedef enum tagEM_VIDEOSYNOPSIS_QUERY_TYPE
{
    EM_VIDEOSYNOPSIS_TASK,                              // ������Ϣ
    EM_VIDEOSYNOPSIS_OBJ,                               // �����Ӧ�Ŀ���
}EM_VIDEOSYNOPSIS_QUERY_TYPE;

// ��ѯŨ����Ƶ��������Ϣ������
typedef struct tagNET_QUERY_VSTASK_INFO
{
    DWORD                dwSize;                        // �ýṹ���С
    DWORD                dwTaskID;                      // ������ID,Ϊ0ʱ��ʾ��ѯ��������
}NET_QUERY_VSTASK_INFO;

// ��ѯŨ����Ƶ������������Ϣ������
typedef struct tagNET_QUERY_VSOBJECT_INFO
{
    DWORD                dwSize;                         // �ýṹ���С
    DWORD*               pdwTaskID;                      // �������������ID,Ϊ-1��ʾ��ѯ��������
    DWORD                dwTaskIDCount;                  // ��Ч��������Ŀ
    DH_MSG_OBJECT        stuObjInfo;                     // ������Ϣ,objectIDΪ��0ʱ��ʾ��ѯ����������������
}NET_QUERY_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo�ӿ������������
typedef struct tagNET_IN_QUERY_VIDEOSYNOPSIS
{
    DWORD                dwSize;                         // �ýṹ���С
    EM_VIDEOSYNOPSIS_QUERY_TYPE emQueryType;             // ��������
    DWORD                dwCount;                        // ��ѯ������
    DWORD                dwBeginNumber;                  // ��ѯ��ʼ���    
    void*                pQueryInfo;                     // ��ѯ������Ϣ,�û�����ռ䣻
                                                         // ���emQueryType==EM_VIDEOSYNOPSIS_TASK,��ӦNET_QUERY_VSTASK_INFO,��СΪsizeof(NET_QUERY_VSTASK_INFO)*dwCount
                                                         // ���emQueryType==EM_VIDEOSYNOPSIS_OBJ,��ӦNET_QUERY_VSOBJECT_INFO,��СΪsizeof(NET_QUERY_VSOBJECT_INFO)*dwCount

    DWORD                dwWaitTime;                     // �ȴ���ʱʱ��,��λms
}NET_IN_QUERY_VIDEOSYNOPSIS;

// ��ѯ����ÿ��Ũ����Ƶ�������Ϣ
typedef struct tagNET_VSTASK_INFO
{
    DWORD                       dwSize;                             // �ýṹ���С
    DWORD                       dwTaskID;                           // ����ID
    NET_MODULE_INFO             stuModuleInfo;                      // ģ����Ϣ
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                        // ����Ĺ�����Ϣ
    NET_GLOBAL_INFO             stuGlobalInfo;                      // ȫ�ֲ���
    NET_TIME                    stuCreateTime;                      // ����Ĵ���ʱ��
    char                        szCurrState[DH_MAX_SYNOPSIS_STATE_NAME];  // ��ǰ��ƵŨ��״̬,"Downloading"-��������","Synopsising"-����Ũ��",
                                                                    // "DownloadFailed"-����ʧ��","DownloadSucceeded"-���سɹ�
                                                                    // "SynopsisFailed"-Ũ��ʧ��","Succeeded"-Ũ���ɹ�
                                                                    // "DownloadPause"-������ͣ,"SynopsisPause"-Ũ����ͣ
    char                        szCreateUser[DH_MAX_NAME_LEN];      // ����������û�
    int                         nProgressOfCurrentState;            // ��ǰŨ�������Ӧ����ɽ���,0~100
    char                        szLocalFilePath[MAX_PATH];          // �����ļ�·����Զ����ƵԴ�ļ����غ��ڱ��ص�·��
    int                         nObjectNum;                         // ĿǰŨ���������ѷ��ֵ���������
    NET_FILEPATH_INFO           stuVideoSourceFilePath;             // Դ��Ƶ�ļ�·��
    NET_FILEPATH_INFO           stuSynopsisVideoFilePath;           // Ũ����Ƶ�ļ�·��
    char                        szFailedCode[DH_MAX_STRING_LEN];    // Ũ����Ƶʧ�ܴ�����,szCurrStateΪ"SynopsisFailed"ʱ��Ч
                                                                    // "OutOfMemory" �ڴ治��;
                                                                    // "TooMany_TargetInVideo"  ������ƵĿ��������;
                                                                    // "InvalidFilePointer" �ļ�ָ����Ч;
                                                                    // "InvalidFilePath" �ļ�·����Ч;
                                                                    // "CreateDirectoryFailed"  �����ļ���·��ʧ��;
                                                                    // "WriteDataFailed" дTube�м��ļ�ʧ��
                                                                    // "DataSizeTooLarge" Tube�ļ�̫��
                                                                    // "Detect_Nothing" ���������˶�Ŀ��
                                                                    // "OpenDataFailed" ���м��ļ�ʧ��
                                                                    // "InvalidSynopsisBackgroud" Ũ��������Ч
                                                                    // "ColorRetrieval" �������ɫ��������
                                                                    // "UnsupportRuleType" ��֧�ֵĹ�������
                                                                    // "RuleNumberExceedLimit" ����������
                                                                    // "NoFunctionCfgInfo" ָ������Ӧ���ܵ�û��������Ϣ
                                                                    // "FunctionNumberExceedLimit" ÿ������Ĺ�����Ŀ��������
                                                                    // "PointsExceedLimit" �߻�������ĵ�������
                                                                    // "BadFunctionType" ����Ĺ�������
                                                                    // "RulePointNumber" �����������
                                                                    // "MaskRegionNumberExceedLimit" ����������������
                                                                    // "CameraSceneSwitch" ��������л�
                                                                    // "TooManyTargeInFrame" ��֡��Ŀ��������
                                                                    // "InalidSynopsisDesity" Ũ���ܶ���Ч
                                                                    // "ExtrackColorFeatureFailed" ��ȡ��ɫ����ʧ��
                                                                    // "JpegEncodeFrameFailed" Jpeg����ʧ��
                                                                    // "JpegParamRestFailed" Jpeg���ñ������ʧ��
                                                                    // "JpegDecodeFrameFailed" Jpeg����ʧ��
                                                                    // "RetrieveObjectIdInvalid" ����Ŀ��ID��Ч
                                                                    // "RetrieveImageInvalid" ����ͼ����Ч
                                                                    // "NetworkAnomaly" ӳ���������쳣
                                                                    // "ObjectNumberLimit" ��������Ŀ����Ŀ����
                                                                    // "CreateChannelFailed" ����ͨ��ʧ��
                                                                    // "ReadUGFileFailed" ��ȡUG�ļ�ʧ��
                                                                    // "GetSynopsisInfoFailed" ��ȡŨ����Ƶ��Ϣʧ��
                                                                    // "ObjectNumberExceedLimit" ������Ŀ����Ŀ��������
                                                                    // "RebuildBackgroudFailed" �ؽ�����ʧ��
                                                                    // "NotExistMiddleFile" �м��ļ�������
                                                                    // "NotExistSourceFile" ԭʼ�ļ�������
                                                                    // "NotDog" û�м��ܹ�
                                                                    // "NotEnoughFreeDisk" ���̿ռ䲻��
                                                                    // "StartDecodeFail" ��ʼ����ʧ��
                                                                    // "DecodeTimeOut" ����ȴ���ʱ
                                                                    // "EncodeTimeOut" ����ȴ���ʱ
                                                                    // "ExactTimeOut" ��ȡ���յȴ���ʱ
                                                                    // "ReadMidlleFileFail" ��ȡ�м��ļ�ʧ��
                                                                    // "ExactPictureFail" ��ȡͼƬʧ��
    char                        szTaskName[DH_COMMON_STRING_64];    //  Ũ����������                           
}NET_VSTASK_INFO;

// Ũ����Ƶ������ÿ��������Ϣ
typedef struct tagNET_VSOBJECT_INFO
{
    DWORD                dwSize;                        // �ýṹ���С
    DWORD                dwTaskID;                      // �����Ӧ����ID
    DH_MSG_OBJECT        stuObjInfo;                    // ������Ϣ
    NET_FILEPATH_INFO    stuFilePathInfo;               // �����Ӧ���ļ���Ϣ
    DWORD                dwFileLength;                  // �����ļ����ֽ�����С
}NET_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo�ӿ������������
typedef struct tagNET_OUT_QUERY_VIDEOSYNOPSIS
{
    DWORD                dwSize;                        // �ýṹ���С
    DWORD                dwTotalCount;                  // ���ϴ˴β�ѯ�����Ľ��������
    DWORD                dwFoundCount;                  // ���β�ѯ���ص�����
    void*                pResult;                       // ���ص���Ϣ,�û�����ռ�
                                                        // ���emQueryType==EM_VIDEOSYNOPSIS_TASK,��ӦNET_VSTASK_INFO,��СΪsizeof(NET_VSTASK_INFO)*dwMaxCount
                                                        // ���emQueryType==EM_VIDEOSYNOPSIS_OBJ,��ӦNET_VSOBJECT_INFO,��СΪsizeof(NET_VSOBJECT_INFO)*dwMaxCount
    DWORD                dwMaxCount;                    // �û�ϣ���Ľ���ĸ���
}NET_OUT_QUERY_VIDEOSYNOPSIS;

// CLIENT_FindSynopsisFile�ӿڲ������� 
// Ũ������ļ���ѯ����
typedef enum tagNET_EM_QUERY_SYNOPSIS_FILE
{
    DH_FILE_QUERY_VIDEO,                                // ��ͨ¼���ļ���Ϣ,��Ӧ��ѯ�ṹ��:NET_SYNOPSIS_QUERY_VIDEO_PARAM, ���ؽ���ṹ��:NET_SYNOPSISFILE_VIDEO_INFO
    DH_FILE_QUERY_SYNOPSISVIDEO,                        // Ũ����Ƶ��Ϣ, ��Ӧ��ѯ�ṹ��:NET_QUERY_SYNOPSISVIDEO_PARAM,���ؽ���ṹ��:NET_QUERY_SYNOPSISVIDEO_INFO
}NET_EM_QUERY_SYNOPSIS_FILE;

typedef struct __NET_SYNOPSIS_QUERY_VIDEO_PARAM
{
    DWORD               dwSize;
    DWORD               dwQueryMask;                    // ��ѯ��������, ���մӵ͵���λ,��һλ��ʱ��Ρ��ڶ�λ���ļ�·�� 
    NET_TIME            stuStartTime;                   // ��ʼʱ��    
    NET_TIME            stuEndTime;                     // ����ʱ��
    char                szFilePath[DH_MAX_SYNOPSIS_QUERY_FILE_COUNT][MAX_PATH];    // ����ѯ�ļ��ľ���·��
    DWORD               dwFileCount;                    // ����ѯ�ļ��ĸ���
}NET_SYNOPSIS_QUERY_VIDEO_PARAM;

typedef struct  
{
    DWORD               dwSize;
    int                 nTaskId;                        // ����ID
    DWORD               dwOutPutTypeMask;               // ��ǰ������������,��1λ.��Ƶ���(һ�����);��2λŨ����Ƶ    
    char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // ��ǰŨ��״̬
}NET_VIDEOSYNOPSIS_TASK_INFO;

// DH_FILE_QUERY_VIDEO ���ص�¼���ļ���Ϣ
typedef struct
{
    DWORD               dwSize;
    unsigned int        nchannelId;                     // ͨ����
    char                szFilePath[MAX_PATH];           // �ļ�·��
    unsigned int        nFileLenth;                     // �ļ�����,�ֽ�Ϊ��λ
    NET_TIME            stuStarttime;                   // ��ʼʱ��
    NET_TIME            stuEndtime;                     // ����ʱ��
    unsigned int        nWorkDirSN;                     // ����Ŀ¼���    
    unsigned int        nCluster;                       // �غ�                        
    BYTE                bHint;                          // �ļ���λ����
    BYTE                bDriveNo;                       // ���̺�
    BYTE                bReserved[18];                  // �����ֶ�
    int                 nTaskInfoNum;                   // ¼���ļ���Ӧ��Ũ���������
    NET_VIDEOSYNOPSIS_TASK_INFO stuTaskInfo[16];        // ����Ũ��������Ϣ
    //ƵŨ���ļ������Ϣ
    char szSynopsisPicPath[DH_COMMON_STRING_512];       // Ԥ�����ļ���ȡ���Ŀ���	�ļ�·��
                                                        // ֧��HTTP URL��ʾ:"http://www.dahuate.com/1.jpg"
                                                        // ֧��FTP URL��ʾ: "ftp://ftp.dahuate.com/1.jpg"
                                                        // ֧�ַ���������·�� 
                                                        // a)"C:/pic/1.jpg" 
                                                        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int                 nSynopsisMaxTime;               //֧��Ũ����Ƶ���ʱ�䳤��,��λ ��
    int                 nSynopsisMinTime;               //֧��Ũ����Ƶ��Сʱ�䳤��,��λ ��
}NET_SYNOPSISFILE_VIDEO_INFO;

// DH_FILE_QUERY_SYNOPSISVIDEO Ũ����Ƶ�ļ���ѯ����
typedef struct __NET_QUERY_SYNOPSISVIDEO_PARAM
{
    DWORD               dwSize;
    int                 nTaskID;                        // ����ID
}NET_QUERY_SYNOPSISVIDEO_PARAM;

// DH_FILE_QUERY_SYNOPSISVIDEOŨ����Ƶ��ѯ���
typedef struct __NET_QUERY_SYNOPSISVIDEO_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // �ļ�·��
    unsigned int        nFileLenth;                     // �ļ�����
    int                 nDurationTime;                  // ����ʱ��,��λs
}NET_QUERY_SYNOPSISVIDEO_INFO;

// CLIENT_FindSynopsisFile �ӿڲ���
typedef struct tagNET_IN_FIND_SYNOPSISFILE
{
    DWORD               dwSize;                          
    NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // ��ѯ����
    void*               pQueryCondition;                // ��ѯ����,���û������ڴ�
														// ���ѯ����ΪDH_FILE_QUERY_VIDEO,��Ӧ��ѯ�ṹ��:NET_SYNOPSIS_QUERY_VIDEO_PARAM,�����СΪsizeof(NET_SYNOPSIS_QUERY_VIDEO_PARAM)
														// ���ѯ����ΪDH_FILE_QUERY_SYNOPSISVIDEO,��Ӧ��ѯ�ṹ��:NET_QUERY_SYNOPSISVIDEO_PARAM,�����СΪsizeof(NET_QUERY_SYNOPSISVIDEO_PARAM)
	int                 nWaitTime;                      // �ȴ���ʱʱ��,��λms
}NET_IN_FIND_SYNOPSISFILE;

typedef struct tagNET_OUT_FIND_SYNOPSISFILE
{
    DWORD               dwSize;
    LLONG               lFindHandle;                    // ��ѯ���         
}NET_OUT_FIND_SYNOPSISFILE;

// CLIENT_FindNextSynopsisFile �ӿڲ���
typedef struct tagNET_IN_FINDNEXT_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nFileCount;                     // ����ѯ���ļ�����
    NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // ��ѯ����
    void*               pSynopsisFileInfo;              // �ļ���Ϣ��Ż���,���û������ڴ棬��СΪnMaxlen										
    int                 nMaxlen;                        // ��������С
    int                 nWaitTime;                      // �ȴ���ʱʱ��,��λms
}NET_IN_FINDNEXT_SYNOPSISFILE;

typedef struct tagNET_OUT_FINDNEXT_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nRetFileCount;                  // �ӿ�ʵ�ʷ��ص���Ϣ����,����ֵ<nFileCount(�������)����Ӧʱ����ڵ��ļ���ѯ���
}NET_OUT_FINDNEXT_SYNOPSISFILE;

// ���ؽ��Ȼص�����ԭ��, nError��ʾ�����ع��̳��ֵĴ���,1-���治��,2-�Է������ݵ�У�����,3-���ص�ǰ�ļ�ʧ��,4-������Ӧ�����ļ�ʧ��
typedef void (CALLBACK *fSynopsisFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwFileID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

// CLIENT_DownLoadSynosisFile �ӿڲ���
typedef  NET_DOWNLOADFILE_INFO NET_SYNOPSIS_DOWNLOADFILE_INFO;

typedef struct tagNET_IN_DOWNLOAD_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nFileCount;                     // �������ļ���
    NET_SYNOPSIS_DOWNLOADFILE_INFO* pFileInfos;         // �������ļ���Ϣ,���û������ڴ棬��СΪsizeof(NET_SYNOPSIS_DOWNLOADFILE_INFO)*nFileCount
    fSynopsisFileDownLoadPosCB cbPosCallBack;           // ���Ȼص�����
    LDWORD              dwUserData;                     // �û�����
    int                 nWaitTime;                      // �ȴ���ʱʱ��,��λms
}NET_IN_DOWNLOAD_SYNOPSISFILE;

typedef struct tagNET_OUT_DOWNLOAD_SYNOPSISFILE
{
    DWORD               dwSize;
    LLONG               lDownLoadHandle;                // ���ؾ��
}NET_OUT_DOWNLOAD_SYNOPSISFILE;

// �ļ�(��)·����Ϣ
typedef struct    tagNET_SET_FILEPATH_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // �������ļ���·��,Ҳ�������ļ�·����ĿǰŨ����Ƶ������ֻ֧��dav��ʽ���ļ�
}NET_SET_FILEPATH_INFO;

// CLIENT_SetFilePathInfo()�ӿ��������
typedef struct tagNET_IN_SET_FILEPATHINFO
{
    DWORD                dwSize;
    DWORD                dwCount;                       // ��ӵ��ļ�·����Ϣ����
    void*                pFilePathInfo;                 // ָ���ļ�·����ϢNET_SET_FILEPATH_INFO����
														// ���û������ڴ棬��СΪsizeof(NET_SET_FILEPATH_INFO)*dwCount
    DWORD                dwWaitTime;                    // �ȴ���ʱʱ��,��λms
}NET_IN_SET_FILEPATHINFO;


// fAddFileStateCB ����
typedef struct tagNET_CB_ADDFILESTATE
{
    DWORD               dwSize;
    const char*         szFileName;                     // �ļ�����
    const char*         szState;                        // �ļ�����״̬, "Successed",�ɹ�; "Failed",ʧ�ܣ�
}NET_CB_ADDFILESTATE;

// ��¼�豸�ص�����ԭ��, ÿ��1��,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAddFileStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_ADDFILESTATE* pBuf,  int nBufLen, LDWORD dwUser);

// CLIENT_AttacAddFileState()�ӿ��������
typedef struct tagNET_IN_ADDFILE_STATE
{
    DWORD               dwSize;
    fAddFileStateCB     cbAttachState;                 // ���������ļ�״̬�ص�
    LDWORD              dwUser;                        // �û�����
}NET_IN_ADDFILE_STATE;
typedef struct tagNET_OUT_ADDFILE_STATE
{
    DWORD                dwSize;
}NET_OUT_ADDFILE_STATE;

///////////////////////////////////����ʶ��ģ����ؽṹ��///////////////////////////////////////
typedef struct tagNET_UID_CHAR
{
    char szUID[DH_MAX_PERSON_ID_LEN];  //UID����
}NET_UID_CHAR;

// CLIENT_OperateFaceRecognitionDB�ӿ��������
typedef struct __NET_IN_OPERATE_FACERECONGNITIONDB
{
    DWORD             dwSize;
    EM_OPERATE_FACERECONGNITIONDB_TYPE emOperateType;  // ��������
    FACERECOGNITION_PERSON_INFO        stPersonInfo;   // ��Ա��Ϣ 

    //emOperateType��������ΪET_FACERECONGNITIONDB_DELETE_BY_UIDʱʹ��,stPeronInfo�ֶ���Ч
    DWORD            nUIDNum;                          //UID����               
    NET_UID_CHAR     *stuUIDs;                         //��ԱΨһ��ʶ��,�״��ɷ��������,������ID�ֶ�
										               // ���û������ڴ�,��СΪsizeof(NET_UID_CHAR)*nUIDNum
    // ͼƬ����������
    char              *pBuffer;                        // �����ַ
    int               nBufferLen;                      // �������ݳ���
}NET_IN_OPERATE_FACERECONGNITIONDB;

// CLIENT_OperateFaceRecognitionDB�ӿ��������
typedef struct __NET_OUT_OPERATE_FACERECONGNITIONDB
{
    DWORD               dwSize;
}NET_OUT_OPERATE_FACERECONGNITIONDB;

typedef struct __NET_FACE_MATCH_OPTIONS
{
    DWORD               dwSize;
    unsigned int        nMatchImportant;               // ��Ա��Ҫ�ȼ�    1~10,��ֵԽ��Խ��Ҫ,(��ѯ��Ҫ�ȼ����ڵ��ڴ˵ȼ�����Ա)
    EM_FACE_COMPARE_MODE emMode;                       // �����ȶ�ģʽ,���EM_FACE_COMPARE_MODE
    int                 nAreaNum;                      // �����������
    EM_FACE_AREA_TYPE   szAreas[MAX_FACE_AREA_NUM];    // �����������,emModeΪNET_FACE_COMPARE_MODE_AREAʱ��Ч
    int                 nAccuracy;                     // ʶ�𾫶�(ȡֵ1~10,����ֵ����,��⾫�����,����ٶ��½�����СֵΪ1 ��ʾ����ٶ�����,���ֵΪ10��ʾ��⾫�����ȡ� ��ʱֻ�����������Ч)
    int                 nSimilarity;                   // ���ƶ�(������ڸ���ʶ�Ȳű���;�ٷֱȱ�ʾ,1~100)
    int                 nMaxCandidate;                 // ���������ѡ����(�������ƶȽ�������,ȡ���ƶ����ĺ�ѡ��������)
    
}NET_FACE_MATCH_OPTIONS;

typedef struct __NET_FACE_FILTER_CONDTION
{
    DWORD               dwSize;
    NET_TIME            stStartTime;                   // ��ʼʱ��
    NET_TIME            stEndTime;                     // ����ʱ��
    char                szMachineAddress[MAX_PATH];    // �ص�,֧��ģ��ƥ��    
    int                 nRangeNum;                     // ʵ�����ݿ����     
    BYTE                szRange[MAX_FACE_DB_NUM];      // ����ѯ���ݿ�����,���EM_FACE_DB_TYPE
    EM_FACERECOGNITION_FACE_TYPE emFaceType;           // ����ѯ��������,��� EM_FACERECOGNITION
    int                 nGroupIdNum;                   // ��Ա����   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // ��Ա��ID 
    NET_TIME            stBirthdayRangeStart;          // ������ʼʱ��
    NET_TIME            stBirthdayRangeEnd;            // ���ս���ʱ��
}NET_FACE_FILTER_CONDTION;

// CLIENT_StartFindFaceRecognition�ӿ��������
typedef struct __NET_IN_STARTFIND_FACERECONGNITION
{
    DWORD               dwSize;
    BOOL                bPersonEnable;                 // ��Ա��Ϣ��ѯ�����Ƿ���Ч
    FACERECOGNITION_PERSON_INFO stPerson;              // ��Ա��Ϣ��ѯ����
    NET_FACE_MATCH_OPTIONS stMatchOptions;             // ����ƥ��ѡ��
    NET_FACE_FILTER_CONDTION stFilterInfo;             // ��ѯ��������
  
    // ͼƬ����������
    char                *pBuffer;                      // �����ַ
    int                 nBufferLen;                    // �������ݳ���

    int                 nChannelID;                    // ͨ����         
}NET_IN_STARTFIND_FACERECONGNITION;

// CLIENT_StartFindFaceRecognition�ӿ��������
typedef struct __NET_OUT_STARTFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nTotalCount;                   // ���صķ��ϲ�ѯ�����ļ�¼���� 
                                                       // -1��ʾ������δ����,Ҫ�Ƴٻ�ȡ
                                                       // ʹ��CLIENT_AttachFaceFindState�ӿ�״̬

    LLONG               lFindHandle;                   // ��ѯ���
    int                 nToken;                        // ��ȡ���Ĳ�ѯ����
}NET_OUT_STARTFIND_FACERECONGNITION;


// CLIENT_StartMultiFindFaceRecognition �ӿ��������
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITION
{
    DWORD               dwSize;
	int*                pChannelID;                    //  ͨ����
	int					nChannelCount;				   //  ͨ���������
	BOOL                bPersonEnable;                 // ��Ա��Ϣ��ѯ�����Ƿ���Ч
	FACERECOGNITION_PERSON_INFO stPerson;              // ��Ա��Ϣ��ѯ����
	NET_FACE_MATCH_OPTIONS stMatchOptions;             // ����ƥ��ѡ��
    NET_FACE_FILTER_CONDTION stFilterInfo;             // ��ѯ��������
	
    // ͼƬ����������
    char                *pBuffer;                      // �����ַ
    int                 nBufferLen;                    // �������ݳ���
	        
}NET_IN_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognition �ӿ��������
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nTotalCount;                    // ���صķ��ϲ�ѯ�����ļ�¼���� 
														// -1��ʾ������δ����,Ҫ�Ƴٻ�ȡ
														// ʹ��CLIENT_AttachFaceFindState�ӿ�״̬
	
	LLONG               lFindHandle;                   // ��ѯ���
    int                 nToken;                        // ��ȡ���Ĳ�ѯ����
}NET_OUT_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognitionRecord �������(��Ӧ�Ŀ�ʼʶ��������ͨ����ѯ)
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD
{
    DWORD               dwSize;                         // �ṹ���С
	
    // ��ѯ��������
    NET_TIME            stStartTime;                    // ��ʼʱ��
    NET_TIME            stEndTime;                      // ����ʱ��
    char                szMachineAddress[MAX_PATH];     // �ص�,֧��ģ��ƥ��     
    int                 nAlarmType;                     // ����ѯ��������,��� EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // ��Ա��Ϣ�Ƿ���Ч
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // ��Ա��Ϣ
    int*                pChannelID;                     // ͨ����
	int					nChannelCount;					// ͨ������
    int                 nGroupIdNum;                    // ��Ա����   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // ��Ա��ID 
}NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD;

// CLIENT_StartMultiFindFaceRecognitionRecord �������(��Ӧ�Ŀ�ʼʶ��������ͨ����ѯ)
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                    // ���صķ��ϲ�ѯ�����ļ�¼���� 
														// -1��ʾ������δ����,Ҫ�Ƴٻ�ȡ
														// ʹ��CLIENT_AttachFaceFindState�ӿ�״̬
	LLONG               lFindHandle;                   // ��ѯ���
	int                 nToken;                        // ��ȡ���Ĳ�ѯ����
}NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD;

//CLIENT_DoFindFaceRecognitionRecord �������(��Ӧ�Ŀ�ʼʶ��������ͨ����ѯ)
typedef struct tagNET_IN_DOFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                    // ��ѯ�����ļ�¼���� 
														// -1��ʾ������δ����,Ҫ�Ƴٻ�ȡ
														// ʹ��CLIENT_AttachFaceFindState�ӿ�״̬
	LLONG               lFindHandle;                    // ��ѯ��� 
	int					nBeginNumber;					// ��ѯ��ʼ��ţ���ʾ��beginNumber����¼��ʼ��ȡcount����¼���أ�
}NET_IN_DOFIND_FACERECONGNITIONRECORD;

// ����ʶ����Ϣ����
typedef struct tagNET_DOFIND_FACERECONGNITIONRECORD_INFO
{
    BOOL                    bGlobalScenePic;                        // ȫ��ͼ�Ƿ����
    NET_PIC_INFO			stGlobalScenePic;                       // ȫ��ͼƬ�ļ�·��
    DH_MSG_OBJECT           stuObject;                              // Ŀ������������Ϣ
    NET_PIC_INFO			stObjectPic;                            // Ŀ�������ļ�·��
    int                     nCandidateNum;                          // ��ǰ����ƥ�䵽�ĺ�ѡ��������
    CANDIDATE_INFO          stuCandidates[DH_MAX_CANDIDATE_NUM];    // ��ǰ����ƥ�䵽�ĺ�ѡ������Ϣ
    NET_CANDIDAT_PIC_PATHS_EX  stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // ��ǰ����ƥ�䵽�ĺ�ѡ����ͼƬ�ļ�·��
    NET_TIME                stTime;                                 // ��������ʱ��  
    char                    szAddress[MAX_PATH];                    // ���������ص�
    int                     nChannelId;                             // ͨ���� 
	BYTE					bReserved[256];							// ����
}NET_DOFIND_FACERECONGNITIONRECORD_INFO;

//CLIENT_DoFindFaceRecognitionRecord �������(��Ӧ�Ŀ�ʼʶ��������ͨ����ѯ)
typedef struct tagNET_OUT_DOFIND_FACERECONGNITIONRECORD
{
	DWORD											dwSize;
	NET_DOFIND_FACERECONGNITIONRECORD_INFO			*stuResults;		// ���ص�����ʶ����Ϣ����(�ڴ������ͷ����û�����)
	int												nResultNum;			// ���������ʶ����Ϣ���ڴ����
	int												nTotalCount;		// ʵ�ʷ��ظ���
}NET_OUT_DOFIND_FACERECONGNITIONRECORD;


#define MAX_FIND_COUNT  20

// ��ѯ�������ͼƬ�ĸ�ʽ
typedef enum tagEM_NEEDED_PIC_RETURN_TYPE
{
    EM_NEEDED_PIC_TYPE_UNKOWN,            // δ֪����
    EM_NEEDED_PIC_TYPE_HTTP_URL,          // ����ͼƬHTTP����
    EM_NEEDED_PIC_TYPE_BINARY_DATA,       // ����ͼƬ����������
    EM_NEEDED_PIC_TYPE_HTTP_AND_BINARY,   // ���ض����ƺ�HTTP����
}EM_NEEDED_PIC_RETURN_TYPE;

// CLIENT_DoFindFaceRecognition �ӿ��������
typedef struct __NET_IN_DOFIND_FACERECONGNITION
{
    DWORD               dwSize;
    LLONG               lFindHandle;                   	// ��ѯ���
    int                 nBeginNum;                     	// ��ѯ��ʼ���
    int                 nCount;                        	// ��ǰ���ѯ�ļ�¼���� 
	EM_NEEDED_PIC_RETURN_TYPE	emDataType;				// ָ����ѯ�������ͼƬ�ĸ�ʽ
}NET_IN_DOFIND_FACERECONGNITION;

// CLIENT_DoFindFaceRecognition�ӿ��������
typedef struct __NET_OUT_FINDNEXT_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nCadidateNum;                  // ʵ�ʷ��صĺ�ѡ��Ϣ�ṹ�����
    CANDIDATE_INFO      stCadidateInfo[MAX_FIND_COUNT];// ��ѡ��Ϣ����
    
    // ͼƬ����������
    char                *pBuffer;                      // �����ַ
    int                 nBufferLen;                    // �������ݳ���
}NET_OUT_DOFIND_FACERECONGNITION;

// CLIENT_DetectFace�ӿ��������
typedef struct __NET_IN_DETECT_FACE
{
    DWORD               dwSize; 
    DH_PIC_INFO         stPicInfo;                     // ��ͼ��Ϣ

    // ͼƬ����������
    char                *pBuffer;                      // �����ַ
    int                 nBufferLen;                    // �������ݳ���
}NET_IN_DETECT_FACE;

// CLIENT_DetectFace�ӿ��������
typedef struct __NET_OUT_DETECT_FACE
{
    DWORD               dwSize; 
    DH_PIC_INFO         *pPicInfo;                     // ����������ͼƬ��Ϣ,���û�����ռ�,��СΪsizeof(DH_PIC_INFO)*nMaxPicNum
    int                 nMaxPicNum;                    // �������ͼƬ��Ϣ����
    int                 nRetPicNum;                    // ʵ�ʷ��ص�����ͼƬ���� 
    
    // ͼƬ����������
    char                *pBuffer;                      // �����ַ,���û�����ռ�,��ż���������ͼƬ����
    int                 nBufferLen;                    // �������ݳ���
}NET_OUT_DETECT_FACE;

// ��Ա�����ö��
typedef enum tagEM_OPERATE_FACERECONGNITION_GROUP_TYPE
{
    NET_FACERECONGNITION_GROUP_UNKOWN,
    NET_FACERECONGNITION_GROUP_ADD,                     // �����Ա����Ϣ
    NET_FACERECONGNITION_GROUP_MODIFY,                  // �޸���Ա����Ϣ  
    NET_FACERECONGNITION_GROUP_DELETE,                  // ɾ����Ա����Ϣ
}EM_OPERATE_FACERECONGNITION_GROUP_TYPE;

// ��Ա����Ϣ
typedef struct tagNET_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    EM_FACE_DB_TYPE     emFaceDBType;                  // ��Ա������,��� EM_FACE_DB_TYPE
    char                szGroupId[DH_COMMON_STRING_64];// ��Ա��ID,Ψһ��ʶһ����Ա(�����޸�,��Ӳ���ʱ��Ч)
    char                szGroupName[DH_COMMON_STRING_128]; // ��Ա������ 
    char                szGroupRemarks[DH_COMMON_STRING_256]; // ��Ա�鱸ע��Ϣ
    int                 nGroupSize;                    // ��ǰ������Ա��
    int					nSimilarity;				   			// �����ƶ���ֵ�������ȶԸ�����ֵ��Ϊƥ��ɹ�
	int					nRetChnCount;							// ʵ�ʷ��ص�ͨ���Ÿ���
	int					nChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// ��ǰ��󶨵�����Ƶͨ�����б�
}NET_FACERECONGNITION_GROUP_INFO;

// �����Ա����Ϣ
typedef struct tagNET_ADD_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;      // ��Ա����Ϣ 
}NET_ADD_FACERECONGNITION_GROUP_INFO;

// ɾ����Ա����Ϣ
typedef struct tagNET_DELETE_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64];// ��Ա��ID,Ψһ��ʶһ����Ա
}NET_DELETE_FACERECONGNITION_GROUP_INFO;

// �޸���Ա����Ϣ
typedef struct tagNET_MODIFY_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;      // ��Ա����Ϣ 
}NET_MODIFY_FACERECONGNITION_GROUP_INFO;

// CLIENT_OperateFaceRecognitionGroup�ӿ��������
typedef struct tagNET_IN_OPERATE_FACERECONGNITION_GROUP
{
    DWORD               dwSize;
    EM_OPERATE_FACERECONGNITION_GROUP_TYPE emOperateType; // ��������
    void                *pOPerateInfo;                    // ��ز�����Ϣ,���û������ڴ棬�����С���ղ������Ͷ�Ӧ�Ľṹ��
														  // ���������ΪNET_FACERECONGNITION_GROUP_ADD,��Ӧ�ṹ��ΪNET_ADD_FACERECONGNITION_GROUP_INFO;
														  // ���������ΪNET_FACERECONGNITION_GROUP_MODIFY,��Ӧ�ṹ��ΪNET_MODIFY_FACERECONGNITION_GROUP_INFO
														  // ���������ΪNET_FACERECONGNITION_GROUP_DELETE,��Ӧ�ṹ��ΪNET_DELETE_FACERECONGNITION_GROUP_INFO
}NET_IN_OPERATE_FACERECONGNITION_GROUP;   

// CLIENT_OperateFaceRecognitionGroup�ӿ��������
typedef struct tagNET_OUT_OPERATE_FACERECONGNITION_GROUP
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64]; // ������¼����Ա��ID,Ψһ��ʶһ����Ա
}NET_OUT_OPERATE_FACERECONGNITION_GROUP;   

// ��ȡ��Ա����������
#define MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE		64

// CLIENT_GetFaceRecognitionPersonType�ӿ��������
typedef struct tagNET_IN_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;				// �ṹ���С
} NET_IN_GET_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_GetFaceRecognitionPersonType�ӿ��������
typedef struct tagNET_OUT_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;																		// �ṹ���С
    char                szPersonType[MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE][DH_COMMON_STRING_16];	// ��Ա����
	int					nPersonTypeNum;																// ʵ�ʷ��ص���Ա���͸���
	BYTE                byDefault[DH_COMMON_STRING_16];												// ��Ա����,��� EM_PERSON_TYPE
	int					nDefaultNum;																// ������Ա����
} NET_OUT_GET_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_GetDevCaps ��Ӧ������(NET_FACERECOGNITIONSE_CAPS) �������
typedef struct tagNET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD               dwSize;				// �ṹ���С
} NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY; 


// CLIENT_GetDevCaps ��Ӧ������(NET_FACERECOGNITIONSE_CAPS)�������
typedef struct tagNET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD               dwSize;				// �ṹ���С
	BOOL				bmultiFind;			// �Ƿ�֧�ֶ�ͨ������
	UINT				nmaxFaceType;		// ���֧������Զ���������������
} NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY; 


// ��Ա���Ͳ���ö��
typedef enum tagEM_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    NET_PERSON_TYPE_UNKOWN,				// δ֪
	NET_PERSON_TYPE_ADD,				// ����Զ�����Ա����
	NET_PERSON_TYPE_MODIFY,				// �޸���Ա����
	NET_PERSON_TYPE_DELETE,				// ɾ����Ա����
} EM_OPERATE_FACERECOGNITION_PERSON_TYPE;

// �����Ա������Ϣ
typedef struct tagNET_ADD_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// �ṹ���С
	char				szType[DH_COMMON_STRING_16];			// ��Ա����
} NET_ADD_FACERECOGNITION_PERSON_TYPE_INFO;   

// �޸���Ա������Ϣ
typedef struct tagNET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// �ṹ���С
	char				szType[DH_COMMON_STRING_16];			// �޸ĵ���Ա����
	char				szNewType[DH_COMMON_STRING_16];			// �µ���Ա����
} NET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO;   

// ɾ����Ա������Ϣ
typedef struct tagNET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// �ṹ���С
	char				szType[DH_COMMON_STRING_16];			// ��Ա����
} NET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO;   

// CLIENT_OperateFaceRecognitionPersonType�ӿ��������
typedef struct tagNET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD											dwSize;			// �ṹ���С
    EM_OPERATE_FACERECOGNITION_PERSON_TYPE			emOperateType;	// ��������
    void											*pOPerateInfo;	// ��ز�����Ϣ,���û������ڴ棬�����С���ղ������Ͷ�Ӧ�Ľṹ��
																	// ���������ΪNET_PERSON_TYPE_ADD,��Ӧ�ṹ��ΪNET_ADD_FACERECOGNITION_PERSON_TYPE_INFO;
																	// ���������ΪNET_PERSON_TYPE_MODIFY,��Ӧ�ṹ��ΪNET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO
																	// ���������ΪNET_PERSON_TYPE_DELETE,��Ӧ�ṹ��ΪNET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO
} NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_OperateFaceRecognitionPersonType�ӿ�������� (ɾ����Ա����ʱ��Ч)
typedef struct tagNET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;										// �ṹ���С
    char                szFailedCode[DH_COMMON_STRING_16];			// �������
} NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_FindGroupInfo�ӿ��������
typedef struct tagNET_IN_FIND_GROUP_INFO   
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64];// ��Ա��ID,Ψһ��ʶһ����Ա,Ϊ�ձ�ʾ��ѯȫ����Ա����Ϣ
}NET_IN_FIND_GROUP_INFO;

// CLIENT_FindGroupInfo�ӿ��������
typedef struct tagNET_OUT_FIND_GROUP_INFO   
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO *pGroupInfos;      // ��Ա����Ϣ,���û�����ռ�,��СΪsizeof(NET_FACERECONGNITION_GROUP_INFO)*nMaxGroupNum
    int                 nMaxGroupNum;                  // ��ǰ����������С
    int                 nRetGroupNum;                  // �豸���ص���Ա�����
}NET_OUT_FIND_GROUP_INFO;


// CLIENT_SetGroupInfoForChannel�ӿ��������
typedef struct tagNET_IN_SET_GROUPINFO_FOR_CHANNEL
{
    DWORD               dwSize;
    int                 nChannelID;                    // ͨ����
    int                 nGroupIdNum;                   // ��Ա����   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // ��Ա��ID 
}NET_IN_SET_GROUPINFO_FOR_CHANNEL;
// CLIENT_SetGroupInfoForChannel�ӿ��������
typedef struct tagNET_OUT_SET_GROUPINFO_FOR_CHANNEL
{
    DWORD                dwSize;
}NET_OUT_SET_GROUPINFO_FOR_CHANNEL;

// ������ѯ״̬��Ϣ�ص�����, lAttachHandle��CLIENT_AttachFaceFindState�ķ���ֵ
typedef struct tagNET_CB_FACE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //��ƵŨ���������ݿ�����ID
    int                 nProgress;      //����ȡֵ��Χ��0-100,-1,��ʾ��ѯtoken������(������һ�������ڻ�����Ĳ�ѯʱ)
    int                 nCurrentCount;  //Ŀǰ���ϲ�ѯ��������������
}NET_CB_FACE_FIND_STATE;

typedef void (CALLBACK *fFaceFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_FACE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

//CLIENT_AttachFaceFindState�ӿ��������
typedef struct tagNET_IN_FACE_FIND_STATE
{
    DWORD           dwSize;             //�ṹ���С,������д
    
    int             nTokenNum;          //��ѯ������,Ϊ0ʱ,��ʾ�������еĲ�ѯ����
    int            *nTokens;            //��ѯ����,���û������ڴ棬��СΪsizeof(int)*nTokenNum
    fFaceFindState  cbFaceFindState;    //�ص�����
    LDWORD          dwUser;             //�û�����
}NET_IN_FACE_FIND_STATE;

//CLIENT_AttachFaceFindState�ӿ��������
 typedef struct  tagNET_OUT_FACE_FIND_STATE
 {
    DWORD           dwSize;
 }NET_OUT_FACE_FIND_STATE;


// CLIENT_FaceRecognitionSetSearchImageInfo �ӿ��������
typedef struct tagNET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD               dwSize;
    int                 nChannel;                           // ��Ƶ����ͨ����
    char                szFilePath[DH_COMMON_STRING_256];   // ���ļ�·��,����ͼƬ·��
}NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;

// CLIENT_FaceRecognitionSetSearchImageInfo �ӿ��������
typedef struct tagNET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD                dwSize;
}NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;

///////////////////////////////// ��¼�ϴ� /////////////////////////////////

// fBurnCheckCallBack ����
typedef struct tagNET_CB_BURN_CHECK_STATE
{
    DWORD               dwSize;
    const char*         szType;                         // ��Ϣ����
                                                        // "Checking": У����
                                                        // "CheckResult": У����    
    BOOL                bCheckResult;                   // У����, ����"CheckResult", TRUE-�ɹ�, FALSE-ʧ��
    BYTE                byProgress;                     // У�����, ����"Checking", �ٷֱ�, 0~100
    BYTE                reserved[3];
} NET_CB_BURN_CHECK_STATE;

// ��¼У��ص�����ԭ��, lAttachHandle��CLIENT_AttachBurnCheckState�ķ���ֵ
typedef void (CALLBACK *fBurnCheckCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURN_CHECK_STATE* pstState, void* reserved, LDWORD dwUser);

// CLIENT_AttachBurnCheckState �ӿڵ��������(������¼У��״̬)
typedef struct tagNET_IN_ATTACH_BURN_CHECK 
{
    DWORD               dwSize;
    fBurnCheckCallBack  cbBurnCheck;                    // ��¼У��ص�
    LDWORD              dwUser;                         // �û�����
} NET_IN_ATTACH_BURN_CHECK;

// CLIENT_AttachBurnCheckState �ӿڵ��������(������¼У��״̬)
typedef struct tagNET_OUT_ATTACH_BURN_CHECK
{
    DWORD            dwSize;
} NET_OUT_ATTACH_BURN_CHECK;

///////////////////////////////// �߼��豸 /////////////////////////////////

typedef struct tagNET_CB_CAMERASTATE
{
    DWORD               dwSize;
    int                 nChannel;             // ͨ��
    CONNECT_STATE       emConnectState;       // ����״̬
}NET_CB_CAMERASTATE;

// CLIENT_AttachCameraState()�ص�����ԭ��, ÿ��1��,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fCameraStateCallBack) (LLONG lLoginID, LLONG lAttachHandle, const NET_CB_CAMERASTATE *pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachCameraState()�������
typedef struct tagNET_IN_CAMERASTATE
{
    DWORD                   dwSize;
    int *                   pChannels;              // �۲��ͨ����,����Ԫ����,��һ����-1,��۲�����ͨ��
													// ���û������ڴ棬��СΪsizeof(int)*nChannels
    int                     nChannels;              // pChannelsָ�볤��
    fCameraStateCallBack    cbCamera;               // ״̬�ص�����
    LDWORD                  dwUser;                 // �û�����
}NET_IN_CAMERASTATE;

typedef struct tagNET_OUT_CAMERASTATE
{
    DWORD                dwSize;
	int                  nObjectID;                 // ����ID,ÿ��ID��ʾһ��Ψһ������
}NET_OUT_CAMERASTATE;

/////////////////////////////////����汾/////////////////////////////////

// �����豸ץͼ,���ӿ�����Ϣ
typedef struct __NET_SNAP_COMMANDINFO 
{
    char                szCardInfo[16];             // ������Ϣ
    char                reserved[64];               // ����
} NET_SNAP_COMMANDINFO, LPNET_SNAP_COMMANDINFO;

typedef struct
{
    int                 nChannelNum;                // ͨ����
    char                szUseType[32];              // ͨ����;
    DWORD               dwStreamSize;               // ������С(��λ��kb/s)
    char                reserved[32];               // ����
} DHDEV_USE_CHANNEL_STATE;

typedef struct 
{
    char                szUserName[32];                     // �û���
    char                szUserGroup[32];                    // �û���
    NET_TIME            time;                               // ����ʱ��
    int                 nOpenedChannelNum;                  // �����ͨ������
    DHDEV_USE_CHANNEL_STATE    channelInfo[DH_MAX_CHANNUM];
    char                szIpAddress[DH_MAX_IPADDR_LEN_EX];  // ip��ַ
    char                reserved[24];
} DHDEV_USER_NET_INFO;

// ��������״̬��Ϣ
typedef    struct 
{
    int                 nUserCount;                      // �û�����
    DHDEV_USER_NET_INFO stuUserInfo[32];
    char                reserved[256];
}DHDEV_TOTAL_NET_STATE;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip��ַ
    char                szUserGroup[32];                 // �û���
    char                szUserName[32];                  // �û���
    char                reserved[64];
}DHDEV_USER_REJECT_INFO;

// �޳��û�
typedef struct
{ 
    int                       nUserCount;                // �û�����
    DHDEV_USER_REJECT_INFO    stuUserInfo[10];     
    char                      reserved[256];
}DHDEV_REJECT_USER;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip��ַ
    char                szUserGroup[32];                 // �û���
    char                szUserName[32];                  // �û���
    int                 nForbiddenTime;                  // ����ʱ��
    char                reserved[64];
}DHDEV_USER_SHIELD_INFO;

// �����û�
typedef struct
{ 
    int                       nUserCount;                // �û�����
    DHDEV_USER_SHIELD_INFO    stuUserInfo[10];     
    char                      reserved[256];
}DHDEV_SHIELD_USER;

// ��γ��
typedef struct
{//  ������ǰ,ά���ں�
    char                chPreLogi;        // ����ǰ�ñ�־��N��S��W��E,�ֱ��ʾ�����ϡ���������
    char                chPreLati;        // γ��ǰ�ñ�־��N��S��W��E,�ֱ��ʾ�����ϡ���������
    BYTE                reserved[6];      // �����ֽ�,����
    double              dbLongitude;      // ����
    double              dbLatitude;       // γ��
}DHDEV_LONGI_LATI;
// ������Ϣ�Ͷ���Ϣ
typedef struct
{
    char                szPhoneNum[DH_MAX_PHONE_NO_LEN];    // �绰����
    NET_TIME            stMsgTime;                          // ��Ϣ����ʱ��
    char                szMsgType[DH_MAX_MSGTYPE_LEN];      // ��Ϣ���ͣ�������Ϣ-Navigation�� ����Ϣ--SMS��
    char                szSmsContext[DH_MAX_MSG_LEN];       // ���͵���Ϣ����
    DHDEV_LONGI_LATI    stLogiLati;                         // ��ʼ��γ��
    unsigned int        uFlag;                              // 01����־����������ʵ��γ��
    char                szNavigationType[16];               // TNC,Ϊ�����µ�ͼ���ĵ�����ʽ,TXZ,Ϊ�����ߵ�ͼ���ĵ�����ʽ
    char                szAddress[32];                      // �ص���Ϣ
    char                szNavigationMode[32];               // ����ģʽ ��Recommend�Ƽ�,Economical������,Fastest ��죻Shortest ��̣�
    DHDEV_LONGI_LATI    stPassLogiLati[5];                  // ���ɵ�
    DHDEV_LONGI_LATI    stNoPassLogiLati[5];                // �����ɵ�
    BYTE                reserved[256];
}DHDEV_NAVIGATION_SMSS;

// ͼ��ˮӡ����
typedef struct __DHDEV_WATERMAKE_CFG 
{
    DWORD               dwSize;
    int                 nEnable;                                // ʹ��
    int                 nStream;                                // ����(1��n)0-��������
    int                 nKey;                                   // ��������(1-����,2-ͼƬ)
    char                szLetterData[DH_MAX_WATERMAKE_LETTER];  //    ����
    char                szData[DH_MAX_WATERMAKE_DATA];          // ͼƬ����
    BYTE                bReserved[512];                         // ����
} DHDEV_WATERMAKE_CFG;

// �洢λ�����ýṹ��,ÿͨ����������,ÿͨ������ѡ����ִ洢����, Ŀǰ��������, ���ƶ�, Զ�̴洢.
typedef struct 
{
    DWORD               dwSize;
    DWORD               dwLocalMask;                            // ���ش洢���룻��λ��ʾ��
                                                                // ��һλ��ϵͳԤ¼,�ڶ�λ����ʱ¼��,����λ������¼��,
                                                                // ����λ������¼��,����λ������¼��,����λ���ֶ�¼��
    DWORD               dwMobileMask;                           // ���ƶ��洢���� �洢�����籾�ش洢����
    int                 RemoteType;                             // Զ�̴洢���� 0: Ftp  1: Smb 
    DWORD               dwRemoteMask;                           // Զ�̴洢���� �洢�����籾�ش洢����
    DWORD               dwRemoteSecondSelLocal;                 // Զ���쳣ʱ���ش洢����
    DWORD               dwRemoteSecondSelMobile;                // Զ���쳣ʱ���ƶ��洢����
    char                SubRemotePath[MAX_PATH_STOR];           // Զ��Ŀ¼, ���г���Ϊ240
    DWORD               dwFunctionMask;                         // ��������λ,��λ��ʾ,bit0 = 1:����ץͼ�¼������洢λ�ù���
    DWORD               dwAutoSyncMask;                         // �Ƿ�ͬ������;Զ�̴洢������ϻָ���,�Զ������ش洢������ͬ����Զ�̴洢��
    BYTE                bAutoSyncRange;                         // ������ָ���ʱ�̿�ʼ,��Ҫ��ǰͬ��������ʱ�䷶Χ,СʱΪ��λ��0:ͬ����������  1:1Сʱ�ڵ����� n:nСʱ�ڵ�����
    char                reserved[119];
} DH_STORAGE_STATION_CFG;

#define MAX_ALARM_DECODER_NUM 16
typedef struct  
{
    DWORD               dwAlarmDecoder;             // �������֧��8�����������,��8λ���Ժ���չ
    BYTE                bDecoderIndex;              // ��ʾ�ڼ�������������
    BYTE                bReserved[3];
} ALARM_DECODER;

// ��������������
typedef struct
{
    int                 nAlarmDecoderNum;
    ALARM_DECODER       stuAlarmDecoder[MAX_ALARM_DECODER_NUM];
    BYTE                bReserved[32];
} ALARM_DECODER_ALARM;

//DSP����
typedef struct  
{
    BOOL                bError;             //0,DSP���� 1,DSP�쳣
    DWORD               dwErrorMask;        //��λ��ʾ,��0��ʾ�д˴���,0��ʾû�С�(Ŀǰÿ�α���ֻ��һλ��Ч)
                                            //bit DSP����
                                            // 1  DSP����ʧ�� 
                                            // 2  DSP����
                                            // 3  ��ʽ���� 
                                            // 4  �ֱ��ʲ�֧��
                                            // 5  ���ݸ�ʽ��֧��
                                            // 6  �Ҳ���I֡
    DWORD               dwDecChnnelMask;    //��λ��ʾ,�����Ľ���ͨ����,dwErrorMaskΪDSP����,��ʽ����,�ֱ��ʲ�֧��,���ݸ�ʽ��֧��ʱ������Ч
    DWORD               dwDecChnnelMask1;   //��λ��ʾ,33-64ͨ���ı����Ľ���ͨ����, dwErrorMaskΪDSP����,��ʽ����,�ֱ��ʲ�֧��,���ݸ�ʽ��֧��ʱ������Ч
    BYTE                bReserved[24];
}DSP_ALARM;

// ���˱�����������
typedef struct  
{
    int         nFDDINum;
    BYTE        bAlarm[256];
} ALARM_FDDI_ALARM;

#define ALARM_PTZ_LOCATION_INFO DH_PTZ_LOCATION_INFO

// ����Ƶ��ⱨ������
typedef struct
{
    BOOL                bEnable;                    // ��������ʹ��
    int                 Volume_min;                 // ��������Сֵ
    int                 Volume_max;                 // ���������ֵ
    char                reserved[128];    
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];    
    DH_MSG_HANDLE       struHandle;                 // ����ʽ
} DH_AUDIO_DETECT_INFO;

typedef struct  
{
    DWORD                   dwSize;
    int                     AlarmNum;
    DH_AUDIO_DETECT_INFO    AudioDetectAlarm[DH_MAX_AUDIO_IN_NUM];
    char                    reserved[256];
} DH_AUDIO_DETECT_CFG;

typedef struct
{
    BOOL                bTourEnable;                // ��Ѳʹ��
    int                 nTourPeriod;                // ��Ѳ���,��λ��, 5-300 
    DWORD               dwChannelMask;              // ��Ѳ��ͨ��,������ʽ��ʾ
    char                reserved[64];
}DH_VIDEOGROUP_CFG;

// ����������Ʋ�������
typedef struct
{
    DWORD               dwSize;
    int                 nMatrixNum;                 // �������(ע���������޸�)
    DH_VIDEOGROUP_CFG   struVideoGroup[DH_MATRIX_MAXOUT];
    char                reserved[32];
} DHDEV_VIDEO_MATRIX_CFG;   

// WEB·������
typedef struct 
{
    DWORD               dwSize;
    BOOL                bSnapEnable;                    // �Ƿ�ץͼ
    int                 iSnapInterval;                  // ץͼ����
    char                szHostIp[DH_MAX_IPADDR_LEN];    // HTTP����IP
    WORD                wHostPort;
    int                 iMsgInterval;                   // ״̬��Ϣ���ͼ��
    char                szUrlState[DH_MAX_URL_LEN];     // ״̬��Ϣ�ϴ�URL
    char                szUrlImage[DH_MAX_URL_LEN];     // ͼƬ�ϴ�Url
    char                szDevId[DH_MAX_DEV_ID_LEN];     // ������web���
    BYTE                byReserved[2];
} DHDEV_URL_CFG;

// OEM��ѯ
typedef struct  
{
    char                szVendor[DH_MAX_STRING_LEN];
    char                szType[DH_MAX_STRING_LEN];
    char                reserved[128];
} DHDEV_OEM_INFO;


//��ƵOSD��������
typedef struct 
{ 
    DWORD   rgbaFrontground;            // �����ǰ�������ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����
    DWORD   rgbaBackground;             // ����ı��������ֽڱ�ʾ,�ֱ�Ϊ�졢�̡�����͸����    
    RECT    rcRelativePos;              // λ��,����߾��������ı���*8191    
    BOOL    bPreviewBlend;              // Ԥ������ʹ��    
    BOOL    bEncodeBlend;               // �������ʹ��
    BYTE    bReserved[4];               // ����
} DH_DVR_VIDEO_WIDGET;

typedef struct 
{
    DH_DVR_VIDEO_WIDGET     StOSD_POS;                                 // OSD���ӵ�λ�úͱ���ɫ
    char                    SzOSD_Name[DH_VIDEO_OSD_NAME_NUM];         // OSD���ӵ�����
}DH_DVR_VIDEOITEM;
 
// ÿ��ͨ����OSD��Ϣ
typedef struct 
{
    DWORD                   dwSize;
    DH_DVR_VIDEOITEM        StOSDTitleOpt [DH_VIDEO_CUSTOM_OSD_NUM];    // ÿ��ͨ����OSD��Ϣ
    BYTE                    bReserved[16];                              // ����
} DH_DVR_VIDEOOSD_CFG;

// ����CDMA/GPRS������Ϣ
// ʱ��νṹ                                                                
typedef struct 
{
    BYTE                bEnable;                  // ʱ���ʹ��,1��ʾ��ʱ�����Ч,0��ʾ��ʱ�����Ч��
    BYTE                bBeginHour;
    BYTE                bBeginMin;
    BYTE                bBeginSec;
    BYTE                bEndHour;
    BYTE                bEndMin;
    BYTE                bEndSec;
    BYTE                bReserved;                //����
} DH_3G_TIMESECT, *LPDH_3G_TIMESECT;

typedef struct 
{
    DWORD               dwSize;
    BOOL                bEnable;                        // ����ģ��ʹ�ܱ�־
    DWORD               dwTypeMask;                     // �豸֧��������������;��λ��ʾ,��һλ;�Զ�ѡ��;
                                                        // �ڶ�λ��TD-SCDMA���磻����λ��WCDMA����;
                                                        // ����λ��CDMA 1.x����;����λ��CDMA2000����;����λ��GPRS����;
                                                        // ����λ��EVDO����;�ڰ�λ��WIFI
    DWORD               dwNetType;                      // ��ǰ��������������,ΪEM_GPRSCDMA_NETWORK_TYPEֵ
    char                szAPN[128];                     // ���������
    char                szDialNum[128];                 // ���ź���
    char                szUserName[128];                // �����û���
    char                szPWD[128];                     // ��������
    
    /* �������豸��ֻ������ */
    BOOL                iAccessStat;                    // ��������ע��״̬
    char                szDevIP[16];                    // ǰ���豸����IP,�ַ���, ����'\0'��������16byte  
    char                szSubNetMask [16];              // ǰ���豸������������,�ַ���, ����'\0'��������16byte 
    char                szGateWay[16];                  // ǰ���豸��������,�ַ���, ����'\0'��������16byte 
    /* �������豸��ֻ������ */
    int                 iKeepLive;                      // ����ʱ��
    DH_3G_TIMESECT      stSect[DH_N_WEEKS][DH_N_TSECT]; // 3G����ʱ���,��Чʱ���֮��,����ţ���Чʱ���֮��,�رղ��š�
    BYTE                byActivate;                     // �Ƿ���Ҫ���������ż���

    BYTE                bySimStat;                      // SIM(UIM)״̬:����1,������0  (ֻ������) ռ��Reserved��1���ֽ�
    char                szIdentify[128];                // ��Ȩ��ʽ
    bool                bPPPEnable;                     // PPP����,0-�Ͽ�ppp����,1-ppp����
    BYTE                bPPPState;                      // PPP����״̬(ֻ��),���庬���EM_MOBILE_PPP_STATE
    BYTE                bNetCardState;                  // ��������״̬(ֻ��),���庬���EM_3GMOBILE_STATE
    char                szPhyCardNo[32];                // ������
    char                Reserved[4];                    // �����ֽ�,������չ
    BYTE                byPinShow;                      // PIN���Ƿ���ʾ(ֻ��), 0-��֧��, 1-��ʾ, 2-����ʾ
    BYTE                byPinEnable;                    // PIN������ʹ��(ֻ��), 0-��ʹ��, 1-ʹ��
    BYTE                byPinCount;                     // PIN��ʣ�����ô���(ֻ��), 0~3
    //-------------------------------�����ֶ�����dwSize�����Ч------------------------------------
    char                szPinNo[16];                    // PIN��ֵ, ��ĸ�����ֵ��������
} DHDEV_CDMAGPRS_CFG;

// ¼������������
typedef struct  
{
    DWORD               dwSize;
    int                 nType;                          // 0:��ʱ��,1������С
    int                 nValue;                         // nType = 0ʱ:��λ����,nType = 1ʱ:��λKB
    char                Reserved[128];                  // �����ֽ�,������չ
} DHDEV_RECORD_PACKET_CFG;

// (����)����ע���������Ϣ
typedef struct __DEV_AUTOREGISTER_INFO 
{
    LONG            lConnectionID;                      // ����ID
    char            szServerIp[DH_MAX_IPADDR_LEN];      // ����ע���������IP
    int             nPort;                              // ����ע��������˿�0- 65535
    int             nState;                             // ��������״̬��0��ע��ʧ�ܣ�1-ע��ɹ�; 2-����ʧ��
    char            reserved[16];
} DEV_AUTOREGISTER_INFO;

typedef struct __DEV_SERVER_AUTOREGISTER 
{
    DWORD                    dwSize;
    int                      nRegisterSeverCount;                                            // ����ע�����������
    DEV_AUTOREGISTER_INFO    stuDevRegisterSeverInfo[DH_CONTROL_AUTO_REGISTER_NUM];            // ������ע���������Ϣ
    char                     reserved[256];
} DEV_SERVER_AUTOREGISTER, *LPDEV_SERVER_AUTOREGISTER;

// ������¼�����ϴ�
typedef struct
{
    DWORD               dwSize;        
    char                szSourFile[MAX_PATH_STOR];    // Դ�ļ�·��
    int                 nFileSize;                    // Դ�ļ���С,���С�ڵ���0,sdk���м����ļ���С.
    char                szBurnFile[MAX_PATH_STOR];    // ��¼����ļ���
    BYTE                bReserved[64];
} DHDEV_BURNFILE_TRANS_CFG;

// �����ļ��ϴ�
typedef struct
{
    char                 szFile[MAX_PATH_STOR];      // �����ļ�·��
    int                  nFileSize;                  // �����ļ���С 
    BYTE                 byChannelId;                // ͨ����
    BYTE                 byManufactryType;           // ��������,���EM_IPC_TYPE
    BYTE                 byReserved[126];            // ����      
}DHDEV_UPGRADE_FILE_INFO;

// �ڰ������ϴ�
typedef struct  
{
    char                 szFile[MAX_PATH_STOR];     // �ڰ������ļ�·��
    int                  nFileSize;                 // �����ļ���С
    BYTE                 byFileType;                // ��ǰ�ļ�����,0-������,1-������ 
    BYTE                 byAction;                  // ����,0-����,1-׷��
    BYTE                 byReserved[126];           // ����
}DHDEV_BLACKWHITE_LIST_INFO;

// �ڰ���������
typedef struct
{
    char                 szFile[MAX_PATH_STOR];     // �ڰ������ļ�����·��
    BYTE                 byFileType;                // ��ǰ�ļ�����,0-������,1-������
    BYTE                 byReserved[127];           // ����
}DHDEV_LOAD_BLACKWHITE_LIST_INFO;

// ֣������ķEC_U��Ƶ���ݵ���ʹ������
typedef struct 
{
    BOOL                bEnable;                    // ʹ��
    int                 nPort;                      // �˿�
    BYTE                bReserved[64];
} DHDEV_OSD_ENABLE_CFG;

// �����������:��������ʹ������
typedef struct    
{
    BOOL                bAutoBootEnable;                //�Զ�����ʹ��
    DWORD               dwAutoBootTime;                 //ÿ���Զ�����ʱ���, ��λ��,��0����.[0,82800]
    BOOL                bAutoShutDownEnable;            //�Զ��ػ�ʹ��
    DWORD               dwAutoShutDownTime;             //ÿ���Զ��ػ�ʱ���, ��λ��,��0����.[0,82800]
    DWORD               dwShutDownDelayTime;            //��ʱ�ػ�ʱ��,��λ��.
    BYTE                bEventNoDisk;                   //1,(Ignore:����); 2,(Reboot:����ϵͳ)
    BYTE                bWifiEnable;                    //�Ƿ�֧�ֳ�������ģ��.
    BYTE                bUpperSpeedEnable;              //�Ƿ�ʹ�ó����ж�
    BYTE                bLowerSpeedEnable;              //�Ƿ�ʹ�õ����ж�
    DWORD               dwUpperSpeedValue;              //����ֵ������(1,1000).����/Сʱ
    DWORD               dwLowerSpeedValue;              //����ֵ������(1,1000).����/Сʱ
    DWORD               dwUpperSpeedDelayTime;          //���ó��ٳ���ֵ
    DWORD               dwLowerSpeedDelayTime;          //���õ��ٳ���ֵ
    DWORD               dwAlarmMaskEnable;              //��ѯ/���õ��ӱ�����Ϣʹ��,0:�ر�,1:��, ÿһλ�ӵ͵��߱�ʾ�����ⲿ����ͨ��0-Nʹ��
    BOOL                bSpeedOverAlarmRecordEnable;    // ���ٱ�������¼��ʹ��
    BOOL                bSpeedLowAlarmRecordEnable;     // ���ٱ�������¼��ʹ�� 
    BYTE                bReserved[480];                 //reserved byte.
} DHDEV_ABOUT_VEHICLE_CFG;

// atm:��ѯ�������������Ϣ
typedef struct  
{
    DWORD               dwDataSource;                   //��λ, λ0:Net(����), λ1:Com(����), λ2:Com422(����422)
    char                szProtocol[32][33];             //Э������,��󳤶�32(����һ��������).
    BYTE                bReserved[256];
} DHDEV_ATM_OVERLAY_GENERAL;
 
// atm:���õ�������
typedef struct 
{
    DWORD               dwDataSource;                   // 1:Net(����), 2:Com(����), 3:Com422(����422)
    char                szProtocol[33];                 // Э������,��DHDEV_ATM_OVERLAY_GENERAL����
    BYTE                bReserved_1[3];
    DWORD               dwChannelMask;                  // ���ӵ�ͨ����,�����ʾ��
    BYTE                bMode;                          // 1:Preview(Ԥ������), 2:Encode(�������), 3:Preview&Encode(Ԥ���ͱ������)
    BYTE                bLocation;                      // 1:LeftTop(����), 2:LeftBottom(����), 3:RightTop(����), 4:RightBottom(����)
    BYTE                bReserved_3[2];           
    int                 nLatchTime;                     // ������ʾ�ӳ�ʱ��,����¼����ʱ�ر�ʱ��,0~65535s
    BYTE                bReserved_4[3];
    BYTE                bRecordSrcKeyNum;               // �ؼ��ָ���  
    int                 nRecordSrcKey[32];              // ����Ƶͨ����Ӧ����Դ�ؼ���(��ͬͨ�����Զ�Ӧ��ͬ������Դ)  
    BYTE                bReserved_2[120];
} DHDEV_ATM_OVERLAY_CONFIG;


// atm:���õ�������
typedef struct 
{
    DWORD               dwSize;                         // �ṹ���С
    DWORD               dwDataSource;                   // 1:Net(����), 2:Com(����), 3:Com422(����422)
    char                szProtocol[33];                 // Э������,
    BYTE                bReserved_1[3];
    DWORD               dwChannelMask[8];               // ���ӵ�ͨ����,�����ʾ, dwChannelMask[0]��ʾ0-31ͨ��,�������ơ�
    BYTE                bMode;                          // 1:Preview(Ԥ������), 2:Encode(�������), 3:Preview&Encode(Ԥ���ͱ������)
    BYTE                bLocation;                      // 1:LeftTop(����), 2:LeftBottom(����), 3:RightTop(����), 4:RightBottom(����)
    BYTE                bReserved_3[2];           
    int                 nLatchTime;                     // ������ʾ�ӳ�ʱ��,����¼����ʱ�ر�ʱ��,0~65535s
    BYTE                bReserved_4[3];
    BYTE                bRecordSrcKeyNum;               // �ؼ��ָ���  
    int                 nRecordSrcKey[256];             // ����Ƶͨ����Ӧ����Դ�ؼ���(��ͬͨ�����Զ�Ӧ��ͬ������Դ)  
} DHDEV_ATM_OVERLAY_CONFIG_EX;

// �״����á�������
typedef struct tagNET_RADAR_CARSPEED_INFO
{

    int                 nTriggerLower;                  // ����ֵ����  ��Χ 1~255km/h
    int                 nTriggerUpper;                  // ����ֵ����  ��Χ 1~255km/h
    int                 nLimitLower;                    // ����ֵ����  ��Χ 5~255km/h
    int                 nLimitUpper;                    // ����ֵ����  ��Χ 5~255km/h
} NET_RADAR_CARSPEED_INFO;

// ���״����� 
typedef struct tagDEV_DAHUA_RADAR_CONFIG
{
    int							nAngle;                         // �Ƕȣ����������״�̽ͷ��װ�ĽǶ���ɵ��ٶ���� ��λ�ȣ���Χ0~45
    BOOL						bLowSpeed;                      // �Ƿ����õ����٣�Ϊ TRUE NET_RADAR_CARSPEED_INFO �ṹ�и�����ֵ��Ч
    BOOL						bSpeedForSize;                  // �Ƿ����ô�С�����٣�Ϊ FALSE ʱ��С���ٶ����ã�stuSmallCarSpeed����Ч
    NET_RADAR_CARSPEED_INFO     stuSmallCarSpeed;               // С���ٶ����ã�bSpeedForSize Ϊ TRUE ʱ nTriggerLower ��ԱͬʱҲ�����г��ʹ󳵵Ĵ���ֵ����
    NET_RADAR_CARSPEED_INFO     stuMediumCarSpeed;              // �г��ٶ����ã�bSpeedForSize Ϊ TRUE ʱ��Ч���� nTriggerLower ��Աʼ����Ч
    NET_RADAR_CARSPEED_INFO     stuBigCarSpeed;                 // ���ٶ����ã�bSpeedForSize Ϊ TRUE ʱ��Ч���� nTriggerLower ��Աʼ����Ч
    char						szName[256];                    // �豸��װ��ַ
    int							nSensitivity;                   // ����� ��Χ0~5��0���
    int							nDetectMode;                    // ���ģʽ��ȡֵ��-1 ������ 0 ǰ������ 1 ǰ��ȥ�� 2 �������� 3 ����ȥ�� 4 ǰ��˫�� 5 ����˫��
	BYTE						bReserved[1024];
} DEV_DAHUA_RADAR_CONFIG;

// �״�����
typedef struct tagDEV_RADAR_CONFIG
{	
	DWORD							dwSize;
	BOOL							bEnable;                          		// �Ƿ�����
	int								nPort;							  		// ���ڶ˿ں�
	DH_COMM_PROP					stuCommAttr;							// ��������
	int								nAddress;								// �豸��ַ����������Ϲ��˶�������豸��ͨ����ַ����
	int								nPreSpeedWait;							// �ٶ���������µȴ�ʱ�䣬�ٶ���ʱ��δץ�� ��Χ (1 -- 5000ms)
	int								nDelaySpeedWait;						// �ٶȺ�������µȴ�ʱ�䣬ץ��ʱ��û�����ٶ� ��Χ (1 -- 5000ms)
	BOOL							bDahuaRadarEnable;						// ���״������Ƿ����
	DEV_DAHUA_RADAR_CONFIG			stuDhRadarConfig;						// ���״��������
}DEV_RADAR_CONFIG;


#define DH_MAX_BACKUPDEV_NUM            16
#define DH_MAX_BACKUP_NAME              32

// �����豸�б�
typedef struct 
{
    int                 nBackupDevNum;                                // ʵ�ʵı����豸����
    char                szBackupDevNames[DH_MAX_BACKUPDEV_NUM][DH_MAX_BACKUP_NAME]; // �����豸������
} DHDEV_BACKUP_LIST, *LPDHDEV_BACKUP_LIST;

// �����豸��������
typedef enum __BACKUP_TYPE
{
    BT_DHFS = 0,                            // ˽���ļ�ϵͳ
    BT_DISK,                                // �ƶ�Ӳ��
    BT_CDRW                                 // ���̿�¼
} DHDEV_BACKUP_TYPE;    

// �����豸�ӿ�����
typedef enum __BACKUP_BUS
{
    BB_USB = 0,                             // usb�ӿ�
    BB_1394,                                // 1394�ӿ�
    BB_IDE,                                 // ide�ӿ�
    BB_ESATA,                               // esata�ӿ�
} DHDEV_BACKUP_BUS;    

typedef struct 
{
    char                szName[32];                     // �豸�� 
    BYTE                byType;                         // �����豸�Ľ������� ö��ֵ��BACKUP_TYPE
    BYTE                byBus;                          // �����豸�Ľӿ����� ö��ֵ��BACKUP_BUS
    UINT                nCapability;                    // ������, ��kBytesΪ��λ
    UINT                nRemain;                        // ʣ������,��kBytesΪ��λ
    char                szDirectory[128];               // Զ�̱��ݵ�Ŀ¼
} DHDEV_BACKUP_INFO, *LPDHDEV_BACKUP_INFO;

typedef struct 
{
    char                szName[32];                     // �豸�� 
    UINT                nCapability;                    // ������, ��kBytesΪ��λ
    UINT                nRemain;                        // ��ǰ����ʣ������,��kBytesΪ��λ
} DHDEV_BACKUP_FEEDBACK, *LPDHDEV_BACKUP_FEEDBACK;

#define  DH_MAX_BACKUPRECORD_NUM 1024

typedef struct  
{
    char                szDeviceName[DH_MAX_BACKUP_NAME];            //�����豸����
    int                 nRecordNum;                                  //���ݼ�¼����
    NET_RECORDFILE_INFO stuRecordInfo[DH_MAX_BACKUPRECORD_NUM];      //���ݼ�¼��Ϣ
} BACKUP_RECORD, *LPBACKUP_RECORD;

// ��ͨ������Ƶ����
typedef struct
{
    int                 iChannelID;      // ͨ����
    DH_RealPlayType     realplayType;    // ��Ƶ����
    char                reserve[32];
}DHDEV_IN_MULTIPLAY_PARAM;

// ��ͨ������Ƶ���
typedef struct
{
    int                 iChannelID;      // ͨ����
    LLONG               lRealHandle;     // ʵʱ���Ӿ��
    char                reserve[32];
}DHDEV_OUT_MULTIPLAY_PARAM;


/////////////////////////////////ƽ̨����/////////////////////////////////

// ƽ̨�������� �� U��ͨ
typedef struct
{
    BOOL                bChnEn;
    char                szChnId[DH_INTERVIDEO_UCOM_CHANID];
} DH_INTERVIDEO_UCOM_CHN_CFG;

typedef struct
{
    DWORD               dwSize;
    BOOL                bFuncEnable;                            // ���빦��ʹ��
    BOOL                bAliveEnable;                           // ����ʹ��
    DWORD               dwAlivePeriod;                          // ��������,��λ��,0-3600
    char                szServerIp[DH_MAX_IPADDR_LEN];          // CMS��IP
    WORD                wServerPort;                            // CMS��Port
    char                szRegPwd[DH_INTERVIDEO_UCOM_REGPSW];    // ע������
    char                szDeviceId[DH_INTERVIDEO_UCOM_DEVID];   // �豸id
    char                szUserName[DH_INTERVIDEO_UCOM_USERNAME];
    char                szPassWord[DH_INTERVIDEO_UCOM_USERPSW];
    DH_INTERVIDEO_UCOM_CHN_CFG  struChnInfo[DH_MAX_CHANNUM];    // ͨ��id,en
} DHDEV_INTERVIDEO_UCOM_CFG;

// ƽ̨�������� �� ��������
typedef struct
{
    DWORD               dwSize;
    unsigned short      usCompanyID[2];             // ��˾ID,��ֵ,��ͬ�ĵ���������˾,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szDeviceNO[32];             // ǰ���豸���к�,�ַ���,����'\0'��������32byte
    char                szVSName[32];               // ǰ���豸����,�ַ���,����'\0'��������16byte
    char                szVapPath[32];              // VAP·��
    unsigned short      usTcpPort;                  // TCP�˿�,��ֵ����ֵ 1~65535 
    unsigned short      usUdpPort;                  // UDP�˿�,��ֵ����ֵ 1~65535
    bool                bCsEnable[4];               // ���ķ�����ʹ�ܱ�־,��ֵ��trueʹ��,false��ʹ��,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szCsIP[16];                 // ���ķ�����IP��ַ,�ַ���,����'\0'��������16byte
    unsigned short      usCsPort[2];                // ���ķ������˿�,��ֵ����ֵ 1~65535,����4�ֽڶ���,Ŀǰֻ�������һ��
    bool                bHsEnable[4];               // ����������ʹ�ܱ�־,��ֵ��trueʹ��,false��ʹ��,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szHsIP[16];                 // ����������IP��ַ,�ַ���,����'\0'��������16byte
    unsigned short      usHsPort[2];                // �����������˿�,��ֵ����ֵ 1~65535,����4�ֽڶ���,Ŀǰֻ�������һ��
    int                 iHsIntervalTime;            // �����������������,��ֵ(��λ:��)
    bool                bRsEnable[4];               // ע�������ʹ�ܱ�־,��ֵ��trueʹ��,false��ʹ��,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szRsIP[16];                 // ע�������IP��ַ,�ַ���,����'\0'��������16byte
    unsigned short      usRsPort[2];                // ע��������˿�,��ֵ����ֵ 1~65535,����4�ֽڶ���,Ŀǰֻ�������һ��
    int                 iRsAgedTime;                // ע���������Чʱ��,��ֵ(��λ:Сʱ)
    char                szAuthorizeServerIp[16];    // ��Ȩ������IP
    unsigned short      usAuthorizePort[2];         // ��Ȩ�������˿�,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szAuthorizeUsername[32];    // ��Ȩ�������ʺ�
    char                szAuthorizePassword[36];    // ��Ȩ����������
    
    char                szIpACS[16];                // ACS(�Զ�ע�������) IP
    unsigned short      usPortACS[2];               // ACS Port,����4�ֽڶ���,Ŀǰֻ�������һ��
    char                szUsernameACS[32];          // ACS�û���
    char                szPasswordACS[36];          // ACS����
    bool                bVideoMonitorEnabled[4];    // DVS�Ƿ����ϱ�ǰ����Ƶ�źż����Ϣ,��ֵ��trueʹ��,false��ʹ��
    int                 iVideoMonitorInterval;      // �ϱ�����(����)
    
    char                szCoordinateGPS[64];        // GPS����
    char                szPosition[32];             // �豸λ��
    char                szConnPass[36];             // �豸������
} DHDEV_INTERVIDEO_BELL_CFG;

// ƽ̨�������� �� ������ά
typedef struct  
{
    DWORD               dwSize;
    unsigned short      nSevPort;                               // �������˿�,��ֵ,��ֵ1~65535
    char                szSevIp[DH_INTERVIDEO_NSS_IP];          // ������IP��ַ,�ַ���,����'\0'��������32byte
    char                szDevSerial[DH_INTERVIDEO_NSS_SERIAL];  // ǰ���豸���к�,�ַ���,����'\0'��������32byte
    char                szUserName[DH_INTERVIDEO_NSS_USER];
    char                szPwd[DH_INTERVIDEO_NSS_PWD];
} DHDEV_INTERVIDEO_NSS_CFG;

// ƽ̨�������� �� ������
typedef struct  
{
    char               szDevSerial[DH_INTERVIDEO_AMP_DEVICESERIAL];                  //ǰ���豸���к�,�������������к�,�ò���ֻ��
    char               szDevName[DH_INTERVIDEO_AMP_DEVICENAME];                      //ǰ���豸����,������������,�ò���ֻ��
    char               szRegUserName[DH_INTERVIDEO_AMP_USER];                        //ע��������û���
    char               szRegPwd[DH_INTERVIDEO_AMP_PWD];                              //ע�����������
    BYTE               bReserved[128];
} DHDEV_INTERVIDEO_AMP_CFG;  
////////////////////////////////HDVRר��//////////////////////////////////
// ����������չ�ṹ��
typedef struct 
{
    /* ��Ϣ����ʽ,����ͬʱ���ִ���ʽ,����
     * 0x00000001 - �����ϴ�
     * 0x00000002 - ����¼��
     * 0x00000004 - ��̨����
     * 0x00000008 - �����ʼ�
     * 0x00000010 - ������Ѳ
     * 0x00000020 - ������ʾ
     * 0x00000040 - �������
     * 0x00000080 - Ftp�ϴ�
     * 0x00000100 - ����
     * 0x00000200 - ������ʾ
     * 0x00000400 - ץͼ
    */

    /* ��ǰ������֧�ֵĴ���ʽ,��λ�����ʾ */
    DWORD               dwActionMask;

    /* ��������,��λ�����ʾ,���嶯������Ҫ�Ĳ����ڸ��Ե����������� */
    DWORD               dwActionFlag;
    
    /* �������������ͨ��,�������������,Ϊ1��ʾ��������� */ 
    BYTE                byRelAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
    DWORD               dwDuration;                                 /* ��������ʱ�� */

    /* ����¼�� */
    BYTE                byRecordChannel[DH_MAX_VIDEO_IN_NUM_EX];    /* ����������¼��ͨ��,Ϊ1��ʾ������ͨ�� */
    DWORD               dwRecLatch;                                 /* ¼�����ʱ�� */

    /* ץͼͨ�� */
    BYTE                bySnap[DH_MAX_VIDEO_IN_NUM_EX];
    /* ��Ѳͨ�� */
    BYTE                byTour[DH_MAX_VIDEO_IN_NUM_EX];             /* ��Ѳͨ�� 0-31·*/

    /* ��̨���� */
    DH_PTZ_LINK         struPtzLink[DH_MAX_VIDEO_IN_NUM_EX];
    DWORD               dwEventLatch;                               /* ������ʼ��ʱʱ��,sΪ��λ,��Χ��0~15,Ĭ��ֵ��0 */
    /* �����������������ͨ��,�������������,Ϊ1��ʾ��������� */ 
    BYTE                byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
    BYTE                bMessageToNet;
    BYTE                bMMSEn;                                     /*���ű���ʹ��*/
    BYTE                bySnapshotTimes;                            /*���ŷ���ץͼ���� */
    BYTE                bMatrixEn;                                  /*!< ����ʹ�� */
    DWORD               dwMatrix;                                   /*!< �������� */            
    BYTE                bLog;                                       /*!< ��־ʹ��,Ŀǰֻ����WTN��̬�����ʹ�� */
    BYTE                bSnapshotPeriod;                            /*!<ץͼ֡���,ÿ�����֡ץһ��ͼƬ,һ��ʱ����ץ�ĵ���������ץͼ֡���йء�0��ʾ����֡,����ץ�ġ�*/
    BYTE                byTour2[DH_MAX_VIDEO_IN_NUM_EX];            /* ��Ѳͨ�� 32-63·*/
    BYTE                byEmailType;                                /*<0,ͼƬ����,1,¼�񸽼�>*/
    BYTE                byEmailMaxLength;                           /*<����¼��ʱ����󳤶�,��λMB>*/
    BYTE                byEmailMaxTime;                             /*<������¼��ʱ���ʱ�䳤��,��λ��>*/
    BYTE                byReserved[475];   
} DH_MSG_HANDLE_EX;

// �ⲿ������չ
typedef struct
{
    BYTE                byAlarmType;                        // ����������,0������,1������
    BYTE                byAlarmEn;                          // ����ʹ��
    BYTE                byReserved[2];                        
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struHandle;                         // ����ʽ
} DH_ALARMIN_CFG_EX, *LPDHDEV_ALARMIN_CFG_EX; 

// ��̬��ⱨ��
typedef struct 
{
    BYTE                byMotionEn;                         // ��̬��ⱨ��ʹ��
    BYTE                byReserved;
    WORD                wSenseLevel;                        // �����
    WORD                wMotionRow;                         // ��̬������������
    WORD                wMotionCol;                         // ��̬������������
    BYTE                byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // �������,���32*32������
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX        struHandle;                     //����ʽ
} DH_MOTION_DETECT_CFG_EX;


// �𾯱���
typedef struct
{
    BOOL                byFireEn;              // �𾯱���ʱ�ܣ�
    DH_MSG_HANDLE_EX    struHandle;            // ����ʽ
    BYTE                byReserved[128];
}DHDEV_FIRE_ALARM_CFG;

// ��̬��ⱨ�� 
typedef struct 
{
    BYTE                byStaticEn;                         // ��̬��ⱨ��ʹ��
    BYTE                byLatch;                            // �����ʱ(��Χ0-127,�����Χ����nLatch)    
    WORD                wSenseLevel;                        // �����
    WORD                wStaticRow;                         // ��̬������������
    WORD                wStaticCol;                         // ��̬������������
    BYTE                byDetected[DH_STATIC_ROW][DH_STATIC_COL]; // �������,���32*32������
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // ����ʽ
    int                 nLatch;                             // �����ʱ
    BYTE                bReserved[64];                      // �����ֶ�
} DH_STATIC_DETECT_CFG_EX;

// ACC���߱����¼�����
typedef struct _DHDEV_ACC_POWEROFF_CFG
{
    BOOL                bEnable;               // ACC���߱���ʹ��
    int                 nDelayTime;            // ACC���߱�����ʱʱ��,��λ����
    DH_MSG_HANDLE_EX    struHandle;            // ����ʽ
    BYTE                Reserved[128];         // �����ֶ�
}DHDEV_ACC_POWEROFF_CFG;

// �����б����¼�����
typedef struct _DHDEV_EXPLOSION_PROOF_CFG
{
    BOOL                bEnable;               // �����б���ʹ��
    DH_MSG_HANDLE_EX    struHandle;            // ����ʽ
    BYTE                Reserved[128];         // �����ֶ�
}DHDEV_EXPLOSION_PROOF_CFG;

// Raid�¼�����
typedef struct _DHDEV_RAID_EVENT_CFG
{
    BOOL                bEnable;               // Raid�¼�ʹ��
    DH_MSG_HANDLE_EX    struHandle;            // ����ʽ
    BYTE                Reserved[128];         // �����ֶ�
}DHDEV_RAID_EVENT_CFG;

// ��Ƶ��ʧ����
typedef struct
{
    BYTE                byAlarmEn;                          // ��Ƶ��ʧ����ʹ��
    BYTE                byReserved[3];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // ����ʽ
} DH_VIDEO_LOST_CFG_EX;

// ͼ���ڵ�����
typedef struct
{
    BYTE                byBlindEnable;                      // ʹ��
    BYTE                byBlindLevel;                       // �����1-6
    BYTE                byReserved[2];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // ����ʽ
} DH_BLIND_CFG_EX;

// Ӳ����Ϣ(�ڲ�����)
typedef struct 
{
    BYTE                byNoDiskEn;                         // ��Ӳ��ʱ����
    BYTE                byReserved_1[3];
    DH_TSECT            stNDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struNDHandle;                       // ����ʽ
    BYTE                byLowCapEn;                         // Ӳ�̵�����ʱ����
    BYTE                byLowerLimit;                       // ������ֵ,0-99
    BYTE                byReserved_2[2];
    DH_TSECT            stLCSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struLCHandle;                       // ����ʽ
    BYTE                byDiskErrEn;                        // Ӳ�̹��ϱ���
    BYTE                bDiskNum;
    BYTE                byReserved_3[2];
    DH_TSECT            stEDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struEDHandle;                       // ����ʽ
} DH_DISK_ALARM_CFG_EX;

typedef struct
{
    BYTE                byEnable;
    BYTE                byReserved[3];
    DH_MSG_HANDLE_EX    struHandle;
} DH_NETBROKEN_ALARM_CFG_EX;

// ǰ�˽������ò�����Ϣ
typedef struct __DEV_ENCODER_CFG 
{
    int                 nChannels;                  // ����ͨ������
    DEV_ENCODER_INFO    stuDevInfo[32];             // ������ͨ����ǰ�˱�������Ϣ
    BYTE                byHDAbility;                // ����ͨ��������֧�ָ�����Ƶ����(Ϊ0��ʾ��֧�ָ�������)
                                                    // ע�����֧�ָ�������,����ͨ��Ϊ0~N-1,��N֮�������ͨ������Ϊ����,�п��ܱ��治�ɹ�
    BYTE                bTVAdjust;                  // �豸�Ƿ�֧��TV����, 0:��֧�� 1:֧��.
    BYTE                bDecodeTour;                // �豸�Ƿ�֧�ֽ�����Ѳ, 0:��֧�� ����0:��ʾǰ��֧����Ѳ����豸��.
    BYTE                bRemotePTZCtl;              // ָʾ�Ƿ�֧��Զ����̨���ơ�

    char                reserved[12];
} DEV_ENCODER_CFG, *LPDEV_ENCODER_CFG;

// ǰ�˽������ò�����Ϣ��չ
typedef struct __DEV_ENCODER_CFG_EX 
{
    int                 nChannels;                  // ����ͨ������
    DEV_ENCODER_INFO    stuDevInfo[128];            // ������ͨ����ǰ�˱�������Ϣ
    BYTE                byHDAbility;                // ����ͨ��������֧�ָ�����Ƶ����(Ϊ0��ʾ��֧�ָ�������)
    // ע�����֧�ָ�������,����ͨ��Ϊ0~N-1,��N֮�������ͨ������Ϊ����,�п��ܱ��治�ɹ�
    BYTE                bTVAdjust;                  // �豸�Ƿ�֧��TV����, 0:��֧�� 1:֧��.
    BYTE                bDecodeTour;                // �豸�Ƿ�֧�ֽ�����Ѳ, 0:��֧�� ����0:��ʾǰ��֧����Ѳ����豸��.
    BYTE                bRemotePTZCtl;              // ָʾ�Ƿ�֧��Զ����̨���ơ�
    char                reserved[256];
} DEV_ENCODER_CFG_EX, *LPDEV_ENCODER_CFG_EX;

// struct ������
typedef struct tagDHCONFIG_CONTROLER{
    DH_COMM_PROP        struComm;                        // ��������
    BYTE                bLightGroup[DH_MAX_LIGHT_NUM];   // �ܿص����飨����Ŵ�1��ʼ����,����[1,3,8,0��0]��ʾ�������Ϊ1,3,8�ĵ�
    BYTE                bDeviceAddr;                     // ��������ַ
    BYTE                bComPortType;                    // �������� 0:485����, 1:232����
    BYTE                bReserved[6];                    // ����
} DH_CONFIG_CONTROLER;

// �ƹ��������
typedef struct __DHDEV_LIGHTCONTROL_CFG
{
    DH_CONFIG_CONTROLER    struControlers[DH_MAX_CONTROLER_NUM];  // ��������
    BYTE                   bControlerNum;                         // ��Ч��������Ŀ
    BYTE                   bReserved[1023];                       // ����
} DHDEV_LIGHTCONTROL_CFG, *LPDHDEV_LIGHTCONTROL_CFG;


// 3G������Ϣ����
typedef struct
{
    int                 nStrategy;       //����ʹ�ò���, 0:���������� 1:��ʱ�����
    int                 nUpLimit;        //����ʹ������, ������: ��λMB ��ʱ��: ��λСʱ
    int                 nreserved[22];   //�����ֽ�
}DHDEV_3GFLOW_INFO_CFG;

// IPv6����
typedef struct 
{
    char               szLinkAddr[44];      // ��·��ַ: �ַ���, ����Ϊ44;(��������ÿ̨����ӵ��Ψһ����·��ַ,ֻ��)
    char               szHostIP[40];        // ����IP
    DWORD              dwPreFix;            // ����ǰ׺����Χ��1-128,�ɶ���д��
    char               szGateWay[40];       // Ĭ������
    BOOL               bAutoGet;            // �Զ���ȡʹ��
    char               szPrimaryDns[40];    // ��ѡDNS
    char               szSecondDns[40];     // ��ѡDNS
    char               cReserved[256];      // �����ֶ�
}DHDEV_IPV6_CFG;

//��洢����
typedef struct __DEV_URGENCY_RECORD_CFG
{
    DWORD   dwSize;             // �ṹ���С
    BOOL    bEnable;            // �Ƿ�ʹ��,1ʹ��,0��ʹ��
    UINT    nMaxRecordTime;     // ���¼��ʱ��,��λ��
}DHDEV_URGENCY_RECORD_CFG;

// �������в�������
typedef struct __DEV_ELEVATOR_ATTRI_CFG
{
    DWORD   dwSize;             // �ṹ���С
    UINT    nMAXFloorNum;       //���¥�� ��С2
    UINT    nFloorDelayTime;    //ͣ���ж�ʱ��,5-60�����ִ�ʱ�䳤����Ϊ�ǵ���ͣ����¥�㡣
    UINT    nIntervalTime;      //�������л����о���һ������ʱ��,���������ʱ��,����Ϊ���ݹ���,����ֹͣ������֮�䡣
}DHDEV_ELEVATOR_ATTRI_CFG;

// ��������ͷ״̬��ѯ
typedef struct tagDHDEV_VIRTUALCAMERA_STATE_INFO
{
    DWORD              nStructSize;                  // �ṹ���С
    int                nChannelID;                   // ͨ����
    CONNECT_STATE      emConnectState;               // ����״̬
    UINT               uiPOEPort;                    // ����������ͷ�����ӵ�POE�˿ں�,0��ʾ����POE���� 
    char               szDeviceName[64];             // �豸����
    char               szDeviceType[128];            // �豸����
    char               szSystemType[128];            // ϵͳ�汾
    char               szSerialNo[DH_SERIALNO_LEN];  // ���к�
    int                nVideoInput;                  // ��Ƶ����
    int                nAudioInput;                  // ��Ƶ����
    int                nAlarmOutput;                 // �ⲿ����
}DHDEV_VIRTUALCAMERA_STATE_INFO;

// �豸������Ƶ/��Ȧģʽ״̬����Ϣ��ѯ
typedef struct tagDHDEV_TRAFFICWORKSTATE_INFO
{
    DWORD                nStructSize;      // �ṹ���С
    int                  nChannelID;       // ͨ����
    DH_TRAFFIC_SNAP_MODE emSnapMode;       // ץ��ģʽ
}DHDEV_TRAFFICWORKSTATE_INFO;

typedef enum tagEM_NET_DEFENCE_AREA_TYPE
{
    EM_NET_DEFENCE_AREA_TYPE_UNKNOW,                    // δ֪
    EM_NET_DEFENCE_AREA_TYPE_INTIME,                    // ��ʱ���� 
    EM_NET_DEFENCE_AREA_TYPE_DELAY,                     // ��ʱ����
    EM_NET_DEFENCE_AREA_TYPE_FULLDAY,                   // 24Сʱ����
    EM_NET_DEFENCE_AREA_TYPE_Follow,                    // �������
    EM_NET_DEFENCE_AREA_TYPE_MEDICAL,                   // ҽ�ƽ����
    EM_NET_DEFENCE_AREA_TYPE_PANIC,                     // �ֻŷ���
    EM_NET_DEFENCE_AREA_TYPE_FIRE,                      // �𾯷���
    EM_NET_DEFENCE_AREA_TYPE_FULLDAYSOUND,              // 24Сʱ��������
    EM_NET_DEFENCE_AREA_TYPE_FULLDATSLIENT,             // 24Сʱ��������
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE1,                 // �������1
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE2,                 // �������2
    EM_NET_DEFENCE_AREA_TYPE_INSIDE,                    // �ڲ�����
    EM_NET_DEFENCE_AREA_TYPE_OUTSIDE,                   // �ⲿ����
    EN_NET_DEFENCE_AREA_TYPE_PEOPLEDETECT,              // ��Ա������
} EM_NET_DEFENCE_AREA_TYPE;

// ���ر����¼�(��DH_ALARM_ALARM_EX����)
typedef struct tagALARM_ALARM_INFO_EX2
{
    DWORD                           dwSize;
    int                             nChannelID;             // ͨ����
    int                             nAction;                // 0:��ʼ 1:ֹͣ
    NET_TIME                        stuTime;                // �����¼�������ʱ��
    NET_SENSE_METHOD                emSenseType;            // ����������
    DH_MSG_HANDLE_EX                stuEventHandler;        // ������Ϣ
    EM_NET_DEFENCE_AREA_TYPE        emDefenceAreaType;      // ��������
    UINT 							nEventID;				//�¼�ID
    char                            szName[DH_COMMON_STRING_32];  // ͨ������               
    int                             nCount;                 // �¼���������
}ALARM_ALARM_INFO_EX2;

/////////////////////////////////���ܽ�ͨͼƬ���Ľӿڲ���/////////////////////////////////
typedef struct RESERVED_DATA_INTEL_BOX
{
    DWORD  dwEventCount;        //�¼�����
    DWORD* dwPtrEventType;      //ָ���������¼����͵�ֵ���ռ����û��Լ�����,��СΪsizeof(DWORD)*dwEventCount
    DWORD  dwInternalTime;      // ͼƬ�ϴ����ʱ��,��λ��s
    BYTE   bReserved[1020];     //�����ֽ�
}ReservedDataIntelBox;

#define RESERVED_TYPE_FOR_INTEL_BOX 0x00000001
typedef struct RESERVED_PARA
{
    DWORD   dwType;         //pData����������
                            //��[dwType]Ϊ RESERVED_TYPE_FOR_INTEL_BOX ʱ,pData ��ӦΪ�ṹ��ReservedDataIntelBox�ĵ�ַ                    
                            //��[dwType]Ϊ RESERVED_TYPE_FOR_COMMON ʱ,[pData]��ӦΪ�ṹ��NET_RESERVED_COMMON�Ľṹ���ַ
                            //��[dwType]Ϊ RESERVED_TYPE_FOR_PATH ʱ,[pData]��Ӧ�ṹ��NET_RESERVED_PATH�Ľṹ���ַ
    void*   pData;          //����,���û������ڴ棬��С�ο���Ӧ�Ľṹ��
}ReservedPara;

#define RESERVED_TYPE_FOR_COMMON   0x00000010
typedef struct tagNET_RESERVED_COMMON
{
    DWORD                   dwStructSize;
    ReservedDataIntelBox*   pIntelBox;          // ����RESERVED_TYPE_FOR_INTEL_BOX
    DWORD                   dwSnapFlagMask;     // ץͼ��־(��λ),0λ:"*",1λ:"Timing",2λ:"Manual",3λ:"Marked",4λ:"Event",5λ:"Mosaic",6λ:"Cutout"
}NET_RESERVED_COMMON;

#define RESERVED_TYPE_FOR_PATH  0x00000100
//ͼƬ·������
typedef enum tagNET_PICTURE_PATH_TYPE
{
    NET_PATH_LOCAL_PATH     ,   //����Ӳ�̻���sd���ɹ�д��·��
    NET_PATH_FTP_PATH       ,   //�豸�ɹ�д��ftp��������·��
    NET_PATH_VIDEO_PATH     ,   //��ǰ������Ҫ��ȡ��ǰΥ�µĹ�����Ƶ��FTP�ϴ�·��
}NET_PICTURE_PATH_TYPE;

#define MAX_PIC_PATH_NUM        16
typedef struct tagNET_RESERVED_PATH
{
    int                     nMaxPathNum;                        //ͼƬ·������,Ϊ0ʱ�����豸Ĭ��·��
    NET_PICTURE_PATH_TYPE   emPictruePaths[MAX_PIC_PATH_NUM];   //ͼƬ·������
}NET_RESERVED_PATH;

/////////////////////////////////��������ƽӿڲ���/////////////////////////////////
// �����ṹ��Ϣ
typedef struct 
{
    DWORD       dwSize;
    int         nScene;     //�������
}DHDEV_INTELLI_SCENE_INFO;
// �����߽���λ��Ϣ
typedef struct 
{
    DWORD       dwSize;
    int         nScene;     //�������
    int         nType;      //0:�ϱ߽���λ,1:�±߽���λ,2:��߽�,3:�ұ߽�
}DHDEV_INTELLI_SCENELIMIT_INFO;
// �ֶ�����Ŀ��ṹ����Ϣ
typedef struct
{
    DWORD       dwSize;
    int         nObjectID;   // ����ID,-1 ��ʾweb�Ͽ�ѡ��������֡�ϴ���������λ������,>=0��ʾ��ѡ��������֡�ϴ�������
    RECT        stuBound;    // ���η�Χ,��������һ����[0,8192]����
}DHDEV_INTELLI_TRACKOBJECT_INFO;

typedef enum __TRACKCONTROL_TYPE
{
        DH_TRACK_MARKSCENE,        // �궨����, ��Ӧ��DHDEV_INTELLI_SCENE_INFO�ṹ��
        DH_TRACK_GOTOSCENE,        // ת��������,��Ӧ��DHDEV_INTELLI_SCENE_INFO�ṹ��
        DH_TRACK_MARKSCENELIMIT,   // �궨�����߽���λ,��Ӧ��DHDEV_INTELLI_SCENELIMIT_INFO�ṹ��
        DH_TRACK_GOTOSCENELIMIT,   // ת���������߽���λ��,��Ӧ��DHDEV_INTELLI_SCENELIMIT_INFO�ṹ��
        DH_TRACK_MARKSCENEMAXZOOM, // �궨���������ٱ���, ��Ӧ��DHDEV_INTELLI_SCENE_INFO�ṹ��
        DH_TRACK_OBJECT,           // ѡ�г����еĸ���Ŀ��,��Ӧ��DHDEV_INTELLI_TRACKOBJECT_INFO������
        DH_TRACK_START,            // ��ʼ���ܸ���,����ָ��������Ϣ
        DH_TRACK_STOP,             // ֹͣ���ܸ���,����ָ��������Ϣ
        DH_TRACK_TYPE_NUM,
}DH_TRACKCONTROL_TYPE;
//������������������
typedef struct tagNET_IN_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
    int         nChannelID;            // ͨ��ID
    DH_TRACKCONTROL_TYPE emCtrlType;   // ��������
    void*       pCtrlInfo;             // �������Ͷ�Ӧ������Ϣ�ṹ��ָ��,�μ�DH_TRACKCONTROL_TYPE���塣���û������ڴ�
    int         nMaxLen;               // ������Ϣ�ṹ���С
    int         nWaittime;             // �ȴ���ʱʱ��
}NET_IN_CONTROL_INTELLITRACKER;
//������������������
typedef struct tagNET_OUT_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
}NET_OUT_CONTROL_INTELLITRACKER;

/////////////////////////////////��Ƶ�����ӿڲ���/////////////////////////////////
#define MAX_TEMPLATEIMAGE_NUM               32                      //��ЧͼƬ��������

//��ȡ��Ƶ���������������
typedef struct tagNET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // ͨ��ID
    char                szRule[DH_COMMON_STRING_128];               // ģ��ͼƬ��Ӧ�Ĺ���
}NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE;

//��ȡ��Ƶ���������������
typedef struct tagNET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    unsigned int        nImageNum;                                  // ��ЧͼƬ����
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // ͼƬ��Ϣ
    char*               pBuffer;                                    // ͼƬ������ָ��, ���û��Լ�����
    int                 nBufLen;                                    // ͼƬ��������С, ���û��Լ���д
    int                 nRetLen;                                    // ��ȡ��ͼƬ�����ܳ���, �����û���д, ���Ը��ݴ˲����жϷ���Ļ�������С�Ƿ��㹻
}NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE;

//������Ƶ���������������
typedef struct tagNET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // ͨ��ID
    char                szRule[DH_COMMON_STRING_128];               // ģ��ͼƬ��Ӧ�Ĺ���
    unsigned int        nImageNum;                                  // ��ЧͼƬ����
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // ͼƬ��Ϣ
    char*               pBuffer;                                    // ͼƬ������ָ��,���û������ڴ棬��СΪnBufLen
    int                 nBufLen;                                    // ͼƬ��������С
}NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE;

//������Ƶ���������������
typedef struct tagNET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD       dwSize;
}NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE;

/////////////////////////////////��̭����/////////////////////////////////

// ��ѯ�豸����״̬ͨ����Ϣ,��ؽӿ�����̭,�벻Ҫʹ��
typedef struct
{
    BYTE                byRecordStatic;             // ͨ���Ƿ���¼��0����¼��,1���ֶ�¼��,2���Զ�¼��
    BYTE                bySignalStatic;             // ���ӵ��ź�״̬��0������,1���źŶ�ʧ
    BYTE                byHardwareStatic;           // ͨ��Ӳ��״̬��0������,1���쳣,����DSP����
    char                reserve;
    DWORD               dwBitRate;                  // ʵ������
    DWORD               dwLinkNum;                  // �ͻ������ӵĸ���
    DWORD               dwClientIP[DH_MAX_LINK];    // �ͻ��˵�IP��ַ
} NET_DEV_CHANNELSTATE, *LPNET_DEV_CHANNELSTATE;

// ��ѯ�豸����״̬,��ؽӿ�����̭,�벻Ҫʹ��
typedef struct
{
    DWORD                dwDeviceStatic;                    // �豸��״̬��0x00������,0x01��CPUռ�ù���,0x02��Ӳ������
    NET_DEV_DISKSTATE    stHardDiskStatic[DH_MAX_DISKNUM]; 
    NET_DEV_CHANNELSTATE stChanStatic[DH_MAX_CHANNUM];      //ͨ����״̬
    BYTE                 byAlarmInStatic[DH_MAX_ALARMIN];   //�����˿ڵ�״̬��0��û�б���,1���б���
    BYTE                 byAlarmOutStatic[DH_MAX_ALARMOUT]; //��������˿ڵ�״̬��0��û�����,1���б������
    DWORD                dwLocalDisplay;                    // ������ʾ״̬��0������,1��������
} NET_DEV_WORKSTATE, *LPNET_DEV_WORKSTATE;

// Э����Ϣ
typedef struct 
{
    char                 protocolname[12];        // Э����
    unsigned int         baudbase;                // ������
    unsigned char        databits;                // ����λ
    unsigned char        stopbits;                // ֹͣλ
    unsigned char        parity;                  // У��λ
    unsigned char        reserve;
} PROTOCOL_INFO, *LPPROTOCOL_INFO;

// ����Խ���������
typedef struct 
{
    // ��Ƶ�������
    BYTE                byInFormatTag;            // ��������,��PCM
    BYTE                byInChannels;             // ������
    WORD                wInBitsPerSample;         // �������                    
    DWORD               dwInSamplesPerSec;        // ������

    // ��Ƶ�������
    BYTE                byOutFormatTag;           // ��������,��PCM
    BYTE                byOutChannels;            // ������
    WORD                wOutBitsPerSample;        // �������                
    DWORD               dwOutSamplesPerSec;       // ������
} DHDEV_TALK_CFG, *LPDHDEV_TALK_CFG;


/////////////////////////////////// ���� ///////////////////////////////////////

#define DH_MATRIX_INTERFACE_LEN         16          // �źŽӿ����Ƴ���
#define DH_MATRIX_MAX_CARDS             128         // �����ӿ��������
#define DH_SPLIT_PIP_BASE               1000        // �ָ�ģʽ���л��Ļ���ֵ
#define DH_MAX_SPLIT_MODE_NUM           64          // ���ָ�ģʽ��
#define DH_MATRIX_MAX_CHANNEL_IN        1500        // �����������ͨ����
#define DH_MATRIX_MAX_CHANNEL_OUT       256         // ����������ͨ����
#define DH_DEVICE_NAME_LEN              64          // �豸���Ƴ���
#define DH_MAX_CPU_NUM                  16          // ���CPU����
#define DH_MAX_FAN_NUM                  16          // ����������
#define DH_MAX_POWER_NUM                16          // ����Դ����
#define DH_MAX_BATTERY_NUM              16          // ���������
#define DH_MAX_TEMPERATURE_NUM          256         // ����¶ȴ���������
#define DH_MAX_ISCSI_NAME_LEN           128         // ISCSI���Ƴ���
#define DH_VERSION_LEN                  64          // �汾��Ϣ����
#define DH_MAX_STORAGE_PARTITION_NUM    32          // �洢�����������
#define DH_STORAGE_MOUNT_LEN            64          // ���ص㳤��
#define DH_STORAGE_FILE_SYSTEM_LEN      16          // �ļ�ϵͳ���Ƴ���
#define DH_MAX_MEMBER_PER_RAID          32          // RAID��Ա�������
#define DH_DEV_ID_LEN_EX                128         // �豸ID��󳤶�
#define DH_MAX_BLOCK_NUM                32          // �����������
#define DH_MAX_SPLIT_WINDOW             128         // ���ָ������
#define DH_FILE_TYPE_LEN                64          // �ļ����ͳ���
#define DH_DEV_ID_LEN                   128         // �豸ID��󳤶�
#define DH_DEV_NAME_LEN                 128         // �豸������󳤶�
#define DH_TSCHE_DAY_NUM                8           // ʱ����һά��С, ��ʾ����
#define DH_TSCHE_SEC_NUM                6           // ʱ���ڶ�ά��С, ��ʾʱ����
#define DH_SPLIT_INPUT_NUM              256         // ˾���豸�����л�ʱ��һ��split֧�ֵ�����ͨ����

#define DH_DEVICE_ID_LOCAL              "Local"     // �����豸ID
#define DH_DEVICE_ID_REMOTE             "Remote"    // Զ���豸ID
#define DH_DEVICE_ID_UNIQUE             "Unique"    // �豸��ͳһ���

// �ָ�ģʽ
typedef enum tagDH_SPLIT_MODE
{
    DH_SPLIT_1 = 1,                                 // 1����
    DH_SPLIT_2 = 2,                                 // 2����
    DH_SPLIT_4 = 4,                                 // 4����
    DH_SPLIT_6 = 6,                                 // 6����
    DH_SPLIT_8 = 8,                                 // 8����
    DH_SPLIT_9 = 9,                                 // 9����
    DH_SPLIT_12 = 12,                               // 12����
    DH_SPLIT_16 = 16,                               // 16����
    DH_SPLIT_20 = 20,                               // 20����
    DH_SPLIT_25 = 25,                               // 25����
    DH_SPLIT_36 = 36,                               // 36����
    DH_SPLIT_64 = 64,                               // 64����
    DH_SPLIT_144 = 144,                             // 144����
    DH_PIP_1 = DH_SPLIT_PIP_BASE + 1,               // ���л�ģʽ, 1��ȫ������+1��С���洰��
    DH_PIP_3 = DH_SPLIT_PIP_BASE + 3,               // ���л�ģʽ, 1��ȫ������+3��С���洰��
    DH_SPLIT_FREE = DH_SPLIT_PIP_BASE * 2,          // ���ɿ���ģʽ,�������ɴ������رմ���,�������ô���λ�ú�Z�����
    DH_COMPOSITE_SPLIT_1 = DH_SPLIT_PIP_BASE * 3 + 1,    // �ں�����Ա1�ָ�
    DH_COMPOSITE_SPLIT_4 = DH_SPLIT_PIP_BASE * 3 + 4,    // �ں�����Ա4�ָ�
	DH_SPLIT_3  = 10,                                // 3����
	DH_SPLIT_3B = 11,								 // 3���浹Ʒ 
} DH_SPLIT_MODE;

#define DH_PROTOCOL_DAHUA2 DH_PROTOCOL_PRIVATE2
#define DH_PROTOCOL_DAHUA3 DH_PROTOCOL_PRIVATE3

// �豸Э������
typedef enum tagDH_DEVICE_PROTOCOL
{
    DH_PROTOCOL_PRIVATE2,                   // ˽��2��Э��
    DH_PROTOCOL_PRIVATE3,                   // ˽��3��Э��
    DH_PROTOCOL_ONVIF,                      // Onvif    
    DH_PROTOCOL_VNC,                        // ������������
    DH_PROTOCOL_TS,                         // ��׼TS
    
    DH_PROTOCOL_PRIVATE = 100,              // ˽��Э��        
    DH_PROTOCOL_AEBELL,                     // ���籴��        
    DH_PROTOCOL_PANASONIC,                  // ����        
    DH_PROTOCOL_SONY,                       // ����        
    DH_PROTOCOL_DYNACOLOR,                  // Dynacolor        
    DH_PROTOCOL_TCWS,                       // �������        
    DH_PROTOCOL_SAMSUNG,                    // ����        
    DH_PROTOCOL_YOKO,                       // YOKO        
    DH_PROTOCOL_AXIS,                       // ��Ѷ��        
    DH_PROTOCOL_SANYO,                      // ����               
    DH_PROTOCOL_BOSH,                       // Bosch        
    DH_PROTOCOL_PECLO,                      // Peclo        
    DH_PROTOCOL_PROVIDEO,                   // Provideo        
    DH_PROTOCOL_ACTI,                       // ACTi        
    DH_PROTOCOL_VIVOTEK,                    // Vivotek        
    DH_PROTOCOL_ARECONT,                    // Arecont        
    DH_PROTOCOL_PRIVATEEH,                  // PrivateEH            
    DH_PROTOCOL_IMATEK,                     // IMatek        
    DH_PROTOCOL_SHANY,                      // Shany        
    DH_PROTOCOL_VIDEOTREC,                  // ����ӯ��        
    DH_PROTOCOL_URA,                        // Ura        
    DH_PROTOCOL_BITICINO,                   // Bticino         
    DH_PROTOCOL_ONVIF2,                     // OnvifЭ������, ͬDH_PROTOCOL_ONVIF    
    DH_PROTOCOL_SHEPHERD,                   // �Ӱ�        
    DH_PROTOCOL_YAAN,                       // �ǰ�        
    DH_PROTOCOL_AIRPOINT,                   // Airpop        
    DH_PROTOCOL_TYCO,                       // TYCO        
    DH_PROTOCOL_XUNMEI,                     // Ѷ��        
    DH_PROTOCOL_HIKVISION,                  // ����        
    DH_PROTOCOL_LG,                         // LG        
    DH_PROTOCOL_AOQIMAN,                    // ������        
    DH_PROTOCOL_BAOKANG,                    // ����            
    DH_PROTOCOL_WATCHNET,                   // Watchnet        
    DH_PROTOCOL_XVISION,                    // Xvision        
    DH_PROTOCOL_FUSITSU,                    // ��ʿͨ        
    DH_PROTOCOL_CANON,                      // Canon        
    DH_PROTOCOL_GE,                         // GE        
    DH_PROTOCOL_Basler,                     // ��˹��        
    DH_PROTOCOL_Patro,                      // ������        
    DH_PROTOCOL_CPKNC,                      // CPPLUS Kϵ��        
    DH_PROTOCOL_CPRNC,                      // CPPLUS Rϵ��        
    DH_PROTOCOL_CPUNC,                      // CPPLUS Uϵ��        
    DH_PROTOCOL_CPPLUS,                     // CPPLUS IPC    
    DH_PROTOCOL_XunmeiS,                    // Ѷ��s,ʵ��Э��ΪOnvif        
    DH_PROTOCOL_GDDW,                       // �㶫����        
    DH_PROTOCOL_PSIA,                       // PSIA        
    DH_PROTOCOL_GB2818,                     // GB2818            
    DH_PROTOCOL_GDYX,                       // GDYX        
    DH_PROTOCOL_OTHER,                      // ���û��Զ���   
} DH_DEVICE_PROTOCOL;

// һ��Ļ�ķָ�ģʽ��Ϣ
typedef struct tagDH_SPLIT_MODE_INFO
{
    DWORD               dwSize;
    DH_SPLIT_MODE       emSplitMode;            // �ָ�ģʽ
    int                 nGroupID;               // �������
    DWORD               dwDisplayType;          // ��ʾ���ͣ������DH_SPLIT_DISPLAY_TYPE��ע�͸�ģʽ����ʾ������"PicInPic"����, ��ģʽ����ʾ���ݰ�NVD���й����������DisChn�ֶξ�����������,û����һ����ʱ,Ĭ��Ϊ��ͨ��ʾ����,��"General"��
} DH_SPLIT_MODE_INFO;

// �ָ�����
typedef struct tagDH_SPLIT_CAPS 
{
    DWORD               dwSize;
    int                 nModeCount;                             // ֧�ֵķָ�ģʽ����
    DH_SPLIT_MODE       emSplitMode[DH_MAX_SPLIT_MODE_NUM];     // ֧�ֵķָ�ģʽ
    int                 nMaxSourceCount;                        // �����ʾԴ������
    int                 nFreeWindowCount;                       // ֧�ֵ�������ɿ�����Ŀ
    BOOL                bCollectionSupported;                   // �Ƿ�֧�������ղ�
    DWORD               dwDisplayType;                          // �����ʾ�����ʾ����,�����DH_SPLIT_DISPLAY_TYPE��ע�͸�ģʽ����ʾ������"PicInPic"����, ��ģʽ����ʾ���ݰ�NVD���й����������DisChn�ֶξ�����������,û����һ����ʱ,Ĭ��Ϊ��ͨ��ʾ����,��"General"��
    int                 nPIPModeCount;                          // ���л�֧�ֵķָ�ģʽ����
    DH_SPLIT_MODE       emPIPSplitMode[DH_MAX_SPLIT_MODE_NUM];  // ���л�֧�ֵķָ�ģʽ
    int                 nInputChannels[DH_SPLIT_INPUT_NUM];     // ֧�ֵ�����ͨ��
    int                 nInputChannelCount;                     // ֧�ֵ�����ͨ������, 0��ʾû������ͨ������
    int                 nBootModeCount;                         // ��ָ�ģʽ����
    DH_SPLIT_MODE       emBootMode[DH_MAX_SPLIT_MODE_NUM];      // ֧�ֵ���Ĭ�ϻ���ָ�ģʽ
} DH_SPLIT_CAPS;

// ����Ȩ����֤��Ϣ
typedef struct tagDH_CASCADE_AUTHENTICATOR
{
    DWORD               dwSize;
    char                szUser[DH_NEW_USER_NAME_LENGTH];        // �û���
    char                szPwd[DH_NEW_USER_PSW_LENGTH];          // ����
    char                szSerialNo[DH_SERIALNO_LEN];            // �豸���к�
} DH_CASCADE_AUTHENTICATOR;

typedef enum tagEM_SRC_PUSHSTREAM_TYPE
{   
    EM_SRC_PUSHSTREAM_AUTO,        // �豸�˸�������ͷ�Զ�ʶ��Ĭ��ֵ
    EM_SRC_PUSHSTREAM_HIKVISION,   // ����˽������
    EM_SRC_PUSHSTREAM_PS,          // PS��
    EM_SRC_PUSHSTREAM_TS,          // TS��
    EM_SRC_PUSHSTREAM_SVAC,        // SVAC����
}EM_SRC_PUSHSTREAM_TYPE;

// ��ʾԴ
typedef struct tagDH_SPLIT_SOURCE
{
    DWORD               dwSize;
    BOOL                bEnable;                                // ʹ��
    char                szIp[DH_MAX_IPADDR_LEN];                // IP, �ձ�ʾû������
    char                szUser[DH_USER_NAME_LENGTH];            // �û���, ����ʹ��szUserEx
    char                szPwd[DH_USER_PSW_LENGTH];              // ����, ����ʹ��szPwdEx
    int                 nPort;                                  // �˿�
    int                 nChannelID;                             // ͨ����
    int                 nStreamType;                            // ��Ƶ����, -1-�Զ�, 0-������, 1-������1, 2-������2, 3-������3, 4-snap, 5-Ԥ��
    int                 nDefinition;                            // ������, 0-����, 1-����
    DH_DEVICE_PROTOCOL  emProtocol;                             // Э������
    char                szDevName[DH_DEVICE_NAME_LEN];          // �豸����
    int                 nVideoChannel;                          // ��Ƶ����ͨ����
    int                 nAudioChannel;                          // ��Ƶ����ͨ����
    //--------------------------------------------------------------------------------------
    // ����ֻ�Խ�������Ч
    BOOL                bDecoder;                               // �Ƿ��ǽ�����
    BYTE                byConnType;                             // -1: auto, 0��TCP��1��UDP��2���鲥
    BYTE                byWorkMode;                             // 0��ֱ����1��ת��
    WORD                wListenPort;                            // ָʾ��������Ķ˿�,ת��ʱ��Ч; byConnTypeΪ�鲥ʱ,����Ϊ�ಥ�˿�
    char                szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp��չ,ǰ��DVR��IP��ַ(������������)
    BYTE                bySnapMode;                             // ץͼģʽ(nStreamType==4ʱ��Ч) 0����ʾ����һ֡,1����ʾ��ʱ��������
    BYTE                byManuFactory;                          // Ŀ���豸����������, ����ο�EM_IPC_TYPE��
    BYTE                byDeviceType;                           // Ŀ���豸���豸����, 0:IPC
    BYTE                byDecodePolicy;                         // Ŀ���豸�Ľ������, 0:������ǰ
                                                                // 1:ʵʱ�ȼ��� 2:ʵʱ�ȼ���
                                                                // 3:ʵʱ�ȼ��� 4:Ĭ�ϵȼ�
                                                                // 5:�����ȼ��� 6:�����ȼ���
                                                                // 7:�����ȼ���
    //--------------------------------------------------------------------------------------
    DWORD               dwHttpPort;                             // Http�˿ں�, 0-65535
    DWORD               dwRtspPort;                             // Rtsp�˿ں�, 0-65535
    char                szChnName[DH_DEVICE_NAME_LEN];          // Զ��ͨ������, ֻ�ж�ȡ�������Ʋ�Ϊ��ʱ�ſ����޸ĸ�ͨ��������
    char                szMcastIP[DH_MAX_IPADDR_LEN];           // �ಥIP��ַ, byConnTypeΪ�鲥ʱ��Ч
    char                szDeviceID[DH_DEV_ID_LEN_EX];           // �豸ID, ""-null, "Local"-����ͨ��, "Remote"-Զ��ͨ��, ������������RemoteDevice�е��豸ID
    BOOL                bRemoteChannel;                         // �Ƿ�Զ��ͨ��(ֻ��)
    unsigned int        nRemoteChannelID;                       // Զ��ͨ��ID(ֻ��), bRemoteChannel=TRUEʱ��Ч
    char                szDevClass[DH_DEV_TYPE_LEN];            // �豸����, ��IPC, DVR, NVR��
    char                szDevType[DH_DEV_TYPE_LEN];             // �豸�����ͺ�, ��IPC-HF3300
    char                szMainStreamUrl[MAX_PATH];              // ������url��ַ, byManuFactoryΪDH_IPC_OTHERʱ��Ч
    char                szExtraStreamUrl[MAX_PATH];             // ������url��ַ, byManuFactoryΪDH_IPC_OTHERʱ��Ч
    int                 nUniqueChannel;                         // �豸��ͳһ��ŵ�Ψһͨ����, ֻ��
    DH_CASCADE_AUTHENTICATOR stuCascadeAuth;                    // ������֤��Ϣ, �豸IDΪ"Local/Cascade/SerialNo"ʱ��Ч, ����SerialNo���豸���к�
    int                 nHint;                                  // 0-��ͨ��ƵԴ, 1-������ƵԴ
    int                 nOptionalMainUrlCount;                  // ������������ַ����
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH];  // ������������ַ�б�
    int                 nOptionalExtraUrlCount;                 // ���ø�������ַ����
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // ���ø�������ַ�б�
    //--------------------------------------------------------------------------------------
    //Э���������ֶ�
    int                 nInterval;                              // ��Ѳʱ����   ��λ����
    char                szUserEx[DH_NEW_USER_NAME_LENGTH];      // �û���
    char                szPwdEx[DH_NEW_USER_PSW_LENGTH];        // ����
    EM_SRC_PUSHSTREAM_TYPE  emPushStream;           // ������ʽ����������,ֻ��byConnTypeΪTCP-Push��UDP-Push���и��ֶ�
} DH_SPLIT_SOURCE;

// ��Ƶ���������
typedef struct tagDH_VIDEO_OUT_CAPS 
{
    DWORD               dwSize;
    BOOL                bColor;                                 // �Ƿ�֧�������ɫ����
    BOOL                bMargin;                                // �Ƿ�֧�ֱ߽�����
    int                 nLayers;                                // ֧��ͬʱ��ʾ��ͼ����
    BOOL                bPowerMode;                             // �Ƿ�֧�ֵ�Դ����
    int                 bSplitMode;                             // ֧�ֵĻ���ָ�ģʽ, 0-������, 1-'#'����ģʽ(����������), 2-����ģʽ
    unsigned int        nBackground;                            // ֧�ֵı�����ʽ, ��λ��ʾ, 0-��ɫ, 1-ͼƬ
    BOOL                bBindOutput;                            // �Ƿ�֧��������ֱ��ʰ�����
    BOOL                bAudioSupport;                          // �Ƿ�֧����Ƶ���
    DWORD               dwAudioMode;                            // ֧�ֵ���Ƶģʽ, ��λ��ʾ, bit0-�������, bit1-�ӿ����
} DH_VIDEO_OUT_CAPS;

// ��ɫBCSH
typedef struct tagDH_COLOR_BCSH 
{
    int                 nBirghtness;                // ����
    int                 nContrast;                  // �Աȶ�
    int                 nSaturation;                // ���Ͷ�
    int                 nHue;                       // ɫ��
} DH_COLOR_BCSH;

// �ߴ�
typedef struct tagDH_SIZE 
{
    int                 nWidth;                     // ���
    int                 nHeight;                    // �߶�
} DH_SIZE;

// �Ȱβ�ģʽ
typedef struct tagDH_HOT_PLUG_MODE
{
    DWORD               dwSize;
    int                 nMode;                      // �Ȱβ�ģʽ, 0-�Ȳ��ģʽ, 1-ǿ�����ģʽ
} DH_HOT_PLUG_MODE;

// ��Ƶ���ѡ��
typedef struct tagDH_VIDEO_OUT_OPT
{
    DWORD               dwSize;
    DH_RECT*            pstuMargin;                 // �߽緶Χ
    DH_COLOR_BCSH*      pstuColor;                  // �����ɫ
    DH_COLOR_RGBA*      pstuBackground;             // ����ɫ
    DH_SIZE*            pstuSize;                   // ����ߴ�
    DH_HOT_PLUG_MODE*   pstuHotPlugMode;            // �Ȱβ�ģʽ
} DH_VIDEO_OUT_OPT;

#define NET_VIDEOANALYSE_SCENES (32)
#define NET_VIDEOANALYSE_RULES (64)

// ���ܷ���
typedef struct tagNET_PD_VIDEOANALYSE
{
    BOOL                bSupport;                   // �Ƿ�֧�����ܷ���
    char                szSupportScenes[NET_VIDEOANALYSE_SCENES][DH_COMMON_STRING_64];   // ֧�ֵĳ���
    char                SupportRules[NET_VIDEOANALYSE_RULES][DH_COMMON_STRING_64];       // ֧�ֵĹ���
} NET_PD_VIDEOANALYSE;

// ��Ʒ����
typedef struct tagDH_PRODUCTION_DEFNITION
{
    DWORD               dwSize;
    int                 nVideoInChannel;                        // ��Ƶ����ͨ����
    int                 nVideoOutChannel;                       // ��Ƶ���ͨ����
    int                 nRemoteDecChannel;                      // Զ�̽���ͨ����
    char                szDevType[DH_DEV_TYPE_LEN];             // �豸����
    char                szVendor[DH_MAX_NAME_LEN];              // OEM�ͻ�
    int                 nOEMVersion;                            // OEM�汾
    int                 nMajorVerion;                           // ���汾��
    int                 nMinorVersion;                          // �ΰ汾��
    int                 nRevision;                              // �޶��汾
    char                szWebVerion[DH_MAX_NAME_LEN];           // Web�汾
    char                szDefLanguage[DH_MAX_NAME_LEN];         // Ĭ������
    NET_TIME            stuBuildDateTime;                       // ����ʱ��, ��ȷ����
    int                 nAudioInChannel;                        // ��Ƶ����ͨ����
    int                 nAudioOutChannel;                       // ��Ƶ���ͨ����
    BOOL                bGeneralRecord;                         // �Ƿ�֧�ֶ�ʱ�洢
    BOOL                bLocalStore;                            // �Ƿ�֧�ֱ��ش洢
    BOOL                bRemoteStore;                           // �Ƿ�֧������洢
    BOOL                bLocalurgentStore;                      // �Ƿ�֧�ֽ�洢������
    BOOL                bRealtimeCompress;                      // �Ƿ�֧��ʵʱѹ���洢
    DWORD               dwVideoStandards;                       // ֧�ֵ���Ƶ��ʽ�б�, bit0-PAL, bit1-NTSC
    int                 nDefVideoStandard;                      // Ĭ����Ƶ��ʽ, 0-PAL, 1-NTSC
    int                 nMaxExtraStream;                        // �������·��
    int                 nRemoteRecordChannel;                   // Զ��¼��ͨ����
    int                 nRemoteSnapChannel;                     // Զ��ץͼͨ����
    int                 nRemoteVideoAnalyseChannel;             // Զ����Ƶ����ͨ����
    int                 nRemoteTransmitChannel;                 // Զ��ʵʱ��ת�����ͨ����
    int                 nRemoteTransmitFileChannel;             // Զ���ļ�����ͨ��ͨ����
    int                 nStreamTransmitChannel;                 // ������紫��ͨ������
    int                 nStreamReadChannel;                     // �����ļ���ͨ������
    int                 nMaxStreamSendBitrate;                  // ����������緢������, kbps
    int                 nMaxStreamRecvBitrate;                  // �����������ӿ�����, kbps
    BOOL                bCompressOldFile;                       // �Ƿ�ѹ�����ļ�, ȥ��P֡, ����I֡
    BOOL                bRaid;                                  // �Ƿ�֧��RAID
    int                 nMaxPreRecordTime;                      // ���Ԥ¼ʱ��, s
    BOOL                bPtzAlarm;                              // �Ƿ�֧����̨����
    BOOL                bPtz;                                   // �Ƿ�֧����̨
    BOOL                bATM;                                   // �Ƿ���ʾATM��ع���
    BOOL                b3G;                                    // �Ƿ�֧��3Gģ��
    BOOL                bNumericKey;                            // �Ƿ�����ּ�
    BOOL                bShiftKey;                              // �Ƿ��Shift��
    BOOL                bCorrectKeyMap;                         // ������ĸӳ����Ƿ���ȷ
    BOOL                bNewATM;                                // �µĶ���ATMǰ���
    BOOL                bDecoder;                               // �Ƿ��ǽ�����
    DEV_DECODER_INFO    stuDecoderInfo;                         // ��������Ϣ, bDecoder=trueʱ��Ч
    int                 nVideoOutputCompositeChannels;          // �ں������ͨ������
    BOOL                bSupportedWPS;                          // �Ƿ�֧��WPS����
    int                 nVGAVideoOutputChannels;                // VGA��Ƶ���ͨ����
    int                 nTVVideoOutputChannels;                 // TV��Ƶ���ͨ����
    int                 nMaxRemoteInputChannels;                // ���Զ��ͨ����
    int                 nMaxMatrixInputChannels;                // ������ͨ����
    int                 nMaxRoadWays;                           // ���ܽ�ͨ��󳵵��� 1~6
    int                 nMaxParkingSpaceScreen;                 // ������Խ����֧�ֵ����������� 0~20

    int                 nPtzHorizontalAngleMin;                 // ��̨ˮƽ��С�Ƕ�, [0-360]
    int                 nPtzHorizontalAngleMax;                 // ��̨ˮƽ���Ƕ�, [0-360]
    int                 nPtzVerticalAngleMin;                   // ��̨��ֱ��С�Ƕ�, [-90,90]
    int                 nPtzVerticalAngleMax;                   // ��̨��ֱ���Ƕ�, [-90,90]
    BOOL                bPtzFunctionMenu;                       // �Ƿ�֧����̨���ܲ˵�
    BOOL                bLightingControl;                       // �Ƿ�֧�ֵƹ����
    DWORD               dwLightingControlMode;                  // �ֶ��ƹ����ģʽ, ��λ, ��NET_LIGHTING_CTRL_ON_OFF
    int                 nNearLightNumber;                       // �����������, 0��ʾ��֧��
    int                 nFarLightNumber;                        // Զ���������, 0��ʾ��֧��
    BOOL                bFocus;                                 // �Ƿ�֧�ֿ��ƾ۽�
    BOOL                bIris;                                  // �Ƿ�֧�ֿ��ƹ�Ȧ
    char                szPtzProtocolList[DH_COMMON_STRING_1024];// ��̨֧�ֵ�Э���б�, �����Ƕ��, ÿ����';'�ָ�
    BOOL                bRainBrushControl;                      // �Ƿ�֧����ˢ����
    int                 nBrushNumber;                           // ��ˢ����, Ϊ0ʱ��ʾ��֧��
    int                 nLowerMatrixInputChannels[DH_MAX_LOWER_MITRIX_NUM]; // ��λ������Ƶ����ͨ��, �±��Ӧ������
    int                 nLowerMatrixOutputChannels[DH_MAX_LOWER_MITRIX_NUM];// ��λ������Ƶ���ͨ��, �±��Ӧ������
    BOOL                bSupportVideoAnalyse;                   // �Ƿ�֧�����ܷ���
    BOOL                bSupportIntelliTracker;                 // �Ƿ�֧�����ܸ���

    DWORD               nSupportBreaking;                       //�豸֧�ֵ�Υ����������(��λ��ȡ)
                                                                //0-����� 1-ѹ�� 2-���� 3-Ƿ�� 4-���� 5-�г�ռ�� 6-����ռ�� 7-Υ����ʻ����ת����ת����ͷ��
                                                                //8-Υ�½�������� 9-Υ��ͣ�� 10-��ͨӵ�� 11-����������ʻ 12-Υ�±�� 13-ѹ���� 14-·����ʻ
                                                                //15-�ֶ�ץ�� 16-Υ������ 17-�������������� 18-�������� 19-������С 20-Υ��ռ�� 21-Υ�µ���
                                                                //22-ѹֹͣ�� 23-���Ƶ� 24-��������ͣ�� 25-��λ�г� 26-��λ�޳� 27-��λ�г�ѹ�� 28-���޳���
                                                                //29-���� 30-��ϵ��ȫ�� 31-��ʻԱ����
    DWORD               nSupportBreaking1;                      //0-��ʻԱ��绰 1-���˴���� 2-����ӵ�½��� 3-δ���涨���ν���ͨ��
    NET_PD_VIDEOANALYSE stuVideoAnalyse;                        //���ܷ���
    BOOL                bTalkTransfer;                          //�Ƿ�֧��ת���Խ�����
	BOOL				bCameraAttribute;						// �Ƿ�֧���������ͷ����ҳ��
	BOOL				bPTZFunctionViaApp;						// �Ƿ�֧����Ӧ�����ص���̨�����߼�
	BOOL				bAudioProperties;						// �����Ƿ�֧�������
	BOOL				bIsCameraIDOsd;							// �Ƿ�֧���������ŵ���
	BOOL				bIsPlaceOsd;							// �Ƿ�֧�ֵص���Ϣ����

	unsigned int		nMaxGeographyTitleLine;					// ����λ�õ������֧������
} DH_PRODUCTION_DEFNITION;

// �ֶ��ƹ����ģʽ
#define NET_LIGHTING_CTRL_ON_OFF                0x01            // ֱ�ӿ���ģʽ
#define NET_LIGHTING_CTRL_ADJUST_BRIGHTNESS     0x02            // �ֶ���������ģʽ
#define NET_LIGHTING_CTRL_ZOOM_PRIO             0x04            // ��������


// �����ӿ�����, �������Ϳ������
#define DH_MATRIX_CARD_MAIN                 0x10000000          // ����
#define DH_MATRIX_CARD_INPUT                0x00000001          // ���뿨
#define DH_MATRIX_CARD_OUTPUT               0x00000002          // �����
#define DH_MATRIX_CARD_ENCODE               0x00000004          // ���뿨
#define DH_MATRIX_CARD_DECODE               0x00000008          // ���뿨
#define DH_MATRIX_CARD_CASCADE              0x00000010          // ������
#define DH_MATRIX_CARD_INTELLIGENT          0x00000020          // ���ܿ�
#define DH_MATRIX_CARD_ALARM                0x00000040          // ������
#define DH_MATRIX_CARD_RAID                 0x00000080          // ӲRaid��
#define DH_MATRIX_CARD_NET_DECODE           0x00000100          // ������뿨

// �����ӿ���Ϣ
typedef struct tagDH_MATRIX_CARD
{
    DWORD               dwSize;
    BOOL                bEnable;                                // �Ƿ���Ч
    DWORD               dwCardType;                             // �ӿ�����
    char                szInterface[DH_MATRIX_INTERFACE_LEN];   // �źŽӿ�����, "CVBS", "VGA", "DVI"...
    char                szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // �豸ip������, ������ӿڵ��ӿ�����Ϊ��
    int                 nPort;                                  // �˿ں�, ������ӿڵ��ӿ�����Ϊ0
    int                 nDefinition;                            // ������, 0=����, 1=����
    int                 nVideoInChn;                            // ��Ƶ����ͨ����
    int                 nAudioInChn;                            // ��Ƶ����ͨ����
    int                 nVideoOutChn;                           // ��Ƶ���ͨ����
    int                 nAudioOutChn;                           // ��Ƶ���ͨ����
    int                 nVideoEncChn;                           // ��Ƶ����ͨ����
    int                 nAudioEncChn;                           // ��Ƶ����ͨ����
    int                 nVideoDecChn;                           // ��Ƶ����ͨ����
    int                 nAudioDecChn;                           // ��Ƶ����ͨ����
    int                 nStauts;                                // ״̬: -1-δ֪, 0-����, 1-����Ӧ, 2-�������, 3-��ͻ, 4-��������, 5-��·״̬�쳣, 6-�Ӱ屳��δ���, 7-����汾����
    int                 nCommPorts;                             // ������
    int                 nVideoInChnMin;                         // ��Ƶ����ͨ������Сֵ
    int                 nVideoInChnMax;                         // ��Ƶ����ͨ�������ֵ
    int                 nAudioInChnMin;                         // ��Ƶ����ͨ������Сֵ
    int                 nAudioInChnMax;                         // ��Ƶ����ͨ�������ֵ
    int                 nVideoOutChnMin;                        // ��Ƶ���ͨ������Сֵ
    int                 nVideoOutChnMax;                        // ��Ƶ���ͨ�������ֵ
    int                 nAudioOutChnMin;                        // ��Ƶ���ͨ������Сֵ
    int                 nAudioOutChnMax;                        // ��Ƶ���ͨ�������ֵ    
    int                 nVideoEncChnMin;                        // ��Ƶ����ͨ������Сֵ
    int                 nVideoEncChnMax;                        // ��Ƶ����ͨ�������ֵ
    int                 nAudioEncChnMin;                        // ��Ƶ����ͨ������Сֵ
    int                 nAudioEncChnMax;                        // ��Ƶ����ͨ�������ֵ
    int                 nVideoDecChnMin;                        // ��Ƶ����ͨ������Сֵ
    int                 nVideoDecChnMax;                        // ��Ƶ����ͨ�������ֵ
    int                 nAudioDecChnMin;                        // ��Ƶ����ͨ������Сֵ
    int                 nAudioDecChnMax;                        // ��Ƶ����ͨ�������ֵ
    int                 nCascadeChannels;                       // ����ͨ����
    int                 nCascadeChannelBitrate;                 // ����ͨ������, ��λMbps
    int                 nAlarmInChnCount;                       // ��������ͨ����
    int                 nAlarmInChnMin;                         // ��������ͨ������Сֵ
    int                 nAlarmInChnMax;                         // ��������ͨ�������ֵ
    int                 nAlarmOutChnCount;                      // �������ͨ����
    int                 nAlarmOutChnMin;                        // ��������ͨ������Сֵ
    int                 nAlarmOutChnMax;                        // ��������ͨ�������ֵ
    int                 nVideoAnalyseChnCount;                  // ���ܷ���ͨ����
    int                 nVideoAnalyseChnMin;                    // ���ܷ���ͨ������Сֵ
    int                 nVideoAnalyseChnMax;                    // ���ܷ���ͨ�������ֵ
    int                 nCommPortMin;                           // ���ں���Сֵ
    int                 nCommPortMax;                           // ���ں����ֵ
    char                szVersion[DH_COMMON_STRING_32];         // �汾��Ϣ
    NET_TIME            stuBuildTime;                           // ����ʱ��
    char                szBIOSVersion[DH_COMMON_STRING_64];     // BIOS�汾��
    char				szMAC[DH_MACADDR_LEN];					// MAC��ַ
} DH_MATRIX_CARD;

// �����ӿ��б�
typedef struct tagDH_MATRIX_CARD_LIST 
{
    DWORD               dwSize;
    int                 nCount;                                 // �ӿ�����
    DH_MATRIX_CARD      stuCards[DH_MATRIX_MAX_CARDS];          // �ӿ��б�
} DH_MATRIX_CARD_LIST;

// ��Ƶ�������
typedef struct tagDH_VIDEO_OUT_WINDOW
{
    DWORD               dwSize;
    int                 nBackboardID;               // �����
    int                 nScreenID;                  // ��Ļ��
    int                 nWindowID;                  // ���ں�
} DH_VIDEO_OUT_WINDOW;

// ���ñ���Դ��Ϣ,�������
typedef struct tagNET_IN_SETBACKUP_SOURCES_INFO
{
	DWORD				dwSize;
	int					nSetSourcesNum;				// 	����Դ��Ϣ����
	DH_SPLIT_SOURCE	*	pSource;					//  Դ��Ϣָ��(�ڴ����û������ͷ�)
} NET_IN_SETBACKUP_SOURCES_INFO;

// ���ñ���Դ��Ϣ,�������
typedef struct tagNET_OUT_SETBACKUP_SOURCES_INFO
{
	 DWORD				dwSize;
} NET_OUT_SETBACKUP_SOURCES_INFO;

// CLIENT_GetISCSITargets�ӿ��������
typedef struct tagDH_IN_ISCSI_TARGETS
{
    DWORD               dwSize;
    const char*         pszAddress;                 // ��������ַ
    int                 nPort;                      // �˿�
    const char*         pszUser;                    // �û���
    const char*         pszPwd;                     // ����
} DH_IN_ISCSI_TARGETS;

// ISCSI Target��Ϣ
typedef struct tagDH_ISCSI_TARGET 
{
    DWORD               dwSize;
    char                szName[DH_MAX_ISCSI_NAME_LEN];              // ����
    char                szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];     // ��������ַ
    char                szUser[DH_NEW_USER_NAME_LENGTH];            // �û���
    int                 nPort;                                      // �˿�
    UINT                nStatus;                                    // ״̬, 0-δ֪, 1-������, 2-δ����, 3-����ʧ��, 4-��֤ʧ��, 5-���ӳ�ʱ, 6-������    
} DH_ISCSI_TARGET;

// CLIENT_GetISCSITargets�ӿ��������
typedef struct tagDH_OUT_ISCSI_TARGETS
{
    DWORD               dwSize;
    DH_ISCSI_TARGET*    pstuTargets;                // iscsi����,���û������ڴ棬��СΪsizeof(DH_ISCSI_TARGET)*nMaxCount
    int                 nMaxCount;                  // iscsi�����С
    int                 nRetCount;                  // ��ȡ����iscsi��Ϣ��
} DH_OUT_ISCSI_TARGETS;

typedef enum tagDH_BITMAP_ACCURACY
{
    BA_DAY ,            //�� 
    BA_HOUR ,           //Сʱ
    BA_5MIN ,           //5����
}DH_BITMAP_ACCURACY;

#define DH_MAX_BITMAPS        256                        // λͼ�ֽ���,DH_MAX_BITMAPS*8λ
#define DH_MAX_CHN_NUM        256                        // ���ͨ����
//CLIENT_GetBitmap�ӿ��������
typedef struct tagDH_IN_BITMAP
{
    DWORD               dwSize;
    NET_TIME            stuStartTime;                   // ��ʼʱ��, ��ȷ����
    NET_TIME            stuEndTime;                     // ����ʱ��, ��ȷ����
    int                 nChnList[DH_MAX_CHN_NUM];       // [1, ��, 10]    ͨ�����б�,-1��ʾȫ��ͨ��,0��ʾ�б����
    DH_BITMAP_ACCURACY  emAccuracy;                     // λͼ����    
}DH_IN_BITMAP;

typedef struct tagDH_BITMAP_INFO
{
    DWORD               dwSize;
    int                 nChnID;                         //ͨ����,ͨ����λ0,��ʾ�б����
    BYTE                bBitmap[DH_MAX_BITMAPS];        //λͼ(ÿһ����λ��ʾһ����ѯ�̶�,�ɵ�λ���λ���)
                                                        //֧��DH_MAX_BITMAPS * 8���̶�
    int                 nBitNum;                        //��ȡ��λͼλ��
}DH_BITMAP_INFO;

//CLIENT_GetBitmap�ӿ��������
typedef struct tagDH_OUT_BITMAP
{
    DWORD               dwSize;
    DH_BITMAP_INFO      *pstBitmapInfos;   // ���û������ڴ棬��СΪsizeof(DH_BITMAP_INFO)*nMaxBitmapInfo
    int                 nGetBitmapInfo;
    int                 nMaxBitmapInfo;    
}DH_OUT_BITMAP;

// �洢�豸����
typedef struct tagDH_STORAGE_DEVICE_NAME 
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];
} DH_STORAGE_DEVICE_NAME;

// RAID״̬
#define DH_RAID_STATE_ACTIVE            0x00000001
#define DH_RAID_STATE_INACTIVE          0x00000002
#define DH_RAID_STATE_CLEAN             0x00000004
#define DH_RAID_STATE_FAILED            0x00000008
#define DH_RAID_STATE_DEGRADED          0x00000010
#define DH_RAID_STATE_RECOVERING        0x00000020
#define DH_RAID_STATE_RESYNCING         0x00000040
#define DH_RAID_STATE_RESHAPING         0x00000080
#define DH_RAID_STATE_CHECKING          0x00000100
#define DH_RAID_STATE_NOTSTARTED        0x00000200

// RAID��Ա��Ϣ
typedef struct tagNET_RAID_MEMBER_INFO 
{
    DWORD               dwSize;
    DWORD               dwID;                                       // ���̺�, ���������������ڴŹ�Ĳ�λ
    BOOL                bSpare;                                     // �Ƿ�ֲ��ȱ�, true-�ֲ��ȱ�, false-RAID����
} NET_RAID_MEMBER_INFO;

// RAID��Ϣ
typedef struct tagDH_STORAGE_RAID
{
    DWORD               dwSize;
    int                 nLevel;                                     // �ȼ�    
    int                 nState;                                     // RAID״̬���, �� DH_RAID_STATE_ACTIVE | DH_RAID_STATE_DEGRADED
    int                 nMemberNum;                                 // ��Ա����
    char                szMembers[DH_MAX_MEMBER_PER_RAID][DH_STORAGE_NAME_LEN];    // RAID��Ա	
    float               fRecoverPercent;                            // ͬ���ٷֱ�, 0~100, RAID״̬����"Recovering"��"Resyncing"ʱ��Ч
    float               fRecoverMBps;                               // ͬ���ٶ�, ��λMBps, RAID״̬����"Recovering"��"Resyncing"ʱ��Ч
    float               fRecoverTimeRemain;                         // ͬ��ʣ��ʱ��, ��λ����, RAID״̬����"Recovering"��"Resyncing"ʱ��Ч
    NET_RAID_MEMBER_INFO stuMemberInfos[DH_MAX_MEMBER_PER_RAID];    // RAID��Ա��Ϣ
	int                 nRaidDevices;                               // RAID�豸����
	int                 nTotalDevices;                              // RAID�豸����
	int                 nActiveDevices;                             // ��豸����
	int                 nWorkingDevices;                            // �����豸����
	int                 nFailedDevices;                             // ʧ���豸����
	int                 nSpareDevices;                              // �ȱ��豸����
} DH_STORAGE_RAID;

// �洢������Ϣ
typedef struct tagDH_STORAGE_PARTITION
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];                // ����
    INT64               nTotalSpace;                                // �ܿռ�, byte
    INT64               nFreeSpace;                                 // ʣ��ռ�, byte
    char                szMountOn[DH_STORAGE_MOUNT_LEN];            // ���ص�
    char                szFileSystem[DH_STORAGE_FILE_SYSTEM_LEN];   // �ļ�ϵͳ
    int                 nStatus;                                    // ����״̬, 0-LV������, 1-LV����
} DH_STORAGE_PARTITION;

// ��չ����Ϣ
typedef struct tagDH_STORAGE_TANK 
{
    DWORD               dwSize;
    int                 nLevel;                                     // ����, �����ǵ�0��,�������������
    int                 nTankNo;                                    // ͬһ����չ���ڵ���չ�ڱ��, ��0��ʼ
    int                 nSlot;                                      // ��Ӧ�����ϵİ忨��, ��0��ʼ���
} DH_STORAGE_TANK;

// �洢�豸״̬
#define NET_STORAGE_DEV_OFFLINE                 0                   // ����Ӳ���ѻ�״̬
#define NET_STORAGE_DEV_RUNNING                 1                   // ����Ӳ������״̬
#define NET_STORAGE_DEV_ACTIVE                  2                   // RAID�
#define NET_STORAGE_DEV_SYNC                    3                   // RAIDͬ��
#define NET_STORAGE_DEV_SPARE                   4                   // RAID�ȱ�(�ֲ�)
#define NET_STORAGE_DEV_FAULTY                  5                   // RAIDʧЧ
#define NET_STORAGE_DEV_REBUILDING              6                   // RAID�ؽ�
#define NET_STORAGE_DEV_REMOVED                 7                   // RAID�Ƴ�
#define NET_STORAGE_DEV_WRITE_ERROR             8                   // RAIDд����
#define NET_STORAGE_DEV_WANT_REPLACEMENT        9                   // RAID��Ҫ���滻
#define NET_STORAGE_DEV_REPLACEMENT             10                  // RAID������豸
#define NET_STORAGE_DEV_GLOBAL_SPARE            11                  // ȫ���ȱ�
#define NET_STORAGE_DEV_ERROR                   12                  // ����, ���ַ�������
#define NET_STORAGE_DEV_RAIDSUB                 13                  // ����Ŀǰ�ǵ���, ԭ���ǿ�Raid����, �п�����������Զ�����Raid

// �洢�豸��Ϣ
typedef struct tagDH_STORAGE_DEVICE 
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];                    // ����
    INT64               nTotalSpace;                                    // �ܿռ�, byte
    INT64               nFreeSpace;                                     // ʣ��ռ�, byte
    BYTE                byMedia;                                        // ����, 0-DISK, 1-CDROM, 2-FLASH
    BYTE                byBUS;                                          // ����, 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI
    BYTE                byVolume;                                       // ������, 0-�����, 1-Raid��, 2-VG�����, 3-ISCSI
    BYTE                byState;                                        // ����Ӳ��״̬, ȡֵΪ NET_STORAGE_DEV_OFFLINE �� NET_STORAGE_DEV_RUNNING ��
    int                 nPhysicNo;                                      // ͬ���豸�洢�ӿڵ�������
    int                 nLogicNo;                                       // ͬ���豸�洢�ӿڵ��߼����
    char                szParent[DH_STORAGE_NAME_LEN];                  // �ϼ��洢������
    char                szModule[DH_STORAGE_NAME_LEN];                  // �豸ģ��
    char                szSerial[DH_SERIALNO_LEN];                      // �豸���к�
    char                szFirmware[DH_VERSION_LEN];                     // �̼��汾
    int                 nPartitionNum;                                  // ������
    DH_STORAGE_PARTITION stuPartitions[DH_MAX_STORAGE_PARTITION_NUM];   // ������Ϣ
    DH_STORAGE_RAID     stuRaid;                                        // RAID��Ϣ, ֻ��RAID��Ч(byVolume == 1)
    DH_ISCSI_TARGET     stuISCSI;                                       // ISCSI��Ϣ, ֻ��ISCSI����Ч(byVolume == 3)
    BOOL                abTank;                                         // ��չ��ʹ��
    DH_STORAGE_TANK     stuTank;                                        // Ӳ��������չ����Ϣ, abTankΪTRUEʱ��Ч
} DH_STORAGE_DEVICE;

// �ָ��OSD��Ϣ
typedef struct tagNET_SPLIT_OSD 
{
    DWORD               dwSize;
    BOOL                bEnable;                    // ʹ��
    DH_COLOR_RGBA       stuFrontColor;              // ǰ����ɫ
    DH_COLOR_RGBA       stuBackColor;               // ������ɫ
    DH_RECT             stuFrontRect;               // ǰ������
    DH_RECT             stuBackRect;                // ��������
    BOOL                bRoll;                      // �Ƿ������ʾ, ֻ���ı���Ч
    BYTE                byRollMode;                 // ����ģʽ, ֻ���ı���Ч, 0-��������, 1-��������, 2-�������¹���, 3-�������Ϲ���
    BYTE                byRoolSpeed;                // ��������, ֻ���ı���Ч, 0~4, ��ֵԽ�����Խ��
    BYTE                byFontSize;                 // �����С, ֻ���ı���Ч
    BYTE                byTextAlign;                // ���뷽ʽ, 0-����, 1-����, 2-����
    BYTE                byType;                     // OSD����, 0-�ı�, 1-ͼ��
    BYTE                Reserved[3];                // �����ֽ�
    char                szContent[MAX_PATH];        // OSD����, ������Ϊͼ��, ����Ϊͼ������
    float               fPitch;                     // �ַ����, 0.0 ~ 5.0
    char                szFontType[DH_COMMON_STRING_64]; // ��������
} NET_SPLIT_OSD;

// CLIENT_GetSplitOSD �ӿ��������(��ȡ���봰�����OSD��Ϣ)
typedef struct tagDH_IN_SPLIT_GET_OSD
{
    DWORD               dwSize;
    int                 nChannel;                   // ͨ����
    int                 nWindow;                    // ���ں�
} DH_IN_SPLIT_GET_OSD;

// CLIENT_GetSplitOSD �ӿ��������(��ȡ���봰�����OSD��Ϣ)
typedef struct tagDH_OUT_SPLIT_GET_OSD
{
    DWORD               dwSize;
    int                 nOSDNum;                            // OSD����
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD��Ϣ
} DH_OUT_SPLIT_GET_OSD;

// CLIENT_SetSplitOSD �ӿ��������(���ý��봰�����OSD��Ϣ)
typedef struct tagDH_IN_SPLIT_SET_OSD
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
    int                 nWindow;                            // ���ں�
    int                 nOSDNum;                            // OSD����
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD��Ϣ
} DH_IN_SPLIT_SET_OSD;

// CLIENT_SetSplitOSD �ӿ��������(���ý��봰�����OSD��Ϣ)
typedef struct tagDH_OUT_SPLIT_SET_OSD
{
    DWORD               dwSize;
} DH_OUT_SPLIT_SET_OSD;

// CLIENT_GetSplitOSDEx �ӿ��������(��ȡ���봰�����OSD��Ϣ)
typedef struct tagNET_IN_SPLIT_GET_OSD_EX
{
    DWORD               dwSize;
    int                 nChannel;                   // ͨ����
    int                 nWindow;                    // ���ں�
} NET_IN_SPLIT_GET_OSD_EX;

// CLIENT_GetSplitOSDEx �ӿ��������(��ȡ���봰�����OSD��Ϣ)
typedef struct tagNET_OUT_SPLIT_GET_OSD_EX
{
    DWORD               dwSize;
    int                 nOSDNum;                            // OSD����
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX]; // OSD��Ϣ
} NET_OUT_SPLIT_GET_OSD_EX;


// CLIENT_SetSplitOSDEx�ӿ��������(���ý��봰�����OSD��Ϣ)
typedef struct tagNET_IN_SPLIT_SET_OSD_EX
{
	DWORD               dwSize;
    int                 nChannel;                           	// ͨ����
    int                 nWindow;                            	// ���ں�
    int                 nOSDNum;                            	// OSD����
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];    	// OSD��Ϣ
}NET_IN_SPLIT_SET_OSD_EX;

// CLIENT_SetSplitOSDEx �ӿ��������(���ý��봰�����OSD��Ϣ)
typedef struct tagNET_OUT_SPLIT_SET_OSD_EX
{
    DWORD               dwSize;
} NET_OUT_SPLIT_SET_OSD_EX;


// ��Ƶ������Ʒ�ʽ
typedef enum
{
    EM_VIDEO_OUT_CTRL_CHANNEL,              // �߼�ͨ���ſ��Ʒ�ʽ, ����������ƴ��������Ч
    EM_VIDEO_OUT_CTRL_COMPOSITE_ID,         // ƴ����ID���Ʒ�ʽ, ֻ��ƴ������Ч
} EM_VIDEO_OUT_CTRL_TYPE;

// CLIENT_SetSplitSourceEx �ӿڵ��������
typedef struct tagNET_IN_SET_SPLIT_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // ��Ƶ������Ʒ�ʽ
    int                     nChannel;           // ��Ƶ����߼�ͨ����, emCtrlTypeΪEM_VIDEO_OUT_CTRL_CHANNELʱ��Ч
    const char*             pszCompositeID;     // ƴ����ID, emCtrlTypeΪEM_VIDEO_OUT_CTRL_COMPOSITE_IDʱ��Ч
    int                     nWindow;            // ���ں�, -1��ʾ��ǰ�ָ�ģʽ�µ����д���
    DH_SPLIT_SOURCE*        pstuSources;        // ��ƵԴ��Ϣ, ��nWindow=-1ʱ, ��ƵԴ�Ǹ�����, �������봰����һ��
												// ���û������ڴ棬��СΪsizeof(DH_SPLIT_SOURCE)*nSourceCount
    int                     nSourceCount;       // ��ƵԴ����
} NET_IN_SET_SPLIT_SOURCE;

// ������ƵԴ�ķ��ؽ��
typedef struct tagNET_SET_SPLIT_SOURCE_RESULT 
{
    DWORD                   dwSize;
    int                     nPushPort;          // ����ģʽ���豸�˼����˿ں�
} NET_SET_SPLIT_SOURCE_RESULT;

// CLIENT_SetSplitSourceEx �ӿڵ��������
typedef struct tagNET_OUT_SET_SPLIT_SOURCE
{
    DWORD                   dwSize;
    NET_SET_SPLIT_SOURCE_RESULT* pstuResults;   // ���óɹ���ķ���ֵ, ��ӦNET_IN_SET_SPLIT_SOURCE�еĴ�������, �û������ڴ�,��СΪsizeof(NET_SET_SPLIT_SOURCE_RESULT)*nMaxResultCount, �������Ҫ����ΪNULL
    int                     nMaxResultCount;    // pstuResults����Ĵ�С
    int                     nRetCount;          // ���ص�����
} NET_OUT_SET_SPLIT_SOURCE;

//������ö��
typedef enum tagNET_VOLUME_TYPE
{
    VOLUME_TYPE_ALL = 0      ,      //���о�
    VOLUME_TYPE_PHYSICAL     ,      //�����
    VOLUME_TYPE_RAID         ,      //Raid��
    VOLUME_TYPE_VOLUME_GROUP ,      //VG�������
    VOLUME_TYPE_ISCSI        ,      //iSCSI��
    VOLUME_TYPE_INVIDUAL_PHY ,      //������������������,û�м��뵽, RAID,�������ȵ����У�
    VOLUME_TYPE_GLOBAL_SPARE ,      //ȫ���ȱ���
    VOLUME_TYPE_MAX          ,
}NET_VOLUME_TYPE;


#define    MAX_DEVICE_VOLUME_NUMS        128                //�����͵��������

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES���ͽӿ��������
typedef struct tagNET_IN_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //Ҫ��ȡ�ľ�����
} NET_IN_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES���ͽӿ��������
typedef struct tagNET_OUT_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    int                 nDevNamesNum;                       //��ȡ���豸�Ĵ洢ģ��������
    char                szStoregeDevNames[MAX_DEVICE_VOLUME_NUMS][DH_STORAGE_NAME_LEN]; //�豸���б�
}NET_OUT_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS�ӿ��������
typedef struct tagNET_IN_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //Ҫ��ȡ�ľ�����
} NET_IN_STORAGE_DEV_INFOS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS�ӿ��������
typedef struct tagNET_OUT_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    int                 nDevInfosNum;                      //��ȡ���豸�Ĵ洢ģ����Ϣ�б�
    DH_STORAGE_DEVICE   stuStoregeDevInfos[MAX_DEVICE_VOLUME_NUMS]; //�豸��Ϣ�б�,DH_STORAGE_DEVICE��dwsize�踳ֵ
} NET_OUT_STORAGE_DEV_INFOS;

typedef enum tagNET_RECENCY_CAR_INFO
{
    RECENCY_CAR_INFO_UNKNOW = 0 ,
    RECENCY_CAR_INFOO_NEWEST    ,      //����
    RECENCY_CAR_INFO_ODLEST     ,      //���
    RECENCY_CAR_INFO_MAX        ,
}NET_RECENCY_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO�ӿ��������
typedef struct tagNET_IN_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD                   dwSize;
    int                     nChannel;       //ץ��ͨ����
    NET_RECENCY_CAR_INFO    emRecencyType;  //��ȡ������Ϣ������,���µĻ�����ɵ�
    DWORD                   nIndex;         //�ڼ���������Ϣ,��1��ʼ,���Ϊ0Ҳ��ʾ��1��
}NET_IN_GET_RECENCY_JUNCTION_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO�ӿ��������
typedef struct tagNET_OUT_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD           dwSize;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;        // ��ͨ������Ϣ
}NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO;

// 
#define NET_MAX_FISHEYE_WINDOW_NUM               8         // ������۴�����

// ����λ����Ϣ
typedef struct tagNET_FISHEYE_WINDOW_INFO
{
    DWORD             dwSize;
    DWORD             dwWindowID;                        // ����ID
    int               nFocusX;                           // EPtz��������̨���Ľ��������
    int               nFocusY;                           // EPtz (������̨���Ľ���������   
    int               nHorizontalAngle;                  // EPtz��ˮƽ�Ƕ�
    int               nVerticalAngle;                    // EPtz�Ĵ�ֱ�Ƕ�
}NET_FISHEYE_WINDOW_INFO;

// ��ӦCLIENT_QueryDevInfo�ӿ�,NET_QUERY_DEV_FISHEYE_WININFO��ѯ���۴�����Ϣ�������
typedef struct tagNET_IN_FISHEYE_WININFO
{
    DWORD               dwSize;
    int                 nChannelId;                      // ͨ����
    int                 nWindowNum;                      // ����ѯ�Ĵ�����
    int                 nWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // ����id,�����ظ�
}NET_IN_FISHEYE_WININFO;

// ��ӦCLIENT_QueryDevInfo�ӿ�,NET_QUERY_DEV_FISHEYE_WININFO��ѯ���۴�����Ϣ�������
typedef struct tagNET_OUT_FISHEYE_WININFO
{
    DWORD               dwSize;
    int                 nWindowNum;                      //�Ĵ�����
    NET_FISHEYE_WINDOW_INFO stuWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // ���ھ�����Ϣ
}NET_OUT_FISHEYE_WININFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE�ӿ��������
typedef struct tagNET_IN_GET_LANES_STATE
{
    DWORD                   dwSize;
    int                     nLaneNumber; //-1�����ѯ���г���,>=0ʱ��ʾ��ѯָ������
}NET_IN_GET_LANES_STATE;

//�źŵ�ָʾ״̬
typedef enum tagNET_TRAFFIC_LIGHT_STATUS
{
    LIGHT_STATUS_UNKNOWN  = 0   ,    //δ֪
    LIGHT_STATUS_RED            ,    //���
    LIGHT_STATUS_GREEN          ,    //�̵�
    LIGHT_STATUS_YELLOW         ,    //�Ƶ�
}NET_TRAFFIC_LIGHT_STATUS;

//�źŵ�ָʾ��Ϣ
typedef struct tatNET_TRAFFIC_LIGHT_INFO
{
    DWORD                       dwSize;
    NET_TRAFFIC_LIGHT_STATUS    emStraightLightInfo;    //ֱ���źŵ�״̬
    NET_TRAFFIC_LIGHT_STATUS    emLeftLightInfo;        //��ת�źŵ�״̬
    NET_TRAFFIC_LIGHT_STATUS    emRightLightInfo;       //��ת�źŵ�״̬
    NET_TRAFFIC_LIGHT_STATUS    emUTurnLightInfo;       //��ͷ�źŵ�״̬
}NET_TRAFFIC_LIGHT_INFO;

//��������
typedef enum tagNET_TRAFFIC_DIRECTION
{
    DIRECTION_UNKNOW    = 0 ,   //δ֪
    DIRECTION_STRAIGHT      ,   //ֱ��
    DIRECTION_LEFT          ,   //��ת
    DIRECTION_RIGHT         ,   //��ת
    DIRECTION_UTURN         ,   //��ͷ
}NET_TRAFFIC_DIRECTION;

//������Ϣ
typedef struct tagNET_TRAFFIC_LANE_INFO
{
    DWORD                   dwSize;
    UINT                    nLaneNumber;                                    //������,0��ʼ
    UINT                    nSupportDirectionNum;                           //����������ʹ�ķ�����
    NET_TRAFFIC_DIRECTION   emTrafficDirections[MAX_LANE_DIRECTION_NUM];    //��������,��ʾ�˳���������ʹ�����з���
    NET_TRAFFIC_JAM_STATUS  emJamState;                                     //��·ӵ��״��
    //������Ϣ
    UINT                    nLargeVehicleNum;                               //���ͳ�����
    UINT                    nMediumVehicleNum;                              //���ͳ�����
    UINT                    nSmallVehicleNum;                               //С�ͳ�����
    UINT                    nMotoNum;                                       //Ħ�г�����
}NET_TRAFFIC_LANE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE�ӿ��������
typedef struct tagNET_OUT_GET_LANES_STATE
{
    DWORD                   dwSize;
    int                     nGetLaneInfoNum;                    //��ȡ���ĳ�����Ϣ��
    NET_TRAFFIC_LANE_INFO   stLaneInfos[MAX_LANE_INFO_NUM];     //��ȡ���ĳ�����Ϣ
    NET_TRAFFIC_LIGHT_INFO  stLightInfo;                        //�źŵ�ָʾ״̬
}NET_OUT_GET_LANES_STATE;

//CLIENT_QueryDevInfo , NET_QUERY_SYSTEM_INFO ���ͽӿ��������
typedef struct tagNET_IN_SYSTEM_INFO
{
    DWORD               dwSize;
} NET_IN_SYSTEM_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_SYSTEM_INFO ���ͽӿ��������
typedef struct tagNET_OUT_SYSTEM_INFO
{
    DWORD               dwSize;
    BOOL                bHasRTC;                       //�Ƿ���RTCоƬ(��¼ϵͳʱ����)Ĭ��TRUE,��ʾ��RTC
    int                 nRetMCUNum;                   // ���صĵ�Ƭ������ 	 	 
    char                szMCUVersion[MAX_MCU_NUM][DH_MAX_VERSION_LEN];         // ��Ƭ������汾��
}NET_OUT_SYSTEM_INFO;


//CLIENT_QueryDevInfo , NET_QUERY_REG_DEVICE_NET_INFO ���ͽӿ��������
typedef struct tagNET_IN_REGDEV_NET_INFO
{
    DWORD               dwSize;
    char                szDevSerial[DH_DEV_SERIALNO_LEN];   // ����ע��ʱ�ϱ����豸���к�
}NET_IN_REGDEV_NET_INFO;

//����ע������ʹ�õ���������
typedef enum tagNET_CELLUAR_NET_TYPE 
{
    EM_CELLUAR_NET_UNKNOW           =   -1  ,    //δ֪
    EM_CELLUAR_NET_PRIVATE_3G_4G    =   0   ,    //ר��3G/4G����,(�繫������)
    EM_CELLUAR_NET_COMMERCIAL_3G_4G =   1   ,    //���õ�3G/4G����,(���ƶ������ŵ�)
    EM_CELLUAR_NET_MAX , 
}NET_CELLUAR_NET_TYPE;

//CLIENT_QueryDevInfo , NET_QUERY_REG_DEVICE_NET_INFO  ���ͽӿ��������
typedef struct tagNET_OUT_REGDEV_NET_INFO
{
    DWORD                   dwSize;
    NET_CELLUAR_NET_TYPE    emCelluarNetType;           //����ע������ʹ�õ���������
}NET_OUT_REGDEV_NET_INFO;

// ��ȡ��Ƶͨ�����������������
typedef enum tagNET_VIDEO_CHANNEL_TYPE
{
    NET_VIDEO_CHANNEL_TYPE_ALL,                         // ȫ��
    NET_VIDEO_CHANNEL_TYPE_INPUT,                       // ����
    NET_VIDEO_CHANNEL_TYPE_OUTPUT,                      // ���
} NET_VIDEO_CHANNEL_TYPE;

//CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO �����������
typedef struct tagNET_IN_GET_VIDEOCHANNELSINFO
{
    DWORD                               dwSize;
    NET_VIDEO_CHANNEL_TYPE              emType;         // ��Ҫ��ȡ��ͨ������                     
} NET_IN_GET_VIDEOCHANNELSINFO;

typedef struct tagNET_VIDEOCHANNELS_INPUT 
{
    int                     nThermographyCount;         // �ȳ���ͨ������
    int                     nThermography[64];          // �ȳ���ͨ����ͨ����
    int                     nMultiPreviewCount;         // �໭��Ԥ��ͨ������
    int                     nMultiPreview[4];	        // �໭��Ԥ��ͨ����
    int                     nPIPCount;                  // ���л�ͨ������
    int                     nPIP[4];    	            // ���л�ͨ����
    int                     nCompressPlayCount;         // ����ѹ���ط�ͨ������
    int                     nCompressPlay[4];	        // ����ѹ���ط�ͨ����
	int						nSDCount;					// ���ͨ������
	int						nSD[64];					// ���ͨ����
    char                    reserved[252];
} NET_VIDEOCHANNELS_INPUT;

typedef struct tagNET_VIDEOCHANNELS_OUTPUT 
{
    int                     nVGACount;                  // VGA�������
    int                     nVGA[128];                  // VGA���
    int                     nTVCount;                   // TV�������
    int                     nTV[128];                   // TV���
    char                    reserved[512];
} NET_VIDEOCHANNELS_OUTPUT;

//CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO �����������
typedef struct tagNET_OUT_GET_VIDEOCHANNELSINFO
{
    DWORD                       dwSize;
    NET_VIDEOCHANNELS_INPUT     stInputChannels;        // ����ͨ����Ϣ,��ȡ����ΪNET_VIDEO_CHANNEL_TYPE_ALL/INPUTʱ��Ч        
    NET_VIDEOCHANNELS_OUTPUT    stOutputChannels;       // ���ͨ����Ϣ,��ȡ����ΪNET_VIDEO_CHANNEL_TYPE_ALL/OUTPUTʱ��Ч
} NET_OUT_GET_VIDEOCHANNELSINFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES �����������
typedef struct tagNET_IN_WORKGROUP_NAMES
{
    DWORD                       dwSize;
} NET_IN_WORKGROUP_NAMES;

// ����Ŀ¼������󳤶�
#define WORKGROUP_NAME_LEN      32

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES �����������
typedef struct tagNET_OUT_WORKGROUP_NAMES
{
    DWORD                       dwSize;
    int                         nCount;                         // ���������
    char                        szName[64][WORKGROUP_NAME_LEN]; // ÿ�������������
} NET_OUT_WORKGROUP_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO �����������
typedef struct tagNET_IN_WORKGROUP_INFO
{
    DWORD                       dwSize;
    char                        szName[WORKGROUP_NAME_LEN];     // ��Ҫ��ȡ��Ϣ�Ĺ�����                    
} NET_IN_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO �����������
typedef struct tagNET_OUT_WORKGROUP_INFO
{
    DWORD                       dwSize;
    int                         nState;                         // ״̬��0 ������,1 ����,2 ��,3 ����
    int                         nTotalSpace;                    // �ܿռ� ��λ��MB -1��ʾ��ȡʧ��
    int                         nFreeSpace;                     // ʣ��ռ� ��λ��MB -1��ʾ��ȡʧ��
} NET_OUT_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT �����������
typedef struct tagNET_IN_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    char                        szSSID[DH_MAX_SSID_LEN];        // ��Ҫ��ȡ��Ϣ��������������,Ϊ��ʱ������������                    
} NET_IN_WLAN_ACCESSPOINT;

typedef struct tagNET_WLAN_ACCESSPOINT_INFO
{
    char                        szSSID[DH_MAX_SSID_LEN];        // ������������
    int                         nStrength;                      // �ź�ǿ�� ��Χ0-100
    int                         nAuthMode;                     // ��֤ģʽ0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
                                                                // 6:WPA-NONE(����adhoc����ģʽ),
                                                                // 7-11�ǻ��ģʽ,ѡ�������κ�һ�ֶ����Խ������� 
                                                                // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
                                                                // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
    int                         nEncrAlgr;                     // ����ģʽ0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
                                                                // 7: TKIP+AES(���ģʽ) 8: UnKnown
    char                        reserved[1016];
} NET_WLAN_ACCESSPOINT_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT �����������
typedef struct tagNET_OUT_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    int                         nCount;                         // ���������������
    NET_WLAN_ACCESSPOINT_INFO   stuInfo[64];                    // �������Ϣ                       
} NET_OUT_WLAN_ACCESSPOINT;

// CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION �����������
typedef struct tagNET_IN_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    int                     nChannel;                   // ���ں�
} NET_IN_TRAFFICRADAR_VERSION;

// CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION �����������
typedef struct tagNET_OUT_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    char                    szVersion[DH_MAX_VERSION_LEN];  // �汾��
} NET_OUT_TRAFFICRADAR_VERSION;

// �ӿ� CLIENT_AttachLanesState ���������
typedef NET_OUT_GET_LANES_STATE NET_CB_LANES_STATE;

// �ӿ� CLIENT_AttachLanesState �ص�����
typedef void (CALLBACK *fNotifyLanesState)(LLONG lLanesStateHandle, NET_CB_LANES_STATE* pLanesStateInfo, LDWORD dwUser, void *reserved);

// �ӿ� CLIENT_AttachLanesState ���������
typedef struct tagNET_IN_ATTACH_LANES_STATE
{
    DWORD                dwSize;                         // �˽ṹ���С
    int                  nChannelID;                     // ͨ����
    int                  nLaneNumber;                    // -1���������г���,>=0ʱ��ʾ����ָ������
    
    fNotifyLanesState    cbNotifyLanesState;             // �ص�����
    LDWORD               dwUser;                         // �û��Զ������
} NET_IN_ATTACH_LANES_STATE;

// �ӿ� CLIENT_AttachLanesState ���������
typedef struct tagNET_OUT_ATTACH_LANES_STATE
{
    DWORD                dwSize;                         // �˽ṹ���С
} NET_OUT_ATTACH_LANES_STATE;

// CLIENT_MatrixSwitch �������
typedef struct tagNET_IN_MATRIX_SWITCH
{
    DWORD           dwSize;
    DH_SPLIT_MODE   emSplitMode;                // �ָ�ģʽ
    int*            pnOutputChannels;           // ���ͨ��, ��ͬʱָ��������ͨ��һ���л�, ����һ��
												// ���û������ڴ棬��СΪsizeof(int)*nOutputChannelCount
    int             nOutputChannelCount;        // ���ͨ����
    int*            pnInputChannels;            // ����ͨ��, ÿ���ָ��һ����Ӧһ������ͨ��
												// ���û������ڴ棬��СΪsizeof(int)*nInputChannelCount
    int             nInputChannelCount;         // ����ͨ����
} NET_IN_MATRIX_SWITCH;

// CLIENT_MatrixSwitch �������
typedef struct tagNET_OUT_MATRIX_SWITCH 
{
    DWORD            dwSize;
} NET_OUT_MATRIX_SWITCH;

// CLIENT_SplitSetMultiSource �ӿڵ��������
typedef struct tagNET_IN_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // ��Ƶ������Ʒ�ʽ
    int                     nChannel;           // ��Ƶ����߼�ͨ����, emCtrlTypeΪEM_VIDEO_OUT_CTRL_CHANNELʱ��Ч
    const char*             pszCompositeID;     // ƴ����ID, emCtrlTypeΪEM_VIDEO_OUT_CTRL_COMPOSITE_IDʱ��Ч
    BOOL                    bSplitModeEnable;   // �Ƿ�ı�ָ�ģʽ
    DH_SPLIT_MODE           emSplitMode;        // �ָ�ģʽ, bSplitModeEnable=TRUEʱ��Ч
    int                     nGroupID;           // �ָ�����, bSplitModeEnable=TRUEʱ��Ч
    int*                    pnWindows;          // ���ں�����,���û������ڴ棬��СΪsizeof(int)*nWindowCount
    int                     nWindowCount;       // ��������
    DH_SPLIT_SOURCE*        pstuSources;        // ��ƵԴ��Ϣ, �ֱ��Ӧÿ������, ����ͬ������,���û������ڴ棬��СΪsizeof(DH_SPLIT_SOURCE)*nWindowCount
} NET_IN_SPLIT_SET_MULTI_SOURCE;

// CLIENT_SplitSetMultiSource �ӿڵ��������
typedef struct tagNET_OUT_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
} NET_OUT_SPLIT_SET_MULTI_SOURCE;

// ��Ƶ�ָ��������
typedef enum tagNET_SPLIT_OPERATE_TYPE
{
    NET_SPLIT_OPERATE_SET_BACKGROUND,           // ���ñ���ͼƬ, ��Ӧ NET_IN_SPLIT_SET_BACKGROUND �� NET_OUT_SPLIT_SET_BACKBROUND
    NET_SPLIT_OPERATE_GET_BACKGROUND,           // ��ȡ����ͼƬ, ��Ӧ NET_IN_SPLIT_GET_BACKGROUND �� NET_OUT_SPLIT_GET_BACKGROUND
    NET_SPLIT_OPERATE_SET_PREPULLSRC,           // ����Ԥ����Դ, ��Ӧ NET_IN_SPLIT_SET_PREPULLSRC �� NET_OUT_SPLIT_SET_PREPULLSRC
    NET_SPLIT_OPERATE_SET_HIGHLIGHT,            // ����Դ�߿����ʹ�ܿ���, ��Ӧ NET_IN_SPLIT_SET_HIGHLIGHT �� NET_OUT_SPLIT_SET_HIGHLIGHT
    NET_SPLIT_OPERATE_SET_ZORDER,               // ��������Z��, ��Ӧ NET_IN_SPLIT_SET_ZORDER �� NET_OUT_SPLIT_SET_ZORDER
    NET_SPLIT_OPERATE_SET_TOUR,                 // ������Ѳ����, ��Ӧ NET_IN_SPLIT_SET_TOUR �� NET_OUT_SPLIT_SET_TOUR
    NET_SPLIT_OPERATE_GET_TOUR_STATUS,          // ��ȡ������Ѳ״̬, ��Ӧ NET_IN_SPLIT_GET_TOUR_STATUS �� NET_OUT_SPLIT_GET_TOUR_STATUS
    NET_SPLIT_OPERATE_GET_SCENE,                // ��ȡ���ڴ�����Ϣ, ��Ӧ NET_IN_SPLIT_GET_SCENE �� NET_OUT_SPLIT_GET_SCENE
    NET_SPLIT_OPERATE_OPEN_WINDOWS,             // ��������, ��Ӧ NET_IN_SPLIT_OPEN_WINDOWS �� NET_OUT_SPLIT_OPEN_WINDOWS
    NET_SPLIT_OPERATE_SET_WORK_MODE,            // ���ù���ģʽ, ��Ӧ NET_IN_SPLIT_SET_WORK_MODE �� NET_OUT_SPLIT_SET_WORK_MODE
    NET_SPLIT_OPERATE_GET_PLAYER,               // ��ȡ������ʵ��,��Ӧ NET_IN_SPLIT_GET_PLAYER �� NET_OUT_SPLIT_GET_PLAYER
    NET_WM_OPERATE_SET_WORK_MODE,               // ���ô��ڹ���ģʽ,��Ӧ NET_IN_WM_SET_WORK_MODE �� NET_OUT_WM_SET_WORK_MODE
    NET_WM_OPERATE_GET_WORK_MODE,               // ��ȡ���ڹ���ģʽ,��Ӧ NET_IN_WM_GET_WORK_MODE �� NET_OUT_WM_GET_WORK_MODE
    NET_SPLIT_OPERATE_CLOSE_WINDOWS,            // �����ش�, ��Ӧ NET_IN_SPLIT_CLOSE_WINDOWS �� NET_OUT_SPLIT_CLOSE_WINDOWS
    NET_WM_OPERATE_SET_FISH_EYE_PARAM,          // ��������������۽������� , ��ӦNET_IN_WM_SET_FISH_EYE_PARAM �� NET_OUT_WM_SET_FISH_EYE_PARAM
	NET_WM_OPERATE_SET_CORRIDOR_MODE,			// ���ô�������ģʽ����ӦNET_IN_WM_SET_CORRIDOR_MODE��NET_OUT_WM_SET_CORRIDOR_MODE
	NET_WM_OPERATE_GET_CORRIDOR_MODE,			// ��ȡ��������ģʽ����ӦNET_IN_WM_GET_CORRIDOR_MODE��NET_OUT_WM_GET_CORRIDOR_MODE
	NET_WM_OPERATE_SET_VOLUME_COLUMN,			// ������ʾ������ʹ��ģʽ����ӦNET_IN_WM_SET_VOLUME_COLUMN��NET_OUT_WM_SET_VOLUME_COLUMN
	NET_WM_OPERATE_GET_VOLUME_COLUMN,			// ��ȡ��ʾ������ʹ��ģʽ����ӦNET_IN_WM_GET_VOLUME_COLUMN��NET_OUT_WM_GET_VOLUME_COLUMN
	NET_WM_OPERATE_SET_BACKGROUND,				// ���ô��ڱ���ͼƬ����ӦNET_IN_WM_SET_BACKGROUND��NET_OUT_WM_SET_BACKGROUND
	NET_WM_OPERATE_GET_BACKGROUND,				// ��ȡ���ڱ���ͼƬ����ӦNET_IN_WM_GET_BACKGROUND��NET_OUT_WM_GET_BACKGROUND
} NET_SPLIT_OPERATE_TYPE;
 
// ����Դ�߿����ʹ�ܿ����������
typedef struct tagNET_IN_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize; 
    int             nChannel;                   // ��Ƶ���ͨ��
    int             nWindow;                    // ���ں�
    BOOL            bHighLightEn;               // �߿����ʹ��,TRUE-��ʾ����
    DH_COLOR_RGBA   stuColor;                   // �߿���ɫ 
    int				nBlinkTimes;				// �߿���˸����
    int				nBlinkInterval;				// ��˸���ʱ��,��λms
}NET_IN_SPLIT_SET_HIGHLIGHT;

// ����Դ�߿����ʹ�ܿ����������
typedef struct tagNET_OUT_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize;
}NET_OUT_SPLIT_SET_HIGHLIGHT;

// ����Ԥ����Դ�������
typedef struct tagNET_IN_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nChannel;                   // ��Ƶ���ͨ��
    int             nWindow;                    // ���ں�
    int             nSrcCount;                  // Ԥ����Դ����
    DH_SPLIT_SOURCE* pSources;                  // Ԥ����Դ��Ϣ,���û������ڴ棬��СΪsizeof(DH_SPLIT_SOURCE)*nSrcCount
} NET_IN_SPLIT_SET_PREPULLSRC;

// ����Ԥ����Դ�ķ��ؽ��
typedef struct tagNET_SPLIT_SET_PREPULLSRC_RESULT 
{
    DWORD           dwSize;
    BOOL            bResult;                    // ���ý��, TRUE-�ɹ�, FALSE-ʧ��
    DWORD           dwErrorCode;                // ʧ�ܴ�����
} NET_SPLIT_SET_PREPULLSRC_RESULT;

// ����Ԥ����Դ�������
typedef struct tagNET_OUT_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nResultCount;               // �������, ��Ԥ����Դ������ͬ
    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // ���
} NET_OUT_SPLIT_SET_PREPULLSRC;

// ������Ƶ�������ͼ�������
typedef struct tagNET_IN_SPLIT_SET_BACKGROUND
{
    DWORD            dwSize;
    int              nChannel;                   // ��Ƶ���ͨ����
    BOOL             bEnable;                    // ʹ��
    const char*      pszFileName;                // ����ͼ����
} NET_IN_SPLIT_SET_BACKGROUND;

// ������Ƶ�������ͼ�������
typedef struct tagNET_OUT_SPLIT_SET_BACKGROUND 
{
    DWORD            dwSize;
} NET_OUT_SPLIT_SET_BACKGROUND;

// ��ȡ��Ƶ�������ͼ�������
typedef struct tagNET_IN_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    int              nChannel;                   // ��Ƶ���ͨ����
} NET_IN_SPLIT_GET_BACKGROUND;

// ��ȡ��Ƶ�������ͼ�������
typedef struct tagNET_OUT_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    BOOL             bEnable;                            // ʹ��
    char             szFileName[DH_COMMON_STRING_256];   // ����ͼ����
} NET_OUT_SPLIT_GET_BACKGROUND;

//���ô��ڱ���ͼ�������
typedef struct tagNET_IN_WM_SET_BACKGROUND
{
	DWORD				dwSize;
	int					nChannel;							// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	char			   *pszCompositeID;						// �ں���ID
	int					nWindowID;							// ���ں�
	BOOL				bEnable;							// �Ƿ���ӵ�ͼ
	char				szFileName[DH_COMMON_STRING_128];	// ����ͼƬ����
} NET_IN_WM_SET_BACKGROUND;

// ���ô��ڱ���ͼ�������
typedef struct tagNET_OUT_WM_SET_BACKGROUND
{
	DWORD            	dwSize;
} NET_OUT_WM_SET_BACKGROUND;

// ��ȡ���ڱ���ͼ�������
typedef struct tagNET_IN_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	int					nChannel;				// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	char			   *pszCompositeID;			// �ں���ID
	int					nWindowID;				// ���ں�
} NET_IN_WM_GET_BACKGROUND;

// ��ȡ���ڱ���ͼ�������
typedef struct tagNET_OUT_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	BOOL             	bEnable;                            // �Ƿ���ӵ�ͼ
    char             	szFileName[DH_COMMON_STRING_128];   // ����ͼ����
} NET_OUT_WM_GET_BACKGROUND;

// ����Z����
typedef enum tagNET_WINDOW_ZORDER
{
    NET_WINDOW_ZORDER_TOP,                              // ����
    NET_WINDOW_ZORDER_BOTTOM,                           // �ײ�
    NET_WINDOW_ZORDER_UP,                               // ����һ��
    NET_WINDOW_ZORDER_DOWN,                             // ����һ��
} NET_WINDOW_ZORDER;

// ���ڲ������
typedef struct tagDH_WND_ZORDER
{
    DWORD               dwSize;
    unsigned int        nWindowID;                      // �������
    unsigned int        nZOrder;                        // Z����
} DH_WND_ZORDER;

// ���ô���Z���������
typedef struct tagNET_IN_SPLIT_SET_ZORDER 
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
    int                 nWindow;                        // ���ں�
    NET_WINDOW_ZORDER   emZOrder;                       // ������Z��
} NET_IN_SPLIT_SET_ZORDER;

// ���ô���Z���������, ����һ�����ڵ�Z���Ӱ�����д���, ���ص��������д��ڵ�Z��
typedef struct tagNET_OUT_SPLIT_SET_ZORDER
{
    DWORD               dwSize;
    DH_WND_ZORDER*      pZOders;                        // ���ڴ�������, �û������ڴ�,��СΪsizeof(DH_WND_ZORDER)*nMaxWndCount
    int                 nMaxWndCount;                   // ���ڴ��������С
    int                 nWndCount;                      // ���صĴ�������
} NET_OUT_SPLIT_SET_ZORDER;

// ������Ѳ����
typedef enum tagEM_NET_WINDOW_TOUR_ACTION 
{
    EM_NET_WND_TOUR_ACTION_START,                       // ��ʼ
    EM_NET_WND_TOUR_ACTION_STOP,                        // ֹͣ
} EM_NET_WINDOW_TOUR_ACTION;

// ������Ѳ�����������, ��ӦNET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_IN_SPLIT_SET_TOUR 
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
    int                 nWindow;                        // ���ں�
    EM_NET_WINDOW_TOUR_ACTION emAction;                 // ��Ѳ����
} NET_IN_SPLIT_SET_TOUR;

// ������Ѳ�����������, ��ӦNET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_OUT_SPLIT_SET_TOUR 
{
    DWORD               dwSize;
} NET_OUT_SPLIT_SET_TOUR;

// ��ȡ������Ѳ״̬�������, ��ӦNET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_IN_SPLIT_GET_TOUR_STATUS
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
    int                 nWindow;                        // ���ں�, -1��ʾ���д���
} NET_IN_SPLIT_GET_TOUR_STATUS;

// ��Ѳ״̬
typedef enum tagNET_TOUR_STATUS
{
    NET_TOUR_UNKNOWN,                               // δ֪
    NET_TOUR_START,                                 // ��Ѳ��
    NET_TOUR_STOP,                                  // ��Ѳֹͣ
}NET_TOUR_STATUS;

// ������Ѳ״̬��Ϣ
typedef struct tagNET_WINDOW_TOUR_STATUS_INFO 
{
    DWORD               dwSize;
    int                 nWindow;                        // ���ں�
    NET_TOUR_STATUS     emStatus;                       // ״̬
} NET_WINDOW_TOUR_STATUS_INFO;

// ��ȡ������Ѳ״̬�������, ��ӦNET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_OUT_SPLIT_GET_TOUR_STATUS
{
    DWORD               dwSize;
    NET_WINDOW_TOUR_STATUS_INFO* pstuStatus;            // ״̬��Ϣָ��,  �û������ڴ�. ��ѯ���ں�Ϊ-1ʱ��ʾ������ڵ���Ϣ����.
    int                 nMaxStatusCount;                // ״̬��Ϣ�������, �û�����
    int                 nRetStatusCount;                // ״̬��Ϣʵ������, ��ѯ�õ�
} NET_OUT_SPLIT_GET_TOUR_STATUS;

// ���������������, ��ӦNET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_IN_SPLIT_OPEN_WINDOWS 
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���id
    int                 nWindowNum;                     // ��������
    NET_RECT*           pstuWindowRects;                // ������������,���û������ڴ棬��СΪsizeof(NET_RECT)*nWindowNum
    BOOL                bDirectable;                    // ����ֱͨ����
} NET_IN_SPLIT_OPEN_WINDOWS;

// ������Ϣ
typedef struct tagNET_SPLIT_WINDOW_INFO
{
    DWORD               dwSize;
    int                 nWindowID;                      // ���ں�
    int                 nZOrder;                        // Z����
    char                szControlID[DH_DEV_ID_LEN];     // ���Ʊ��
} NET_SPLIT_WINDOW_INFO;

// ���������������, ��ӦNET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_OUT_SPLIT_OPEN_WINDOWS 
{
    DWORD               dwSize;
    NET_SPLIT_WINDOW_INFO*  pstuWindows;                // ������Ϣ, �û������ڴ�,��СΪsizeof(NET_SPLIT_WINDOW_INFO)*nMaxWindowCount
    int                 nMaxWindowCount;                // ������Ϣ�������, �û�����
    int                 nRetWindowCount;                // ��������
} NET_OUT_SPLIT_OPEN_WINDOWS;

// ����ָ��ģʽ
typedef enum tagNET_SPLIT_WORK_MODE
{
    NET_SPLIT_WORK_MODE_UNKNOWN,                        // δ֪
    NET_SPLIT_WORK_MODE_LOCAL,                          // ������ͨģʽ
    NET_SPLIT_WORK_MODE_REPLAY,                         // �ط�ģʽ
}NET_SPLIT_WORK_MODE;

// ���ù���ģʽ�������, ��Ӧ NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_SPLIT_SET_WORK_MODE 
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
    NET_SPLIT_WORK_MODE emMode;                         // ����ģʽ
}NET_IN_SPLIT_SET_WORK_MODE;

// ���ù���ģʽ�������, ��Ӧ NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_SPLIT_SET_WORK_MODE 
{
    DWORD               dwSize;
}NET_OUT_SPLIT_SET_WORK_MODE;

// ����������
typedef enum tagNET_SPLIT_PLAYER_TYPE
{
    NET_SPLIT_PLAYER_TYPE_UNKNOWN,                       // δ֪
    NET_SPLIT_PLAYER_TYPE_FILE_LIST,                     // �ļ��б�����
    NET_SPLIT_PLAYER_TYPE_FILE,                          // �ļ�������
}NET_SPLIT_PLAYER_TYPE;

// ��ȡ������ʵ���������, ��Ӧ NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_IN_SPLIT_GET_PLAYER
{
    DWORD                 dwSize;
    int                   nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*           pszCompositeID;                 // �ں���ID
    NET_SPLIT_PLAYER_TYPE emType;                         // ����������
    int                   nWindow;                        // ���������ڵĴ��ں�
}NET_IN_SPLIT_GET_PLAYER;

// ��ȡ������ʵ���������, ��Ӧ NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_OUT_SPLIT_GET_PLAYER
{
    DWORD                 dwSize;
    LLONG                 lPlayerID;                      // ������ʵ��ID
}NET_OUT_SPLIT_GET_PLAYER;

// ���ڹ���ģʽ
typedef enum tagNET_WM_WORK_MODE
{
    NET_WM_WORK_MODE_UNKNOWN,                             // δ֪
    NET_WM_WORK_MODE_DISPLAY,                             // Ԥ��ģʽ
    NET_WM_WORK_MODE_REPLAY,                              // �ط�ģʽ  
}NET_WM_WORK_MODE;

// ���ô��ڹ���ģʽ�������, ��Ӧ NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*           pszCompositeID;                 // �ں���ID
    int                   nWindow;                        // ���ں�
    NET_WM_WORK_MODE      emMode;                         // ���ڹ���ģʽ
}NET_IN_WM_SET_WORK_MODE;

//���ô��ڹ���ģʽ�������, ��Ӧ NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
}NET_OUT_WM_SET_WORK_MODE;

// ��ȡ���ڹ���ģʽ�������, ��Ӧ NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_IN_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*           pszCompositeID;                 // �ں���ID
    int                   nWindow;                        // ���ں�
}NET_IN_WM_GET_WORK_MODE;

//��ȡ���ڹ���ģʽ�������, ��Ӧ NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_OUT_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    NET_WM_WORK_MODE      emMode;                         // ���ڹ���ģʽ
}NET_OUT_WM_GET_WORK_MODE;

// ���ô�������ģʽ�����������ӦNET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				  nChannel;			// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	const char* 		  pszCompositeID;	// �ں���ID
	int 				  nWindow;			// ���ں�
	BOOL	  			  bIsCorridor;		// ��������ģʽ(TRUE:��  FALSE:�ر�)
} NET_IN_WM_SET_CORRIDOR_MODE;

// ���ô�������ģʽ�����������ӦNET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;		// �û�ʹ��ʱ��ֵΪ�ṹ���С
} NET_OUT_WM_SET_CORRIDOR_MODE;

// ��ȡ��������ģʽ�����������ӦNET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				  nChannel;			// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	const char* 		  pszCompositeID;	// �ں���ID
	int 				  nWindow;			// ���ں�
} NET_IN_WM_GET_CORRIDOR_MODE;

// ��ȡ��������ģʽ�����������ӦNET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL	  			  bIsCorridor;		// ��������ģʽ(TRUE:��  FALSE:�ر�)
} NET_OUT_WM_GET_CORRIDOR_MODE;

// ������ʾ������ʹ��ģʽ�����������ӦNET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_SET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				  nChannel;			// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	const char* 		  pszCompositeID;	// �ں���ID
	BOOL				  bIsEnable;	    // �Ƿ���ʾ������(TRUE:��ʾ  FALSE:�ر�)
} NET_IN_WM_SET_VOLUME_COLUMN;				

// ������ʾ������ʹ��ģʽ�����������ӦNET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_SET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
} NET_OUT_WM_SET_VOLUME_COLUMN;

// ��ȡ��ʾ������ʹ��ģʽ���˲�������ӦNET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_GET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				  nChannel;			// ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
	const char* 		  pszCompositeID;	// �ں���ID
} NET_IN_WM_GET_VOLUME_COLUMN;

// ��ȡ��ʾ������ʹ��ģʽ�����������ӦNET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_GET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL				   bIsEnable;		// �Ƿ���ʾ������(TRUE:��ʾ  FALSE:�ر�)	
} NET_OUT_WM_GET_VOLUME_COLUMN;

// �����ش��������, ��ӦNET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_IN_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
    int*                pnWindows;                      // ���ں�����ָ��,���û������ڴ�,��СΪsizeof(int)*nWindowCount
    int                 nWindowCount;                   // ��������
} NET_IN_SPLIT_CLOSE_WINDOWS;

// �ش��������
typedef struct tagNET_SPLIT_CLOSE_WINDOW_RESULT 
{
    BOOL                bResult;                        // ���
    char                reserved[256];                  // �����ֽ�
} NET_SPLIT_CLOSE_WINDOW_RESULT ;

// �����ش��������, ��ӦNET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_OUT_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    NET_SPLIT_CLOSE_WINDOW_RESULT* pstuResults;         // �������, �û������ڴ�,��СΪsizeof(NET_SPLIT_CLOSE_WINDOW_RESULT)*nMaxResultCount. �������Ҫ���ؽ��, ����ΪNULL
    int                 nMaxResultCount;                // ��������������, �û���д.
    int                 nRetResultCount;                // ���صĽ������
} NET_OUT_SPLIT_CLOSE_WINDOWS;

//��������۽���ģʽ
typedef enum tagNET_WM_FISHEYE_CALIBRATE_MODE
{
    NET_WM_FISHEYE_CALIBRATE_MODE_UNKOWN ,            // δ֪ģʽ
    NET_WM_FISHEYE_CALIBRATE_MODE_CLOSE ,             // �ر������㷨
    NET_WM_FISHEYE_CALIBRATE_MODE_ORIGINAL,           // ԭʼģʽ(������) �����ű���
    NET_WM_FISHEYE_CALIBRATE_MODE_PANORAMA,           // 1P
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_ONE,       // 1P+1
    NET_WM_FISHEYE_CALIBRATE_MODE_DOUBLE_PANORAMA,    // 2P        
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_DOUBLE_PAN,     // 1+2p
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_THREEE,    // 1+3
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_THREEE,    // 1p+3
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_TWO,       // 1+2
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_FOUR,      // 1+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_FOUR,      // 1p+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_SIX,       // 1p+6
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_EIGHT,     // 1+8
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_EIGHT,     // 1P+8
}NET_WM_FISHEYE_CALIBRATE_MODE;

//���۽��������������
typedef struct tagNET_WM_FISH_EYE_REGION_PARAM
{
    int     nCoordinateX;         // �������Ķ�Ӧ��ԭʼԲ�ĺ�����
    int     nCoordinateY;         // �������Ķ�Ӧ��ԭʼԲ�ĺ�����������
    int     nAngleH;              // ��X��YΪ����,У������Χ��ˮƽ�Ƕ�
    int     nAngleV;              // ��X��YΪ����,У������Χ�Ĵ�ֱ�Ƕ�
    int 	nAvailable;			  // ��ʾ�Ƿ����
    BYTE    Reserved[124];        // �����ֽ�
}NET_WM_FISH_EYE_REGION_PARAM;

#define MAX_FISH_EYE_REGION_NUM     9
//ģʽ��ʼ����������Ϣ,������ģʽ�л��ָ�����һ�ε�״̬
typedef struct tagNET_WM_SET_FISHEYE_INIT_PARAM
{
    BOOL                            bUseRegion;         // ΪTRUEʱ,ʹ�����³�Ա���г�ʼ��,ΪFALSEʱ���³�Ա��Ч
    int                             nCircular;          // ����ƫ��(������ʾģʽ�д�ԭʼͼʱ�����塣��1+3��1+8��ģʽ��1����)
    int                             nPanorama;          // ȫ��ƫ��(������ʾģʽ��ȫ��ʱ������,��1P��2P��ģʽ)
	int                             nFishEyeRegionNum;  // ���۽������������������(�����������ʵ�ʵĽ���ģʽ.��1+3,����4��Ԫ��)
    NET_WM_FISH_EYE_REGION_PARAM    stFishEyeRegions[MAX_FISH_EYE_REGION_NUM];    // ���۽����������������Ϣ
    BYTE                            Reserved[1024];                       // �����ֽ�
}NET_WM_SET_FISHEYE_INIT_PARAM;

//������̨�����ƶ�����
typedef struct tagNET_WM_SET_FISHEYE_EPTZ_PARAM
{
	int 							nOptWayType;		// ��������(��ʾ������̨����ʱ��arg1,��ʾ���ƶ����ǷŴ�)
	int 							nOptWinNum; 		// С���ں�(��ǰ���ڲ�����С���ں�)
	int 							nOptWayData;		// ��������(��ʾ������̨����ʱ�����ݴ�С����OptWayType���ʹ��)
	BYTE                            Reserved[512];      // �����ֽ�
}NET_WM_SET_FISHEYE_EPTZ_PARAM;

//��������������۽��������������, ��ӦNET_IN_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_IN_WM_SET_FISH_EYE_PARAM
{
    DWORD                           dwSize;
    int                             nChannel;            // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*                     pszCompositeID;      // �ں���ID
    int                             nWindowID;           // ��Ӧ������Ĵ��ں�

    NET_FISHEYE_MOUNT_MODE          emMount;            // ���۰�װģʽ
    NET_WM_FISHEYE_CALIBRATE_MODE   emCalibrate;        // ���۽���ģʽ
    NET_WM_SET_FISHEYE_INIT_PARAM   stInitParam;        // ģʽ��ʼ����������Ϣ   
    NET_WM_SET_FISHEYE_EPTZ_PARAM	stEPtzParam;		// ������̨�����ƶ�����
}NET_IN_WM_SET_FISH_EYE_PARAM;

//��������������۽��������������, ��ӦNET_OUT_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_OUT_WM_SET_FISH_EYE_PARAM
{
    DWORD dwSize;
}NET_OUT_WM_SET_FISH_EYE_PARAM;

////////////////////////////////// ϵͳ״̬ ////////////////////////////////////////

// CPU��Ϣ
typedef struct tagDH_CPU_INFO
{
    DWORD               dwSize;
    int                 nUsage;                         // CPU������
} DH_CPU_INFO;

// CPU״̬
typedef struct tagDH_CPU_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                        // ��ѯ�Ƿ�ɹ�
    int                 nCount;                         // CPU����
    DH_CPU_INFO         stuCPUs[DH_MAX_CPU_NUM];        // CPU��Ϣ
} DH_CPU_STATUS;

// �ڴ���Ϣ
typedef struct tagDH_MEMORY_INFO
{
    DWORD               dwSize;
    DWORD               dwTotal;                        // ���ڴ�, M
    DWORD               dwFree;                         // ʣ���ڴ�, M
} DH_MEMORY_INFO;

// �ڴ�״̬
typedef struct tagDH_MEMORY_STATUS 
{
    DWORD               dwSize;
    BOOL                bEnable;                        // ��ѯ�Ƿ�ɹ�
    DH_MEMORY_INFO      stuMemory;                      // �ڴ���Ϣ
} DH_MEMORY_STATUS;

// ������Ϣ
typedef struct tagDH_FAN_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // ����
    DWORD               nSpeed;                         // �ٶ�
} DH_FAN_INFO;

// ����״̬
typedef struct tagDH_FAN_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                        // ��ѯ�Ƿ�ɹ�
    int                 nCount;                         // ��������
    DH_FAN_INFO         stuFans[DH_MAX_FAN_NUM];        // ����״̬
} DH_FAN_STATUS;

// ��Դ����״̬����
typedef enum __EM_CURRENT_STATE_TYPE
{
    EM_CURRENT_STATE_UNKNOWN = 0,
    EM_CURRENT_STATE_OVER_CURRENT,                      // ��������
    EM_CURRENT_STATE_NORMAL,                            // ��������
    EM_CURRENT_STATE_UNDER_CURRENT,                     // ��ԴǷ��
}EM_CURRENT_STATE_TYPE;

// ��Դ��ѹ״̬����
typedef enum tagEM_VOLTAGE_STATE_TYPE
{
    EM_VOLTAGE_STATE_UNKNOWN,                           // δ֪
    EM_VOLTAGE_STATE_OVER,                              // ��ѹ
    EM_VOLTAGE_STATE_NORMAL,                            // ����
    EM_VOLTAGE_STATE_UNDER,                             // Ƿѹ
} EM_VOLTAGE_STATE_TYPE;

// ��Դ��Ϣ
typedef struct tagDH_POWER_INFO
{
    DWORD               dwSize;
    BOOL                bPowerOn;                       // ��Դ״̬, 0-�ر�, 1-��, 2-�򿪵��й���
    EM_CURRENT_STATE_TYPE emCurrentState;               // ��Դ����״̬
    EM_VOLTAGE_STATE_TYPE emVoltageState;               // ��Դ��ѹ״̬
} DH_POWER_INFO;


// �����λ״̬
typedef enum __EM_BATTERY_EXIST_STATE
{
    EM_BATTERY_EXIST_STATE_UNKNOWN = 0,
    EM_BATTERY_EXIST_STATE_EXIST,                       // �����λ
    EM_BATTERY_EXIST_STATE_MISSING,                     // ��ض�ʧ
}EM_BATTERY_EXIST_STATE;

// ��ص���״̬
typedef enum __EM_BATTERY_STATE
{
    EM_BATTERY_STATE_UNKNOWN = 0,
    EM_BATTERY_STATE_NORMAL,                            // ��������
    EM_BATTERY_STATE_LOW,                               // ������
}EM_BATTERY_STATE;

// �����Ϣ, CLIENT_QueryDevState�ӿڵ� DH_DEVSTATE_POWER_STATE �������
typedef struct tagDH_BATTERY_INFO
{
    DWORD               dwSize;
    int                 nPercent;                       // ��������ٷֱ�
    BOOL                bCharging;                      // �Ƿ����ڳ��
    EM_BATTERY_EXIST_STATE emExistState;                // �����λ״̬
    EM_BATTERY_STATE    emState;                        // ��ص���״̬
	float				fVoltage;						// ��ص�ѹ
} DH_BATTERY_INFO;

// ��Դ״̬
typedef struct tagDH_POWER_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                            // ��ѯ�Ƿ�ɹ�
    int                 nCount;                             // ��Դ����
    DH_POWER_INFO       stuPowers[DH_MAX_POWER_NUM];        // ��Դ״̬
    int                 nBatteryNum;                        // �������
    DH_BATTERY_INFO     stuBatteries[DH_MAX_BATTERY_NUM];   // ���״̬
} DH_POWER_STATUS;

// �¶���Ϣ
typedef struct tagDH_TEMPERATURE_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];         // ����������
    float               fTemperature;                       // �¶�
} DH_TEMPERATURE_INFO;

// �¶�״̬
typedef struct tagDH_TEMPERATURE_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                            // ��ѯ�Ƿ�ɹ�
    int                 nCount;                             // �¶�����
    DH_TEMPERATURE_INFO stuTemps[DH_MAX_TEMPERATURE_NUM];   // �¶���Ϣ 
} DH_TEMPERATURE_STATUS;

// ϵͳ״̬
typedef struct tagDH_SYSTEM_STATUS
{
    DWORD                   dwSize;
    DH_CPU_STATUS*          pstuCPU;                        // CPU״̬
    DH_MEMORY_STATUS*       pstuMemory;                     // �ڴ�״̬
    DH_FAN_STATUS*          pstuFan;                        // ����״̬
    DH_POWER_STATUS*        pstuPower;                      // ��Դ״̬
    DH_TEMPERATURE_STATUS*  pstuTemp;                       // �¶�״̬
} DH_SYSTEM_STATUS;

// ��ӦCLIENT_QueryDevState()�ӿڵ� DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE�������
// ��ȡ����ͨ��״̬
typedef enum tagNET_ALARM_CHANNEL_TYPE
{
    NET_ALARM_CHANNEL_TYPE_ALL,                             // ����ͨ���������������У�
    NET_ALARM_CHANNEL_TYPE_ALARMIN,                         // ��������ͨ��
    NET_ALARM_CHANNEL_TYPE_ALARMOUT,                        // �������ͨ��
    NET_ALARM_CHANNEL_TYPE_ALARMBELL,                       // ����ͨ��
    NET_ALARM_CHANNEL_TYPE_EXALARMIN,                       // ��չģ�鱨������ͨ��
    NET_ALARM_CHANNEL_TYPE_EXALARMOUT,                      // ��չģ�鱨�����ͨ��
}NET_ALARM_CHANNEL_TYPE;

typedef struct tagNET_CLIENT_ALARM_CHANNELS_STATE
{
    DWORD                       dwSize;
    NET_ALARM_CHANNEL_TYPE      emType;                     // ��ѯ����ͨ��������                                                                                                                                
    int                         nAlarmInCount;              // �����������,���û�ָ��
    int                         nAlarmInRetCount;           // �������뷵�ظ���
    BOOL*                       pbAlarmInState;             // ��������״̬����,���û������ڴ�,ÿ��Ԫ�ر�ʾһ��ͨ��״̬,TRUEΪ������,FALSEΪ������
															// ���û������ڴ�,��Сsizeof(BOOL)*nAlarmInCount
	int                         nAlarmOutCount;             // �����������,���û�ָ��
    int                         nAlarmOutRetCount;          // �����������
    BOOL*                       pbAlarmOutState;            // �������״̬����,���û������ڴ�,ÿ��Ԫ�ر�ʾһ��ͨ��״̬,TRUEΪ�����,FALSEΪ���
															// ���û������ڴ�,��Сsizeof(BOOL)*nAlarmOutCount
	int                         nAlarmBellCount;            // ���Ÿ���,���û�ָ��
    int                         nAlarmBellRetCount;         // ���ŷ��ظ���
    BOOL*                       pbAlarmBellState;           // ����״̬����,���û������ڴ�,ÿ��Ԫ�ر�ʾһ��ͨ��״̬,TRUEΪ�����,FALSEΪ�����
															// ���û������ڴ�,��Сsizeof(BOOL)*nAlarmBellCount
	int                         nExAlarmInCount;            // ��չģ�鱨���������,���û�ָ��
    int                         nExAlarmInRetCount;         // ��չģ�鱨�����뷵�ظ���
    BOOL*                       pbExAlarmInState;           // ��չģ�鱨������״̬����,���û������ڴ�,ÿ��Ԫ�ر�ʾһ��ͨ��״̬,TRUEΪ�����,FALSEΪ�����
															// ���û������ڴ�,��Сsizeof(BOOL)*nExAlarmInCount
	int*                        pnExAlarmInDestionation;    // ��չģ�鱨��������Чͨ����λ��,���û������ڴ�,��Сsizeof(int)*nExAlarmInCount
    int                         nExAlarmOutCount;           // ��չģ�鱨���������,���û�ָ��
    int                         nExAlarmOutRetCount;        // ��չģ�鱨���������
    BOOL*                       pbExAlarmOutState;          // ��չģ�鱨�����״̬����,���û������ڴ�,ÿ��Ԫ�ر�ʾһ��ͨ��״̬,TRUEΪ�����,FALSEΪ�����
															// ���û������ڴ棬��СΪsizeof(BOOL)*nExAlarmOutCount
	int*                        pnExAlarmOutDestionation;   // ��չģ�鱨�������Чͨ����λ��,���û������ڴ棬��СΪsizeof(int)*nExAlarmOutCount
}NET_CLIENT_ALARM_CHANNELS_STATE;


// ���������ӵı���������
typedef struct tagNET_ALARMKEYBOARD_COUNT
{
    DWORD               dwSize;
    int                 nAlarmKeyboardCount;        // �����ŵı���������Ŀ
}NET_ALARMKEYBOARD_COUNT;

// �豸�������ӵ��豸����
typedef enum tagEM_COM_PORT_DEVICE_TYPE
{
    EM_COM_PORT_DEVICE_TYPE_UNKNOWN,        // δ֪��
    EM_COM_PORT_DEVICE_TYPE_PTZ,            // ptz
    EM_COM_PORT_DEVICE_TYPE_GPS,            // GPS
    EM_COM_PORT_DEVICE_TYPE_ALARMKEYBOARD,  // ��������
    EM_COM_PORT_DEVICE_TYPE_EXALARMBOX,     // ��չ��������
}EM_COM_PORT_DEVICE_TYPE;

// ��ȡ�豸COM�˿����ӵ��豸ͨ����Ϣ(���)
typedef struct tagNET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;
    EM_COM_PORT_DEVICE_TYPE emDeviceType;   // �豸����
}NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// ��ȡ�豸COM�˿����ӵ��豸ͨ����Ϣ(����)
typedef struct tagNET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;    
    int                 nDeviceCount;               // �豸��Ŀ(����,���������ߺ����ߵ�)
    int                 nMaxOnlineDeviceCount;      // ���ߵ��豸��������(���)
    int                 nRetOnlineDeviceCount;      // �豸���صĵ�ǰ���ߵ��豸����(����)      
    int*                pOnlineChannel;             // ��ǰ���ߵ��豸��ͨ����������(���,���û������ͷ��ڴ�)    
}NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// ��ȡ�豸COM�˿����ӵ��豸ͨ����Ϣ,pInParam��pInParamOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetComPortDeviceChannelInfo(LLONG lLoginID,const NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO* pInParam,NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO* pOutParam,int nWaitTime);

////////////////////////////////// �������� ////////////////////////////////////////
// CLIENT_OpenSplitWindow�ӿ��������(����)
typedef struct tagDH_IN_SPLIT_OPEN_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                   // ͨ����(����)
    DH_RECT             stuRect;                    // ����λ��, 0~8192
    BOOL                bDirectable;                // �����Ƿ�����ֱͨ����, ֱͨ��ָƴ������ʽ��,�˴�����������Ϊ����������
} DH_IN_SPLIT_OPEN_WINDOW;

// CLIENT_OpenSplitWindow�ӿ��������(����)
typedef struct tagDH_OUT_SPLIT_OPEN_WINDOW
{
    DWORD               dwSize;
    unsigned int        nWindowID;                  // �������
    unsigned int        nZOrder;                    // ���ڴ���        
} DH_OUT_SPLIT_OPEN_WINDOW;

// CLIENT_CloseSplitWindow�ӿ��������(�ش�)
typedef struct tagDH_IN_SPLIT_CLOSE_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                   // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    UINT                nWindowID;                  // �������
    const char*         pszCompositeID;             // �ں���ID
} DH_IN_SPLIT_CLOSE_WINDOW;

// CLIENT_CloseSplitWindow�ӿ��������(�ش�)
typedef struct tagDH_OUT_SPLIT_CLOSE_WINDOW
{
    DWORD               dwSize;
} DH_OUT_SPLIT_CLOSE_WINDOW;

// CLIENT_SetSplitWindowRect�������(���ô���λ��)
typedef struct tagDH_IN_SPLIT_SET_RECT
{
    DWORD               dwSize;
    int                 nChannel;                   // ͨ����(����)
    UINT                nWindowID;                  // �������
    DH_RECT             stuRect;                    // ����λ��, 0~8192
    BOOL                bDirectable;                // �����Ƿ�����ֱͨ����, ֱͨ��ָƴ������ʽ��,�˴�����������Ϊ����������
} DH_IN_SPLIT_SET_RECT;

// CLIENT_SetSplitWindowRect�ӿ��������(���ô���λ��)
typedef struct tagDH_OUT_SPLIT_SET_RECT
{
    DWORD               dwSize;
} DH_OUT_SPLIT_SET_RECT;

// CLIENT_GetSplitWindowRect�ӿ��������(��ȡ����λ��)
typedef struct tagDH_IN_SPLIT_GET_RECT
{
    DWORD               dwSize;
    int                 nChannel;                  // ͨ����(����)
    UINT                nWindowID;                 // �������
} DH_IN_SPLIT_GET_RECT;

// CLIENT_GetSplitWindowRect�ӿ��������(��ȡ����λ��)
typedef struct tagDH_OUT_SPLIT_GET_RECT
{
    DWORD               dwSize;    
    DH_RECT             stuRect;                   // ����λ��, 0~8192
} DH_OUT_SPLIT_GET_RECT;

// CLIENT_SetSplitWindowLevels�ӿ��������(���ô��ڴ���)
typedef struct tagDH_IN_SPLIT_SET_TOP_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                  // ͨ����(����)
    int                 nWindowID;                 // �������
} DH_IN_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetSplitWindowLevels�ӿ��������(���ô��ڴ���)
typedef struct tagDH_OUT_SPLIT_SET_TOP_WINDOW
{
    DWORD               dwSize;
    DH_WND_ZORDER*      pZOders;                   // ���ڴ�������,���û������ڴ�,��СΪsizeof(DH_WND_ZORDER)*nMaxWndCount
    int                 nMaxWndCount;              // ���ڴ��������С
    int                 nWndCount;                 // ���صĴ�������
} DH_OUT_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetDisplayMode�ӿ��������(����ǽ��ʾģʽ����)
typedef struct tagDH_IN_WM_SET_DISPLAY_MODE 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszBlockID;                 // ����ID, NULL/""-��������
    int                 nTVID;                      // ��ʾ��Ԫ���, -1��ʾ������������ʾ��Ԫ
    UINT                nDisplayMode;               // ��ʾģʽ, 0-��׼, 1-����, 2-����
} DH_IN_WM_SET_DISPLAY_MODE;

// CLIENT_SetDisplayMode�ӿ��������(����ǽ��ʾģʽ����)
typedef struct tagDH_OUT_WM_SET_DISPLAY_MODE
{
    DWORD               dwSize;
} DH_OUT_WM_SET_DISPLAY_MODE;

// ������������ʾ��Ԫ����ʾģʽ
typedef struct tagDH_BLOCK_DISPLAY_MODE
{
    DWORD               dwSize;
    int*                pTVModes;                   // TV��ʾģʽ����
    int                 nMaxTVCount;                // TV��ʾģʽ�����С
    int                 nRetTVCount;                // ʵ��TV����
} DH_BLOCK_DISPLAY_MODE;

// CLIENT_GetDisplayMode�ӿڵ��������(��ȡ����ǽ��ʾģʽ)
typedef struct tagDH_IN_WM_GET_DISPLAY_MODE 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszBlockID;                 // ����ID, NULL/""-��������
    int                 nTVID;                      // ��ʾ��Ԫ���, -1��ʾ������������ʾ��Ԫ
} DH_IN_WM_GET_DISPLAY_MODE;

// CLIENT_GetDisplayMode�ӿڵ��������(��ȡ����ǽ��ʾģʽ)
typedef struct tagDH_OUT_WM_GET_DISPLAY_MODE
{
    DWORD                   dwSize;
    DH_BLOCK_DISPLAY_MODE*  pBlockModes;            // ������ʾģʽ����,���û������ڴ棬��СΪsizeof(DH_BLOCK_DISPLAY_MODE)*nMaxBlockCount
    int                     nMaxBlockCount;         // ������ʾģʽ�����С
    int                     nRetBlockCount;         // ʵ����������
} DH_OUT_WM_GET_DISPLAY_MODE;

// CLIENT_PowerControl�ӿ��������(����ǽ��Դ����)
typedef struct tagDH_IN_WM_POWER_CTRL 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszBlockID;                 // ����ID, NULL/""-��������
    int                 nTVID;                      // ��ʾ��Ԫ���, -1��ʾ������������ʾ��Ԫ
    BOOL                bPowerOn;                   // �Ƿ�򿪵�Դ
} DH_IN_WM_POWER_CTRL;

// CLIENT_PowerControl�ӿ��������(����ǽ��Դ����)
typedef struct tagDH_OUT_WM_POWER_CTRL
{
    DWORD               dwSize;
} DH_OUT_WM_POWER_CTRL;

// CLIENT_LoadMonitorWallCollection�ӿ��������(�������ǽԤ��)
typedef struct tagDH_IN_WM_LOAD_COLLECTION 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszName;                    // Ԥ������
} DH_IN_WM_LOAD_COLLECTION;

// CLIENT_LoadMonitorWallCollection�ӿ��������(�������ǽԤ��)
typedef struct tagDH_OUT_WM_LOAD_COLLECTION 
{
    DWORD               dwSize;
} DH_OUT_WM_LOAD_COLLECTION;

// CLIENT_SaveMonitorWallCollection�ӿ��������(�������ǽԤ��)
typedef struct tagDH_IN_WM_SAVE_COLLECTION 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszName;                    // Ԥ������
    const char*         pszControlID;               // ����id
} DH_IN_WM_SAVE_COLLECTION;

// CLIENT_SaveMonitorWallCollection�ӿ��������(�������ǽԤ��)
typedef struct tagDH_OUT_WM_SAVE_COLLECTION 
{
    DWORD               dwSize;
} DH_OUT_WM_SAVE_COLLECTION;

// CLIENT_RenameMonitorWallCollection�ӿ��������(Ԥ��������)
typedef struct tagDH_IN_WM_RENAME_COLLECTION 
{
    DWORD               dwSize;
    int                 nMonitorWallID;                // ����ǽ���
    const char*         pszOldName;                    // ԭ����
    const char*         pszNewName;                    // ������
} DH_IN_WM_RENAME_COLLECTION;

// CLIENT_RenameMonitorWallCollection�ӿ��������(Ԥ��������)
typedef struct tagDH_OUT_WM_RENAME_COLLECTION
{
    DWORD                dwSize;
} DH_OUT_WM_RENAME_COLLECTION;

// ���鴰����Ϣ
typedef struct tagDH_WINDOW_COLLECTION
{
    DWORD               dwSize;
    int                 nWindowID;                      // ����ID
    BOOL                bWndEnable;                     // �����Ƿ���Ч
    DH_RECT             stuRect;                        // ��������, ���ɷָ�ģʽ����Ч
    BOOL                bDirectable;                    // �����Ƿ�����ֱͨ����
    int                 nZOrder;                        // ����Z����
    BOOL                bSrcEnable;                     // ��ʾԴ�Ƿ���Ч
    char                szDeviceID[DH_DEV_ID_LEN_EX];   // �豸ID
    int                 nVideoChannel;                  // ��Ƶͨ����
    int                 nVideoStream;                   // ��Ƶ��������
    int                 nAudioChannel;                  // ��Ƶͨ��
    int                 nAudioStream;                   // ��Ƶ��������
    int                 nUniqueChannel;                 // �豸��ͳһ��ŵ�Ψһͨ����
} DH_WINDOW_COLLECTION;

// �����ղ�
typedef struct tagDH_BLOCK_COLLECTION 
{
    DWORD                dwSize;
    DH_SPLIT_MODE        emSplitMode;                   // �ָ�ģʽ
    DH_WINDOW_COLLECTION stuWnds[DH_MAX_SPLIT_WINDOW];  // ������Ϣ����
    int                  nWndsCount;                    // ��������
    char                 szName[DH_DEVICE_NAME_LEN];    // �ղؼ�����
    int                  nScreen;                       // ���ͨ����, ����ƴ����
    char                 szCompositeID[DH_DEV_ID_LEN_EX]; // ƴ����ID    
    DH_WINDOW_COLLECTION* pstuWndsEx;                   // ������Ϣ����ָ��, ���û������ڴ�. ��stuWnds�����С������ʱ����ʹ��
    int                  nMaxWndsCountEx;               // ��󴰿�����, �û���д. pstuWndsEx�����Ԫ�ظ���
    int                  nRetWndsCountEx;               // ���ش�������
} DH_BLOCK_COLLECTION;

// ����ǽ��ʾ��Ԫ
typedef struct tagDH_MONITORWALL_OUTPUT 
{
    DWORD               dwSize;
    char                szDeviceID[DH_DEV_ID_LEN];          // �豸ID, ����ʱΪ""
    int                 nChannel;                           // ͨ����
    char                szName[DH_DEV_NAME_LEN];            // ��Ļ����
} DH_MONITORWALL_OUTPUT;

// ����ǽ��ʾ����
typedef struct tagDH_MONITORWALL_BLOCK
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // ��������
    char                    szCompositeID[DH_DEV_ID_LEN];   // ƴ����ID
    char                    szControlID[DH_DEV_ID_LEN];     // ����ID
    int                     nSingleOutputWidth;             // ������ʾ��Ԫ��ռ����������
    int                     nSingleOutputHeight;            // ������ʾ��Ԫ��ռ����������
    DH_RECT                 stuRect;                        // ��������
    DH_TSECT                stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // ����ʱ���, ��һά��Ԫ�ر�ʾ����~�����ͽڼ���
    DH_MONITORWALL_OUTPUT*  pstuOutputs;                    // ��ʾ��Ԫ����, �û������ڴ�
    int                     nMaxOutputCount;                // ��ʾ��Ԫ�����С, �û���д
    int                     nRetOutputCount;                // ���ص���ʾ��Ԫ����
} DH_MONITORWALL_BLOCK;

// ����ǽ����
typedef struct tagDH_MONITORWALL 
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // ����
    int                     nGridLine;                      // ��������
    int                     nGridColume;                    // ��������
    DH_MONITORWALL_BLOCK*   pstuBlocks;                     // ��ʾ��������, �û������ڴ�
    int                     nMaxBlockCount;                 // ��ʾ���������С, �û���д
    int                     nRetBlockCount;                 // ���ص���ʾ��������
    BOOL                    bDisable;                       // �Ƿ����, 0-�õ���ǽ��Ч, 1-�õ���ǽ��Ч
    char                    szDesc[DH_COMMON_STRING_256];   // ����ǽ������Ϣ
} DH_MONITORWALL;

// ����ǽԤ��
typedef struct tagDH_MONITORWALL_COLLECTION 
{
    DWORD                dwSize;
    char                 szName[DH_DEVICE_NAME_LEN];    // ����ǽԤ������
    DH_BLOCK_COLLECTION  stuBlocks[DH_MAX_BLOCK_NUM];   // ��������
    int                  nBlocksCount;                  // ��������
    char                 szControlID[DH_DEV_ID_LEN_EX]; // ����ID
    DH_MONITORWALL       stuMonitorWall;                // ����ǽ����
} DH_MONITORWALL_COLLECTION;

// CLIENT_GetMonitorWallCollections�ӿ��������(��ȡ����ǽԤ����Ϣ)
typedef struct tagDH_IN_WM_GET_COLLECTIONS 
{
    DWORD                dwSize;
    int                  nMonitorWallID;                // ����ǽID
} DH_IN_WM_GET_COLLECTIONS;

// CLIENT_GetMonitorWallCollections�ӿ��������(��ȡ����ǽԤ����Ϣ)
typedef struct tagDH_OUT_WM_GET_COLLECTIONS 
{
    DWORD                       dwSize;    
    DH_MONITORWALL_COLLECTION*  pCollections;           // ����ǽԤ������
    int                         nMaxCollectionsCount;   // ����ǽԤ�������С
    int                         nCollectionsCount;      // ����ǽԤ������
} DH_OUT_WM_GET_COLLECTIONS;

// CLIENT_GetSplitWindowsInfo�ӿ��������
typedef struct tagDH_IN_SPLIT_GET_WINDOWS 
{
    DWORD              dwSize;
    int                nChannel;                        // ͨ����
} DH_IN_SPLIT_GET_WINDOWS;

// CLIENT_GetSplitWindowsInfo�ӿ��������
typedef struct tagDH_OUT_SPLIT_GET_WINDOWS 
{
    DWORD                   dwSize;
    DH_BLOCK_COLLECTION     stuWindows;                 // ������Ϣ
} DH_OUT_SPLIT_GET_WINDOWS;

// CLIENT_LoadSplitCollection�ӿ��������(�����ղ�)
typedef struct tagDH_IN_SPLIT_LOAD_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // ���ͨ����
    const char*       pszName;                  // �ղؼ�����
} DH_IN_SPLIT_LOAD_COLLECTION;

// CLIENT_LoadSplitCollection�ӿ��������(�����ղ�)
typedef struct tagDH_OUT_SPLIT_LOAD_COLLECTION 
{
    DWORD             dwSize;
} DH_OUT_SPLIT_LOAD_COLLECTION;

// CLIENT_SaveSplitCollection�ӿ��������(�����ղ�)
typedef struct tagDH_IN_SPLIT_SAVE_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // ���ͨ����
    const char*       pszName;                  // �ղؼ�����
} DH_IN_SPLIT_SAVE_COLLECTION;

// CLIENT_SaveSplitCollection�ӿ��������(�����ղ�)
typedef struct tagDH_OUT_SPLIT_SAVE_COLLECTION 
{
    DWORD             dwSize;
} DH_OUT_SPLIT_SAVE_COLLECTION;

// CLIENT_RenameSplitCollection�ӿ��������(�ղ�������)
typedef struct tagDH_IN_SPLIT_RENAME_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // ���ͨ����
    const char*       pszOldName;               // ԭ����
    const char*       pszNewName;               // ������
} DH_IN_SPLIT_RENAME_COLLECTION;

// CLIENT_RenameSplitCollection�ӿ��������(�ղ�������)
typedef struct tagDH_OUT_SPLIT_RENAME_COLLECTION
{
    DWORD             dwSize;
} DH_OUT_SPLIT_RENAME_COLLECTION;

// CLIENT_GetSplitCollections�ӿ��������(��ȡ�ղؼ���Ϣ)
typedef struct tagDH_IN_SPLIT_GET_COLLECTIONS 
{
    DWORD             dwSize;
    int               nChannel;                // ���ͨ����
} DH_IN_SPLIT_GET_COLLECTIONS;

// CLIENT_GetSplitCollections�ӿ��������(��ȡ�ղؼ���Ϣ)
typedef struct tagDH_OUT_SPLIT_GET_COLLECTIONS 
{
    DWORD                dwSize;    
    DH_BLOCK_COLLECTION* pCollections;                  // �ղؼ�����,���û������ڴ棬��СΪsizeof(DH_BLOCK_COLLECTION)*nMaxCollectionsCount
    int                  nMaxCollectionsCount;          // �ղؼ������С
    int                  nCollectionsCount;             // ���ص��ղؼ�����
} DH_OUT_SPLIT_GET_COLLECTIONS;

// CLIENT_DeleteSplitCollection�ӿڵ��������(ɾ���ղؼ�)
typedef struct tagDH_IN_SPLIT_DELETE_COLLECTION 
{
    DWORD                dwSize;
    int                  nChannel;                      // ���ͨ����
    const char**         ppszNames;                     // �ղؼ���������
    int                  nNameCount;                    // �ղؼ����������С
} DH_IN_SPLIT_DELETE_COLLECTION;

// CLIENT_DeleteSplitCollection�ӿڵ��������(ɾ���ղؼ�)
typedef struct tagDH_OUT_SPLIT_DELETE_COLLECTION 
{
    DWORD                dwSize;
} DH_OUT_SPLIT_DELETE_COLLECTION;

// �ں���ͨ����Ϣ
typedef struct tagDH_COMPOSITE_CHANNEL
{
    DWORD               dwSize;
    char                szMonitorWallName[DH_DEVICE_NAME_LEN];  // ����ǽ����
    char                szCompositeID[DH_DEV_ID_LEN_EX];        // �ں���ID
    int                 nVirtualChannel;                        // ����ͨ����
} DH_COMPOSITE_CHANNEL;

// ��Ѳʹ������
typedef struct tagDHDEV_TOUR_ENABLE
{
    DWORD               dwSize;
    BOOL                bEnable;                    // ��Ѳʹ��
    BOOL                bStart;                     // �Ƿ�������Ѳ(ֻ��). ��Ѳʹ�ܴ򿪵�û��������Ѳ����Դʱ, bStart=FALSE
} DHDEV_TOUR_ENABLE_CFG;

// CLIENT_SetDecodePolicy�ӿ��������(���ý������)
typedef struct tagDH_IN_SET_DEC_POLICY 
{
    DWORD               dwSize;
    int                 nChannel;               // ͨ����
    int                 nWindow;                // ���ں�, -1��ʾͨ�������д���
    int                 nPolicyLevel;           // ������Եȼ�, ��5��(-2, -1, 0, 1, 2), ֵԽ��Խ�������ӳ�Խ��
                                                // -2��ʾʵʱ�����, 2��ʾ���������, 0Ĭ��
} DH_IN_SET_DEC_POLICY;

// CLIENT_SetDecodePolicy�ӿ��������(���ý������)
typedef struct tagDH_OUT_SET_DEC_POLICY 
{
    DWORD                dwSize;
} DH_OUT_SET_DEC_POLICY;

// CLIENT_GetDecodePolicy�ӿ��������(��ȡ�������)
typedef struct tagDH_IN_GET_DEC_POLICY 
{
    DWORD                dwSize;
    int                  nChannel;              // ͨ����
    int                  nWindow;               // ���ں�, -1��ʾͨ�������д���
} DH_IN_GET_DEC_POLICY;

// CLIENT_GetDecodePolicy�ӿ��������(��ȡ�������)
typedef struct tagDH_OUT_GET_DEC_POLICY 
{
    DWORD                dwSize;
    int                  nPolicyLevel;          // ������Եȼ�, ��5��(-2, -1, 0, 1, 2), ֵԽ��Խ�������ӳ�Խ��
                                                // -2��ʾʵʱ�����, 2��ʾ���������, 0Ĭ��
} DH_OUT_GET_DEC_POLICY;

// ��Ƶ���ģʽ
typedef enum
{
    DH_AUDIO_AUTO,                              // �Զ��л���Ƶ���, ֻ��һ����Ƶ����
    DH_AUDIO_DISABLE,                           // ��ֹ������Ƶ��� 
    DH_AUDIO_FORCE,                             // ǿ������û�ָ����ĳ�����ڵ���Ƶ, ֻ��һ����Ƶ����
    DH_AUDIO_ENABLE_ONE,                        // ����ָ��������Ƶ, �����ж�·��Ƶ���   
    DH_AUDIO_DISABLE_ONE,                       // �ر�ָ��������Ƶ, �����ж�·��Ƶ���
    DH_AUDIO_MULTI,                             // ��·��Ƶ���, ��ѯʱ����, ����ʱ��ֵ��Ч
} DH_AUDIO_OUTPUT_MODE;

// CLIENT_SetSplitAudioOuput�ӿ��������(������Ƶ���ģʽ)
typedef struct tagDH_IN_SET_AUDIO_OUTPUT 
{
    DWORD                dwSize;
    int                  nChannel;              // ͨ����
    DH_AUDIO_OUTPUT_MODE emMode;                // ��Ƶ���ģʽ
    int                  nWindow;               // ������ں�, emModeΪDH_AUDIO_FORCE/DH_AUDIO_ENABLE_ONE/DH_AUDIO_DISABLE_ONEʱ��Ч, ָ�������Ƶ�Ĵ��ں�
} DH_IN_SET_AUDIO_OUTPUT;

// CLIENT_SetSplitAudioOuput�ӿ��������(������Ƶ���ģʽ)
typedef struct tagDH_OUT_SET_AUDIO_OUTPUT
{
    DWORD                dwSize;
} DH_OUT_SET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput�ӿ��������(��ȡ��Ƶ���ģʽ)
typedef struct tagDH_IN_GET_AUDIO_OUTPUT
{
    DWORD                dwSize;
    int                  nChannel;              // ͨ����
} DH_IN_GET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput�ӿ��������(��ȡ��Ƶ���ģʽ)
typedef struct tagDH_OUT_GET_AUDIO_OUTPUT
{
    DWORD                dwSize;
    DH_AUDIO_OUTPUT_MODE emMode;                // ��Ƶ���ģʽ
    int                  nWindow;               // ������ں�, emModeΪDH_AUDIO_FORCEʱ��Ч
    int*                 pMultiWindows;         // ������ں��б�, emModeΪDH_AUDIO_MULTIʱ��Ч, �û������ڴ�,��СΪsizeof(int)*nMaxMultiWindowCount
    int                  nMaxMultiWindowCount;  // ������ں��б��������, �û���д
    int                  nRetMultiWindowCount;  // ������ں�����, emModeΪDH_AUDIO_MULTIʱ��Ч
} DH_OUT_GET_AUDIO_OUTPUT;

// CLIENT_GetEncodePlan �ӿ��������(��ȡ��¼����ʱʹ�õı������)
typedef struct tagDH_IN_GET_ENCODE_PLAN
{
    DWORD               dwSize;
    unsigned int        nChannel;               // ָ��Ҫ��ȡ�ı���ͨ����
    unsigned int        nExpectTime;            // ҵ��Ԥ��ʱ��     ����,��λ������
    unsigned int        nCapacity;              // ���õ��豸����,����,��λ:M
}DH_IN_GET_ENCODE_PLAN;
// CLIENT_GetEncodePlan �ӿ��������(��ȡ��¼����ʱʹ�õı������)
typedef struct tagDH_OUT_GET_ENCODE_PLAN
{
    DWORD               dwSize;
    int                 nResolutionType;        // emResolutionTypes��Ա���� 
    CAPTURE_SIZE        emResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// ��Ƶ�ֱ��ʷ�Χ
    CAPTURE_SIZE        emResolution;           // �Ƽ���Ƶ�ֱ���
    unsigned int        nBitRate;               // ��Ƶ�̶�����ֵ
}DH_OUT_GET_ENCODE_PLAN;

// CLIENT_GetEncodePlanByResolution �ӿ��������(����ָ���Ĺ��������ͷֱ������ʼ���ҵ��ʱ��)
typedef struct tagNET_IN_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nChannel;               // ָ��Ҫ��ȡ�ı���ͨ����
	CAPTURE_SIZE        emResolution;			// ��Ƶ�ֱ���
	unsigned int        nBitRate;               // ��Ƶ����ֵ
	unsigned int		nCapacity;				// ���õ��豸����
} NET_IN_GET_ENCODEPLANE_BY_RESOLUTION;

// CLIENT_GetEncodePlanByResolution �ӿ��������(����ָ���Ĺ��������ͷֱ������ʼ���ҵ��ʱ��)
typedef struct tagNET_OUT_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nExpectTime;			// ҵ��Ԥ��ʱ��
} NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION;


// ��֯Ŀ¼�߼�����
typedef struct tagDH_ORGANIZATION_NODE_LOGIC_OBJECT 
{
    DWORD               dwSize;
    char                szName[DH_NODE_NAME_LEN];       // ����
    char                szType[DH_DEV_TYPE_LEN];        // ����
    char                szDevID[DH_DEV_ID_LEN_EX];      // �豸ID
    char                szControlID[DH_DEV_ID_LEN_EX];  // ����ID, ֻ��
    int                 nChannel;                       // ͨ����
} DH_ORGANIZATION_NODE_LOGIC_OBJECT;

// ��֯Ŀ¼
typedef struct tagDH_ORGANIZATION_NODE_DIRECTORY
{
    DWORD               dwSize;
    char                szName[DH_NODE_NAME_LEN];       // ����
    char                szControlID[DH_DEV_ID_LEN_EX];  // ����ID
} DH_ORGANIZATION_NODE_DIRECTORY;

// ��֯Ŀ¼�ڵ���Ϣ
typedef struct tagDH_ORGANIZATION_NODE 
{
    DWORD               dwSize;
    int                 nNodeType;                        // �ڵ�����, 0-�߼�����, 1-Ŀ¼
    DH_ORGANIZATION_NODE_LOGIC_OBJECT    stuLogicObject;  // �߼�����, nNodeType==0ʱ��Ч
    DH_ORGANIZATION_NODE_DIRECTORY       stuDirectory;    // Ŀ¼, nNodeType==1ʱ��Ч        
} DH_ORGANIZATION_NODE;

// ���ӽڵ����
typedef struct tagDH_ORGANIZATION_ADD_NODE_PARAM
{
    DWORD                dwSize;
    int                  nPosition;                     // ����λ��, -1-��ʼ, -2-ĩβ, 0~n
    DH_ORGANIZATION_NODE stuNode;                       // �ڵ���Ϣ
} DH_ORGANIZATION_ADD_NODE_PARAM;

// CLIENT_OrganizationAddNodes�ӿڵ��������(���ӽڵ�)
typedef struct tagDH_IN_ORGANIZATION_ADD_NODES
{
    DWORD                dwSize;
    char*                pszPath;                       // ·��
    DH_ORGANIZATION_ADD_NODE_PARAM* pstuNodes;          // �ڵ���Ϣ����ָ��,���û������ڴ棬��СΪsizeof(DH_ORGANIZATION_ADD_NODE_PARAM)*nNodeCount
    int                  nNodeCount;                    // �ڵ�����
} DH_IN_ORGANIZATION_ADD_NODES;

// ���ӽڵ�Ľ��
typedef struct tagDH_ORGANIZATION_ADD_NODE_RESULT
{
    DWORD               dwSize;
    BOOL                bResult;                        // ���
    char                szPath[MAX_PATH];               // ·��, �ɹ�����node·��,ʧ�ܷ������nodeʱ��·��
} DH_ORGANIZATION_ADD_NODE_RESULT;

// CLIENT_OrganizationAddNodes�ӿڵ��������(���ӽڵ�)
typedef struct tagDH_OUT_ORGANIZATION_ADD_NODES
{
    DWORD               dwSize;
    DH_ORGANIZATION_ADD_NODE_RESULT* pstuResults;       // �������ָ��
    int                 nMaxResultCount;                // ��������С
    int                 nRetResultCount;                // ���صĽ������
} DH_OUT_ORGANIZATION_ADD_NODES;

// �ڵ�·��
typedef struct tagDH_ORGANIZATION_NODE_PATH 
{
    DWORD               dwSize;
    char                szPath[MAX_PATH];               // ·��
} DH_ORGANIZATION_NODE_PATH;

// CLIENT_OrganizationDeleteNodes�ӿڵ��������(ɾ���ڵ�)
typedef struct tagDH_IN_ORGANIZATION_DELETE_NODES
{
    DWORD               dwSize;
    DH_ORGANIZATION_NODE_PATH*  pstuPath;               // �ڵ�·������,���û������ڴ棬��СΪsizeof(DH_ORGANIZATION_NODE_PATH)*nPathCount
    int                 nPathCount;                     // �ڵ�����
} DH_IN_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationDeleteNodes�ӿڵ��������(ɾ���ڵ�)
typedef struct tagDH_OUT_ORGANIZATION_DELETE_NODES 
{
    DWORD               dwSize;
} DH_OUT_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationGetNodes�ӿڵ��������(��ȡ�ڵ���Ϣ)
typedef struct tagDH_IN_ORGANIZATION_GET_NODES 
{
    DWORD               dwSize;
    char*               pszPath;                        // ·��
    int                 nLevel;                         // ����, 0-����, 1-��һ��
} DH_IN_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationGetNodes�ӿڵ��������(��ȡ�ڵ���Ϣ)
typedef struct tagDH_OUT_ORGANIZATION_GET_NODES 
{
    DWORD                   dwSize;
    DH_ORGANIZATION_NODE*   pstuNodes;                  // �ڵ�����, �û������ڴ�,��СΪsizeof(DH_ORGANIZATION_NODE)*nMaxNodeCount
    int                     nMaxNodeCount;              // �ڵ������С
    int                     nRetNodeCount;              // ���صĽڵ�����
} DH_OUT_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationSetNode�ӿڵ��������(���ýڵ�)
typedef struct tagDH_IN_ORGANIZATION_SET_NODE 
{
    DWORD                dwSize;
    char*                pszPath;                    // ·��
    DH_ORGANIZATION_NODE stuNode;                    // �ڵ���Ϣ
} DH_IN_ORGANIZATION_SET_NODE;

// CLIENT_OrganizationSetNode�ӿڵ��������(���ýڵ�)
typedef struct tagDH_OUT_ORGANIZATION_SET_NODE 
{
    DWORD               dwSize;
} DH_OUT_ORGANIZATION_SET_NODE;

// ��Ƶ����ͨ����Ϣ
typedef struct tagDH_VIDEO_INPUTS
{
    DWORD               dwSize;
    char                szChnName[DH_DEVICE_NAME_LEN];      // ͨ������
    BOOL                bEnable;                            // ʹ��
    char                szControlID[DH_DEV_ID_LEN_EX];      // ����ID
    char                szMainStreamUrl[MAX_PATH];          // ������url��ַ 
    char                szExtraStreamUrl[MAX_PATH];         // ������url��ַ
    int                 nOptionalMainUrlCount;              // ������������ַ����
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH];  // ������������ַ�б�
    int                 nOptionalExtraUrlCount;             // ���ø�������ַ����
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // ���ø�������ַ�б�
} DH_VIDEO_INPUTS;

typedef struct tagDH_REMOTE_DEVICE 
{
    DWORD               dwSize;
    BOOL                bEnable;                            // ʹ��
    char                szIp[DH_MAX_IPADDR_LEN];            // IP
    char                szUser[DH_USER_NAME_LENGTH];        // �û���,����ʹ��szUserEx
    char                szPwd[DH_USER_PSW_LENGTH];          // ����,����ʹ��szPwdEx
    int                 nPort;                              // �˿�
    int                 nDefinition;                        // ������, 0-����, 1-����
    DH_DEVICE_PROTOCOL  emProtocol;                         // Э������
    char                szDevName[DH_DEVICE_NAME_LEN];      // �豸����
    int                 nVideoInputChannels;                // ��Ƶ����ͨ����
    int                 nAudioInputChannels;                // ��Ƶ����ͨ����
    char                szDevClass[DH_DEV_TYPE_LEN];        // �豸����, ��IPC, DVR, NVR��
    char                szDevType[DH_DEV_TYPE_LEN];         // �豸�����ͺ�, ��IPC-HF3300
    int                 nHttpPort;                          // Http�˿�
    int                 nMaxVideoInputCount;                // ��Ƶ����ͨ�������
    int                 nRetVideoInputCount;                // ����ʵ��ͨ������
    DH_VIDEO_INPUTS*    pstuVideoInputs;                    // ��Ƶ����ͨ����Ϣ,���û������ڴ棬��СΪsizeof(DH_VIDEO_INPUTS)*nMaxVideoInputCount
    char                szMachineAddress[DH_MAX_CARD_INFO_LEN]; // �豸�����
    char                szSerialNo[DH_SERIALNO_LEN];        // �豸���к�
    int                 nRtspPort;                          // Rtsp�˿�

	/*����������ƽ̨��չ*/
	char                szUserEx[DH_USER_NAME_LEN_EX];       // �û���
    char                szPwdEx[DH_USER_PSW_LEN_EX];         // ����
} DH_REMOTE_DEVICE;

typedef enum tagNET_LOGIC_CHANNEL_TYPE
{
    LOGIC_CHN_UNKNOWN,              // δ֪
    LOGIC_CHN_LOCAL,                // ����ͨ��
    LOGIC_CHN_REMOTE,               // Զ��ͨ��
    LOGIC_CHN_COMPOSE,              // �ϳ�ͨ��, ����ͥ���豸�������л�ͨ���ͻ���ͨ��
    LOGIC_CHN_MATRIX,               // ģ�����ͨ��
    LOGIC_CHN_CASCADE,              // ����ͨ��
} NET_LOGIC_CHN_TYPE;

// ���õ���ʾԴ��Ϣ
typedef struct tagDH_MATRIX_CAMERA_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEV_ID_LEN_EX];           // ����
    char                szDevID[DH_DEV_ID_LEN_EX];          // �豸ID
    char                szControlID[DH_DEV_ID_LEN_EX];      // ����ID
    int                 nChannelID;                         // ͨ����, DeviceID�豸��Ψһ
    int                 nUniqueChannel;                     // �豸��ͳһ��ŵ�Ψһͨ����
    BOOL                bRemoteDevice;                      // �Ƿ�Զ���豸
    DH_REMOTE_DEVICE    stuRemoteDevice;                    // Զ���豸��Ϣ
    NET_STREAM_TYPE     emStreamType;                       // ��Ƶ��������
    NET_LOGIC_CHN_TYPE  emChannelType;                      // ͨ������
} DH_MATRIX_CAMERA_INFO;

// CLIENT_MatrixGetCameras�ӿڵ��������
typedef struct tagDH_IN_MATRIX_GET_CAMERAS 
{
    DWORD               dwSize;
} DH_IN_MATRIX_GET_CAMERAS;

// CLIENT_MatrixGetCameras�ӿڵ��������
typedef struct tagDH_OUT_MATRIX_GET_CAMERAS 
{
    DWORD                   dwSize;
    DH_MATRIX_CAMERA_INFO*  pstuCameras;                    // ��ʾԴ��Ϣ����, �û������ڴ�,��СΪsizeof(DH_MATRIX_CAMERA_INFO)*nMaxCameraCount
    int                     nMaxCameraCount;                // ��ʾԴ�����С
    int                     nRetCameraCount;                // ���ص���ʾԴ����
} DH_OUT_MATRIX_GET_CAMERAS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO ��ѯԶ���豸��Ϣ�������
typedef struct tagNET_IN_GET_DEVICE_INFO
{
    DWORD                       dwSize;                                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_IN_GET_DEVICE_INFO)
    char                        szDevice[DH_DEV_ID_LEN_EX];                 // �豸ID
    // �豸����,�� szDevice �ֶ�Ϊ��ʱ,�����ֶ���Ч
    char                        szAttributeIP[DH_COMMON_STRING_32];             // �豸��ַ
    int                         nAttributePort;                                 // �豸�˿�
    char                        szAttributeUsername[DH_COMMON_STRING_128];      // �û���
    char                        szAttributePassword[DH_COMMON_STRING_128];      // ����
    char                        szAttributeManufacturer[DH_COMMON_STRING_128];  // ����Э��
}NET_IN_GET_DEVICE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO ��ѯԶ���豸��Ϣ�������
typedef struct tagNET_OUT_GET_DEVICE_INFO
{
    DWORD                       dwSize;         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_OUT_GET_DEVICE_INFO)
    DH_REMOTE_DEVICE            stuInfo;        // �豸��Ϣ,�ýṹ���ڲ���Ա dwSize ���û���ֵ
}NET_OUT_GET_DEVICE_INFO;

// CLIENT_MatrixSetCameras�ӿڵ��������
typedef struct tagDH_IN_MATRIX_SET_CAMERAS 
{
    DWORD                   dwSize;
    DH_MATRIX_CAMERA_INFO*  pstuCameras;                    // ��ʾԴ��Ϣ����, �û������ڴ棬��СΪsizeof(DH_MATRIX_CAMERA_INFO)*nCameraCount
    int                     nCameraCount;                   // ��ʾԴ�����С
} DH_IN_MATRIX_SET_CAMERAS;

// CLIENT_MatrixSetCameras�ӿڵ��������
typedef struct tagDH_OUT_MATRIX_SET_CAMERAS 
{
    DWORD                   dwSize;
} DH_OUT_MATRIX_SET_CAMERAS;

// ������ʾԴ��Ϣ
typedef struct tagDH_SPLIT_WND_SOURCE 
{
    DWORD                   dwSize;
    BOOL                    bEnable;                        // ��ʾԴ�Ƿ���Ч
    char                    szDeviceID[DH_DEV_ID_LEN];      // �豸ID
    char                    szControlID[DH_DEV_ID_LEN];     // ����ID
    int                     nVideoChannel;                  // ��Ƶͨ����
    int                     nVideoStream;                   // ��Ƶ��������
    int                     nAudioChannel;                  // ��Ƶͨ��
    int                     nAudioStream;                   // ��Ƶ��������
    int                     nUniqueChannel;                 // �豸��ͳһ��ŵ�Ψһͨ����, ֻ��
    BOOL                    bRemoteDevice;                  // �Ƿ�Զ���豸
    DH_REMOTE_DEVICE        stuRemoteDevice;                // Զ���豸��Ϣ
} DH_SPLIT_WND_SOURCE;

// �ָ����Ϣ
typedef struct tagDH_SPLIT_WINDOW 
{
    DWORD                   dwSize;
    BOOL                    bEnable;                        // �����Ƿ�����ƵԴ
    int                     nWindowID;                      // ����ID
    char                    szControlID[DH_DEV_ID_LEN];     // ����ID
    DH_RECT                 stuRect;                        // ��������, ���ɷָ�ģʽ����Ч
    BOOL                    bDirectable;                    // �����Ƿ�����ֱͨ����
    int                     nZOrder;                        // ����Z����
    DH_SPLIT_WND_SOURCE     stuSource;                      // ��ʾ��Ϣ
} DH_SPLIT_WINDOW;

// ƴ��������
typedef struct tagDH_SPLIT_SCENE 
{
    DWORD                   dwSize;
    char                    szCompositeID[DH_DEV_ID_LEN];   // ƴ����ID
    char                    szControlID[DH_DEV_ID_LEN];     // ����ID
    DH_SPLIT_MODE           emSplitMode;                    // �ָ�ģʽ
    DH_SPLIT_WINDOW*        pstuWnds;                       // ������Ϣ����, �û������ڴ�,��СΪsizeof(DH_SPLIT_WINDOW)*nMaxWndCount
    int                     nMaxWndCount;                   // ������Ϣ�����С, �û���д
    int                     nRetWndCount;                   // ���صĴ�������
} DH_SPLIT_SCENE;

// ����ǽ����
typedef struct tagDH_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // ��ǰԤ������
    char                    szControlID[DH_DEV_ID_LEN];     // ����ID
    DH_MONITORWALL          stuMonitorWall;                 // ����ǽ����    
    DH_SPLIT_SCENE*         pstuSplitScene;                 // ƴ����������Ϣ����, �û������ڴ�,��СΪsizeof(DH_SPLIT_SCENE)*nMaxSplitSceneCount
    int                     nMaxSplitSceneCount;            // ƴ�������������С, �û���д
    int                     nRetSplitSceneCount;            // ���ص�ƴ������������
} DH_MONITORWALL_SCENE;

// CLIENT_MonitorWallGetScene�ӿ��������(��ȡ����ǽ����)
typedef struct tagDH_IN_MONITORWALL_GET_SCENE 
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // ����ǽ���
} DH_IN_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallGetScene�ӿ��������(��ȡ����ǽ����)
typedef struct tagDH_OUT_MONITORWALL_GET_SCENE 
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // ��ǰԤ������, ����Ϊ��
    DH_MONITORWALL_SCENE    stuScene;                       // ����ǽ����
} DH_OUT_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallSetScene�ӿ��������(���õ���ǽ����)
typedef struct tagDH_IN_MONITORWALL_SET_SCENE 
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // ����ǽ���
    DH_MONITORWALL_SCENE    stuScene;                       // ����ǽ����
} DH_IN_MONITORWALL_SET_SCENE;

// CLIENT_MonitorWallSetScene�ӿ��������(���õ���ǽ����)
typedef struct tagDH_OUT_MONITORWALL_SET_SCENE 
{
    DWORD                   dwSize;
} DH_OUT_MONITORWALL_SET_SCENE;

//CLIENT_QueryNetStat�ӿ�,��ѯ����ΪNET_APP_DATA_STATʱ���������(��ȡЭ��ջͳ������)
typedef struct tagNET_IN_NETAPP_NET_DATA_STAT
{
    DWORD       dwSize;    
    char        szEthName[DH_MAX_ETH_NAME];                //������
}NET_IN_NETAPP_NET_DATA_STAT;

//�������ͳ������,������ifconfigͬ
typedef struct tagNET_NETAPP_RECEIVE_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwFrame;
}NET_NETAPP_RECEIVE_STAT;

//�������ͳ������,������ifconfigͬ
typedef struct tagNET_NETAPP_TRANSMIT_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwCarrier;
    DWORD        dwCollisions;
    DWORD        dwTxQueue;
}NET_NETAPP_TRANSMIT_STAT;

//CLIENT_QueryNetStat�ӿ�,��ѯ����ΪNET_APP_DATA_STATʱ���������(��ȡЭ��ջͳ������)
typedef struct tagNET_OUT_NETAPP_NET_DATA_STAT
{                    
    DWORD                        dwSize;
    NET_NETAPP_RECEIVE_STAT      stuReceiveStat;        // �������ͳ������,������ifconfigͬ
    NET_NETAPP_TRANSMIT_STAT     stuTransmitStat;       // �������ͳ������,������ifconfigͬ
    int                          nSpeed;                // �����ٶ�,��λMbps
}NET_OUT_NETAPP_NET_DATA_STAT;

//CLIENT_QueryNetStat�ӿ�,��ѯ����ΪNET_APP_LINK_STAT ʱ���������(��ȡ������·״̬)
typedef struct tagNET_IN_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    char        szEthName[DH_MAX_ETH_NAME];             //������
}NET_IN_NETAPP_LINK_STATUS;

//CLIENT_QueryNetStat�ӿ�,��ѯ����ΪNET_APP_LINK_STAT ʱ���������(��ȡ������·״̬)
typedef struct tagNET_OUT_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    BOOL        bWorking;               // �Ƿ����ڹ��� 
    BOOL        bIPConflict;            // IP�Ƿ��ͻ
}NET_OUT_NETAPP_LINK_STATUS;

// �����ź�����
#define DH_VIDEO_SIGNAL_CVBS        0x0001
#define DH_VIDEO_SIGNAL_SDI         0x0002
#define DH_VIDEO_SIGNAL_VGA         0x0004 
#define DH_VIDEO_SIGNAL_DVI         0x0008
#define DH_VIDEO_SIGNAL_HDMI        0x0010 
#define DH_VIDEO_SIGNAL_YPBPR       0x0020 
#define DH_VIDEO_SIGNAL_SFP         0x0040 
#define DH_VIDEO_SIGNAL_HDCVI       0x0080 
#define DH_VIDEO_SIGNAL_DUAL_LINK   0x0100 

// ��Ƶ����������
typedef struct tagDH_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    DWORD            dwSignalType;                  // �����ź�����
    BOOL             bAutoFocusPeak;                // �Ƿ�֧�־۽���ֵ����
    BOOL             bElectricFocus;                // �Ƿ�֧�ֵ綯����
    BOOL             bSyncFocus;                    // �Ƿ�֧��ͬ���Խ�
    BOOL             bSetColor;                     // �Ƿ�֧����Ƶ��ɫ����
    BOOL             bGain;                         // �Ƿ�֧���������
    BOOL             bPhase;                        // �Ƿ�֧����λ����
	int				 nSubChannel;					// ��Ƶ��ͨ��(�ɼ���)����
	DH_RECT			 stuRect[MAX_SUBCHANNEL_NUM];	// ÿ��sensor����������ƴ�ӻ����е�λ��
} DH_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps�ӿ��������
typedef struct tagDH_IN_GET_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    int              nChannel;                      // ��Ƶ����ͨ����
} DH_IN_GET_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps�ӿ��������
typedef struct tagDH_OUT_GET_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    DH_VIDEO_IN_CAPS stuCaps;                       // ����
} DH_OUT_GET_VIDEO_IN_CAPS;

// ��Ƶ���ģʽ
typedef struct tagDH_VIDEO_OUT_MODE 
{
    DWORD            dwSize;
    int              nWidth;                        // ˮƽ�ֱ���
    int              nHeight;                       // ��ֱ�ֱ���
    int              nBPP;                          // ��ɫ���
    int              nFormat;                       // ����ź�ģʽ, 0-Auto, 1-TV, 2-VGA, 3-DVI
    int              nRefreshRate;                  // ˢ��Ƶ��
    int              nPhysicalPort;                 // ���������, VGA, TV, DVI���Զ������, ���Դ�0��ʼ
    int              nScanFormat;                   // ɨ��ģʽ, 0-����, 1-����
} DH_VIDEO_OUT_MODE;

// CLIENT_EnumVideoOutModes�ӿ��������
typedef struct tagDH_IN_ENUM_VIDEO_OUT_MODES 
{
    DWORD            dwSize;
    int              nChannel;
} DH_IN_ENUM_VIDEO_OUT_MODES;

// CLIENT_EnumVideoOutModes�ӿ��������
typedef struct tagDH_OUT_ENUM_VIDEO_OUT_MODES 
{
    DWORD               dwSize;
    DH_VIDEO_OUT_MODE*  pstuModes;                  // ģʽ����, �û������ڴ�,��СΪsizeof(DH_VIDEO_OUT_MODE)*nMaxModeCount
    int                 nMaxModeCount;              // ģʽ�����С, �û���д
    int                 nRetModeCount;              // ���ص�ģʽ����
} DH_OUT_ENUM_VIDEO_OUT_MODES;

// ����ǽ��Ļ��������
typedef enum tagDH_OUTPUT_ATTRIBUTE_TYPE
{
    DH_OUTPUT_ATTRIBUTE_VIDEO, 
    DH_OUTPUT_ATTRIBUTE_YPBPR, 
    DH_OUTPUT_ATTRIBUTE_VGA, 
    DH_OUTPUT_ATTRIBUTE_DVI, 
    DH_OUTPUT_ATTRIBUTE_MENU, 
} DH_OUTPUT_ATTRIBUTE_TYPE;

// ����ǽ��ʾ��Ԫ��Ļ����������(DH_OUTPUT_ATTRIBUTE_CAPS) Video����
#define    DH_ATTR_VIDEO_BRIGHTNESS     0X00000001
#define    DH_ATTR_VIDEO_CONTRAST       0X00000002
#define    DH_ATTR_VIDEO_SATURATION     0X00000004
#define    DH_ATTR_VIDEO_SHAPENESS      0X00000008
#define    DH_ATTR_VIDEO_DENOISE        0X00000010

// ����ǽ��ʾ��Ԫ��Ļ����������(DH_OUTPUT_ATTRIBUTE_CAPS) YPbPr����
#define    DH_ATTR_YPBPR_BRIGHTNESS     0X00000001
#define    DH_ATTR_YPBPR_CONTRAST       0X00000002
#define    DH_ATTR_YPBPR_SATURATION     0X00000004
#define    DH_ATTR_YPBPR_SHAPENESS      0X00000008
#define    DH_ATTR_YPBPR_DENOISE        0X00000010

// ����ǽ��ʾ��Ԫ��Ļ����������(DH_OUTPUT_ATTRIBUTE_CAPS) VGA����
#define    DH_ATTR_VGA_BRIGHTNESS       0X00000001
#define    DH_ATTR_VGA_CONTRAST         0X00000002
#define    DH_ATTR_VGA_HORPOSITION      0X00000004
#define    DH_ATTR_VGA_VERPOSITION      0X00000008
#define    DH_ATTR_VGA_CLOCK            0X00000010

// ����ǽ��ʾ��Ԫ��Ļ����������(DH_OUTPUT_ATTRIBUTE_CAPS) DVI����
#define    DH_ATTR_DVI_BRIGHTNESS       0X00000001
#define    DH_ATTR_DVI_CONTRAST         0X00000002
#define    DH_ATTR_DVI_HORPOSITION      0X00000004
#define    DH_ATTR_DVI_VERPOSITION      0X00000008
#define    DH_ATTR_DVI_CLOCK            0X00000010

// ����ǽ��ʾ��Ԫ��Ļ����������(DH_OUTPUT_ATTRIBUTE_CAPS) Menu����
#define    DH_ATTR_MENU_MENU            0X00000001
#define    DH_ATTR_MENU_UP              0X00000002
#define    DH_ATTR_MENU_DOWN            0X00000004
#define    DH_ATTR_MENU_LEFT            0X00000008
#define    DH_ATTR_MENU_RIGHT           0X00000010
#define    DH_ATTR_MENU_FACTORYMENU     0X00000020

// ����ǽ��ʾ��Ԫ��Ļ����������
typedef struct tagDH_OUTPUT_ATTRIBUTE_CAPS
{
    DWORD           dwSize;
    BOOL            abVideo;                // Video�����Ƿ���Ч
    DWORD           dwVideo;                // Video����, ��λ��ʾ, �����DH_ATTR_VIDEO_BRIGHTNESS��
    BOOL            abYPbPr;                // YPbPr�����Ƿ���Ч
    DWORD           dwYPbPr;                // YPbPr����, ��λ��ʾ, �����DH_ATTR_VGA_BRIGHTNESS��
    BOOL            abVGA;                  // VGA�����Ƿ���Ч
    DWORD           dwVGA;                  // VGA����, ��λ��ʾ, �����DH_ATTR_VGA_BRIGHTNESS��
    BOOL            abDVI;                  // DVI�����Ƿ���Ч
    DWORD           dwDVI;                  // DVI����, ��λ��ʾ, �����DH_ATTR_DVI_BRIGHTNESS
    BOOL            abMenu;                 // Menu�����Ƿ���Ч
    DWORD           dwMemu;                 // Menu����, ��λ��ʾ, �����DH_ATTR_MENU_MENU��
} DH_OUTPUT_ATTRIBUTE_CAPS;

// CLIENT_MonitorWallGetAttributeCaps �ӿ��������
typedef struct tagDH_IN_MONITORWALL_GET_ARRT_CAPS
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // ����ǽ���
    const char*         pszCompositeID;             // ƴ����ID
    int                 nOutputID;                  // ��ʾ��Ԫ���
} DH_IN_MONITORWALL_GET_ARRT_CAPS;

// CLIENT_MonitorWallGetAttributeCaps �ӿ��������
typedef struct tagDH_OUT_MONITORWALL_GET_ARRT_CAPS
{
    DWORD                       dwSize;
    DH_OUTPUT_ATTRIBUTE_CAPS    stuCaps;            // ����������
} DH_OUT_MONITORWALL_GET_ARRT_CAPS;


// CLIENT_MonitorWallAutoAdjust �ӿ��������
typedef struct tagDH_IN_MONITORWALL_AUTO_ADJUST
{
    DWORD           dwSize;
    int             nMonitorWallID;                 // ����ǽ���
    const char*     pszCompositeID;                 // ƴ����ID
    int*            pOutputs;                       // ��ʾ��Ԫ�������ָ��, ����Ԫ������ʾ��ԪID, �û������ڴ�,��СΪsizeof(int)*nOutputCount
    int             nOutputCount;                   // ��ʾ��Ԫ����, pOutputsԪ������
} DH_IN_MONITORWALL_AUTO_ADJUST;

// CLIENT_MonitorWallAutoAdjust �ӿ��������
typedef struct tagDH_OUT_MONITORWALL_AUTO_ADJUST
{
    DWORD           dwSize;
} DH_OUT_MONITORWALL_AUTO_ADJUST;

// ��ʾ��Ԫ���Լ�ֵ��
typedef struct tagDH_ATTR_PAIR
{
    DWORD       dwKey;                      // ���Լ�
                                            // ����ΪDH_OUTPUT_ATTRIBUTE_VIDEOʱ, ʹ�ú�DH_ATTR_VIDEO_BRIGHTNESS��
                                            // ����ΪDH_OUTPUT_ATTRIBUTE_YPBPRʱ, ʹ�ú�DH_ATTR_YPBPR_BRIGHTNESS��
                                            // �����������Դ�����
    int         nValue;                     // ����ֵ, 0-���� 1-����, 2-����
} DH_ATTR_PAIR;

// CLIENT_MonitorWallSetAttribute �ӿ��������
typedef struct tagDH_IN_MONITORWALL_SET_ATTR
{
    DWORD                    dwSize;
    int                      nMonitorWallID;                    // ����ǽ���
    const char*              pszCompositeID;                    // ƴ����ID
    int                      nOutputID;                         // ��ʾ��Ԫ���
    DH_OUTPUT_ATTRIBUTE_TYPE emAttrType;                        // ��������, ���Ͳ�ͬʱ, ��Ӧ������(stuAttrs)Ҳ��ͬ
    DH_ATTR_PAIR             stuAttrs[DH_MAX_ATTR_NUM];         // ����ֵ
} DH_IN_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetAttribute �ӿ��������
typedef struct tagDH_OUT_MONITORWALL_SET_ATTR
{
    DWORD            dwSize;
} DH_OUT_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetBackLight �ӿ��������
typedef struct tagDH_IN_MONITORWALL_SET_BACK_LIGHT
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // ����ǽ���
    const char*         pszCompositeID;                     // ƴ����ID
    int                 nOutputID;                          // ��ʾ��Ԫ���
    int                 nMode;                              // ����ģʽ, 0-ѭ�����ñ���ģʽ,1-��ѭ��ģʽ
} DH_IN_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallSetBackLight �ӿ��������
typedef struct tagDH_OUT_MONITORWALL_SET_BACK_LIGHT
{
    DWORD               dwSize;
} DH_OUT_MONITORWALL_SET_BACK_LIGHT;


// CLIENT_MonitorWallGetPowerSchedule �ӿ��������
typedef struct tagNET_IN_WM_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // ����ǽ���
    const char*         pszCompositeID;                     // ƴ����ID
} NET_IN_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetPowerSchedule �ӿ��������
typedef struct tagNET_OUT_MW_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // ����ʱ���, ��һά��Ԫ�ر�ʾ����~�����ͽڼ���
} NET_OUT_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule �ӿ��������
typedef struct tagNET_IN_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // ����ǽ���
    const char*         pszCompositeID;                     // ƴ����ID, NULL��ʾ������
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // ����ʱ���, ��һά��Ԫ�ر�ʾ����~�����ͽڼ���
} NET_IN_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule �ӿ��������
typedef struct tagNET_OUT_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
} NET_OUT_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetScrnCtrlParam �ӿ��������
typedef struct tagNET_IN_MW_GET_SCRN_CTRL_PARAM
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // ����ǽ���
    const char*         pszCompositeID;                     // ƴ����ID
} NET_IN_MW_GET_SCRN_CTRL_PARAM;

#define DH_MAX_SCREEN_PORT_NUM        16                    // �����Ļ����˿���
#define DH_MAX_COMPSITE_SCREEN_NUM    256                   // ���ƴ��������

// ��Ļ����˿���Ϣ
typedef struct tagNET_SCREEN_PORT_INFO
{
    DWORD               dwSize;
    char                szType[DH_COMMON_STRING_16];        // �˿�����, "DVI", "VGA", "HDMI"��, ���������ͬ���͵Ķ���˿�
    char                szAddress[DH_COMMON_STRING_16];     // �˿ڵ�ַ
    char                szDeviceID[DH_DEV_ID_LEN_EX];       // �󶨵���Ƶ����豸��
    int                 nOutputChannel;                     // ��Ƶ���ͨ����
} NET_SCREEN_PORT_INFO;


typedef struct tagNET_SCREEN_PORT_GROUP 
{
    DWORD                dwSize;
    int                  nPortNum;                          // �˿���
    NET_SCREEN_PORT_INFO stuPorts[DH_MAX_SCREEN_PORT_NUM];  // �˿���Ϣ
} NET_SCREEN_PORT_GROUP;

// ����ǽ��Ļ���Ʋ���
typedef struct tagNET_WM_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nCommPort;                                  // ���ں�
    DH_COMM_PROP            stuCommProp;                                // ��������
    char                    szProtocol[DH_COMMON_STRING_32];            // ����Э��
    int                     nResolutionNum;                             // �ֱ�������
    CAPTURE_SIZE            emResolutions[DH_MAX_CAPTURE_SIZE_NUM];     // ��Ƶ�ֱ����б�
    int                     nScreenCodeNum;                             // ��Ļ������
    char                    szScreenCode[DH_MAX_COMPSITE_SCREEN_NUM][DH_COMMON_STRING_16];    // ��Ļ����, ��������Ѱַ��, �ñ������û�����, ������ͬ
    int                     nScreenPortsNum;                            // ��Ļ����˿���Ϣ����
    NET_SCREEN_PORT_GROUP   stuScreenPorts[DH_MAX_COMPSITE_SCREEN_NUM]; // ��Ļ����˿���Ϣ    
} NET_WM_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetScrnCtrlParam �ӿ��������
typedef struct tagNET_OUT_MW_GET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // ��Ļ���Ʋ���
} NET_OUT_MW_GET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam �ӿ��������
typedef struct tagNET_IN_MW_SET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nMonitorWallID;             // ����ǽ���
    const char*             pszCompositeID;             // ƴ����ID
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // ��Ļ���Ʋ���
} NET_IN_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam �ӿ��������
typedef struct tagNET_OUT_MW_SET_SCRN_CTRL_PARAM
{
    DWORD           dwSize;
} NET_OUT_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetBackgroudColor �ӿ��������
typedef struct tagNET_IN_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    int             nMonitorWallID;             // ����ǽ���
} NET_IN_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallGetBackgroudColor �ӿ��������
typedef struct tagNET_OUT_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    DH_COLOR_RGBA   stuScreenColor;             // ��Ļ����ɫ
    DH_COLOR_RGBA   stuWindowColor;             // ���ڱ���ɫ
} NET_OUT_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallSetBackgroudColor �ӿ��������
typedef struct tagNET_IN_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // ����ǽ���
    DH_COLOR_RGBA   stuScreenColor;             // ��Ļ����ɫ
    DH_COLOR_RGBA   stuWindowColor;             // ���ڱ���ɫ
} NET_IN_MW_SET_BACKGROUD_COLOR;

// CLIENT_MonitorWallSetBackgroudColor �ӿ��������
typedef struct tagNET_OUT_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
} NET_OUT_MW_SET_BACKGROUD_COLOR;

// �ź�Դ����
typedef enum tagEM_SIGNAL_TYPE
{
	EM_SIGNAL_TYPE_UNKNOWN,								// δ֪����
	EM_SIGNAL_TYPE_VIDEO,								// "Video"
	EM_SIGNAL_TYPE_VGA,									// "VGA"
	EM_SIGNAL_TYPE_YPBPR,								// "YPbPr"
	EM_SIGNAL_TYPE_HDMI,								// "HDMI"
	EM_SIGNAL_TYPE_DVI,									// "DVI"
	EM_SIGNAL_TYPE_SDI,									// "SDI"
	EM_SIGNAL_TYPE_CVBS,								// "CVBS"
}EM_SIGNAL_TYPE;

// CLIENT_MonitorWallSwitchDisplaySignal �ӿ��������
typedef struct tagNET_IN_MW_SWITCH_DISPLAY_SIGNAL
{	
	DWORD				dwSize;							// �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_INT_SWITCH_DISPLAYSIGNAL)
    int                 nMonitorWallID;                 // ����ǽ���
	char*			    pszCompositeID;					// ��ʾ��Ԫ��ID
	int					nOutputID;						// ��ʾ��Ԫ������, -1��ʾ�����е�������ʾ��Ԫ
	EM_SIGNAL_TYPE		emSignalType;					// �ź�Դ���� 
	int					nIndex;							// �����źŶ������, ��0��ʼ, �ж����ͬ�ź�Դ����ʱ, ����ָ���ĸ�����
}NET_IN_MW_SWITCH_DISPLAY_SIGNAL;

// CLIENT_MonitorWallSwitchDisplaySignal �ӿ��������
typedef struct tagNET_OUT_MW_SWITCH_DISPLAY_SIGNAL			
{
	DWORD				dwSize;							// �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_OUT_SWICH_DISPLAYSIGNAL)
}NET_OUT_MW_SWITCH_DISPLAY_SIGNAL;

//////////////////////////////////////////////////////////////////////////
// CLIENT_OperateMonitorWall�ӿڲ���
//////////////////////////////////////////////////////////////////////////

// ����ǽ��������
typedef enum tagNET_MONITORWALL_OPERATE_TYPE
{
    NET_MONITORWALL_OPERATE_ADD,            // ��ӵ���ǽ, ��Ӧ NET_IN_MONITORWALL_ADD �� NET_OUT_MONITORWALL_ADD
    NET_MONITORWALL_OPERATE_CTRL_TOUR,      // Ԥ����Ѳ����, ��Ӧ NET_IN_CTRL_COLLECTIONTOUR �� NET_OUT_CTRL_COLLECTIONTOUR
    NET_MONITORWALL_OPERATE_GET_STATUS,     // ��ȡ����ǰ״̬, ��Ӧ NET_IN_MONITORWALL_GET_STATUS �� NET_OUT_MONITORWALL_GET_STATUS
    NET_MONITORWALL_OPERATE_SET_COLL_SCHD,  // ����Ԥ��ʱ���, ��Ӧ NET_IN_MONITORWALL_SET_COLL_SCHD �� NET_OUT_MONITORWALL_SET_COLL_SCHD
    NET_MONITORWALL_OPERATE_GET_COLL_SCHD,  // ��ȡԤ��ʱ���, ��Ӧ NET_IN_MONITORWALL_GET_COLL_SCHD �� NET_OUT_MONITORWALL_GET_COLL_SCHD
    NET_MONITORWALL_OPERATE_REMOVE,         // ɾ������ǽ, ��Ӧ NET_IN_MONITORWALL_REMOVE �� NET_OUT_MONITORWALL_REMOVE
    NET_MONITORWALL_OPERATE_SET_ENABLE,     // ����ʹ��, ��Ӧ NET_IN_MONITORWALL_SET_ENABLE �� NET_OUT_MONITORWALL_SET_ENABLE
    NET_MONITORWALL_OPERATE_GET_ENABLE,     // ��ȡʹ��, ��Ӧ NET_IN_MONITORWALL_GET_ENABLE �� NET_OUT_MONITORWALL_GET_ENABLE
    NET_MONITORWALL_OPERATE_NAME_EXIST,     // ����ǽ�Ƿ����, ��Ӧ NET_IN_MONITORWALL_NAME_EXIST �� NET_OUT_MONITORWALL_NAME_EXIST
	NET_MONITORWALL_OPERATE_RENAME,			// �޸ĵ���ǽ����, ��Ӧ NET_IN_MONITORWALL_RENAME  �� NET_OUT_MONITORWALL_RENAME 
} NET_MONITORWALL_OPERATE_TYPE;

// ��ӵ���ǽ�������
typedef struct tagNET_IN_MONITORWALL_ADD
{
    DWORD dwSize;
    DH_MONITORWALL stuMonitorWall; // ����ǽ��Ϣ
} NET_IN_MONITORWALL_ADD;

// ��ӵ���ǽ�������
typedef struct tagNET_OUT_MONITORWALL_ADD
{
    DWORD dwSize;
    unsigned int nMonitorWallID; // ����ǽID
} NET_OUT_MONITORWALL_ADD;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_IN_CTRL_COLLECTIONTOUR 
{
    DWORD              dwSize;
    int                nChannel;                       // ͨ����
    int                nAction;                        // ��Ѳ����, 0:����, 1:��ʼ
} NET_IN_CTRL_COLLECTIONTOUR;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_OUT_CTRL_COLLECTIONTOUR 
{
    DWORD                   dwSize;
} NET_OUT_CTRL_COLLECTIONTOUR;

// ��������״̬
typedef enum tagNET_MATRIX_STATUS
{
    MATRIX_STATUS_UNKNOWN,              // δ֪
    MATRIX_STATUS_TOUR,                 // Ԥ����Ѳ
    MATRIX_STATUS_NORMAL,               // ��ͨԤ��
} NET_MATRIX_STATUS;

#define DH_MAX_COLLECTION_NUM   64      // ���Ԥ����
// ����״̬��Ϣ
typedef struct tagNET_MONITORWALL_STATUS_INFO
{
    DWORD       dwSize;
    int         nInterval;                      // ��Ѳʱ����
    int         nCollectionNum;                 // Ԥ����Ѳ��
    char        szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];         // Ԥ����Ѳ������
    char        szName[DH_DEVICE_NAME_LEN];     // ��ǰ��ʾ��Ԥ������
} NET_MONITORWALL_STATUS_INFO;

// // CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_IN_MONITORWALL_GET_STATUS 
{
    DWORD              dwSize;
    int                nChannel;                        // ͨ����
} NET_IN_MONITORWALL_GET_STATUS;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_OUT_MONITORWALL_GET_STATUS
{
    DWORD                           dwSize;
    NET_MATRIX_STATUS               emMatrixStatus;     // ����״̬
    NET_MONITORWALL_STATUS_INFO     stuStatusInfo;      // ״̬��Ϣ
} NET_OUT_MONITORWALL_GET_STATUS;

// ����ǽԤ��ʱ���
typedef struct tagMONITORWALL_COLLECTION_SCHEDULE
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // Ԥ������
    DH_TSECT            stuSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];   // ʱ���, ��һά��Ԫ�ر�ʾ����~�����ͽڼ���
} MONITORWALL_COLLECTION_SCHEDULE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // Ԥ����
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // Ԥ��ʱ���
    int                 nMonitorWallID;                 // ����ǽID
} NET_IN_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    BOOL                bAllCollections;                // TRUE-��ѯ����Ԥ��, ����Ҫָ��Ԥ������. FALSE-��ѯ��������Ӧ��Ԥ��
    int                 nCollectionNum;                 // Ԥ����, bAllCollectionsΪFALSEʱ��Ч
    char                szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];   // Ԥ������
    int                 nMonitorWallID;                 // ����ǽID
} NET_IN_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // Ԥ����
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // Ԥ��ʱ���
} NET_OUT_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_IN_MONITORWALL_REMOVE 
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // Ҫɾ���ĵ���ǽ����
    char                szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128];  // ����ǽ����
} NET_IN_MONITORWALL_REMOVE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_OUT_MONITORWALL_REMOVE 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_REMOVE;

// ����ǽʹ����Ϣ
typedef struct tagNET_MONITORWALL_ENABLE_INFO
{
    DWORD               dwSize;
    BOOL                bEanble;                        // ʹ��
    char                szName[DH_COMMON_STRING_128];   // ����ǽ����
} NET_MONITORWALL_ENABLE_INFO;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_IN_MONITORWALL_SET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // Ҫ���õĵ���ǽ����
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM];  // ����ǽʹ��
} NET_IN_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_SET_ENABLE
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_GET_ENABLE
typedef struct tagNET_IN_MONITORWALL_GET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // Ҫ��ѯ�ĵ���ǽ����, -1��ʾ��ѯ���е���ǽ
    char                szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128];  // ����ǽ����, nMonitorWallNum>0ʱ��Ч
} NET_IN_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_GET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // ����ǽ����
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM];  // ����ǽʹ��
} NET_OUT_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_IN_MONITORWALL_NAME_EXIST 
{
    DWORD               dwSize;
    const char*         pszName;                        // ����ǽ����
} NET_IN_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_OUT_MONITORWALL_NAME_EXIST 
{
    DWORD               dwSize;
    BOOL                bExist;                        // ����ǽ�Ƿ��Ѵ���
} NET_OUT_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_RENAME�޸ĵ���ǽ����
typedef struct tagNET_IN_MONITORWALL_RENAME
{
	DWORD               dwSize;
	unsigned int		unMonitorWallID;							// ����ǽID
	char				szNewName[MAX_MONITORWALL_NAME_LEN];		// �µĵ���ǽ����
} NET_IN_MONITORWALL_RENAME;

// CLIENT_OperateMonitorWall�ӿ��������=>NET_MONITORWALL_OPERATE_RENAME�޸ĵ���ǽ����
typedef struct tagNET_OUT_MONITORWALL_RENAME
{
	DWORD               dwSize;
} NET_OUT_MONITORWALL_RENAME;

/************************************************************************/
/*                              U��ץ��                                    */
/************************************************************************/

// CLIENT_StartSniffer �ӿ��������
typedef struct tagDH_IN_START_SNIFFER 
{
    DWORD           dwSize;
    const char*     pszNetInterface;            // ��������
    const char*     pszPath;                    // ץ���洢�ļ���, �ձ�ʾ���浽Ĭ��·��
    int             nSaveType;                  // �ļ�����, 0-Wireshark/Tcpdump
    const char*     pszFilter;                  // ��������, ��"host 172.9.88.200 and port 8080 and tcp"
} DH_IN_START_SNIFFER;

// CLIENT_StartSniffer �ӿ��������
typedef struct tagDH_OUT_START_SNIFFER 
{
    DWORD           dwSize;
} DH_OUT_START_SNIFFER;

// ץ����Ϣ
typedef struct tagDH_SNIFFER_INFO
{
    DWORD           dwSize;
    DWORD           nSnifferID;                 // ץ��ID
} DH_SNIFFER_INFO;

// CLIENT_GetSnifferInfo �ӿ��������
typedef struct tagDH_IN_GET_SNIFFER_INFO
{
    DWORD           dwSize;
    const char*     pszNetInterface;
} DH_IN_GET_SNIFFER_INFO;

// CLIENT_GetSnifferInfo �ӿ��������
typedef struct tagDH_OUT_GET_SNIFFER_INFO
{
    DWORD               dwSize;
    DH_SNIFFER_INFO*    pstuSniffers;           // ץ����Ϣ����, �û������ڴ�
    int                 nMaxSnifferCount;       // ץ����Ϣ�����С, �û���д
    int                 nRetSnifferCount;       // ���ص�ץ����Ϣ����
} DH_OUT_GET_SNIFFER_INFO;

/************************************************************************/
/*                              �ļ�����                                */
/************************************************************************/

// ��ʽ��������Ϣ
typedef struct tagDH_FORMAT_PATITION 
{
    DWORD               dwSize;
    const char*         pszStorageName;         // �洢�豸����
    const char*         pszPatitionName;        // ������
    const char*         pszFileSystem;          // �ļ�ϵͳ��ʽ
} DH_FORMAT_PATITION;

// CLIENT_CreateRemoteFile �ӿ��������
typedef struct tagDH_IN_CREATE_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszPath;                // �ļ���
    BOOL                bDirectory;             // �Ƿ��ļ���
} DH_IN_CREATE_REMOTE_FILE;

// CLIENT_CreateRemoteFile �ӿ��������
typedef struct tagDH_OUT_CREATE_REMOTE_FILE 
{
    DWORD               dwSize;
} DH_OUT_CREATE_REMOTE_FILE;

// CLIENT_RemoveRemoteFiles �ӿ��������
typedef struct tagDH_IN_REMOVE_REMOTE_FILES
{
    DWORD               dwSize;
    const char**        pszPath;                // �ļ�·������ָ��
    int                 nFileCount;             // �ļ�·������
} DH_IN_REMOVE_REMOTE_FILES;

// CLIENT_RemoveRemoteFiles �ӿ��������
typedef struct tagDH_OUT_REMOVE_REMOTE_FILES 
{
    DWORD               dwSize;
} DH_OUT_REMOVE_REMOTE_FILES;

// CLIENT_RenameRemoteFile �ӿ��������
typedef struct tagDH_IN_RENAME_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszOldPath;             // ���ļ���
    const char*         pszNewPath;             // ���ļ���
} DH_IN_RENAME_REMOTE_FILE;

// CLIENT_RenameRemoteFile �ӿ��������
typedef struct tagDH_OUT_RENAME_REMOTE_FILE 
{
    DWORD               dwSize;
} DH_OUT_RENAME_REMOTE_FILE;

// �ļ�/Ŀ¼��Ϣ
typedef struct tagDH_REMOTE_FILE_INFO 
{
    DWORD               dwSize;
    BOOL                bDirectory;                     // �Ƿ��ļ���
    char                szPath[MAX_PATH];               // ·��
    NET_TIME            stuCreateTime;                  // ����ʱ��
    NET_TIME            stuModifyTime;                  // �޸�ʱ��
    INT64               nFileSize;                      // �ļ���С
    char                szFileType[DH_FILE_TYPE_LEN];   // �ļ�����
} DH_REMOTE_FILE_INFO;

// ��ȡ�ļ�������
typedef enum tagDH_REMOTE_FILE_COND
{
    DH_REMOTE_FILE_COND_NONE,                           // ������
    DH_REMOTE_FILE_COND_VOICE,                          // �����������ļ�,*�޷�*��·����ȡ,*ֻ��*��ȡ��ȡ�ļ�����
} DH_REMOTE_FILE_COND;

// CLIENT_ListRemoteFile �ӿ��������
typedef struct tagDH_IN_LIST_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszPath;                        // ·��
    BOOL                bFileNameOnly;                  // ֻ��ȡ�ļ�����, �������ļ�����Ϣ, �ļ���Ϣ��ֻ���ļ�����Ч
    DH_REMOTE_FILE_COND emCondition;                    // ָ����ȡ�ļ�������
} DH_IN_LIST_REMOTE_FILE;

// CLIENT_ListRemoteFile �ӿ��������
typedef struct tagDH_OUT_LIST_REMOTE_FILE 
{
    DWORD                   dwSize;
    DH_REMOTE_FILE_INFO*    pstuFiles;                  // �ļ���Ϣ����, �û������ڴ�,��СΪsizeof(DH_REMOTE_FILE_INFO)*nMaxFileCount
    int                     nMaxFileCount;              // �ļ���Ϣ�����С, �û���д
    int                     nRetFileCount;              // ���ص��ļ�����
} DH_OUT_LIST_REMOTE_FILE;

// �����ļ����ԡ���������
typedef enum tagNET_SET_FILEATTR_ACTION
{
    EM_SET_FILEATTR_ACTION_UNKNOWN = 0,                 // δ֪
    EM_SET_FILEATTR_ACTION_MARK,                        // �ļ�����
} NET_SET_FILEATTR_ACTION;

// CLIENT_SetFileAttribute �ӿ��������
typedef struct tagDH_IN_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
    unsigned int            nDriveNo;                       // ���̺�
    unsigned int            nPartition;                     // ������
    unsigned int            nCluster;                       // �غ�
    NET_SET_FILEATTR_ACTION emAction;                       // ÿ�����Զ�Ӧһ��key,����ֵ��value����
                                                            // ����key:Mark �ļ�����,��Ӧvalue,�ӳ�����ʱ��(��λ:��)
    char                    szValue[DH_COMMON_STRING_64];   // ����ֵ
} DH_IN_SET_FILEATTRIBUTE;

// CLIENT_SetFileAttribute �ӿ��������
typedef struct tagDH_OUT_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
} DH_OUT_SET_FILEATTRIBUTE;

// �ֶ������洢�豸
typedef struct tagDH_EJECT_STORAGE_DEVICE
{
    DWORD               dwSize;    
    const char*         pszStorageName;                 // �洢�豸����
} DH_EJECT_STORAGE_DEVICE;

// �ֶ�װ�ش洢�豸
typedef struct tagDH_LOAD_STORAGE_DEVICE 
{
    DWORD               dwSize;
    const char*         pszStorageName;                 // �洢�豸����
} DH_LOAD_STORAGE_DEVICE;

// CLIENT_UploadRemoteFile �ӿ��������(�ϴ��ļ����豸)
typedef struct tagDH_IN_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileSrc;                     // Դ�ļ�·��
    const char*         pszFileDst;                     // Ŀ���ļ�·��
    const char*         pszFolderDst;                   // Ŀ���ļ���·������ΪNULL, NULLʱ�豸ʹ��Ĭ��·��
    unsigned int        nPacketLen;                     // �ļ��ְ���С(�ֽ�): 0��ʾ���ְ�
} DH_IN_UPLOAD_REMOTE_FILE;

// CLIENT_UploadRemoteFile �ӿ��������(�ϴ��ļ����豸)
typedef struct tagDH_OUT_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
} DH_OUT_UPLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile �ӿ��������(�ļ�����)
typedef struct tagDH_IN_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileName;                    // ��Ҫ���ص��ļ���
    const char*         pszFileDst;                     // ����ļ�·��
} DH_IN_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile �ӿ��������(�ļ�����)
typedef struct tagDH_OUT_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
} DH_OUT_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadPieceFile �ӿ�����������ļ����أ�
typedef struct tagNET_IN_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	char				szFileName[MAX_PATH];		   // ��Ҫ���ص��ļ���,֧��ȫ·��
	UINT				nOffSet;					   // ����ƫ��,��λ�ֽ�
													   // ����ļ��ܳ���Ϊ50KB,ÿ����������������Ϊ32KB,��ô��һ������ʱ,nOffSetΪ0,�ڶ�������nOffSetΪ32KB
	UINT				nNeedLength;				   // ��������������,��λ�ֽڣ�����Ϊ32KB,��󲻳���4MB	
} NET_IN_DOWNLOAD_PIECE_FILE;

// CLIENT_DownloadPieceFile �ӿ�����������ļ����أ�
typedef struct tagNET_OUT_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	UINT				nFileLength;	 // �ļ��ܳ���
	UINT				nPacketLength;   // ���η��ص����ݳ���,��λ�ֽ�,����Ϊ32KB,��󲻳���4MB
	char*               szBuffer;        // ����������ļ�����,���û������ڴ�,��СΪnBufferLen
	UINT				nBufferLen;      // ����������ļ����ݳ���,��λ�ֽ�
} NET_OUT_DOWNLOAD_PIECE_FILE;

/************************************************************************/
/*                              �����豸                                */
/************************************************************************/
// �����豸��������
typedef struct tagDH_IN_SEARCH_CONDITON
{
    DWORD               dwSize;
    const char*         pMachineName;                   // �豸���ƻ���
    const char*         pMachineAddr;                   // �豸����ص�(�磺������.���ϴ��.ΰҵ·��)
    const char*         pSerialNo;                      // �豸���к�
    const char*         pChannelName;                   // ��Ƶ����ͨ����
} DH_MATRIX_SEARCH_CONDITON;

// CLIENT_MatrixSearch �ӿ��������(���������豸)
typedef struct tagDH_IN_MATIRX_SEARCH
{
    DWORD                       dwSize;
    const char*                 pSerialNo;              // �����豸���к�,"Local"-���豸,"Root"-���豸,�����豸���豸�����кű�ʾ
    DH_MATRIX_SEARCH_CONDITON   stuCondition;           // ��������, ����Ϊ��һ���������
} DH_IN_MATRIX_SEARCH;

// CLIENT_MatrixSearch �ӿ��������(���������豸)
typedef struct tagDH_OUT_MATRIX_SEARCH
{
    DWORD               dwSize;
    DH_REMOTE_DEVICE*   pstuRemoteDevices;              // �豸�б�, �û������ڴ�,��СΪsizeof(DH_REMOTE_DEVICE)*nMaxDeviceCount
    int                 nMaxDeviceCount;                // �豸�б����ֵ, �û���д
    int                 nRetDeviceCount;                // ʵ�ʷ����豸����
} DH_OUT_MATRIX_SEARCH;

// CLIENT_GetMatrixTree �ӿ��������
typedef struct tagDH_IN_GET_MATRIX_TREE
{
    DWORD               dwSize;
    const char*         pSerialNo;                      // �����豸���к�,"Local"-���豸,"Root"-���豸,�����豸���豸�����кű�ʾ
    int                 nLevel;                         // ��ü����豸��Ϣ,0-�����豸��,1-�����豸,2-�����豸+���豸������һ���豸,
                                                        // 3-�����豸+���豸������һ���豸+��һ���豸����һ���豸
} DH_IN_GET_MATRIX_TREE;

// �����豸��Ϣ
typedef struct tagDH_CASCADE_DEVICE_INFO
{
    DWORD               dwSize;
    int                 nLevel;                         // ��ǰ�豸������
    char                szPath[MAX_PATH];               // �豸����·��,��ʽ��name1.name2.name3...
    DH_REMOTE_DEVICE    stuDeviceInfo;                  // �豸��ϸ��Ϣ
} DH_CASCADE_DEVICE_INFO;

// CLIENT_GetMatrixTree �ӿ��������
typedef struct tagDH_OUT_GET_MATRIX_TREE
{
    DWORD                   dwSize;
    DH_CASCADE_DEVICE_INFO* pstuRemoteDevices;          // �����豸��Ϣ
    int                     nMaxDeviceCount;            // �����豸��Ϣ���ֵ
    int                     nRetDeviceCount;            // ���ص�ʵ���豸����
} DH_OUT_GET_MATRIX_TREE;

// CLIENT_GetSuperiorMatrixList �ӿ��������
typedef struct tagDH_IN_GET_SUPERIOR_MATRIX_LIST
{
    DWORD                   dwSize;
} DH_IN_GET_SUPERIOR_MATRIX_LIST;

// CLIENT_GetSuperiorMatrixList �ӿ��������
typedef struct tagDH_OUT_GET_SUPERIOR_MATRIX_LIST
{
    DWORD                   dwSize;
    DH_REMOTE_DEVICE*       pstuRemoteDevices;          // �豸�б�, �û������ڴ�
    int                     nMaxDeviceCount;            // �豸�б����ֵ, �û���д
    int                     nRetDeviceCount;            // ʵ�ʷ����豸����
} DH_OUT_GET_SUPERIOR_MATRIX_LIST;

////////////////////////////////////¼�񱸷ݻָ�//////////////////////////////////////

// ¼�񱸷ݻָ�������Ϣ
typedef struct tagDH_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    unsigned int        nTaskID;                        // ����ID
    char                szDeviceID[DH_DEV_ID_LEN_EX];   // �豸ID
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    int                 nState;                         // ��ǰ����״̬, 0-�ȴ�, 1-������, 2-���, 3-ʧ��
} DH_REC_BAK_RST_TASK;

// CLIENT_AddRecordBackupRestoreTask�ӿ��������
typedef struct tagDH_IN_ADD_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    const char*         pszDeviceID;                    // �豸ID
    int*                pnChannels;                     // ͨ������
    int                 nChannelCount;                  // ͨ�������С,���û������ڴ�,��СΪsizeof(int)*nChannelCount
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
} DH_IN_ADD_REC_BAK_RST_TASK;

// CLIENT_RemoveRecordBackupRestoreTask�ӿ��������
typedef struct tagDH_IN_REMOVE_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    unsigned int*       pnTaskIDs;                      // ����ID����,���û������ڴ棬��СΪsizeof(int)*nTaskCount
    int                 nTaskCount;                     // ��������
} DH_IN_REMOVE_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask�ӿ��������
typedef struct tagDH_IN_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
} DH_IN_QUERY_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask�ӿ��������
typedef struct tagDH_OUT_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD                   dwSize;
    DH_REC_BAK_RST_TASK*    pTasks;                     // ��������,���û������ڴ棬��СΪsizeof(DH_REC_BAK_RST_TASK)*nMaxCount
    int                     nMaxCount;                  // �����С
    int                     nReturnCount;               // ���ص���������
} DH_OUT_QUERY_REC_BAK_RST_TASK;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    const char*             pszDeviceID;                // �豸ID
    int                     nChannel;                   // ͨ����
} DH_LOGIC_DEVICE_ADD_CAMERA_PARAM;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    char                    szDeviceID[DH_DEV_ID_LEN];  // �豸ID
    int                     nChannel;                   // ͨ����
    int                     nUniqueChannel;             // ͳһ���
    int                     nFailedCode;                // ʧ����, 0-�ɹ�,1-Unique��ַ�ռ����� 2-�Ѿ����
} DH_LOGIC_DEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCameras �ӿ��������
typedef struct tagDH_IN_ADD_LOGIC_DEVICE_CAMERA
{
    DWORD                   dwSize;
    DH_LOGIC_DEVICE_ADD_CAMERA_PARAM* pCameras;         // ��ƵԴ��Ϣ����,���û������ڴ棬��СΪsizeof(DH_LOGIC_DEVICE_ADD_CAMERA_PARAM)*nCameraCount
    int                     nCameraCount;               // ��ƵԴ��Ϣ����
} DH_IN_ADD_LOGIC_DEVICE_CAMERA;

// CLIENT_MatrixAddCameras �ӿ��������
typedef struct tagDH_OUT_ADD_LOGIC_DEVICE_CAMERA 
{
    DWORD                   dwSize;
    DH_LOGIC_DEVICE_ADD_CAMERA_RESULT* pResults;        // �����ƵԴ�������, �û������ڴ�,��СΪsizeof(DH_LOGIC_DEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
    int                     nMaxResultCount;            // ��������С, �û���д
    int                     nRetResultCount;            // ʵ�ʽ������
} DH_OUT_ADD_LOGIC_DEVICE_CAMERA;

//��ƵԴ��Ϣ
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // ͳһ���
    int                     nChannel;                   // ͨ����   
} DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM;

//�����ƵԴ�����Ϣ
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // ͳһ���
    int                     nFailedCode;                // ʧ����, 0-�ɹ�,1-ͨ����֧������
} DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCamerasByDevice �ӿ��������
typedef struct tagDH_IN_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;
    char                    pszDeviceID[DH_DEV_ID_LEN]; // �豸ID
    DH_REMOTE_DEVICE        stuRemoteDevice;            // Զ���豸��Ϣ
    int                     nCameraCount;               // ��ƵԴ��Ϣ����
    DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM* pCameras;       // ��ƵԴ��Ϣ����,�û������ڴ�,��СΪsizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM)*nCameraCount
}DH_IN_ADD_LOGIC_BYDEVICE_CAMERA;

// CLIENT_MatrixAddCamerasByDevice �ӿ��������
typedef struct tagDH_OUT_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;                         
    char                    szDeviceID[DH_DEV_ID_LEN];    // �豸ID
    int                     nMaxResultCount;              // ��������С, �û���д
    int                     nRetResultCount;              // ʵ�ʽ������
    DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT* pResults;        // �����ƵԴ�������,�û������ڴ�,��СΪsizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
}DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA;

// ��ƵԴ��Ϣ
typedef struct tagNET_CAMERA_INFO
{	
    int                     nUniqueChannel;             // ͳһ���,  -1��ʾ�豸�Զ�����ͨ����
    unsigned int            nChannel;                   // ͨ����   
    BYTE                	reserved[128];				// �����ֽ�
} NET_CAMERA_INFO;

// �豸����Ϣ
typedef struct tagNET_CAMERA_GROUP_INFO
{
	char                    szDeviceID[DH_DEV_ID_LEN];	// �豸ID
    int                     nCameraCount;				// ��ƵԴ��Ϣ����
    NET_CAMERA_INFO			*pCameras;       			// ��ƵԴ��Ϣ����,�û������ڴ�,��СΪsizeof(NET_CAMERA_INFO)*nCameraCount
	DH_REMOTE_DEVICE        stuRemoteDevice;			// Զ���豸��Ϣ, szDeviceID û��ֵʱ��Ч
	BYTE                	reserved[1024];				// �����ֽ�
} NET_CAMERA_GROUP_INFO;

// CLIENT_MatrixAddCamerasByGroup (���������ƵԴ) �ӿ��������
typedef struct tagNET_IN_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   dwSize;
	int						nCameraGroup;				// �豸�����
	NET_CAMERA_GROUP_INFO	*pstCameraGroupInfo; 		// �豸����Ϣ
} NET_IN_ADD_LOGIC_BYGROUP_CAMERA;

// �����ƵԴ�鷵�ص���ƵԴ��ӽ����Ϣ
typedef struct tagNET_ADD_BYGROUP_RESULT_CAMERA
{
    unsigned int           	nUniqueChannel;             // ͳһ���
    unsigned int            nFailedCode;                // ʧ����, 0-�ɹ�,1-ͨ����֧������
    BYTE					reserved[128];				// �����ֽ�
} NET_ADD_BYGROUP_RESULT_CAMERA;

// �����ƵԴ�鷵�ؽ����Ϣ
typedef struct tagNET_ADD_BYGROUP_RESULT
{
	char                    			szDeviceID[DH_DEV_ID_LEN];    	// �豸ID
	int									nResultCam;						// ��ƵԴ�����������NET_CAMERA_GROUP_INFO �е�nCameraCount һ��
	NET_ADD_BYGROUP_RESULT_CAMERA		*pstResultCamera;				// ���ص���ƵԴ�����Ϣ
																		// ���û������ڴ棬��СΪsizoef(NET_ADD_BYGROUP_RESULT_CAMERA)*nRetResultCamera
	BYTE								reserved[1024];					// �����ֽ�
} NET_ADD_BYGROUP_RESULT;

// CLIENT_MatrixAddCamerasByGroup (���������ƵԴ) �ӿ��������
typedef struct tagNET_OUT_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   			dwSize;
	int									nGroupCount;			// ���ص�group�����������NET_IN_ADD_LOGIC_BYGROUP_CAMERA �е�nCameraGroupһ��
	NET_ADD_BYGROUP_RESULT				*pstAddByGroupResult;	// �����ƵԴ�鷵�صĽ������
																// ���û������ڴ�, ��СΪsizeof(NET_ADD_BYGROUP_RESULT)*nGroupCount
} NET_OUT_ADD_LOGIC_BYGROUP_CAMERA;


/************************************************************************/
/*                         ���ݿ��¼����                               */
/************************************************************************/
typedef struct tagNET_AUTHORITY_TYPE
{
  DWORD                       dwSize; 
  EM_NET_AUTHORITY_TYPE       emAuthorityType;                          //Ȩ������
  BOOL                        bAuthorityEnable;                         //Ȩ��ʹ��
}NET_AUTHORITY_TYPE;

// ��ͨ�ڰ�������¼��Ϣ
typedef struct tagNET_TRAFFIC_LIST_RECORD
{
  DWORD                      dwSize; 
  int                        nRecordNo;                                 // ֮ǰ��ѯ���ļ�¼��
  char                       szMasterOfCar[DH_MAX_NAME_LEN];            // ��������
  char                       szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];    // ���ƺ��� 
  EM_NET_PLATE_TYPE          emPlateType;                               // ��������
  EM_NET_PLATE_COLOR_TYPE    emPlateColor;                              // ������ɫ 
  EM_NET_VEHICLE_TYPE        emVehicleType;                             // �������� 
  EM_NET_VEHICLE_COLOR_TYPE  emVehicleColor;                            // ������ɫ
  NET_TIME                   stBeginTime;                               // ��ʼʱ��
  NET_TIME                   stCancelTime;                              // ����ʱ��
  int                        nAuthrityNum;                              // Ȩ�޸���
  NET_AUTHORITY_TYPE         stAuthrityTypes[DH_MAX_AUTHORITY_LIST_NUM];// Ȩ���б� , ����������
  EM_NET_TRAFFIC_CAR_CONTROL_TYPE emControlType;                        // �������� ,����������
}NET_TRAFFIC_LIST_RECORD;

// ��ͨ�ڰ������˻���¼��ѯ����
typedef struct
{
    DWORD                    dwSize;
    char                     szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];      // ���ƺ�
    char                     szPlateNumberVague[DH_MAX_PLATE_NUMBER_LEN]; // ���ƺ���ģ����ѯ
    int                      nQueryResultBegin;                           // ��һ�������ؽ���ڲ�ѯ����е�ƫ���� 
    BOOL                     bRapidQuery;                                 // �Ƿ���ٲ�ѯ, TRUE:Ϊ����,���ٲ�ѯʱ���ȴ���������ɾ���Ĳ�����ɡ�Ĭ��Ϊ�ǿ��ٲ�ѯ
}FIND_RECORD_TRAFFICREDLIST_CONDITION;

// ���ɳ����ϱ��¼�, ��Ӧ�¼����� DH_ALARM_TRAFFIC_SUSPICIOUSCAR
typedef struct tagALARM_TRAFFIC_SUSPICIOUSCAR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // �¼�����, -1:δ֪,0:Start, 1:Stop, 2:Pulse
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // �����ĺ�������Ϣ
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ
}ALARM_TRAFFIC_SUSPICIOUSCAR_INFO;


// ��¼������¼��ѯ����
typedef struct
{
    DWORD                    dwSize;
    NET_TIME                 stuStartTime;                      // ��ʼʱ��
    NET_TIME                 stuEndTime;                        // ����ʱ��
}FIND_RECORD_BURN_CASE_CONDITION;


// �Ž�����¼��ѯ����
typedef struct tagFIND_RECORD_ACCESSCTLCARD_CONDITION
{
    DWORD                    dwSize;
    char                     szCardNo[DH_MAX_CARDNO_LEN];      // ����
    char                     szUserID[DH_MAX_USERID_LEN];      // �û�ID
    BOOL                     bIsValid;                         // �Ƿ���Ч, TRUE:��Ч,FALSE:��Ч
    BOOL                     abCardNo;                         // ���Ų�ѯ�����Ƿ���Ч,��Գ�Ա szCardNo
    BOOL                     abUserID;                         // �û�ID��ѯ�����Ƿ���Ч,��Գ�Ա szUserID
    BOOL                     abIsValid;                        // IsValid��ѯ�����Ƿ���Ч,��Գ�Ա bIsValid
}FIND_RECORD_ACCESSCTLCARD_CONDITION;

// �Ž������¼��ѯ����
typedef struct tagFIND_RECORD_ACCESSCTLPWD_CONDITION
{
    DWORD                     dwSize;
    char                      szUserID[DH_MAX_USERID_LEN];      // �û�ID
}FIND_RECORD_ACCESSCTLPWD_CONDITION;

// �Ž������¼��ѯ����
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION
{
    DWORD                     dwSize;
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // ����
    NET_TIME                  stStartTime;                      // ��ʼʱ��
    NET_TIME                  stEndTime;                        // ����ʱ��
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION;

// �Ž������¼��ѯ����
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
{
    DWORD                     dwSize;
    BOOL                      bCardNoEnable;                    // ���ÿ��Ų�ѯ
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // ����
    BOOL                      bTimeEnable;                      // ����ʱ��β�ѯ
    NET_TIME                  stStartTime;                      // ��ʼʱ��
    NET_TIME                  stEndTime;                        // ����ʱ��
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX;

// �������¼��ѯ����
typedef struct tagFIND_RECORD_SENSORRECORD_CONDITION
{
	DWORD					  dwSize;							
	NET_TIME                  stStartTime;                      // �ɼ�ʱ��β�ѯ�Ŀ�ʼʱ�䣬����
    NET_TIME                  stEndTime;                        // �ɼ�ʱ��β�ѯ�Ľ���ʱ�䣬����
	UINT					  uDeviceID;						// �ɼ��豸ID�ţ�uint_32���͡���8λ��ʾ�Ǳ����ͣ���24λ��ʾ�Ǳ�������š��Ǳ��������£�0-������ 1-ģ�⴫������ѡ��,0xffff��ʾ������Ч
	BOOL                      bDeviceIDEnable;                  // ���òɼ��豸ID��ѯ	
	BOOL                      bStatusEnable;                    // ��������״̬��ѯ
	BYTE					  byStatus;                         // ����״̬0��������1:�쳣��ѡ�0xff��ʾ��״̬
	BYTE					  byReserved[3];					// �����ֽ�	
} FIND_RECORD_SENSORRECORD_CONDITION;

// ���ռ�¼����ѯ����
typedef struct tagFIND_RECORD_ACCESSCTLHOLIDAY_CONDITION
{
    DWORD                     dwSize;	
    char            		  szHolidayNo[DH_COMMON_STRING_32];       // ���ڱ��
}FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION;

// ���ӳ��Ʋ�ѯ����
typedef struct tagFIND_RECORD_ELECTRONICSTAG_CONDITION
{
	DWORD					dwSize;
	NET_TIME                stStartTime;								// ���ݹ���ʱ��β�ѯ�Ŀ�ʼʱ��, ����
    NET_TIME                stEndTime;									// ���ݹ���ʱ��β�ѯ�Ľ���ʱ��, ����
	BOOL					abDevId;									// ��д����Ų�ѯ�����Ƿ���Ч
	UINT					unDevID;									// ���ݶ�д���豸��Ų�ѯ����0��ʼ, ��ѡ
	BOOL					abMatchPic;									// ͼƬƥ���ѯ�����Ƿ���Ч
    BOOL					bMatch;										// �����Ƿ�ƥ����ͼƬ��ѯ, ��ѡ
    BOOL					abPlateNumber;								// ���Ʋ�ѯ�����Ƿ���Ч
    char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// ���ݳ��Ʋ�ѯ, ��ѡ
} FIND_RECORD_ELECTRONICSTAG_CONDITION;

//������Ϣ��ѯ
typedef struct tagFIND_RECORD_RESIDENT_CONDTION
{
	DWORD 					  dwSize;
	char 					  szICNum[DH_MAX_IC_LEN];		   // ���֤��
}FIND_RECORD_RESIDENT_CONDTION;

// ��ͨ������¼��ѯ����
typedef struct tagFIND_RECORD_TRAFFICFLOW_CONDITION
{
    DWORD                     dwSize;
    BOOL                      abChannelId;                      // ͨ���Ų�ѯ�����Ƿ���Ч     
    int                       nChannelId;                       // ͨ����
    BOOL                      abLane;                           // �����Ų�ѯ�����Ƿ���Ч
    int                       nLane;                            // ������
    BOOL                      bStartTime;                      // ��ʼʱ���ѯ�����Ƿ���Ч   
    NET_TIME                  stStartTime;                      // ��ʼʱ��
    BOOL					  bEndTime;                        // ����ʱ���ѯ�����Ƿ���Ч
    NET_TIME                  stEndTime;                        // ����ʱ�� 
    BOOL                      bStatisticsTime;                 // ��ѯ�Ƿ�Ϊͳ��ʱ�䣬bStartTime��bEndTime��ΪTRUE
}FIND_RECORD_TRAFFICFLOW_CONDITION;

#define DH_MAX_CALLTYPE_LIST_NUM                16                  // ������Ͳ�ѯ�����б�������
#define DH_MAX_ENDSTATE_LIST_NUM                16                  // ����״̬��ѯ�����б�������

// ͨ����¼��ѯ����
typedef struct tagFIND_RECORD_VIDEO_TALK_LOG_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bCallTypeEnable;                            // ������Ͳ�ѯ�����Ƿ���Ч
    int                             nCallTypeListNum;                           // ��Ӧ emCallTypeList ����Чö�ٸ���
    EM_VIDEO_TALK_LOG_CALLTYPE      emCallTypeList[DH_MAX_CALLTYPE_LIST_NUM];   // �������ʹ���б�
    BOOL                            bEndStateEnable;                            // ����״̬��ѯ�����Ƿ���Ч
    int                             nEndStateListNum;                           // ��Ӧ emEndStateList ����Чö�ٸ���
    EM_VIDEO_TALK_LOG_ENDSTATE      emEndStateList[DH_MAX_ENDSTATE_LIST_NUM];   // ����״̬ʹ���б�
    BOOL                            bTimeEnable;                                // ����ʱ��β�ѯ
    NET_TIME                        stStartTime;                                // ��ʼʱ��
    NET_TIME                        stEndTime;                                  // ����ʱ��
}FIND_RECORD_VIDEO_TALK_LOG_CONDITION;

// ״̬��¼��ѯ����
typedef struct tagFIND_RECORD_REGISTER_USER_STATE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bUserIDEnable;                                  // �û�ID��ѯ�����Ƿ���Ч
    char                            szUserID[DH_MAX_USERID_LEN];                    // �û�ID
    BOOL                            bOnlineEnable;                                  // �Ƿ����߲�ѯ�����Ƿ���Ч
    int								nOnline;                                        // �Ƿ�����
    BOOL                            bVideoTalkingEnable;                            // ����Խ�״̬��ѯ�����Ƿ���Ч
    EM_REGISTER_USER_STATE          emVideoTalking;                             // ����Խ�״̬
}FIND_RECORD_REGISTER_USER_STATE_CONDITION;

// ��ϵ�˼�¼��ѯ����
typedef struct tagFIND_RECORD_VIDEO_TALK_CONTACT_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bVTShortNumberEnable;                                   // ���ӶԽ��̺Ų�ѯ�����Ƿ���Ч
    char                            szVTShortNumber[DH_COMMON_STRING_32];                   // ���ӶԽ��̺�
}FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION;

// �·���Ʒ��¼��ѯ����
typedef struct tagFIND_RECORD_COMMODITY_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // ID�Ų�ѯ�����Ƿ���Ч
    char                            szID[DH_COMMON_STRING_64];                   // ID��
}FIND_RECORD_COMMODITY_NOTICE_CONDITION;

// ������Ϣ��¼��ѯ����
typedef struct tagFIND_RECORD_HEALTH_CARE_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // ID�Ų�ѯ�����Ƿ���Ч
    char                            szID[DH_COMMON_STRING_64];                   // ID��
}FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION;

// ��ͨ������¼
typedef struct tagNET_RECORD_TRAFFIC_FLOW_STATE 
{
    DWORD                           dwSize;
    int                             nRecordNum;                 // ��¼���
    int                             nChannel;                   // ͨ����   
    int                             nLane;                      // ������
    int                             nVehicles;                  // ͨ����������
    float                           fAverageSpeed;              // ƽ������,��λkm/h
    float                           fTimeOccupyRatio;           // ʱ��ռ����,����λʱ����ͨ������ĳ�������ʱ����ܺ�ռ��λʱ��ı���
    float                           fSpaceOccupyRatio;          // �ռ�ռ����,�����ٷ��ʼ����ĳ��������ܺͳ���ʱ�����ڳ���ƽ����ʻ����
    float                           fSpaceHeadway;              // ��ͷ���,���ڳ���֮��ľ���,��λ��/��
    float                           fTimeHeadway;               // ��ͷʱ��,��λ��/��
    int                             nLargeVehicles;             // �󳵽�ͨ��(9��<����<12��),��/��λʱ��
    int                             nMediumVehicles;            // ���ͳ���ͨ��(6��<����<9��),��/��λʱ��
    int                             nSmallVehicles;             // С����ͨ��(4��<����<6��),��/��λʱ��,
    float                           fBackOfQueue;               // �Ŷӳ���,��λ����, ���źŽ����ͣ���ߵ������Ŷӳ���ĩ��֮��ľ���
}NET_RECORD_TRAFFIC_FLOW_STATE;

// CLIENT_FindRecord�ӿ��������
typedef struct _NET_IN_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    EM_NET_RECORD_TYPE        emType;          // ����ѯ��¼����
    void*                     pQueryCondition; // ��ѯ���Ͷ�Ӧ�Ĳ�ѯ����
											   // ���û������ڴ棬���ݲ�ѯ��¼���ͣ��ҵ���ѯ������Ӧ�Ľṹ�壬����ȷ���ڴ��С
}NET_IN_FIND_RECORD_PARAM;

// CLIENT_FindRecord�ӿ��������
typedef struct _NET_OUT_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    LLONG                     lFindeHandle;    // ��ѯ��¼���,Ψһ��ʶĳ�β�ѯ
}NET_OUT_FIND_RECORD_PARAM;

// CLIENT_FindNextRecord�ӿ��������
typedef struct _NET_IN_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    LLONG                     lFindeHandle;    // ��ѯ���
    int                       nFileCount;      // ��ǰ���ѯ�ļ�¼����
}NET_IN_FIND_NEXT_RECORD_PARAM;

// CLIENT_FindNextRecord�ӿ��������
typedef struct _NET_OUT_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    void*                     pRecordList;     // ��¼�б�,�û������ڴ�,����NET_IN_FIND_RECORD_PARAM�еĲ�ѯ����EM_NET_RECORD_TYPE��ȷ����Ӧ�ṹ�壬����ȷ���ڴ��С
    int                       nMaxRecordNum;   // ����ѯ�б��¼��
    int                       nRetRecordNum;   // ��ѯ���ļ�¼����,����ѯ��������С�����ѯ������ʱ,��ѯ����
}NET_OUT_FIND_NEXT_RECORD_PARAM;

typedef struct tagNET_INSERT_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // ��¼������Ϣ,���û������ڴ棬��СΪsizeof(NET_TRAFFIC_LIST_RECORD)             
}NET_INSERT_RECORD_INFO;

typedef struct tagNET_UPDATE_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // ��¼������Ϣ,���û������ڴ棬��СΪsizeof(NET_TRAFFIC_LIST_RECORD)                
}NET_UPDATE_RECORD_INFO;

typedef struct tagNET_REMOVE_RECORD_INFO
{
    DWORD                     dwSize;
    int                       nRecordNo;       // ֮ǰ��ѯ���ļ�¼��    
}NET_REMOVE_RECORD_INFO;

typedef struct tagNET_IN_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    
    EM_RECORD_OPERATE_TYPE    emOperateType;
    EM_NET_RECORD_TYPE        emRecordType;    // Ҫ������¼��Ϣ����
    void                      *pstOpreateInfo; // ���û������ڴ棬���ղ�����¼��Ϣ���ͣ��õ���¼��Ϣ��Ӧ�Ľṹ�壬����ȷ����Ӧ���ڴ��С
    
}NET_IN_OPERATE_TRAFFIC_LIST_RECORD;

//�ֽ׶�ʵ�ֵĲ����ӿ���,ֻ�з���nRecordNo�Ĳ���,stRetRecord��ʱ������
typedef struct tagNET_OUT_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    int                       nRecordNo;        //��¼��    
}NET_OUT_OPERATE_TRAFFIC_LIST_RECORD;


//����������̨��Ӧ�ṹ
typedef struct tagPTZ_Control_Continuously
{
    PTZ_SPEED_UNIT         stuSpeed;              //��̨�����ٶ�
    int                    nTimeOut;              //�����ƶ���ʱʱ��,��λΪ��
    char                   szReserve[64];         //Ԥ��64�ֽ�
}PTZ_CONTROL_CONTINUOUSLY;

//���Կ�����̨��Ӧ�ṹ
typedef struct tagPTZ_Control_Absolutely
{
    PTZ_SPACE_UNIT         stuPosition;           //��̨�����ƶ�λ��
    PTZ_SPEED_UNIT         stuSpeed;              //��̨�����ٶ�
    char                   szReserve[64];         //Ԥ��64�ֽ�
}PTZ_CONTROL_ABSOLUTELY;

//��̨�������꣬�����ƶ�
typedef struct tagPTZ_LOCATION_SPACE_UNIT
{
    int                    nPositionX;           //��̨ˮƽ���꣬��Χ[0,3599]����ʾ0�ȵ�359.9�ȣ���������10����ʾ����3600��ʾˮƽ����λ��
    int                    nPositionY;           //��̨��ֱ���꣬��Χ[-1800,1800]����ʾ-180.0�ȵ�+180.0�ȣ���������10����ʾ����3600��ʾ��ֱ����λ��
    int                    nZoom;                //��̨��ʵ���ʱ䱶�������޷�Χ�޶�(������о�����ʱֻ�䱶����о�����)����ʾ��С������󱶵ı䱶λ�ã�����10����ʾ
    char                   szReserve[32];        //Ԥ��32�ֽ�
}PTZ_LOCATION_SPACE_UNIT;

//��̨��������,�ٶȵ�Ԫ
typedef struct tagPTZ_LOCATION_SPEED_UNIT
{
    int                    nSpeedX;				//��̨ˮƽ���ٶȵ���ʵֵ,�޷�Χ�޶�(������̨����ٶ�ʱ����̨����ٶ��ƶ�),��Ϊ������Ϊ��,1000����10��/s������100����ʾ
    int                    nSpeedY;				//��̨��ֱ���ٶȵ���ʵֵ,�޷�Χ�޶�(������̨����ٶ�ʱ����̨����ٶ��ƶ�),��Ϊ������Ϊ��,1000����10��/s������100����ʾ
    char                   szReserve[32];       //Ԥ��32�ֽ�
}PTZ_LOCATION_SPEED_UNIT;

//��̨�����ƶ�,ǹ��������ר�ö�Ӧ�ṹ DH_EXTPTZ_INTELLI_TRACKMOVE
typedef struct tagPTZ_CONTROL_INTELLI_TRACKMOVE
{
	DWORD						dwSize;
	int							nChannelID;            // ͨ����
	int							nFlag;				   // �ƶ���ʶλ
													   //0:��ʼlocate��λʹ��,speed�ٶ���Ч,position�ı䱶ֵ��Ч
													   //1:���������ƶ�ʹ��,speed�ٶ���Ч,position�ı䱶ֵ��Ч
													   //2:���������ƶ�ʹ��,speed�ٶ���Ч,position�ı䱶ֵ��Ч

	PTZ_LOCATION_SPACE_UNIT     stuPosition;           // ��̨�����ƶ�λ��
    PTZ_LOCATION_SPEED_UNIT		stuSpeed;              // ��̨�����ٶ�
}PTZ_CONTROL_INTELLI_TRACKMOVE;

//��������,�������Ӧ�ṹ DH_EXTPTZ_AUXIOPEN,DH_EXTPTZ_AUXICLOSE����̨���ƽӿ�CLIENT_DHPTZControlEx2
typedef struct tagPTZ_CONTROL_AUXILIARY
{
	DWORD						dwSize;
	char						szFunctionName[DH_COMMON_STRING_32];   // ��̨�����������ƣ�ͨ��CFG_CAP_CMD_PTZ�����ȡ��̨������(CFG_PTZ_PROTOCOL_CAPS_INFO)��
}PTZ_CONTROL_AUXILIARY;


// ��������ͨ����Ϣ
typedef struct tagNET_ALARM_IN_CHANNEL
{
    DWORD                   dwSize;
    BOOL                    bValid;                             // �Ƿ���Ч, FALSE��ʾ�ñ���ͨ��û��ʹ��
    int                     nChannel;                           // ����ͨ����
    char                    szDeviceID[DH_DEV_ID_LEN];          // �豸ID, ���ر���ͨ��: "Local", Զ���豸: ʹ��uuid��ʾ
    char                    szName[DH_DEV_NAME_LEN];            // ����ͨ������
}NET_ALARM_IN_CHANNEL;

// ����ͨ����
typedef struct tagNET_ALARM_CHANNEL_COUNT 
{
    DWORD                   dwSize;
    int                     nLocalAlarmIn;                      // ���ر�������ͨ����
    int                     nLocalAlarmOut;                     // ���ر������ͨ����
    int                     nRemoteAlarmIn;                     // Զ�̱�������ͨ����
    int                     nRemoteAlarmOut;                    // Զ�̱������ͨ����
}NET_ALARM_CHANNEL_COUNT;

//���ٶ�ת����Ԥ��λ����̨���ƶ�Ӧ�ṹ
typedef struct tagPTZ_Control_GotoPreset
{
    int                     nPresetIndex;           //Ԥ��λ����
    PTZ_SPEED_UNIT          stuSpeed;               //��̨�����ٶ�
    char                    szReserve[64];          //Ԥ��64�ֽ�
}PTZ_CONTROL_GOTOPRESET;

//ɾ��Ԥ��λ����̨���ƶ�Ӧ�ṹ
typedef struct tagPTZ_Control_RemovePreset
{
    int                     nPresetIndex;           //Ԥ��λ����
    char                    szReserve[64];          //Ԥ��64�ֽ�
}PTZ_CONTROL_REMOVEPRESET;

//���ٶ�ת����Ԥ��λ���ץͼ��̨���ƶ�Ӧ�ṹ
typedef struct tagPTZ_Control_GotoPresetSnap
{
    int                     nPresetIndex;           //Ԥ��λ����
	int						nChannel;               //ͨ����
    PTZ_SPEED_UNIT          stuSpeed;               //��̨�����ٶ�
    char                    szReserve[64];          //Ԥ��64�ֽ�
}PTZ_CONTROL_GOTOPRESETSNAP;

// CLIENT_SetTourSource �ӿ��������(���ô�����Ѳ��ʾԴ)
typedef struct tagNET_IN_SET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // ���ͨ����
    int                     nWindow;                // ���ں�
    DH_SPLIT_SOURCE*        pstuSrcs;               // ��ʾԴ����, �ɽ��д�����Ѳ,���û������ڴ棬��СΪsizeof(DH_SPLIT_SOURCE)*nSrcCount
    int                     nSrcCount;              // ��ʾԴ����
} NET_IN_SET_TOUR_SOURCE;

// CLIENT_SetTourSource �ӿ��������(���ô�����Ѳ��ʾԴ)
typedef struct tagNET_OUT_SET_TOUR_SOURCE
{
    DWORD                   dwSize;
} NET_OUT_SET_TOUR_SOURCE;

// CLIENT_GetTourSource �ӿ��������
typedef struct tagNET_IN_GET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // ���ͨ����, pszCompsiteIDΪNULLʱ��Ч
    const char*             pszCompositeID;         // ƴ����ID
    int                     nWindow;                // ���ں�, -1��ʾ���д���
} NET_IN_GET_TOUR_SOURCE;

// ������Ѳ��ʾԴ��Ϣ
typedef struct tagNET_SPLIT_TOUR_SOURCE 
{
    DWORD                   dwSize;
    DH_SPLIT_SOURCE*        pstuSrcs;               // ��ʾԴ����, �û������ڴ�,��СΪsizeof(DH_SPLIT_SOURCE)*nMaxSrcCount
    int                     nMaxSrcCount;           // ��ʾԴ�������
    int                     nRetSrcCount;           // ���ص���ʾԴ����
} NET_SPLIT_TOUR_SOURCE;

// CLIENT_GetTourSource �ӿ��������
typedef struct tagNET_OUT_GET_TOUR_SOURCE
{
    DWORD                   dwSize;    
    NET_SPLIT_TOUR_SOURCE*  pstuWndSrcs;            // ������Ѳ��Ϣ����, �û������ڴ�,��СΪsizeof(NET_SPLIT_TOUR_SOURCE)*nMaxWndCount
    int                     nMaxWndCount;           // �����������, �û���д
    int                     nRetWndCount;           // ���صĴ�������
} NET_OUT_GET_TOUR_SOURCE;

// �ָ���Ѳ״̬��Ϣ
typedef struct tagNET_SPLIT_TOUR_STATUS_INFO
{
    DWORD               dwSize;
    int                 nWindow;                    // ���ں�
    NET_TOUR_STATUS     emStatus;                   // ״̬
    DH_SPLIT_WND_SOURCE stuSource;                  // ��ǰ��ʾԴ��Ϣ
}NET_SPLIT_TOUR_STATUS_INFO;

// ��Ѳ״̬�ص�����ԭ��, lAttachHandle��CLIENT_AttachSplitTour�ķ���ֵ
typedef void (CALLBACK *fTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SPLIT_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_AttachSplitTour�ӿ��������
typedef struct tagNET_IN_ATTACH_SPLIT_TOUR
{
    DWORD               dwSize;
    int                 nChannel;                   // ���ͨ����, pszCompsiteIDΪNULLʱ��Ч
    const char*         pszCompositeID;             // ƴ����ID
    fTourStatusCallBack cbStatus;                   // ��Ѳ״̬�ص�����
    LDWORD              dwUser;                     // ��Ѳ״̬�ص�����
}NET_IN_ATTACH_SPLIT_TOUR;

// CLIENT_AttachSplitTour�ӿ��������
typedef struct tagNET_OUT_ATTACH_SPLIT_TOUR 
{
    DWORD               dwSize;
}NET_OUT_ATTACH_SPLIT_TOUR;

// ���ڹ���ģʽ
typedef enum tagEM_WINDOW_WORKMODE
{
	EM_WINDOW_DISPLAY,				// Ԥ��ģʽ(Ĭ��)
	EM_WINDOW_REPLAY,				// �ط�ģʽ
} EM_WINDOW_WORKMODE;

typedef struct tagNET_SOURCE_INFO
{
	int 				nWindowID;					// ��ǰ���ں�
	int					nCaremaChannel;				// ��ǰ��ƵԴͨ����
	NET_TIME			stuStartTime;				// ��ʼ���ŵ�ʱ��
	EM_WINDOW_WORKMODE	emWorkMode;					// ���ڹ���ģʽ
	BYTE				bReserved[128];				// �����ֽ�
}NET_SOURCE_INFO;

// ������ƵԴ��Ϣ
typedef struct tagNET_WINDOW_SOURCE_INFO
{
	DWORD				dwSize;
	int					nRetSrcCount;							// ʵ����ʾԴ����
	NET_SOURCE_INFO		*pstSourceInfo;						// ��������ʾԴ��Ϣ
} NET_WINDOW_SOURCE_INFO;

// ������ƵԴ��Ϣ�ص�����ԭ��, lAttachHandle��CLIENT_AttachWindowsSource�ķ���ֵ
typedef void (CALLBACK *fWindowSourceCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WINDOW_SOURCE_INFO* pstWindowSource, void* reserved, LDWORD dwUser);

// CLIENT_AttachWindowsSource�ӿ����
typedef struct tagNET_IN_ATTACH_WINDOW_SOURCE
{
	DWORD					dwSize;
	int						nWindowID;					// ����ID��-1��ʾ������Ļ
	int 					nChannel;					// ���ͨ����, pszCompsiteIDΪNULLʱ��Ч
	const char*         	pszCompositeID;             // ƴ����ID
	fWindowSourceCallBack 	cbWindowSource;             // ������ƵԴ�ص�����
    LDWORD              	dwUser;                     // ������ƵԴ�ص�����
} NET_IN_ATTACH_WINDOW_SOURCE;

// CLIENT_AttachWindowsSource�ӿ��������
typedef struct tagNET_OUT_ATTACH_WINDOW_SOURCE
{
    DWORD               dwSize;
}NET_OUT_ATTACH_WINDOW_SOURCE;

// CLIENT_WindowRegionEnlarge�ӿ��������
typedef struct tagNET_IN_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
    int                 	nChannel;           // ���ͨ���Ż��ں�������ͨ����
	int						nWindowID;			// ����ID
	NET_RECT				stuRect;			// ����Ŵ���������ϵΪ��������ϵ��0~8192
} NET_IN_WINDOW_REGION_ENLARGE;

// CLIENT_WindowRegionEnlarge�ӿ��������
typedef struct tagNET_OUT_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
} NET_OUT_WINDOW_REGION_ENLARGE;

// CLIENT_WindowEnlargeReduction�ӿ��������
typedef struct tagNET_IN_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
    int                 	nChannel;           // ���ͨ���Ż��ں�������ͨ����
	int						nWindowID;			// ����ID
} NET_IN_WINDOW_ENLARGE_REDUCTION;

// CLIENT_WindowEnlargeReduction�ӿ��������
typedef struct tagNET_OUT_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
} NET_OUT_WINDOW_ENLARGE_REDUCTION;

// fAttachRecordInfoCB ����, �ϱ���¼���ļ���Ϣ
typedef struct tagNET_CB_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nChannel;               // ͨ����
    char                    szFileName[MAX_PATH];   // ¼������
    DWORD                   dwType;                 // ¼������, ��λ�������£�
                                                    // Bit0-��ʱ¼��
                                                    // Bit1-��̬���¼��
                                                    // Bit2-����¼��
                                                    // Bit3-����¼��
    DWORD                   dwState;                // ¼��״̬, 0-���, 1-ɾ��
} NET_CB_RECORD_INFO;

// ¼����»ص�����ԭ��,lAttachHandle��CLIENT_AttachRecordInfo�ķ���ֵ, ÿ��n��,pBuf->dwSize * n == nBufLen
typedef void (CALLBACK *fAttachRecordInfoCB)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_RECORD_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordInfo �������
typedef struct tagNET_IN_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nInterval;              // ʱ����, �豸ÿ��nInterval��, ����¼����Ϣ
    int                     nDelay;                 // �ϱ���ʱ, �豸��1��nDelayֵ��ѡ���������,�ӳ��ϱ�¼��״̬, nDelay����С��nInterval
    fAttachRecordInfoCB     cbAttachRecordInfo;     // ¼����»ص�����
    LDWORD                  dwUser;                 // �û�����
} NET_IN_ATTACH_RECORD_INFO;

typedef struct tagNET_OUT_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_RECORD_INFO;


//������̨Ԫ���ݽӿڻص�����ԭ��
//pBuf �ֽ׶���ҪΪ DH_PTZ_LOCATION_INFO ����
typedef void (CALLBACK *fPTZStatusProcCallBack)(LLONG lLoginID, LLONG lAttachHandle, void* pBuf, int nBufLen, LDWORD dwUser);

// ������̨Ԫ���ݽӿ��������
typedef struct tagNET_IN_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
    int                     nChannel;              // ��̨ͨ��
    fPTZStatusProcCallBack  cbPTZStatusProc;       // ״̬�ص�����
    LDWORD                  dwUser;                // �û�����
}NET_IN_PTZ_STATUS_PROC;

// ������̨Ԫ���ݽӿ����������
typedef struct tagNET_OUT_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
}NET_OUT_PTZ_STATUS_PROC;

// ��̨������״̬�ṹ
typedef struct tagDH_OUT_PTZ_VIEW_RANGE_STATUS
{
    DWORD      dwSize;
    double     dbDistance;                         // ���Ӿ���, ��λ:��
    int        nAngelH;                            // ˮƽ���ӽǶ�, 0~1800, ��λ:ʮ��֮һ��
    int        nAzimuthH;                          // ˮƽ��λ�Ƕ�, 0~3600, ��λ:ʮ��֮һ��
    int        nInclinationH;                      // ˮƽ��б�Ƕ�, -900~900, ��λ:ʮ��֮һ��
}DH_OUT_PTZ_VIEW_RANGE_STATUS;

//������̨������ص�����ԭ��
typedef void (CALLBACK *fViewRangeStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, DH_OUT_PTZ_VIEW_RANGE_STATUS* pBuf, int nBufLen, LDWORD dwUser);

// ���Ŀ������������
typedef struct tagNET_IN_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
    int                     nChannel;              // ��̨ͨ��
    fViewRangeStateCallBack cbViewRange;           // ״̬�ص�����
    LDWORD                  dwUser;                // �û�����
}NET_IN_VIEW_RANGE_STATE;

// ���Ŀ������������
typedef struct tagNET_OUT_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
}NET_OUT_VIEW_RANGE_STATE;

// ������Ϣ�ṹ
typedef struct tagNET_WEATHER_INFO
{
	float				    fWindSpeed;		       // ����,��λm/s,	��Χ[0.0,60.0]	
	float					fTemperature;		   // �¶�,��λ���϶ȣ���Χ[-40.0,+80.0]
	float					fHumidity;			   // ��׺%,��Χ[0.0,100.0]
	unsigned int			nLight;				   // ����,��λW/(m*m),��Χ[0,2000]
	float					fWindDirection;		   // ����,��λ��,��Χ[0,360)
	float				    fAirPressure;		   // ��ѹ,��λ����,��Χ[10~1100]
	BYTE					byReserved[2048];	   // �����ֽ�
}NET_WEATHER_INFO;

// ����������Ϣ�ص�����ԭ��
typedef void (CALLBACK *fWeatherInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WEATHER_INFO* pBuf, int nBufLen, LDWORD dwUser);

// ����������Ϣ�������
typedef struct tagNET_IN_WEATHER_INFO
{
	DWORD                   dwSize;
	int                     nChannel;              // ��̨ͨ��
	fWeatherInfoCallBack	cbWeatherInfo;         // �ص�����
	LDWORD                  dwUser;                // �û�����
}NET_IN_WEATHER_INFO;

// ����������Ϣ�������
typedef struct tagNET_OUT_WEATHER_INFO
{
	DWORD                   dwSize;
}NET_OUT_WEATHER_INFO;

// ������ࡢ�����С��ռ�������ÿ����� �������
typedef struct tagNET_IN_SET_VIEW_RANGE_BY_OBJECT
{
	DWORD					dwSize;					
	int						nChannel;				// ͨ����
	int						nDistance;				// �������  ����λ�����ף� 
	int						nWidth;					// ������  ����λ�����ף�
	int						nScreenRatio;			// ����ռ���ȣ���λ�����ף�
}NET_IN_SET_VIEW_RANGE_BY_OBJECT;

// ������ࡢ�����С��ռ�������ÿ����� �������
typedef struct tagNET_OUT_SET_VIEW_RANGE_BY_OBJECT
{
    DWORD                   dwSize;
}NET_OUT_SET_VIEW_RANGE_BY_OBJECT;
//������̨��������Ϣ
typedef struct tagPTZ_VIEW_RANGE_INFO
{
    int                     nStructSize;
    int                     nAzimuthH;              // ˮƽ��λ�Ƕ�, 0~3600, ��λ:��
}PTZ_VIEW_RANGE_INFO;

//��ȡ��̨��ѧ�䱶��Ϣ,��Ӧ���� DH_DEVSTATE_PTZ_ZOOM_INFO
typedef struct tagDH_OUT_PTZ_ZOOM_INFO
{
    int                     dwSize;
    int                     nZoomValue;              // ��ѧ�䱶ֵ
}DH_OUT_PTZ_ZOOM_INFO;

// ͨ��������Ϣ
typedef struct tagNET_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    int                     nMaxTotal;              // �豸��ͨ����(������Чͨ����֮��)
    int                     nCurTotal;              // �����õ�ͨ����
    int                     nMaxLocal;              // ��󱾵�ͨ����, ������Ϳɲ���ӿ�ͨ��
    int                     nCurLocal;              // �����ñ���ͨ����
    int                     nMaxRemote;             // ���Զ��ͨ����
    int                     nCurRemote;             // ������Զ��ͨ����
} NET_CHN_COUNT_INFO;

// �豸ͨ��������Ϣ
typedef struct tagNET_DEV_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    NET_CHN_COUNT_INFO      stuVideoIn;             // ��Ƶ����ͨ��
    NET_CHN_COUNT_INFO      stuVideoOut;            // ��Ƶ���ͨ��
} NET_DEV_CHN_COUNT_INFO;

// ¼��״̬��ϸ��Ϣ
typedef struct tagNET_RECORD_STATE_DETAIL 
{
    DWORD                   dwSize;
    BOOL                    bMainStream;            // ������, TRUE-����¼��, FALSE-û��¼��
    BOOL                    bExtraStream1;          // ������1, TRUE-����¼��, FALSE-û��¼��
    BOOL                    bExtraStream2;          // ������2, TRUE-����¼��, FALSE-û��¼��
    BOOL                    bExtraStream3;          // ������3, TRUE-����¼��, FALSE-û��¼��
} NET_RECORD_STATE_DETAIL;

//��̨���Ծ۽���Ӧ�ṹ
typedef struct tagPTZ_Focus_Absolutely
{
    DWORD                    dwValue;               //��̨�۽�λ��,ȡֵ��Χ(0~8191)
    DWORD                    dwSpeed;               //��̨�۽��ٶ�,ȡֵ��Χ(0~7)
    char                     szReserve[64];         //Ԥ��64�ֽ�
}PTZ_FOCUS_ABSOLUTELY;

// CLIENT_PlayAudioFile �ӿ��������
typedef struct tagNET_IN_PLAY_AUDIO_FILE
{
    DWORD                   dwSize;
    const char*             pszFilePath;            // �ļ�·��
    DWORD                   dwOutput;               // ���;��, �����Ƕ������, ��λ��ʾ, bit0-mic, bit1-speaker
} NET_IN_PLAY_AUDIO_FILE;

// CLIENT_PlayAudioFile �ӿ��������
typedef struct tagNET_OUT_PLAY_FILE_STREAM
{
    DWORD                   dwSize;
} NET_OUT_PLAY_AUDIO_FILE;

// RTSP URL��Ϣ�б�ṹ
typedef struct tagNET_DEV_RTSPURL_LIST
{
    DWORD                   dwSize;
    int                     nChannelID;                                 // ͨ����(�û��������)
    int                     nUrlNum;                                    // Url��ַ����
    char                    szURLList[DH_MAX_URL_NUM][DH_MAX_URL_LEN];  // Url��ַ�б�
}NET_DEV_RTSPURL_LIST;

// ��̨����-��ɨ��Ӧ�ṹ
typedef struct tagPTZ_Control_SectorScan
{
    int             nBeginAngle;                    //��ʼ�Ƕ�,��Χ:[-180,180]
    int             nEndAngle;                      //�����Ƕ�,��Χ:[-180,180]
    int             nSpeed;                         //�ٶ�,��Χ:[0,255]
    char            szReserve[64];                  //Ԥ��64�ֽ�
}PTZ_CONTROL_SECTORSCAN;

// �������۵�����̨��Ϣ
typedef struct tagPTZ_CONTROL_SET_FISHEYE_EPTZ
{
    DWORD           dwSize;                         // �ṹ���С
    DWORD           dwWindowID;                     // ����EPtz���ƵĴ��ڱ��
    DWORD           dwCommand;                      // ������̨����
    DWORD           dwParam1;                       // �����Ӧ����1
    DWORD           dwParam2;                       // �����Ӧ����2
    DWORD           dwParam3;                       // �����Ӧ����3
    DWORD           dwParam4;                       // �����Ӧ����4
}PTZ_CONTROL_SET_FISHEYE_EPTZ;

// �����������Ϣ
typedef struct tagPTZ_CONTROL_SET_TRACK_CONTROL
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_SET_TRACK_CONTROL)
    DWORD           dwChannelID;                    // ͨ����
    DWORD           dwCommand;                      // ������̨����,��Ӧö��NET_TRACK_CONTROL_CMD
    DWORD           dwParam1;                       // �����Ӧ����1
    DWORD           dwParam2;                       // �����Ӧ����2
    DWORD           dwParam3;                       // �����Ӧ����3
} PTZ_CONTROL_SET_TRACK_CONTROL;

//===============����ɨ�裬��̨����=============================

// ����ɨ����̨��������(CLIENT_DHPTZAreaScan)
typedef enum tagNET_AREASCAN_EPTZ_CMD
{
	NET_AREASCAN_EPTZ_CMD_SET,					// ���õ�ǰλ��Ϊĳ�������ɨ��߽�(�ṹ������Ϊ PTZ_CONTROL_SET_AREA_SCAN_LIMIT,���������Ч)
    NET_AREASCAN_EPTZ_CMD_DEL,					// ɾ��ĳ������ɨ��(�ṹ������Ϊ PTZ_CONTROL_DEL_AREA_SCAN,���������Ч)
    NET_AREASCAN_EPTZ_CMD_GET, 					// ��ȡ���е�����ɨ�����Ƿ���Ч(�ṹ������Ϊ PTZ_CONTROL_GET_AREA_SCAN_IN,�������Ϊ PTZ_CONTROL_GET_AREA_SCAN_OUT )
    NET_AREASCAN_EPTZ_CMD_START,				// ��ʼ����ɨ��(�ṹ������Ϊ PTZ_CONTROL_START_AREA_SCAN,���������Ч)
    NET_AREASCAN_EPTZ_CMD_STOP,					// ֹͣ����ɨ��(�ṹ������Ϊ PTZ_CONTROL_STOP_AREA_SCAN,���������Ч)
}NET_AREASCAN_EPTZ_CMD;

// ���õ�ǰλ��Ϊĳ�������ɨ��߽�
typedef struct tagPTZ_CONTROL_SET_AREA_SCAN_LIMIT
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_SET_AREA_SCAN_LIMIT)
    int				nChannelID;                     // ͨ����,ͨ���Ŵ�0��ʼ
	int             nIndex;							// �����ţ���Ŵ�1��ʼ
	char			szLimitMode[16];				// ����߽磬"Left":��߽� "Right":�ұ߽�
	int             nZoom;							// ɨ��䱶ֵ,��Χ0~128��Ĭ��Ϊ0����ʾ��ǰֵ��1~128��ʾ��Ӧ�ı䱶��λ
} PTZ_CONTROL_SET_AREA_SCAN_LIMIT;

// ɾ��ĳ������ɨ��
typedef struct tagPTZ_CONTROL_DEL_AREA_SCAN
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_DEL_AREA_SCAN)
    int				nChannelID;                     // ͨ����,ͨ���Ŵ�0��ʼ
	int             nIndex;							// �����ţ���Ŵ�1��ʼ
} PTZ_CONTROL_DEL_AREA_SCAN;

// ��ȡ���е�����ɨ�����Ƿ���Ч,�������
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_IN
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_GET_AREA_SCAN)
    int				nChannelID;                     // ͨ����,ͨ���Ŵ�0��ʼ
	int             nSize;							// Ҫ��ȡ������ɨ�����
} PTZ_CONTROL_GET_AREA_SCAN_IN;

// ������Ч��Ϣ
typedef struct tagNET_AREASCAN_STATE 
{
    BOOL            bValid;							// �����Ƿ���Ч
	BYTE			Reserved[128];					// �����ֽ�
}NET_AREASCAN_STATE;

// ��ȡ���е�����ɨ�����Ƿ���Ч,�������
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_OUT
{
    DWORD                       dwSize;                             // �ṹ���С, �����߱����ʼ�����ֶ�
	UINT				        nValidNum;						    // ���� stuStateInfo ����Ч����
    NET_AREASCAN_STATE			stuStateInfo[DH_COMMON_STRING_32];  // ����״̬��Ϣ
}PTZ_CONTROL_GET_AREA_SCAN_OUT;

// ��ʼ����ɨ��
typedef struct tagPTZ_CONTROL_START_AREA_SCAN
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_START_AREA_SCAN)
    int				nChannelID;                     // ͨ����,ͨ���Ŵ�0��ʼ
	int             nIndex;							// �����ţ���Ŵ�1��ʼ
	int             nSpeed;							// ˮƽɨ���ٶȣ���Χ1~255
	int				nTitleAngle;					// ��ֱɨ��Ƕȣ��ӵ�ǰλ�ð��˽Ƕȵ������ߵݼ�ɨ�裬��Χ0~90��
} PTZ_CONTROL_START_AREA_SCAN;

// ֹͣ����ɨ��
typedef struct tagPTZ_CONTROL_STOP_AREA_SCAN
{
    DWORD           dwSize;                         // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_STOP_AREA_SCAN)
    int				nChannelID;                     // ͨ����,ͨ���Ŵ�0��ʼ
	int             nIndex;							// �����ţ���Ŵ�1��ʼ
} PTZ_CONTROL_STOP_AREA_SCAN;
//===============����ɨ�裬��̨����=============================


// ����۽�ģʽ
typedef enum tagEM_NET_FOCUS_REGION_MODE
{
    EM_NET_FOCUS_REGION_MODE_GLOBAL,                // ȫ��
    EM_NET_FOCUS_REGION_MODE_AUTO,                  // �Զ�
    EM_NET_FOCUS_REGION_MODE_INROIREGION,           // ROI ָ����������
    EM_NET_FOCUS_REGION_MODE_OUTROIREGION,          // ROI ָ����������

}EM_NET_FOCUS_REGION_MODE;

// ����۽�(��Ӧö��DH_EXTPTZ_SET_FOCUS_REGION)
typedef struct tagPTZ_CONTROL_SET_FOCUS_REGION
{
    DWORD                       dwSize;             // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(PTZ_CONTROL_SET_FOCUS_REGION)   
    EM_NET_FOCUS_REGION_MODE    emMode;	            // �۽�ģʽ
    NET_RECT                    stuRect;            // �۽�����,ʹ�����������ϵ��ȡֵ��Ϊ0-8192                        
} PTZ_CONTROL_SET_FOCUS_REGION;


// CLIENT_TransmitInfoForWeb �ӿ���չ����
typedef struct tagNET_TRANSMIT_EXT_INFO
{
    DWORD           dwSize;
    unsigned char*  pInBinBuf;                      // �������������ݻ���
    DWORD           dwInBinBufSize;                 // �������������ݳ���
    int             nJsonDataLen;                   // Json������ݳ���
    int             nBinDataLen;                    // ������������ݳ���
} NET_TRANSMIT_EXT_INFO;

// ����CAN��������
// fAttachProxyCB ����
typedef struct tagNET_CB_CANDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // ��ͨ���ݳ���
    unsigned char*  pDataContent;                   // ��ͨ��������
}NET_CB_CANDATA;

// ����CAN�������ݻص�����ԭ��,lAttachHandle��CLIENT_AttachCAN����ֵ
typedef void (CALLBACK *fAttachCANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_CANDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachCAN()�������
typedef struct tagNET_IN_ATTACH_CAN
{
    DWORD          dwSize;
    int            nChannel;                        // ������CANͨ����
    fAttachCANCB   cbAttachCAN;                     // ע����Ƶ�绰״̬�仯�ص�
    LDWORD         dwUser;                          // �û�����
}NET_IN_ATTACH_CAN;

// CLIENT_AttachCAN()�������
typedef struct tagNET_OUT_ATTACH_CAN
{
    DWORD          dwSize;
}NET_OUT_ATTACH_CAN;

// CLIENT_SendCAN()�������
typedef struct tagNET_IN_SEND_CAN
{
    DWORD          dwSize;
    int            nChannel;                       // CANͨ����
    int            nSendDataLength;                // �������ݳ���
    unsigned char* pSendData;                      // ������������
}NET_IN_SEND_CAN;

// CLIENT_SendCAN()�������
typedef struct tagNET_OUT_SEND_CAN
{
    DWORD          dwSize;
}NET_OUT_SEND_CAN;

// ����͸���������ݻص�fAttachDevCommCB ����
typedef struct tagNET_CB_DEVCOMMDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // ��ͨ���ݳ���
    unsigned char*  pDataContent;                   // ��ͨ��������
}NET_CB_DEVCOMMDATA;

// ����͸���������ݻص�����ԭ��,lAttachHandle��CLIENT_AttachDevComm����ֵ
typedef void (CALLBACK *fAttachDevCommCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_DEVCOMMDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachDevComm()�������
typedef struct tagNET_IN_ATTACH_DEVCOMM
{
    DWORD               dwSize;
    int                 nChannel;                        // ������͸�����ں�
    fAttachDevCommCB    cbAttachDevComm;                 // ע��͸���������ݻص�
    LDWORD              dwUser;                          // �û�����
}NET_IN_ATTACH_DEVCOMM;

// CLIENT_AttachDevComm()�������
typedef struct tagNET_OUT_ATTACH_DEVCOMM
{
    DWORD          dwSize;
}NET_OUT_ATTACH_DEVCOMM;

// ��ȡ��ǰ�豸���ڸ���,��ӦCLIENT_QueryDevState()�ӿڵ� DH_DEVSTATE_GET_COMM_COUNT �������
typedef struct tagNET_GET_COMM_COUNT
{
    DWORD          dwSize;
    int            nChannelCout;                    // ��ȡ���Ĵ�����
}NET_GET_COMM_COUNT;

// CLIENT_ExChangeData �ӿ�����ṹ��
typedef struct tagNET_IN_EXCHANGEDATA
{
    DWORD           dwSize;
    int             nChannel;                       // ���ں�
    BOOL            bFlag;                          // TRUE Ϊ�������ݲ��ȴ��ظ�,FALSE ֻ�ǲɼ�����
    int             nCollectTime;                   // ���ڲɼ�ʱ��(��λ������)
    int             nSendDataLength;                // �������ݳ���,bFlag = TRUE ��Ч
    unsigned char*  pSendData;                      // ������������,bFlag = TRUE ��Ч
}NET_IN_EXCHANGEDATA;

// CLIENT_ExChangeData �ӿ�����ṹ��
typedef struct tagNET_OUT_EXCHANGEDATA
{
    DWORD           dwSize;
}NET_OUT_EXCHANGEDATA;

// ��̨Ԥ�õ�
typedef struct tagNET_PTZ_PRESET 
{
    int                     nIndex;                         // ���
    char                    szName[PTZ_PRESET_NAME_LEN];    // ����
    char                    szReserve[64];                  // Ԥ��64�ֽ�
} NET_PTZ_PRESET;

// ��̨Ԥ�õ��б�
typedef struct tagNET_PTZ_PRESET_LIST 
{
    DWORD                   dwSize;
    DWORD                   dwMaxPresetNum;                 // Ԥ�õ�������
    DWORD                   dwRetPresetNum;                 // ����Ԥ�õ����
    NET_PTZ_PRESET          *pstuPtzPorsetList;             // Ԥ�õ��б�(�����Ҫ���������������ڴ�),�ڴ��СΪsizeof(NET_PTZ_PRESET)*dwMaxPresetNum
} NET_PTZ_PRESET_LIST;

// �¼����� EVENT_IVS_TRAFFIC_RESTRICTED_PLATE (���޳����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_RESTRICTED_PLATE
{
    int                     nChannelID;                     // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];      // �¼�����
    int                     nTriggerType;                   // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD                   PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                            // �¼�������ʱ��
    int                     nEventID;                       // �¼�ID
    int                     nSequence;                      // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                    byEventAction;                  // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                    byImageIndex;                   // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                    byReserved1[2];
    int                     nLane;                          // ��Ӧ������
    DH_MSG_OBJECT           stuObject;                      // ��⵽������
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    DH_EVENT_FILE_INFO      stuFileInfo;                    // �¼���Ӧ�ļ���Ϣ
    int                     nMark;                          // �ײ�����Ĵ���ץ��֡���
    int                     nFrameSequence;                 // ��Ƶ����֡���
    int                     nSource;                        // ��Ƶ����������Դ��ַ
    DWORD                   dwSnapFlagMask;                 // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // ��ͨ������Ϣ
    NET_GPS_INFO            stuGPSInfo;                     // GPS��Ϣ ���ض���
    BYTE                    byReserved[984];                // �����ֽ�
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ
}DEV_EVENT_TRAFFIC_RESTRICTED_PLATE;

// �¼����� EVENT_IVS_TRAFFIC_OVERSTOPLINE (ѹͣ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_OVERSTOPLINE
{
    int                     nChannelID;                     // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];      // �¼�����
    int                     nTriggerType;                   // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD                   PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                            // �¼�������ʱ��
    int                     nEventID;                       // �¼�ID
    int                     nSequence;                      // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                    byEventAction;                  // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                    byImageIndex;                   // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                    byReserved1[2];
    int                     nLane;                          // ��Ӧ������
    DH_MSG_OBJECT           stuObject;                      // ��⵽������
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    DH_EVENT_FILE_INFO      stuFileInfo;                    // �¼���Ӧ�ļ���Ϣ
    int                     nMark;                          // �ײ�����Ĵ���ץ��֡���
    int                     nFrameSequence;                 // ��Ƶ����֡���
    int                     nSource;                        // ��Ƶ����������Դ��ַ
    DWORD                   dwSnapFlagMask;                 // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // ��ӦͼƬ�ķֱ���
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // ��ͨ������Ϣ
    int                     nSpeed;                         // ����ʵ���ٶ�,Km/h
    NET_GPS_INFO            stuGPSInfo;                     // GPS��Ϣ ���ض���
    BYTE                    byReserved[984];                // �����ֽ�
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ

}DEV_EVENT_TRAFFIC_OVERSTOPLINE;



// �¼�����EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(��ͨδϵ��ȫ���¼��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct  tagDEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT
{
    int                     nChannelID;                     // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];      // �¼�����
    int                     nTriggerType;                   // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD                   PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                            // �¼�������ʱ��
    int                     nEventID;                       // �¼�ID
    int                     nSequence;                      // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                    byEventAction;                  // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // �¼���Ӧ�ļ���Ϣ
    int                     nLane;                          // ��Ӧ������
    int                     nMark;                          // �ײ�����Ĵ���ץ��֡���
    int                     nFrameSequence;                 // ��Ƶ����֡���
    int                     nSource;                        // ��Ƶ����������Դ��ַ
    DH_MSG_OBJECT           stuObject;                      // ��⵽������
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // ��ͨ������Ϣ
    int                     nSpeed;                         // ����ʵ���ٶ�,Km/h
    NET_SAFEBELT_STATE      emMainSeat;                     // ����ʻ��λ��ȫ��״̬
    NET_SAFEBELT_STATE      emSlaveSeat;                    // ����ʻ��λ��ȫ��״̬
    DWORD                   dwSnapFlagMask;                 // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // ��ӦͼƬ�ķֱ���
    NET_GPS_INFO            stuGPSInfo;                     // GPS��Ϣ ���ض���
    BYTE                    byReserved[984];                // �����ֽ�
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ

}DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT;

// �¼�����EVENT_IVS_TRAFFIC_DRIVER_SMOKING (��ʻԱ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct  tagDEV_EVENT_TRAFFIC_DRIVER_SMOKING
{
    int                     nChannelID;                     // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];      // �¼�����
    int                     nTriggerType;                   // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD                   PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                            // �¼�������ʱ��
    int                     nEventID;                       // �¼�ID
    int                     nSequence;                      // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                    byEventAction;                  // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // �¼���Ӧ�ļ���Ϣ
    int                     nLane;                          // ��Ӧ������
    int                     nMark;                          // �ײ�����Ĵ���ץ��֡���
    int                     nFrameSequence;                 // ��Ƶ����֡���
    int                     nSource;                        // ��Ƶ����������Դ��ַ
    DH_MSG_OBJECT           stuObject;                      // ��⵽������
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // ��ͨ������Ϣ
    int                     nSpeed;                         // ����ʵ���ٶ�,Km/h
    DWORD                   dwSnapFlagMask;                 // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // ��ӦͼƬ�ķֱ���
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ    
    NET_GPS_INFO            stuGPSInfo;                     // GPS��Ϣ ���ض���
    BYTE                    byReserved[984];                // �����ֽ�
}DEV_EVENT_TRAFFIC_DRIVER_SMOKING;

// �¼�����EVENT_IVS_TRAFFIC_DRIVER_CALLING(��ʻԱ��绰�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct  tagDEV_EVENT_TRAFFIC_DRIVER_CALLING
{
    int                     nChannelID;                     // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];      // �¼�����
    int                     nTriggerType;                   // TriggerType:��������,0������,1�״�,2��Ƶ
    DWORD                   PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                            // �¼�������ʱ��
    int                     nEventID;                       // �¼�ID
    int                     nSequence;                      // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    BYTE                    byEventAction;                  // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // �¼���Ӧ�ļ���Ϣ
    int                     nLane;                          // ��Ӧ������
    int                     nMark;                          // �ײ�����Ĵ���ץ��֡���
    int                     nFrameSequence;                 // ��Ƶ����֡���
    int                     nSource;                        // ��Ƶ����������Դ��ַ
    DH_MSG_OBJECT           stuObject;                      // ��⵽������
    DH_MSG_OBJECT           stuVehicle;                     // ������Ϣ
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // ��ͨ������Ϣ
    int                     nSpeed;                         // ����ʵ���ٶ�,Km/h
    DWORD                   dwSnapFlagMask;                 // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // ��ӦͼƬ�ķֱ���
    EVENT_COMM_INFO         stCommInfo;                     // ������Ϣ
    NET_GPS_INFO            stuGPSInfo;                     // GPS��Ϣ ���ض���
    BYTE                    byReserved[984];                // �����ֽ�
}DEV_EVENT_TRAFFIC_DRIVER_CALLING;


// �¼�����EVENT_IVS_OBJECT_DETECTION(������������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct  tagDEV_EVENT_TRAFFIC_OBJECT_DETECTION
{
    int                 nChannelID;                         // ͨ����
    char                szName[128];                        // �¼�����
    char                bReserved1[4];                      // �ֽڶ���
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID
    DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ
    BYTE                bEventAction;                       // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byReserved[2];                      // �����ֽ�
    BYTE                byImageIndex;                       // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // �¼�Դ�豸�ϵ�index,-1��ʾ������Ч
    char                szSourceDevice[MAX_PATH];           // �¼�Դ�豸Ψһ��ʶ,�ֶβ����ڻ���Ϊ�ձ�ʾ�����豸
    unsigned int        nOccurrenceCount;                   // �¼������ۼƴ���

    int                 nObjectNum;          //������Ϣ��
    DH_MSG_OBJECT_EX   *pstObjectInfo;       //������Ϣ����  
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;  		// �����¼�������Ϣ
    BYTE                byReserved2[892];   //�����ֽ�
}DEV_EVENT_TRAFFIC_OBJECT_DETECTION;

// �����Դ�쳣����
typedef struct tagALARM_POWER_ABNORMAL_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ͨ����
    NET_TIME                stuTime;                        // ʱ��
    DWORD                   dwAction;                       // �¼�����, 0:Start, 1:Stop
}ALARM_POWER_ABNORMAL_INFO;

// ��̬ʹ��
typedef enum tagNET_THREE_STATE_ENABLE
{
    EM_STATE_ENABLE_INVALID = 0,            // ��Ч
    EM_STATE_ENABLE_OFF,                    // ��
    EM_STATE_ENABLE_ON,                     // ��
} NET_THREE_STATE_ENABLE;

// ����ʹ�ܸı��ϱ��¼�
typedef struct tagCONFIG_ENABLE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ͨ����, ��0��ʼ
    NET_THREE_STATE_ENABLE  emMotionDetect;                 // ����ʹ��,     0:��Ч, 1:ʹ�ܹر�, 2:ʹ�ܴ�
    NET_THREE_STATE_ENABLE  emLossDetect;                   // ��Ƶ��ʧʹ��, 0:��Ч, 1:ʹ�ܹر�, 2:ʹ�ܴ�
    NET_THREE_STATE_ENABLE  emBlindDetect;                  // ��Ƶ�ڵ�ʹ��, 0:��Ч, 1:ʹ�ܹر�, 2:ʹ�ܴ�
    NET_THREE_STATE_ENABLE  emAlarmLocal;                   // �ⲿ����ʹ��, 0:��Ч, 1:ʹ�ܹر�, 2:ʹ�ܴ�
}ALARM_CONFIG_ENABLE_CHANGE_INFO;

// ��������Υ������
typedef enum tagEM_ITC_HWS000_IT_TYPE
{
    EM_ITC_HWS000_IT_TYPE_UNKNOWN,      // δ֪
    EM_ITC_HWS000_IT_TYPE_HIGH_SPEED,   // ����
    EM_ITC_HWS000_IT_TYPE_LOW_SPEED,    // ����
}EM_ITC_HWS000_IT_TYPE;

// ���������״�״̬
typedef enum tagEM_ITC_HWS000_RS_TYPE
{
    EM_ITC_HWS000_RS_TYPE_UNKNOWN,      // δ֪
    EM_ITC_HWS000_RS_TYPE_ONLINE,       // ����
    EM_ITC_HWS000_RS_TYPE_OFFLINE,      // ����
}EM_ITC_HWS000_RS_TYPE;

// �������������״̬
typedef enum tagEM_ITC_HWS000_FS_TYPE
{
    EM_ITC_HWS000_FS_TYPE_UNKNOWN,     // δ֪
    EM_ITC_HWS000_FS_TYPE_ONLINE,      // ����
    EM_ITC_HWS000_FS_TYPE_OFFLINE,     // ����
}EM_ITC_HWS000_FS_TYPE;

// ���������豸�¼��뱨��
typedef struct tagALARM_ITC_HWS000
{
    DWORD dwSize;
    EM_ITC_HWS000_IT_TYPE emItType;   // Υ������
    EM_ITC_HWS000_RS_TYPE emRsType;   // �״�����״̬
    EM_ITC_HWS000_FS_TYPE emFsType;   // ���������״̬
    int nOcNum;                       // ���ټ���ֵ
    int nLcNum;                       // Ƿ�ټ���ֵ
    int nAcNum;                       // Υ���ܼ���ֵ
    int nFcNum;                       // �������˸����
}ALARM_ITC_HWS000;

// ����״̬ +-     
typedef enum tagEM_CAR_COME_STATUS       
{       
    EM_CAR_COME_STATUS_UNKNOWN,                            //δ֪       
    EM_CAR_COME_STATUS_COME_IN,                            //�볡       
    EM_CAR_COME_STATUS_COME_OUT,                           //����       
}EM_CAR_COME_STATUS;       
           
// �ֻ������ϱ��¼�       
typedef struct tagALARM_TELEPHONE_CHECK_INFO       
{       
    DWORD                       dwSize;       
    EM_CAR_COME_STATUS          emCarStatus;               //����״̬       
    char                        szTelephoneNum[32];        //�ֻ�����                          
}ALARM_TELEPHONE_CHECK_INFO; 

#define UPDATE_VERSION_LEN        64

// ��ȡ�豸����״̬��Ӧ�ṹ��
typedef struct tagDHDEV_UPGRADE_STATE_INFO
{
    int                  nState;                            // 0:None-û�м�⵽����, Ĭ��״̬; 1:Regular-һ������; 
                                                            // 2:Emergency-ǿ������; 3:Upgrading-������
    
    char                szOldVersion[UPDATE_VERSION_LEN];   // �ɰ汾
    char                szNewVersion[UPDATE_VERSION_LEN];   // �°汾
    DWORD               dwProgress;                         // ��������
    int                 reserved[256];                      // �����ֶ�
}DHDEV_UPGRADE_STATE_INFO;

// ���������ַ���
typedef enum tagNET_CROSSLINE_DIRECTION_INFO
{
    EM_CROSSLINE_DIRECTION_UNKNOW = 0 , 
    EM_CROSSLINE_DIRECTION_LEFT2RIGHT ,   //����
    EM_CROSSLINE_DIRECTION_RIGHT2LEFT ,   //�ҵ���
    EM_CROSSLINE_DIRECTION_ANY        ,   
}NET_CROSSLINE_DIRECTION_INFO;

// �������¼�(��Ӧ�¼� DH_EVENT_CROSSLINE_DETECTION)
typedef struct tagALARM_EVENT_CROSSLINE_INFO
{
    DWORD                           dwSize;                         
    int					            nChannelID;						// ͨ����
    double				            PTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            UTC;							// �¼�������ʱ��
    int					            nEventID;						// �¼�ID
    int                             nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    NET_CROSSLINE_DIRECTION_INFO    emCrossDirection;               // ���ַ���
    int                             nOccurrenceCount;               // ���򱻴���������
    int                             nLevel;                         // �¼�����,GB30147������
}ALARM_EVENT_CROSSLINE_INFO;

// �ƶ��¼�(��Ӧ�¼�DH_ALARM_MOVEDETECTION)
typedef struct tagALARM_MOVE_DETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int								nCount;							// ���򱻴����Ĵ���
	BYTE                			byReserved[1024];   			//�����ֽ�
} ALARM_MOVE_DETECTION_INFO;

// �ǻ��¼�(��Ӧ�¼�DH_ALARM_WANDERDETECTION)
typedef struct tagALARM_WANDERDETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int 							nCount;							// ���򱻴����Ĵ���
	int								nLevel;							// �¼�����,GB31047����
	short							nPreserID;						// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char							szPresetName[64];				// �¼�������Ԥ������
	BYTE                			byReserved[958];   				//�����ֽ�
} ALARM_WANDERDETECTION_INFO;

// ��ԽΧ���¼�(��Ӧ�¼�DH_ALARM_CROSSFENCEDETECTION)
typedef struct tagALARM_CROSSFENCEDETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_CROSSLINE_DIRECTION_INFO	emCrossDirection;               // ���ַ���
	int 							nCount;							// ���򱻴����Ĵ���
	BYTE                			byReserved[1024];   			//�����ֽ�
} ALARM_CROSSFENCEDETECTION_INFO;

// ������¼�(��Ӧ�¼� ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION)
typedef struct tagALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID
	BYTE                			byReserved[1024];   			//�����ֽ�
} ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO;

//��Ź�¼�(��Ӧ�¼�DH_ALARM_FIGHTDETECTION)
typedef struct tagNET_ALARM_FIGHTDETECTION
{	

	int                             nAction;                   		// �¼�����,0:��ʼ1:ֹͣ
	int					            nChannelID;						// ͨ���Ŵ�0��ʼ	
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)    
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��    
	BYTE                			byReserved[1024];   			//�����ֽ�
}NET_ALARM_FIGHTDETECTION;

#define VTO_BUILDING_LEN			8
#define VTO_UNIT_LEN				8

//VTO����ʶ���¼�(��Ӧ�¼�DH_ALARM_ACCESSIDENTIFY)
typedef struct tagNET_ALARM_ACCESSIDENTIFY_INFO
{	
    NET_TIME_EX			            stuTime;						 // �¼�������ʱ��    
	char 							szVTOBuilding[VTO_BUILDING_LEN]; // �����
	char 							szVTOUnit[VTO_UNIT_LEN];		 // ����Ԫ��
	BYTE                			byReserved[1024];   			 // �����ֽ�
}NET_ALARM_ACCESSIDENTIFY_INFO;

//ֱ������£�����޴�Ӧ�¼�(��Ӧ�¼�DH_ALARM_CALL_NO_ANSWERED)
typedef struct tagNET_ALARM_CALL_NO_ANSWERED_INFO
{
	NET_TIME_EX			            stuTime;						 // �¼�������ʱ��
	char 							szCallID[MAX_CALL_ID_LEN];		 // ���ID
	BYTE                			byReserved[1024];   			 // �����ֽ�
} NET_ALARM_CALL_NO_ANSWERED_INFO;

// �Ƿ�ͣ���¼�(��Ӧ�¼�DH_ALARM_PARKINGDETECTION)
typedef struct tagALARM_PARKINGDETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int 							nCount;							// ���򱻴����Ĵ���
	BYTE                			byReserved[1024];   			//�����ֽ�
} ALARM_PARKINGDETECTION_INFO;

// ��Ա�ۼ��¼�(��Ӧ�¼�DH_ALARM_RIOTERDETECTION)
typedef struct tagALARM_RIOTERDETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int 							nCount;							// ���򱻴����Ĵ���
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_RIOTERDETECTION_INFO;

// �¼����� DH_ALARM_TRAFFIC_PARKING(��ͨΥ��ͣ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_PARKING_INFO 
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_PARKING_INFO;


// �¼�����DH_ALARM_TRAFFIC_JAM(��ͨӵ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_JAM_INFO 
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_JAM_INFO;

//�¼����� DH_ALARM_TRAFFIC_PEDESTRAIN(��ͨ�����¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_PEDESTRAIN_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_PEDESTRAIN_INFO;

//�¼����� DH_ALARM_TRAFFIC_THROW(��ͨ������Ʒ�¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_THROW_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_THROW_INFO;

//�¼�����DH_ALARM_TRAFFIC_RETROGRADE(��ͨ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_RETROGRADE_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_RETROGRADE_INFO;

//�¼�����DH_ALARM_TRAFFIC_OVERSPEED(��ͨ�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_OVERSPEED_INFO 
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int								nSpeed;							// ����
	int								nSpeedUpperLimit;				// �ٶ�����
	int								nSpeedLowerLimit;				// �ٶ�����
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_OVERSPEED_INFO;

//�¼�����DH_ALARM_TRAFFIC_UNDERSPEED(��ͨǷ���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_UNDERSPEED_INFO 
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int								nSpeed;							// ����
	int								nSpeedUpperLimit;				// �ٶ�����
	int								nSpeedLowerLimit;				// �ٶ�����
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_TRAFFIC_UNDERSPEED_INFO;

//�¼�����DH_ALARM_RETROGRADE_DETECTION(��Ա�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_RETROGRADE_DETECTION_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID
	int 							nCount;							// ���򱻴����Ĵ���
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_RETROGRADE_DETECTION_INFO;

// AIO�����¼�(��Ӧ�¼�DH_ALARM_AIO_APP_CONFIG_EVENT)
typedef struct tagALARM_AIO_APP_CONFIG_EVENT_INFO
{
	NET_TIME_EX			            stuTime;							// �¼�������ʱ��
	char 							szAddress[DH_MAX_IPADDR_LEN];		// ����ƽ̨�ĵ�ip��ַ
	BYTE                			byReserved[1024];   				// �����ֽ�
}ALARM_AIO_APP_CONFIG_EVENT_INFO;


//�¼�����DH_ALARM_BOX(�������ӱ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_BOX_INFO
{
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	int 							nAlarmBoxIndex;					// ��Ӷ��������ʱ����ʾ��������š���0��ʼ
	int								nAlarmIndex;					// �������ڲ���ͨ���ţ���0��ʼ
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_BOX_INFO;

// �¼����� DH_ALARM_UNDER_VOLTAGE (�͵�ѹ�����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_UNDER_VOLTAGE_INFO
{
	int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID
    BYTE                			byReserved[512];       			// �����ֽ�
}ALARM_UNDER_VOLTAGE_INFO;

// �¼����� DH_ALARM_OVER_VOLTAGE (����ѹ�����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_OVER_VOLTAGE_INFO
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID
    BYTE                			byReserved[512];       			// �����ֽ�    
}ALARM_OVER_VOLTAGE_INFO;

// �¼����� DH_ALARM_TIRED_PHYSIOLOGICAL (����ƣ���¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TIRED_PHYSIOLOGICAL
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TIRED_PHYSIOLOGICAL;


// �¼����� DH_ALARM_CALLING_WHEN_DRIVING (������绰�¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_CALLING_WHEN_DRIVING
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_CALLING_WHEN_DRIVING;


// �¼����� DH_ALARM_TRAFFIC_DRIVER_SMOKING (���������¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_DRIVER_SMOKING
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TRAFFIC_DRIVER_SMOKING;


// �¼����� DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD (������ͷ�����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_DRIVER_LOWER_HEAD
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TRAFFIC_DRIVER_LOWER_HEAD;


// �¼����� DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND (����������α����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_DRIVER_LOOK_AROUND
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TRAFFIC_DRIVER_LOOK_AROUND;


// �¼����� DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST (������ڱ����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_DRIVER_LEAVE_POST
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TRAFFIC_DRIVER_LEAVE_POST;


// �¼����� DH_ALARM_TRAFFIC_DRIVER_YAWN (�������Ƿ�����¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_TRAFFIC_DRIVER_YAWN
{
    int                             nAction;                   		// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS��Ϣ
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_TRAFFIC_DRIVER_YAWN;

// ����λ�ñ����¼�(DH_ALARM_TRAFFIC_VEHICLE_POSITION)
typedef struct tagALARM_TRAFFIC_VEHICLE_POSITION
{
	int             nAction;                   						// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	char			szEventName[DH_COMMON_STRING_128];				// �¼�����
	unsigned int	nObjectID;										// ����ID
	char			szPlateNumber[DH_COMMON_STRING_128];									// ���ƺ�
	int				nPosition;										// ʶ�����뿨��ץ���ߵ���Ծ���(0Ϊ��׼����ʾ��Ƶץ�Ŀ���λ��ʱ�ĳ��ƾ��룻������ʾԽ��ץ���ߣ�������ʾδԽ��ץ����)
	BYTE			byReserved[512];       							// �����ֽ�  
} ALARM_TRAFFIC_VEHICLE_POSITION;

// �¼����� DH_ALARM_MPTBASE_CONNECT (�豸���������״̬�¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_MPTBASE_CONNECT
{
    int                             nAction;                        // �¼�����, 1 ��ʾ�������¼���ʼ, 2 ��ʾ�������¼�����
    BYTE                            byReserved[512];                // �����ֽ� 
} ALARM_MPTBASE_CONNECT;

// �ػ�ԭ��
typedef enum tagEM_SHUTDOWN_REASON_TYPE
{
    EM_SHUTDOWN_REASON_UNKNOWN,                 // δ֪
    EM_SHUTDOWN_REASON_LOWERPOWER,              // �͵���
    EM_SHUTDOWN_REASON_LOSTPOWER,               // ͻȻ���
    EM_SHUTDOWN_REASON_CRASH,                   // ϵͳ����
} EM_SHUTDOWN_REASON_TYPE;

// �¼�����DH_ALARM_LATEST_SHUTDOWN (�豸�ϴιػ�״̬�¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_LATEST_SHUTDOWN
{
	EM_SHUTDOWN_REASON_TYPE			emShutdownReason;				// �ػ�ԭ��		
	BYTE                			byReserved[512];       			// �����ֽ� 
} ALARM_LATEST_SHUTDOWN;

// �¼����� DH_ALARM_AUTO_INSPECTION (�豸�Լ��¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_AUTO_INSPECTION
{
	double				            dbPTS;							// ʱ���(��λ�Ǻ���)
	NET_TIME_EX			            stuTime;						// �¼�������ʱ��
	int					            nEventID;						// �¼�ID

	NET_TIME_EX						stuStartTime;					// �豸��ʼ�Լ�ʱ��
	BOOL							bCheckResult;					// �豸�Լ���,FALSEΪʧ��,TRUEΪ�ɹ�
	BYTE							byReserved[1024];				// �����ֽ�
}ALARM_AUTO_INSPECTION;

// �¼�����
typedef enum tagEM_FACE_VERIFICATION_ACCESS_SNAP_TYPE
{
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_UNKNOWN,			// δ֪����
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_ENTRY,			// ����
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_EXIT,				// ����
}EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE;

// ������Ϣ
typedef struct tagNET_PERSON_INFO
{
	BOOL			bCheckResult;					// �����ȶԽ��,�ɹ�ΪTRUE,ʧ��ΪFALSE
	char			szName[MAX_NAME_LENGTH];			// ����,�ȶԳɹ�ʱ��Ч
	char			szSnapURL[MAX_SNAP_URL_LEN];    // ����ץͼ��ַ
	BYTE			byReserved[512];				// �����ֽ�
}NET_PERSON_INFO;

// ��Ʒ��Ϣ
typedef struct tagNET_GOOD_INFO
{
	char			szCode[MAX_CODE_LEN];			    // ��Ʒ���
	char			szSnapURL[MAX_SNAP_URL_LEN];		// ��Ʒץͼ��ַ
	BYTE			byReserved[512];				    // �����ֽ�
}NET_GOOD_INFO;

// ��������
typedef enum tagEM_OPERATION_TYPE
{
	EM_OPERATION_TYPE_UNKNOWN,					// δ֪����
	EM_OPERATION_TYPE_FETCH,                    // ȡ��Ʒ
	EM_OPERATION_TYPE_STORE,					// ����Ʒ
	EM_OPERATION_TYPE_EXCHANGE,					// ����Ʒ
	EM_OPERATION_TYPE_CHECK,					// ���					
}EM_OPERATION_TYPE;

// �¼����� DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP��������֤����ץͼ��Ϣ�¼�����Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO
{
	double										dbPTS;									// ʱ���(��λ�Ǻ���)
	NET_TIME_EX									stuTime;								// �¼�������ʱ��
	int											nEventID;								// �¼�ID

	int											nRecNo;									// ��¼��ţ���AccessControl�¼��еļ�¼���һ�� 	
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE       emEventType;							// �¼�����
	NET_PERSON_INFO								stuPersonInfo[MAX_PERSON_INFO_NUM];		// ������Ϣ
	int											nRetPersonInfoNum;						// ���ص�������Ϣ����
	NET_GOOD_INFO								stuGoodInfo[MAX_GOOD_INFO_NUM];			// ��Ʒ��Ϣ
	int											nRetGoodInfoNum;						// ���ص���Ʒ��Ϣ����
	EM_OPERATION_TYPE							emOperation;							// ��������
	BYTE										byReserved[1020];						// �����ֽ�
}ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO;

// �¼�����DH_ALARM_VIDEOBLIND(��Ƶ�ڵ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct  tagALARM_VIDEO_BLIND_INFO
{
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						// ͨ����
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    int					            nEventID;						// �¼�ID

    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_VIDEO_BLIND_INFO;

// �¼�����DH_ALARM_DRIVER_NOTCONFIRM (˾��δ��ȷ�ϰ�ť�����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_DRIVER_NOTCONFIRM_INFO
{
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
	double				            dbPTS;							// ʱ���(��λ�Ǻ���)
    BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_DRIVER_NOTCONFIRM_INFO;

// �¼����� DH_ALARM_VIOLATE_NO_FLY_TIME (Υ�������¼�) ��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_VIOLATE_NO_FLY_TIME_INFO
{   
    int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
    double				            dbPTS;							// ʱ���(��λ�Ǻ���)

    BYTE                			byReserved[512];       			// �����ֽ�  
}ALARM_VIOLATE_NO_FLY_TIME_INFO;

//�¼����� DH_ALARM_BOX_ALARM (������ͨ���Ĵ��������¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_BOX_ALARM_INFO
{
    int                             nAction;                   		    // �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    int					            nChannelID;						    // ͨ����
    double				            dbPTS;							    // ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;						    // �¼�������ʱ��
    int					            nEventID;						    // �¼�ID
    

    char                            szAlarmChannelName[DH_COMMON_STRING_64];   // ����ͨ������
    BYTE                			byReserved[1024];   			    // �����ֽ�
}ALARM_BOX_ALARM_INFO;


// �¼�����DH_ALARM_FACEINFO_COLLECT (������Ϣ¼���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_FACEINFO_COLLECT_INFO
{
	
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
	double				            dbPTS;							// ʱ���(��λ�Ǻ���)
	char							szUserID[DH_MAX_USERID_LEN];	// �û�ID
	BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_FACEINFO_COLLECT_INFO;

// �¼�����DH_ALARM_HIGH_SPEED (�������ٱ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_HIGH_SPEED_INFO
{
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    NET_TIME_EX			            stuTime;						// �¼�������ʱ��
	double				            dbPTS;							// ʱ���(��λ�Ǻ���)	
    NET_GPS_STATUS_INFO 			stGPSStatusInfo;                // GPS��Ϣ
	int								nSpeedLimit;					// ��������ֵkm/h
	int								nCurSpeed;						// ��ǰ�����ٶ�km/h
	BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_HIGH_SPEED_INFO;

// �¼�����DH_ALARM_VIDEO_LOSS (��Ƶ��ʧ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_VIDEO_LOSS_INFO
{
	int                             nAction;                   		// �¼�����,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;						// ͨ����
	double				            dbPTS;							// ʱ���(��λ�Ǻ���)	
	BYTE							byReserved1[4];					// �ֽڶ���
	NET_TIME_EX			            stuTime;						// �¼�������ʱ��
	BYTE                			byReserved[512];       			// �����ֽ�    
} ALARM_VIDEO_LOSS_INFO;

#define  VTS_STATE_LONGNUMBER_LEN	24
// VTS
typedef enum tagVTS_STATE
{
    EM_VTS_STATE_UNKNOWN = 0	, 
	EM_VTS_STATE_BUSY			,								// "Busy" æµ
	EM_VTS_STATE_IDLE			,								// "Idle" ����
}VTS_STATE;

// VTS״̬�ϱ�
typedef struct tagALARM_VTSTATE_UPDATE_INFO
{
	int					            nChannelID;						// ͨ����
    NET_TIME			            stuTime;						// �¼�������ʱ��
	VTS_STATE						emState;						// �豸�Խ�״̬
	char							szLongNum[VTS_STATE_LONGNUMBER_LEN];	// ����
	BYTE                			byReserved[1024];   			// �����ֽ�
} ALARM_VTSTATE_UPDATE_INFO;

// �¼�����DH_ALARM_VIDEO_TALK_PATH(�Խ�·���¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagALARM_VIDEO_TALK_PATH_INFO
{
	int                             nAction;                   			// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	int					            nChannelID;							// ͨ����
	double				            dbPTS;								// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            stuTime;							// �¼�������ʱ��
	char							szSrcDevID[DH_COMMON_STRING_128];	// ���Դ�豸ΨһID(IDȡֵ����DevList����)
	char							szDstDevID[DH_COMMON_STRING_128];	// ���Ŀ���豸ΨһID(IDȡֵ����DevList����)
	BYTE                			byReserved[1024];   				// �����ֽ�							
} ALARM_VIDEO_TALK_PATH_INFO;


// ���������ַ���
typedef enum tagNET_CROSSREGION_DIRECTION_INFO
{
    EM_CROSSREGION_DIRECTION_UNKNOW = 0 , 
    EM_CROSSREGION_DIRECTION_ENTER      ,   //����
    EM_CROSSREGION_DIRECTION_LEAVE      ,   //�뿪
    EM_CROSSREGION_DIRECTION_APPEAR     ,   //����
    EM_CROSSREGION_DIRECTION_DISAPPEAR  ,   //��ʧ
}NET_CROSSREGION_DIRECTION_INFO;



//�������¼�(��Ӧ�¼� DH_EVENT_CROSSREGION_DETECTION)
typedef struct tagALARM_EVENT_CROSSREGION_INFO
{
    DWORD                           dwSize;    
    int					            nChannelID;						// ͨ����
    double				            PTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			            UTC;							// �¼�������ʱ��
	int					            nEventID;						// �¼�ID
    int                             nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    NET_CROSSREGION_DIRECTION_INFO  emDirection;                    // ���������ַ���
    NET_CROSSREGION_ACTION_INFO     emActionType;                   // ��������⶯������
    int                             nOccurrenceCount;               // ���򱻴���������
    int                             nLevel;                         // �¼�����,GB30147������
}ALARM_EVENT_CROSSREGION_INFO;


//��Ʒ�����¼�(��Ӧ�¼� DH_EVENT_LEFT_DETECTION)
typedef struct tagALARM_EVENT_LEFT_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// ͨ����
    double				PTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			UTC;							// �¼�������ʱ��
    int					nEventID;						// �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    
    int                 nOccurrenceCount;               // ���򱻴���������
    int                 nLevel;                         // �¼�����,GB30147������
	short				nPreserID;						// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char				szPresetName[64];				// �¼�������Ԥ������
}ALARM_EVENT_LEFT_INFO;

//��������¼�(��Ӧ�¼� DH_EVENT_FACE_DETECTION)
typedef struct tagALARM_EVENT_FACE_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// ͨ����
    double				PTS;							// ʱ���(��λ�Ǻ���)
    NET_TIME_EX			UTC;							// �¼�������ʱ��
    int					nEventID;						// �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
}ALARM_EVENT_FACE_INFO;

   
//IPC����,IPCͨ��DVR��NVR�ϱ��ı��ر���(��Ӧ�¼� DH_ALARM_IPC)
typedef struct tagALARM_IPC_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// ͨ����
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
}ALARM_IPC_INFO;

///////////////////////////////// ��¼�Ự /////////////////////////////////////////

// CLIENT_StartBurnSession �ӿ��������
typedef struct tagNET_IN_START_BURN_SESSION 
{
    DWORD               dwSize;
    unsigned int        nSessionID;                         // �ỰID
} NET_IN_START_BURN_SESSION;

typedef struct tagNET_OUT_START_BURN_SESSION 
{
    DWORD               dwSize;
} NET_OUT_START_BURN_SESSION;

// ��¼ģʽ
typedef enum tagNET_BURN_MODE
{
    BURN_MODE_SYNC,                     // ͬ��
    BURN_MODE_TURN,                     // ����
    BURN_MODE_CYCLE,                    // ѭ��
} NET_BURN_MODE;

// ��¼��չģʽ
typedef enum tagNET_BURN_EXTMODE
{
	BURN_EXTMODE_UNKNOWN,					 // δ֪
    BURN_EXTMODE_NORMAL = 1,                 // ������¼
    BURN_EXTMODE_NODISK,                     // ���̿�¼
} NET_BURN_EXTMODE;

// ��¼����ʽ
typedef enum tagNET_BURN_RECORD_PACK
{
    BURN_PACK_DHAV,                     // DHAV
    BURN_PACK_PS,                       // PS
    BURN_PACK_ASF,                      // ASF
    BURN_PACK_MP4,                      // MP4
    BURN_PACK_TS,                       // TS
} NET_BURN_RECORD_PACK;

// CLIENT_StartBurn �ӿ��������
typedef struct tagNET_IN_START_BURN 
{
    DWORD                dwSize;
    DWORD                dwDevMask;                             // ��¼�豸����, ��λ��ʾ�����¼�豸���
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // ��¼ͨ������
    int                  nChannelCount;                         // ��¼ͨ����
    NET_BURN_MODE        emMode;                                // ��¼ģʽ
    NET_BURN_RECORD_PACK emPack;                                // ��¼����ʽ
    NET_BURN_EXTMODE     emExtMode;                             // ��¼��չģʽ
} NET_IN_START_BURN;

// CLIENT_StartBurn �ӿ��������
typedef struct tagNET_OUT_START_BURN 
{
    DWORD               dwSize;
} NET_OUT_START_BURN;

// CLIENT_BurnMarkTag �ӿ��������
typedef struct tagNET_IN_BURN_MAAK_TAG
{
    DWORD               dwSize;
    const char*         pszDescInfo;                            // ���������Ϣ
} NET_IN_BURN_MARK_TAG;

// CLIENT_BurnMarkTag �ӿ��������
typedef struct tagNET_OUT_BURN_MAAK_TAG
{
    DWORD               dwSize;
} NET_OUT_BURN_MARK_TAG;

// CLIENT_BurnChangeDisk �ӿ��������
typedef struct tagNET_IN_BURN_CHANGE_DISK
{
    DWORD               dwSize;
    BOOL                nAction;                                // ���̶���, 0-��ʼ, 1-����
} NET_IN_BURN_CHANGE_DISK;

// CLIENT_BurnChangeDisk �ӿ��������
typedef struct tagNET_OUT_BURN_CHANGE_DISK
{
    DWORD               dwSize;
} NET_OUT_BURN_CHANGE_DISK;

// ��¼״̬
typedef enum tagNET_BURN_STATE
{
    BURN_STATE_STOP,                    // ֹͣ
    BURN_STATE_STOPING,                 // ֹͣ��
    BURN_STATE_INIT,                    // ��ʼ��
    BURN_STATE_BURNING,                 // ��¼��
    BURN_STATE_PAUSE,                   // ��ͣ
    BURN_STATE_CHANGE_DISK,             // ������
    BURN_STATE_PREPARE_EXTRA_FILE,      // ������ʼ��
    BURN_STATE_WAIT_EXTRA_FILE,         // �ȴ�������¼
    BURN_STATE_UPLOAD_FILE_START,       // ������¼��
    BURN_STATE_CHECKING_DISK,           // ��������
    BURN_STATE_DISK_READY,              // ����׼������
} NET_BURN_STATE;

// ��¼������
typedef enum tagNET_BURN_ERROR_CODE
{
    BURN_CODE_NORMAL,                   // ����
    BURN_CODE_UNKNOWN_ERROR,            // δ֪����
    BURN_CODE_SPACE_FULL,               // ��¼��
    BURN_CODE_START_ERROR,              // ��ʼ��¼����
    BURN_CODE_STOP_ERROR,               // ֹͣ��¼����
    BURN_CODE_WRITE_ERROR,              // ��¼����
	BURN_CODE_UNKNOWN,					// δ֪
} NET_BURN_ERROR_CODE;

// CLIENT_BurnGetState �ӿ��������
typedef struct tagNET_IN_BURN_GET_STATE
{
    DWORD                dwSize;
} NET_IN_BURN_GET_STATE;

// ����ʹ��״̬
typedef enum tagEM_NET_BURN_DEV_USED_STATE
{
	EM_NET_BURN_DEV_USED_STATE_UNKNOWN, //δ֪
	EM_NET_BURN_DEV_USED_STATE_STOP,	//ֹͣ
	EM_NET_BURN_DEV_USED_STATE_BURNING,	//��¼��
}EM_NET_BURN_DEV_USED_STATE;

// ��¼�豸״̬
typedef struct tagNET_BURN_DEV_STATE 
{
    DWORD                dwSize;
    int                  nDeviceID;                             // �����豸ID
    char                 szDevName[DH_BURNING_DEV_NAMELEN];     // �����豸����
    DWORD                dwTotalSpace;                          // ����������, ��λKB
    DWORD                dwRemainSpace;                         // ����ʣ������, ��λKB
	EM_NET_BURN_DEV_USED_STATE	            emUsedType;			// ����ʹ��״̬
	NET_BURN_ERROR_CODE						emError;			// ������������״̬
} NET_BURN_DEV_STATE;

// CLIENT_BurnGetState �ӿ��������
typedef struct tagNET_OUT_BURN_GET_STATE
{
    DWORD                dwSize;
    NET_BURN_STATE       emState;                               // ��¼״̬
    NET_BURN_ERROR_CODE  emErrorCode;                           // ������
    DWORD                dwDevMask;                             // ��¼�豸����, ��λ��ʾ�����¼�豸���
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // ��¼ͨ������
    int                  nChannelCount;                         // ��¼ͨ����
    NET_BURN_MODE        emMode;                                // ��¼ģʽ
    NET_BURN_RECORD_PACK emPack;                                // ��¼����ʽ
    int                  nFileIndex;                            // ��ǰ��¼�ļ����
    NET_TIME             stuStartTime;                          // ��¼��ʼʱ��
    NET_BURN_DEV_STATE   stuDevState[DH_MAX_BURNING_DEV_NUM];   // ��¼�豸״̬
    int                  nRemainTime;                           // ��¼ʣ��ʱ��, ��λ��, -1������Ч
	NET_BURN_EXTMODE	 emExtMode;								// ��չģʽ,��Ϊ���̿�¼ʱ��stuDevState������Ч
} NET_OUT_BURN_GET_STATE;

// fAttachBurnStateCB ����
typedef struct tagNET_CB_BURNSTATE
{
    DWORD               dwSize;
    const char*         szState;                        // ��Ϣ����
                                                        //"UploadFileStart"�����Կ�ʼ�����ϴ�
                                                        //"InitBurnDevice":��ʼ����¼�豸
                                                        //"Burning":��¼��
                                                        //"BurnExtraFileStop"����¼ֹͣ
                                                        //"BurnFilePause":��¼��ͣ
                                                        //"SpaceFull":��¼�ռ���
                                                        //"BurnFileError":��¼����    
    const char*         szFileName;                     // ��ǰ��¼�����ļ���,����"UploadFileStart"��ʼ�����ϴ���Ϣ
    unsigned int        dwTotalSpace;                   // ������,��λKB,����"Burning"��¼��,��ʾ������������
    unsigned int        dwRemainSpace;                  // ʣ������,��λKB,����"Burning"��¼��
    const char*         szDeviceName;                   // ��¼�豸����,�������ֲ�ͬ�Ŀ�¼�豸
    int                 nRemainTime;                    // ��¼ʣ��ʱ��, ��λ��, -1������Ч
}NET_CB_BURNSTATE;

// ��¼�豸�ص�����ԭ��,lAttachHandle��CLIENT_AttachBurnState����ֵ, ÿ��1��,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachBurnStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURNSTATE* pBuf, int nBufLen, LDWORD dwUser);

// ��¼�豸�ص���չ����ԭ��
typedef void (CALLBACK *fAttachBurnStateCBEx)(LLONG lLoginID, LLONG lAttachHandle, NET_OUT_BURN_GET_STATE* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBurnState()�������
typedef struct tagNET_IN_ATTACH_STATE
{
    DWORD                   dwSize;
    const char*             szDeviceName;                   // ��������,��"/dev/sda"
    fAttachBurnStateCB      cbAttachState;                  // ��¼�����ص�
    LDWORD                  dwUser;                         // �û�����
    LLONG                   lBurnSession;                   // ��¼�Ự���, CLIENT_StartBurnSession�ķ���ֵ. ��ֵΪ0ʱ, szDeviceName��Ч, ��ʱ����¼�豸���Ŀ�¼״̬
    fAttachBurnStateCBEx    cbAttachStateEx;                // ��չ��¼�����ص�
    LDWORD                  dwUserEx;                       // ��չ��¼�����ص��û�����
}NET_IN_ATTACH_STATE;

// CLIENT_AttachBurnState �������
typedef struct tagNET_OUT_ATTACH_STATE
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_STATE;

// ��¼�豸�ص�����ԭ��,lUploadHandle��CLIENT_StartUploadFileBurned����ֵ
typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);

// CLIENT_StartUploadFileBurned()�������
typedef struct tagNET_IN_FILEBURNED_START
{
    DWORD                   dwSize;
    const char*             szMode;                         // �ļ��ϴ���ʽ
                                                            // "append", ׷��ģʽ,��ʱ��¼�ļ����̶�Ϊ" FILE.zip ",filename������
                                                            // "evidence", ֤�ݵȴ󸽼�, Ҫ�󵥶���¼�Ĺ�����
    const char*             szDeviceName;                   // ��������,�硰/dev/sda��
    const char*             szFilename;                     // �����ļ�����
    fBurnFileCallBack       cbBurnPos;                      // ��¼���Ȼص�
    LDWORD                  dwUser;                         // �û�����
    LLONG                   lBurnSession;                   // ��¼���, CLIENT_StartBurnSession�ķ���ֵ. ��ֵΪ0ʱ, szDeviceName��Ч, ��ʱ����¼�豸���Ŀ�¼״̬
}NET_IN_FILEBURNED_START;

// CLIENT_StartUploadFileBurned �������
typedef struct tagNET_OUT_FILEBURNED_START
{
    DWORD                   dwSize;
    char                    szState[DH_MAX_NAME_LEN];      // "start"��ϵͳ׼������,���Կ�ʼ�ϴ�; "busy"��ϵͳæ,�Ժ����ԡ�"error"��ϵͳδ�ڿ�¼��,���س���,����ʧ��
}NET_OUT_FILEBURNED_START;

// ��¼������Ϣ
typedef struct tagNET_BURN_CASE_INFO
{
    DWORD       dwSize;
    int         nChannel;                                   // ͨ����
    NET_TIME    stuStartTime;                               // ��¼��ʼʱ��
    NET_TIME    stuEndTime;                                 // ��¼����ʱ��
    int         nIndex;                                     // ���
    int         nCode;                                      // ���
    int         nDiscNum;                                   // ���̱��        
    char        szName[DH_COMMON_STRING_128];               // ����
    char        szPlace[DH_COMMON_STRING_128];              // �참�ص�
    char        szInvestigator[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32]; // �참��Ա
    char        szSuspects[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32];     // �永��Ա
    char        szMemo[DH_COMMON_STRING_256];               // ��ע
    char        szVideoName[DH_COMMON_STRING_128];          // ¼������
    char        szRecorder[DH_COMMON_STRING_32];            // ��¼��
} NET_BURN_CASE_INFO;

// ��¼�豸�ص�����ԭ��,lAttachHandle��CLIENT_AttachBurnCase����ֵ
typedef void (CALLBACK *fBurnCaseCallBack) (LLONG lAttachHandle, NET_BURN_CASE_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnCase �ӿ��������
typedef struct tagNET_IN_ATTACH_BURN_CASE
{
    DWORD                dwSize;
    fBurnCaseCallBack    cbBurnCase;                        // ������Ϣ�ص�����
    LDWORD               dwUser;                            // �û�����
} NET_IN_ATTACH_BURN_CASE;

// CLIENT_AttachBurnCase �ӿ��������
typedef struct tagNET_OUT_ATTACH_BURN_CASE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_CASE;

// ��¼�豸��������
typedef enum tagEM_NET_BURN_DEV_BUS_TYPE
{
    EM_NET_BURN_DEV_BUS_TYPE_UNKNOWN,   // δ֪
    EM_NET_BURN_DEV_BUS_TYPE_IDE,       // IDE
    EM_NET_BURN_DEV_BUS_TYPE_USB,       // USB
    EM_NET_BURN_DEV_BUS_TYPE_1394,      // 1394
    EM_NET_BURN_DEV_BUS_TYPE_SATA,      // SATA
    EM_NET_BURN_DEV_BUS_TYPE_ESATA,     // ESATA
}EM_NET_BURN_DEV_BUS_TYPE;

// ��¼�豸��������
typedef enum tagEM_NET_BURN_DEV_BK_TYPE
{
    EM_NET_BURN_DEV_BK_TYPE_UNKNOWN,    // δ֪
    EM_NET_BURN_DEV_BK_TYPE_DHFS,       // ���ļ�ϵͳ
    EM_NET_BURN_DEV_BK_TYPE_DISK,       // �ƶ�Ӳ��
    EM_NET_BURN_DEV_BK_TYPE_CDRW,       // ���̿�¼
}EM_NET_BURN_DEV_BK_TYPE;

// ��¼�豸״̬��Ϣ
typedef struct tagNET_BURN_DEV_STATE_INFO
{
    char            szName[DH_COMMON_STRING_256];               // ��¼�豸����
    unsigned int    nTotalSpace;                                // ��������������λKB
    unsigned int    nFreeSpace;                                 // ����ʣ����������λKB
    EM_NET_BURN_DEV_TRAY_TYPE        emTrayType;                // ��������״̬
    EM_NET_BURN_DEV_OPERATE_TYPE     emOperateType;             // ����ʹ��״̬
    EM_NET_BURN_DEV_BUS_TYPE         emBusType;                 // ��¼�豸��������
    EM_NET_BURN_DEV_BK_TYPE          emBkType;                  // ��¼�豸��������
} NET_BURN_DEV_STATE_INFO;

// ��¼�豸״̬��Ϣ�б�
typedef struct tagNET_BURN_DEV_STATE_INFO_LIST
{
    unsigned int    nListCount; // �б���Ч��¼�豸״̬��Ϣ�������� pstuNetBurnDevStateInfo ���ʹ��
    NET_BURN_DEV_STATE_INFO *pstuNetBurnDevStateInfo;   // ��¼�豸״̬��Ϣָ�룬�� nListCount ���ʹ��
}NET_BURN_DEV_STATE_INFO_LIST;
// ��¼�豸״̬�ص�����ԭ��,lAttachHandle �� CLIENT_AttachBurnDevState ����ֵ
typedef void (CALLBACK *fBurnDevStateCallBack) (LLONG lAttachHandle, const NET_BURN_DEV_STATE_INFO_LIST* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnDevState �ӿ��������
typedef struct tagNET_IN_ATTACH_BURN_DEV_STATE
{
    DWORD                       dwSize;
    fBurnDevStateCallBack       cbBurnDevState;             // ��¼�豸״̬�ص�����
    LDWORD                      dwUser;                     // �û�����
} NET_IN_ATTACH_BURN_DEV_STATE;

// CLIENT_AttachBurnDevState �ӿ��������
typedef struct tagNET_OUT_ATTACH_BURN_DEV_STATE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_DEV_STATE;

/////////////////////////////////// �����Զ�����ϵͳ����¼�� ///////////////////////////////////////

#define CASE_BACK_UP_CHANNEL_MAX_NUM        32  // ������¼ͨ�������Ŀ
#define CASE_BACK_UP_FILE_TYPE_MAX_NUM      8   // ������¼�ļ����������Ŀ
#define CASE_BACK_UP_INQUEST_INFO_MAX_NUM   8   // ������¼��Ѷ��Ϣ����ѯ��Ŀ
#define CASE_BACK_UP_DEVICE_MAX_NUM         8   // ������¼����豸��Ŀ

// ������¼�ļ�����
typedef enum tagEM_CASE_BACK_UP_FILE_TYPE
{
    EM_CASE_BACK_UP_FILE_TYPE_UNKNOWN,          // δ֪
    EM_CASE_BACK_UP_FILE_TYPE_DAV,              // DAV
    EM_CASE_BACK_UP_FILE_TYPE_JPG,              // JPG
    EM_CASE_BACK_UP_FILE_TYPE_TXT,              // TXT
}EM_CASE_BACK_UP_FILE_TYPE;

// ������¼��������
typedef enum tagEM_CASE_BACK_UP_MODE_TYPE
{
    EM_CASE_BACK_UP_MODE_TYPE_UNKNOWN,          // δ֪��
    EM_CASE_BACK_UP_MODE_TYPE_SYNC,             // ͬ����¼���� ���̱�����ͬ����
    EM_CASE_BACK_UP_MODE_TYPE_CYCLE,            // ѭ����¼���� ͨ������������������ݵı���
}EM_CASE_BACK_UP_MODE_TYPE;

// ��Ƶ�ļ����ݸ�ʽ
typedef enum tagEM_CASE_BACK_UP_PACK_TYPE
{
    EM_CASE_BACK_UP_PACK_TYPE_UNKNOWN,          // δ֪��
    EM_CASE_BACK_UP_PACK_TYPE_DHAV,             // DHAV
    EM_CASE_BACK_UP_PACK_TYPE_MP4,              // MP4
    EM_CASE_BACK_UP_PACK_TYPE_PS,               // PS   
}EM_CASE_BACK_UP_PACK_TYPE;

// ������¼���ݲ�ѯ��Ϣ
typedef struct tagNET_CASE_BACK_UP_INQUEST_INFO
{
    char szTitle[128];                          // �ֶα���
    char szText[128];                           // �ֶ�����
    BYTE byReserved[512];                       // �����ֽ�
}NET_CASE_BACK_UP_INQUEST_INFO;

// �������ݿ�¼��ѯ����
typedef struct tagNET_CASE_BACK_UP_QUERY_CONDITION
{
    int                             nChannelNum;                                        // ��ѯͨ����Ŀ                            
    int                             nChannels[CASE_BACK_UP_CHANNEL_MAX_NUM];            // ��ѯͨ������
    NET_TIME                        stuStartTime;                                       // ��ʼʱ��
    NET_TIME                        stuEndTime;                                         // ����ʱ��
    int                             nFileTypeNum;                                       // �ļ�������Ŀ
    EM_CASE_BACK_UP_FILE_TYPE       emFileTypes[CASE_BACK_UP_FILE_TYPE_MAX_NUM];        // �ļ���������
    char                            szCaseNumber[256];                                  // �������
    int                             nInquestInfoNum;                                    // ��ѯ�ֶ���Ŀ
    NET_CASE_BACK_UP_INQUEST_INFO   stuInquestInfo[CASE_BACK_UP_INQUEST_INFO_MAX_NUM];  // ��ѯ�ֶ�����
    BYTE                            byReserved[1024];                                   // �����ֽ�
}NET_CASE_BACK_UP_QUERY_CONDITION;

// �������ݿ�¼ģʽ��Ϣ
typedef struct tagNET_CASE_BACK_UP_MODE
{
    EM_CASE_BACK_UP_MODE_TYPE   emBackupMode;                                           // ����ģʽ
    int                         nDeviceNum;                                             // �豸��Ŀ
    char                        szDeviceName[CASE_BACK_UP_DEVICE_MAX_NUM][256];         // �豸����
    EM_CASE_BACK_UP_PACK_TYPE   emPackType;                                             // �����ļ�����
    BOOL                        bExtraFile;                                             // �Ƿ��и���
    BOOL                        bDataCheck;                                             // �Ƿ�������У��
    BYTE                        byReserved[1024];                                       // �����ֽ�
}NET_CASE_BACK_UP_MODE;

// ��ʼ�������ݿ�¼���
typedef struct tagNET_IN_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // �ṹ���С
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // ��ѯ����
    NET_CASE_BACK_UP_MODE               stuMode;                                        // ����ģʽ
}NET_IN_START_CASE_BACK_UP;

// ��ʼ�������ݿ�¼ʧ�ܴ���������
typedef enum tagEM_CASE_BACK_UP_START_ERROR_CODE
{
    EM_CASE_BACK_UP_START_ERROR_CODE_UNKNOWN,                                           // δ֪��
    EM_CASE_BACK_UP_START_ERROR_CODE_NORMAL,                                            // ����
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUPING,                                         // �ð������ڱ�����
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_FINDFILE,                                       // δ�����ļ�
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_BUSY,                                       // �豸æ
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_SUPPORT_MEDIA_FORMAT,                           // ��֧�ֵ�ý���ʽ   
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_ERROR,                                      // �����豸����
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUP_FILE_OVER_LIMIT,                            // �����ļ�������������ֵ
    EM_CASE_BACK_UP_START_ERROR_CODE_OTHER_ERROR,                                       // ��������
}EM_CASE_BACK_UP_START_ERROR_CODE;

// ��ʼ�������ݿ�¼����
typedef struct tagNET_OUT_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // �ṹ���С
    EM_CASE_BACK_UP_START_ERROR_CODE    emErrorCode;                                    // ������
}NET_OUT_START_CASE_BACK_UP;

// ֹͣ�������ݿ�¼���
typedef struct tagNET_IN_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // �ṹ���С
}NET_IN_STOP_CASE_BACK_UP;

// ֹͣ�������ݿ�¼����
typedef struct tagNET_OUT_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // �ṹ���С
}NET_OUT_STOP_CASE_BACK_UP;

// �������ݿ�¼״̬
typedef enum tagEM_CASE_BACK_UP_STATE_TYPE
{
    EM_CASE_BACK_UP_STATE_TYPE_UNKNOWN,                                                 // δ֪��
    EM_CASE_BACK_UP_STATE_TYPE_INIT,                                                    // ��ʼ��
    EM_CASE_BACK_UP_STATE_TYPE_STOP,                                                    // ֹͣ
    EM_CASE_BACK_UP_STATE_TYPE_STOPPING,                                                // ֹͣ��
    EM_CASE_BACK_UP_STATE_TYPE_BACKUPING,                                               // ������            
    EM_CASE_BACK_UP_STATE_TYPE_CHANGE_DISK,                                             // ������
    EM_CASE_BACK_UP_STATE_TYPE_PREPARE_EXTRA_FILE,                                      // ������ʼ��
    EM_CASE_BACK_UP_STATE_TYPE_WAIT_EXTRA_FILE,                                         // �ȴ���¼����
    EM_CASE_BACK_UP_STATE_TYPE_UPLOAD_FILE_START,                                       // ������¼��
}EM_CASE_BACK_UP_STATE_TYPE;

// �������ݿ�¼״̬�������
typedef enum tagEM_CASE_BACK_UP_ERROR_CODE
{
    EM_CASE_BACK_UP_ERROR_CODE_UNKNOWN,                                                 // δ֪��
    EM_CASE_BACK_UP_ERROR_CODE_NORMAL,                                                  // ����
    EM_CASE_BACK_UP_ERROR_CODE_SPACE_FULL,                                              // ��¼��
    EM_CASE_BACK_UP_ERROR_CODE_START_ERROR,                                             // ��ʼ��¼����   
    EM_CASE_BACK_UP_ERROR_CODE_STOP_ERROR,                                              // ֹͣ��¼����
    EM_CASE_BACK_UP_ERROR_CODE_WRITE_ERROR,                                             // ��¼�ļ�����   
    EM_CASE_BACK_UP_ERROR_CODE_OTHER_ERROR,                                             // ��������      
}EM_CASE_BACK_UP_ERROR_CODE;

// �������ݿ�¼״̬����
typedef struct tagNET_CASE_BACK_UP_STATE
{
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // ��ǰ��¼״̬
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // �������
    BYTE                        byReserved[512];                                        // �����ֽ�
}NET_CASE_BACK_UP_STATE;

// �������ݿ�¼�ļ���Ϣ
typedef struct tagNET_CASE_BACK_UP_FILE_INFO
{
    int                         nFileCount;                                             // ��Ҫ��¼�������ļ���������
    int                         nCurFileIndex;                                          // ��ǰ���ڿ�¼���ļ���������   
    TP_U64                      nFileTotalLength;                                       // ��Ҫ��¼�������ݴ�С
    TP_U64                      nCurBackupTotalLength;                                  // ��ǰ�Ѿ���¼�˶�������
    TP_U64                      nCurBackupFileTotalLength;                              // ��ǰ���ڿ�¼���ļ��Ĵ�С
    TP_U64                      nCurBackupFileLength;                                   // ��ǰ���ڿ�¼���ļ��Ѿ���¼�����ݴ�С   
    BYTE                        byReserved[512];                                        // �����ֽ�
}NET_CASE_BACK_UP_FILE_INFO;

// �������ݿ�¼�豸��Ϣ
typedef struct tagNET_CASE_BACK_UP_DEVICE_INFO
{
    int                         nDeviceID;                                              // �豸ID
    char                        szDeviceName[256];                                      // �豸����
    int                         nTotalSpace;                                            // �豸�ܵ����� ��λKB
    int                         nRemainSpace;                                           // �豸ʣ������ ��λKB
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // ����״̬
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // �������
    BYTE                        byReserved[512];                                        // �����ֽ�
}NET_CASE_BACK_UP_DEVICE_INFO;

// �������ݿ�¼״̬
typedef struct tagNET_OUT_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // �ṹ���С
    NET_CASE_BACK_UP_STATE          stuBackUpState;                                     // ����״̬��Ϣ
    NET_CASE_BACK_UP_FILE_INFO      stuFileInfo;                                        // �����ļ���Ϣ
    int                             nDeviceNum;                                         // �豸����    
    NET_CASE_BACK_UP_DEVICE_INFO    stuDeviceInfo[CASE_BACK_UP_DEVICE_MAX_NUM];         // �豸��Ϣ����    
}NET_OUT_CASE_BACK_UP_STATE;

// �������ݿ�¼״̬�ص�����
typedef void (CALLBACK *fAttachCaseBackUpState)(LLONG lLoginID, LLONG lAttachHandle, const NET_OUT_CASE_BACK_UP_STATE* pBuf, int nBufLen, LDWORD dwUser);

// �������ݿ�¼״̬attach�������
typedef struct tagNET_IN_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // �ṹ���С  
    fAttachCaseBackUpState          cbAttachState;                                      // �ص�����
    LDWORD                          dwUser;                                             // �û�����
}NET_IN_ATTACH_CASE_BACK_UP_STATE;

// �������ݿ�¼״̬attach��������
typedef struct tagNET_OUT_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // �ṹ���С
}NET_OUT_ATTACH_CASE_BACK_UP_STATE;

// �������ݿ�¼״̬detach�������
typedef struct tagNET_IN_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // �ṹ���С
}NET_IN_DETACH_CASE_BACK_UP_STATE;

// �������ݿ�¼״̬detach��������
typedef struct tagNET_OUT_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // �ṹ���С
}NET_OUT_DETACH_CASE_BACK_UP_STATE;

// ��ȡ�������ݿ�¼��Ϣ���
typedef struct tagNET_IN_GET_CASE_BACK_UP_INFO
{
    DWORD                           dwSize;                                             // �ṹ���С
}NET_IN_GET_CASE_BACK_UP_INFO;

// ��ȡ�������ݿ�¼��Ϣ����
typedef struct tagNET_OUT_GET_CASE_BACK_UP_INFO
{
    DWORD                               dwSize;                                         // �ṹ���С
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // ��������
    NET_CASE_BACK_UP_MODE               stuMode;                                        // ����ģʽ
}NET_OUT_GET_CASE_BACK_UP_INFO;

// ��ʼ�������ݿ�¼
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBackUpCase(LLONG lLoginID, const NET_IN_START_CASE_BACK_UP* pstInParam, NET_OUT_START_CASE_BACK_UP *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ֹͣ�������ݿ�¼
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBackUpCase(LLONG lLoginID, const NET_IN_STOP_CASE_BACK_UP* pstInParam, NET_OUT_STOP_CASE_BACK_UP *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// �����������ݿ�¼״̬
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBackUpCaseState(LLONG lLoginID, const NET_IN_ATTACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_ATTACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ȡ�������������ݿ�¼״̬
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBackUpCaseState(LLONG lAttachHandle, const NET_IN_DETACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_DETACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ��ȡ�������ݿ�¼��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCaseBackUpInfo(LLONG lLoginID, const NET_IN_GET_CASE_BACK_UP_INFO* pstInParam, NET_OUT_GET_CASE_BACK_UP_INFO *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////// �����Զ�����ϵͳ����¼�� ///////////////////////////////////////


/////////////////////////////////// ���ͨ�� ///////////////////////////////////////

#define NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM 36     // ���ͨ�����ָ����Ŀ

// ��ʱ�ָ����Ϣ
typedef struct tagNET_TEMP_SPLIT_WINDOW_INFO
{
    int nChannel;                                       // ���ӻ���ͨ����
    BOOL bAudio;                                        // �Ƿ�����Ƶ
    DH_RECT stuPosition;                                // ��������,����8192����ϵ
    BYTE byReserved[128];                               // �����ֽ�
}NET_TEMP_SPLIT_WINDOW_INFO;

// ��ȡ��ʱ�ָ����Ϣ���
typedef struct tagNET_IN_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // �ṹ���С
    int nComposeChannel;                                // ���ͨ����
}NET_IN_GET_TEMP_SPLIT;

// ��ȡ��ʱ�ָ����Ϣ����
typedef struct tagNET_OUT_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // �ṹ���С
    DH_SPLIT_MODE emSplitMode;                          // �ָ�ģʽ��Ŀǰֻ֧�����32����ָ�ģʽ
    int nSplitNum;                                      // ��ʱ�ָ������,Ŀǰֻ֧�����32����ָ�
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // ��ʱ�ָ����Ϣ����
}NET_OUT_GET_TEMP_SPLIT;

// ������ʱ�ָ����Ϣ���
typedef struct tagNET_IN_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // �ṹ���С
    int nComposeChannel;                                // ���ͨ����
    DH_SPLIT_MODE emSplitMode;                          // �ָ�ģʽ��Ŀǰֻ֧�����32����ָ�ģʽ
    int nSplitNum;                                      // ��ʱ�ָ������,Ŀǰֻ֧�����32����ָ�
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // ��ʱ�ָ����Ϣ����
}NET_IN_SET_TEMP_SPLIT;

// ������ʱ�ָ����Ϣ����
typedef struct tagNET_OUT_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // �ṹ���С
}NET_OUT_SET_TEMP_SPLIT;

// �ָ����Ϣ
typedef struct tagNET_TEMP_SOURCE_WINDOW_INFO
{
    int nWindowID;                                      // ���ڱ��,��0��ʼ
    int nUniqueChannel;                                 // ���ڰ󶨵�ͨ��Դ
    BYTE byReserved[128];                               // �����ֽ�
}NET_TEMP_SOURCE_WINDOW_INFO;

// ������ʱ�ķָ������Դ���
typedef struct tagNET_IN_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // �ṹ���С
    int nComposeChannel;                                // ���ͨ����
    int nWindowNum;                                     // ��������
    NET_TEMP_SOURCE_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // ������Ϣ����
}NET_IN_SET_TEMP_SOURCE;

// ������ʱ�ķָ������Դ����
typedef struct tagNET_OUT_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // �ṹ���С   
}NET_OUT_SET_TEMP_SOURCE;

// ������ʱ�ķָ����Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSplit(LLONG lLoginID, const NET_IN_SET_TEMP_SPLIT* pstInParam, NET_OUT_SET_TEMP_SPLIT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ��ȡ��ʱ�ķָ����Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTempSplit(LLONG lLoginID, const NET_IN_GET_TEMP_SPLIT* pstInParam, NET_OUT_GET_TEMP_SPLIT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ������ʱ�ķָ������Դ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSource(LLONG lLoginID, const NET_IN_SET_TEMP_SOURCE* pstInParam, NET_OUT_SET_TEMP_SOURCE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////// ���ͨ�� ///////////////////////////////////////

/////////////////////////////////// Storage ///////////////////////////////////////

// Զ�̴洢д����
typedef enum tagNET_STORAGE_WRITE_STATE
{
    NS_WRITE_UNKNOWN,                                   // δ֪
    NS_WRITE_OK,                                        // �ɹ�
    NS_WRITE_DISK_IO_ERROR,                             // ����IO����
    NS_WRITE_DISK_NOT_READY,                            // ����δ׼����
    NS_WRITE_DISK_FAULT,                                // ���̹���
    NS_WRITE_STREAM_NOT_EXIST,                          // ������ID������
    NS_WRITE_MOUNT_DISK_ERROR,                          // ���̹��ش���
} NET_STORAGE_WRITE_STATE;

// Զ��������Ϣ
typedef struct tagNET_STORAGE_BLOCK 
{
    DWORD                   dwSize;
    unsigned int            nID;                        // CQFS��ID
    unsigned int            nStreamID;                  // ������Ψһ��ʶ
    unsigned int            nRecycleTimestamp;          // CQFS����ʱ���
    unsigned int            nBeginTimestamp;            // �������ݿ�ʼʱ���
    unsigned int            nEndTimestamp;              // �������ݽ���ʱ���
    unsigned int            nLockCount;                 // ��������ֵ, 0��ʾδ����
    char                    szDiskUUID[DH_COMMON_STRING_64]; // ����UUID
} NET_STORAGE_BLOCK;

// Զ�̴洢����Ϣ״̬
typedef struct tagNET_STORAGE_WRITE_INFO
{
    DWORD                    dwSize;
    NET_STORAGE_WRITE_STATE  emState;                   // д����
    int                      nBlockCount;               // ������
    NET_STORAGE_BLOCK        stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // ����Ϣ
} NET_STORAGE_WRITE_INFO;

//////////////////////////////////////////////////////////////////////////
/// \fn ����д��Զ�̴洢����Ϣ״̬�ص�����
/// \brief 
/// \author yang_xiuqing
/// \param  LLONG lAttachHandle [OUT] ���ľ��, CLIENT_NetStorageAttachWriteInfo�ķ���ֵ 
/// \param  NET_STORAGE_WRITE_INFO * pBuf [OUT] Զ�̴洢����Ϣ״̬
/// \param  int nBufLen [OUT] ״̬��Ϣ����
/// \param  LDWORD dwUser �û�����
/// \return ��
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fNetStorageAttachWriteInfoCB)(LLONG lAttachHandle, NET_STORAGE_WRITE_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_NetStorageAttachWriteInfo �ӿ��������
typedef struct tagNET_IN_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                           dwSize;
    const char*                     pszName;                // Զ�̴洢����, ֵ��NAS�����л�ȡ
    fNetStorageAttachWriteInfoCB    cbISCSIBlcok;           // �ص�����
    LDWORD                          dwUser;                 // �û�����
} NET_IN_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageAttachWriteInfo �ӿ��������
typedef struct tagNET_OUT_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                       dwSize;
} NET_OUT_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo �ӿ��������
typedef struct tagNET_IN_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;
    const char*                 pszName;                    // Զ�̴洢����
} NET_IN_STORAGE_GET_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo �ӿ��������
typedef struct tagNET_OUT_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;    
    int                         nBlockCount;                // ������
    NET_STORAGE_BLOCK           stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // ����Ϣ
} NET_OUT_STORAGE_GET_WRITE_INFO;

// RAID��������
typedef enum tagNET_RAID_OPERATE_TYPE
{
    NET_RAID_OPERATE_ADD,                    // ���RAID, ��Ӧ�ṹ�� NET_IN_RAID_ADD �� NET_OUT_RAID_ADD
    NET_RAID_OPERATE_REMOVE,                 // ɾ��RAID, ��Ӧ�ṹ�� NET_IN_RAID_REMOVE �� NET_OUT_RAID_REMOVE
    NET_RAID_OPERATE_GET_SUBDEVICE,          // ��ȡRAID���豸��Ϣ, ��Ӧ�ṹ�� NET_IN_RAID_GET_SUBDEVICE �� NET_OUT_RAID_GET_SUBDEVICE
    NET_RAID_OPERATE_GET_SUBSMART,           // ��ȡRAID���豸SMART��Ϣ, ��Ӧ�ṹ�� NET_IN_RAID_GET_SUBSMART �� NET_OUT_RAID_GET_SUBSMART
    NET_RAID_OPERATE_MODIFY,                 // �޸�RAID, ��Ӧ�ṹ�� NET_IN_RAID_MODIFY �� NET_OUT_RAID_MODIFY
} NET_RAID_OPERATE_TYPE;

// RAID��Ϣ
typedef struct tagNET_RAID_INFO 
{
    DWORD                dwSize;
    char                 szName[DH_COMMON_STRING_64];     // ����, Ϊ��ʱ�������豸����
    char                 szLevel[DH_COMMON_STRING_16];    // �ȼ�, ����"RAID0", "RAID5"��
    int                  nMemberNum;                      // ��Ա����
    char                 szMembers[DH_MAX_MEMBER_PER_RAID][DH_COMMON_STRING_64]; // ��Ա��Ϣ
} NET_RAID_INFO;

// ���RAID�ķ��ؽ��
typedef struct tagNET_RAID_ADD_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                    // ʧ�ܴ�����
    char                 szName[DH_COMMON_STRING_64];    // ����
} NET_RAID_ADD_RESULT;

// ���RAID�������
typedef struct tagNET_IN_RAID_ADD 
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID����
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID��Ϣ
} NET_IN_RAID_ADD;

// ���RAID�������
typedef struct tagNET_OUT_RAID_ADD 
{
    DWORD                dwSize;
    int                  nResultNum;                        // �����
    NET_RAID_ADD_RESULT  stuResults[DH_MAX_RAID_NUM];       // RAID�����Ľ��
} NET_OUT_RAID_ADD;

// ɾ��RAID�ķ��ؽ��
typedef struct tagNET_RAID_REMOVE_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // ʧ�ܴ�����
} NET_RAID_REMOVE_RESULT;

// ɾ��RAID�������
typedef struct tagNET_IN_RAID_REMOVE 
{
    DWORD                dwSize;
    int                  nRaidNum;                         // RAID����
    char                 szRaids[DH_MAX_RAID_NUM][DH_COMMON_STRING_64];    // RAID��������
} NET_IN_RAID_REMOVE;

// ɾ��RAID�������
typedef struct tagNET_OUT_RAID_REMOVE
{
    DWORD                dwSize;
    int                  nResultNum;                       // �����
    NET_RAID_REMOVE_RESULT stuResults[DH_MAX_RAID_NUM];    // RAID�����Ľ��
} NET_OUT_RAID_REMOVE;

// ��ȡRAID���豸��Ϣ�������
typedef struct tagNET_IN_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    const char*          pszRaidName;                    // RAID����
} NET_IN_RAID_GET_SUBDEVICE;

// ��ȡRAID���豸��Ϣ�������
typedef struct tagNET_OUT_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    int                  nSubDeviceNum;                  // ���豸����
    DH_STORAGE_DEVICE    stuSubDevices[DH_MAX_MEMBER_PER_RAID]; // ���豸��Ϣ
} NET_OUT_RAID_GET_SUBDEVICE;

// RAID���豸SMART��Ϣ
typedef struct tagNET_RAID_SMART_INFO 
{
    DWORD                dwSize;
    unsigned int         nID;                            // ����ID
    char                 szName[DH_COMMON_STRING_64];    // ������
    int                  nCurrent;                       // ����ֵ
    int                  nWorst;                         // ������ֵ
    int                  nThreshold;                     // ��ֵ
    int                  nPredict;                       // ״̬
    char                 szRaw[DH_COMMON_STRING_16];     // ʵ��ֵ
} NET_RAID_SMART_INFO;

// ��ȡRAID���豸SMART��Ϣ�������
typedef struct tagNET_IN_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    const char*          pszSubDevName;                  // RAID���豸����
} NET_IN_RAID_GET_SUBSMART;

// ��ȡRAID���豸SMART��Ϣ�������
typedef struct tagNET_OUT_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    int                  nSmartNum;                          // SMART��Ϣ��
    NET_RAID_SMART_INFO  stuSmartInfos[MAX_SMART_VALUE_NUM]; // SMART��Ϣ
} NET_OUT_RAID_GET_SUBSMART;

// �޸�RAID�ķ��ؽ��
typedef struct tagNET_RAID_MODIFY_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // ʧ�ܴ�����
} NET_RAID_MODIFY_RESULT;

// �޸�RAID�������
typedef struct tagNET_IN_RAID_MODIFY
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID����
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID��Ϣ
} NET_IN_RAID_MODIFY;

// �޸�RAID�������
typedef struct tagNET_OUT_RAID_MODIFY 
{
    DWORD                dwSize;
    int                  nResultNum;                        // �����
    NET_RAID_MODIFY_RESULT stuResults[DH_MAX_RAID_NUM];     // RAID�����Ľ��
} NET_OUT_RAID_MODIFY;


//////////////////////////////// �ⲿ�豸 //////////////////////////////////////////

// ����豸����
typedef enum tagNET_EXT_DEV_TYPE
{
    EXT_DEV_UNKNOWN,                    // δ֪
    EXT_DEV_PROJECTOR,                  // ͶӰ��
    EXT_DEV_SEQUENCE_POWER,            // ��Դ������
} NET_EXT_DEV_TYPE;

// ����豸��Ϣ
typedef struct tagNET_EXTERNAL_DEVICE 
{
    DWORD               dwSize;
    NET_EXT_DEV_TYPE    emType;                             // �豸����
    char                szDevID[DH_DEV_ID_LEN_EX];          // �豸ID, Ψһ���
    char                szDevName[DH_DEV_ID_LEN_EX];        // �豸����
} NET_EXTERNAL_DEVICE;

// ��Դʱ�������Ʋ���
typedef struct tagNET_CTRL_SEQPOWER_PARAM
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // �豸ID
    int                 nChannel;                           // ����ڻ���������
} NET_CTRL_SEQPOWER_PARAM;

// ͶӰ�ǿ��Ʋ���
typedef struct tagNET_CTRL_PROJECTOR_PARAM 
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // �豸ID
} NET_CTRL_PROJECTOR_PARAM;

// ���ⰴ��
typedef struct tagNET_CTRL_INFRARED_KEY_PARAM 
{
    DWORD               dwSize;
    int                 nChannel;                           // �������ͨ����
    unsigned int        nKey;                               // ���ⰴ��ID
} NET_CTRL_INFRARED_KEY_PARAM;

// ��Ӳ�̱���
typedef struct tagALARM_NO_DISK_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                            // ʱ��
    DWORD               dwAction;                           // �¼�����, 0:Start, 1:Stop
}ALARM_NO_DISK_INFO;
//������״̬ö��
typedef enum __EM_CAPSULE_STATE
{
    CAPSULE_STATE_UNKNOW ,      //δ����
    CAPSULE_STATE_NORMAL ,      //����
    CAPSULE_STATE_TIME_OUT ,    //��ʱ
    CAPSULE_STATE_EMERGENCY_CALL,   //����
}EM_CAPSULE_STATE;

//�������¼�
typedef struct tagALARM_PROTECTIVE_CAPSULE_INFO
{
    DWORD               dwSize;
    EM_CAPSULE_STATE    emCapsuleState; //������״̬
    DWORD               nLock;          //0:δ��,1:����; ����emCapsuleStateΪCAPSULE_STATE_NORMALʱ��Ч
    DWORD               nInfrared;      //0:����(����),1:����(����);����emCapsuleStateΪCAPSULE_STATE_NORMALʱ��Ч
}ALARM_PROTECTIVE_CAPSULE_INFO;

// ��ȡ���������������
typedef struct tagNET_IN_VIDEOIN_FISHEYE_CAPS
{
    DWORD                dwSize; 
    int                  nChannel;  //ͨ����
}NET_IN_VIDEOIN_FISHEYE_CAPS;

// ��ȡ���������������
typedef struct tagNET_OUT_VIDEOIN_FISHEYE_CAPS
{
    DWORD                       dwSize; 
    int                         nMountModeNum;                     // ֧�ֵİ�װģʽ����         
    NET_FISHEYE_MOUNT_MODE      emMountModes[NET_MAX_FISHEYE_MOUNTMODE_NUM]; // ֧�ֵİ�װģʽ�б�
    int                         nCalibrateModeNum;                 // ֧�ֵ����۽���ģʽ����  
    NET_FISHEYE_CALIBRATE_MODE  emCalibrateModes[NET_MAX_FISHEYE_CALIBRATEMODE_NUM]; // ֧�ֵ����۽���ģʽ�б�
    int                         nEPtzCmdNum;                       // ֧�ֵ����۵�����̨�������� 
    NET_FISHEYE_EPTZ_CMD        emEPtzCmds[NET_MAX_FISHEYE_EPTZCMD_NUM]; // ֧�ֵ����۵�����̨�����б�
    NET_FISHEYE_TYPE            emType;                                 //��������
}NET_OUT_VIDEOIN_FISHEYE_CAPS;

// ��ȡ��Դʱ���������������
typedef struct tagNET_IN_CAP_SEQPOWER 
{
    DWORD                dwSize;
    const char*          pszDeviceID;                       // �豸ID
} NET_IN_CAP_SEQPOWER;

// ��ȡ��Դʱ���������������
typedef struct tagNET_OUT_CAP_SEQPOWER
{
    DWORD                dwSize;
    int                  nChannelNum;                       // ͨ����
} NET_OUT_CAP_SEQPOWER;

// ��ȡ�豸�������ö�Ӧ�����������
typedef struct tagNET_IN_ENCODE_CFG_CAPS
{
    DWORD               dwSize;           
    int                 nChannelId;                         // ͨ����    
    int                 nStreamType;                        // ��������,0����������1��������1��2��������2��3��������3��4��ץͼ����
                                                            // �˲������Բ���,����ָ��ʲô����,�豸��������������ץͼ����������
    char*               pchEncodeJson;                      // Encode����,ͨ������dhconfigsdk.dll�нӿ�CLIENT_PacketData��װ�õ�
                                                            // ��Ӧ�ķ�װ����Ϊ CFG_CMD_ENCODE                 
}NET_IN_ENCODE_CFG_CAPS;

// �������ö�Ӧ����
typedef struct tagNET_STREAM_CFG_CAPS
{
    DWORD               dwSize;
    int                 nAudioCompressionTypes[DH_MAX_AUDIO_ENCODE_TYPE]; // ֧�ֵ���Ƶ��������,���DH_TALK_CODING_TYPE
    int                 nAudioCompressionTypeNum;                   // ��Ƶѹ����ʽ����
    int                 dwEncodeModeMask;                           // ��Ƶ����ģʽ����,���"����ģʽ"
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// ֧�ֵ���Ƶ�ֱ���
    int                 nResolutionFPSMax[DH_MAX_CAPTURE_SIZE_NUM]; // ��ͬ�ֱ�����֡�����ֵ,�±���nResolutionTypes��Ӧ 
    int                 nResolutionTypeNum;                         // ��Ƶ�ֱ��ʸ���
    int                 nMaxBitRateOptions;                         // �����Ƶ����(kbps) 
    int                 nMinBitRateOptions;                         // ��С��Ƶ����(kbps)
    BYTE                bH264ProfileRank[DH_PROFILE_HIGH];          // ֧�ֵ�H.264 Profile�ȼ�,����ö������ EM_H264_PROFILE_RANK;  
    int                 nH264ProfileRankNum;                        // ֧�ֵ�H.264 Profile�ȼ�����
    int                 nCifPFrameMaxSize;                          // ���ֱ���Ϊcifʱ���p֡(Kbps)
    int                 nCifPFrameMinSize;                          // ���ֱ���Ϊcifʱ��Сp֡(Kbps)
    int                 nFPSMax;                                    // ��Ƶ֡�����ֵ,Ϊ0ʱ,��nResolutionFPSMaxΪ׼
    DH_RESOLUTION_INFO  stuIndivResolutionTypes[DH_MAX_COMPRESSION_TYPES_NUM][DH_MAX_CAPTURE_SIZE_NUM];// ֧�ֵ���Ƶ�ֱ���
	BOOL				abIndivResolution;							// 0: stuResolutionTypes,nResolutionTypeNum ��Ч 
                                                                    // 1: stuIndivResolutionTypes, nIndivResolutionNums ��Ч
    int                 nIndivResolutionNums[DH_MAX_COMPRESSION_TYPES_NUM];// ��ͬ����ģʽ�ֱ�֧�ֵ���Ƶ�ֱ��ʸ���
}NET_STREAM_CFG_CAPS;

// ��ȡ�豸�������ö�Ӧ�����������
typedef struct tagNET_OUT_ENCODE_CFG_CAPS
{
    DWORD               dwSize;
    NET_STREAM_CFG_CAPS stuMainFormatCaps[DH_REC_TYPE_NUM];         // ���������ö�Ӧ����, ����ж��, ��һ����ʾ��ͨ¼������, �ڶ�����ʾ����¼������, ��������ʾ����¼������
    NET_STREAM_CFG_CAPS stuExtraFormatCaps[DH_N_ENCODE_AUX];        // ���������ö�Ӧ����, ����ж��, ��һ����ʾ������1, �ڶ�����ʾ������2, ��������ʾ������3
    NET_STREAM_CFG_CAPS stuSnapFormatCaps[SNAP_TYP_NUM];           // ץͼ�������ö�Ӧ����, ����ж��, ��һ����ʾ��ͨץͼ, �ڶ�����ʾ����ץͼ, ��������ʾ����ץͼ
    int                 nMainFormCaps;                              // ��Ч�����������ö�Ӧ����������
    int                 nExtraFormCaps;                             // ��Ч�ĸ��������ö�Ӧ����������
    int                 nSnapFormatCaps;                            // ��Ч��ץͼ�������ö�Ӧ����������
}NET_OUT_ENCODE_CFG_CAPS;


//��ȡ��Ƶ�������������
typedef struct tagNET_IN_VIDEO_DETECT_CAPS
{
    DWORD               dwSize;           
    int                 nChannel;  //ͨ���� 
}NET_IN_VIDEO_DETECT_CAPS;

// ý������������
typedef enum tagNET_MEDIA_CAP_TYPE
{
    NET_MEDIA_CAP_TYPE_SENSORINFO,      // ��ͷ��������Ϣ
} NET_MEDIA_CAP_TYPE;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS �������
typedef struct tagNET_IN_MEDIAMANAGER_GETCAPS
{
    DWORD               dwSize;
    NET_MEDIA_CAP_TYPE  emType;         // ��Ҫ��ȡ������������
} NET_IN_MEDIAMANAGER_GETCAPS;

// ��ȡ�豸�������ö�Ӧ�����������	 
typedef struct tagNET_IN_SNAP_CFG_CAPS	 	 	 
{        	 	 	 
    int                 nChannelId;                     // ͨ����(��ʼͨ��0) 	 	 	 
    BYTE                bReserved[1024];                // ����	 	 	 
}NET_IN_SNAP_CFG_CAPS;	 	 	 

#define DH_MAX_FPS_NUM                128                // ���֧�ֵ�֡�ʸ���	 	 	 
#define DH_MAX_QUALITY_NUM            32                 // ���֧�ֵĻ��ʸ���	 	 	 

// ץͼ��������	 	 	 
typedef struct tagNET_OUT_SNAP_CFG_CAPS 	 	 	 
{	 	 	 
    int                 nResolutionTypeNum;                // ֧�ֵ���Ƶ�ֱ�����Ϣ	 	 	 
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];	 	 	 
    DWORD               dwFramesPerSecNum;                 // ֧�ֵ�֡����Ϣ	 	 	 
    int                 nFramesPerSecList[DH_MAX_FPS_NUM]; // -25��25��1֡��-24��24��1֡������	 	 	 
                                                           // 0����Ч��1��1��1֡��2��1��2֡��3��1��3֡	 	 	 
                                                           // 4��1��4֡��5��1��5֡��17��1��17֡��18��1��18֡	 	 	 
                                                           // 19��1��19֡��20��1��20֡����	 	 	 
    DWORD               dwQualityMun;                      // ֧�ֵĻ�����Ϣ	 	 	 
    DWORD               nQualityList[DH_MAX_QUALITY_NUM];  // 1-6����6������ߣ� 	 	 
    DWORD               dwMode;                            // ģʽ,��λ����һλ����ʱ���ڶ�λ���ֶ���	 	 	 
    DWORD               dwFormat;                          // ͼƬ��ʽģʽ,��λ����һλ��bmp���ڶ�λ��jpg��	 	 	 
    BYTE                bReserved[2048];                   // ����	 	 	 
} NET_OUT_SNAP_CFG_CAPS;

// ��ͷ����������
typedef enum tagNET_CAMERA_SENSOR
{
    NET_CAMERA_SENSOR_NORMAL,           // һ�㣨�ɼ��⣩
    NET_CAMERA_SENSOR_LEPTON,           // Lepton �ȳ���
    NET_CAMERA_SENSOR_TAU,              // Tau �ȳ���
} NET_CAMERA_SENSOR;

// ��ͷ��������Ϣ
typedef struct tagNET_CAMERA_SENSORINFO
{
    NET_CAMERA_SENSOR   emSensorType;       // ����������
    int                 nChannelsCount;     // �˴��������Ͷ�Ӧ��ͨ������
    int                 nChannels[512];     // �˴��������Ͷ�Ӧ��ͨ����
    char                reserved[512];
} NET_CAMERA_SENSORINFO;

// ý����Ϣ������ͷ������
typedef struct tagNET_MEDIA_SENSORINFO
{
    BOOL                    bSupport;               // �Ƿ�֧�ֱ�������ȡ,ΪTRUEʱ���³�Ա��Ч
    int                     nSensorTypeCount;       // �豸���еľ�ͷ���������͸���
    NET_CAMERA_SENSORINFO   stuDetail[16];          // ÿ�����������͵���ϸ��Ϣ,��Ч������ nSensorTypeCount ָ��
    char                    reserved[1024];
} NET_MEDIA_SENSORINFO;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS �������
typedef struct tagNET_OUT_MEDIAMANAGER_GETCAPS
{
    DWORD                   dwSize;
    NET_MEDIA_SENSORINFO    stuSensorInfo;          // ��ͷ��������Ϣ
} NET_OUT_MEDIAMANAGER_GETCAPS;

// ��Ƶ������������
typedef enum tagNET_ENUM_VIDEOIN_CAP_TYPE
{
    NET_VIDEOIN_CAP_TYPE_CONFLICT,                          // �豸��Ƶ���������ͻ�������Ӧ����NET_OUT_VIDEOIN_CONFLICT_CAPS
}NET_ENUM_VIDEOIN_CAP_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_CAPS �������
typedef struct tagNET_IN_VIDEOIN_CAPS
{
    DWORD                               dwSize;
    int                                 nChannel;                    // ͨ����
    NET_ENUM_VIDEOIN_CAP_TYPE           emCapType;                   // �豸��Ƶ�����������
}NET_IN_VIDEOIN_CAPS;

typedef enum tagNET_ENUM_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE_UNKNOWN,                          // δ֪
    NET_ENUM_CONFLICT_TYPE_MAIN,                             // ������
    NET_ENUM_CONFLICT_TYPE_EXTRA1,                           // ������1
    NET_ENUM_CONFLICT_TYPE_EXTRA2,                           // ������2
    NET_ENUM_CONFLICT_TYPE_TVOUT,                            // ģ�����
    NET_ENUM_CONFLICT_TYPE_DSP,                              // ����
    NET_ENUM_CONFLICT_TYPE_SMARTENC,                         // Smart����(��GOP)
    NET_ENUM_CONFLICT_TYPE_SETGOP,                           // ����GOP
    NET_ENUM_CONFLICT_TYPE_ROI,                              // ����Ȥ����
    NET_ENUM_CONFLICT_TYPE_CBR,                              // �㶨��������
    NET_ENUM_CONFLICT_TYPE_SVC,                              // SVC����
    NET_ENUM_CONFLICT_TYPE_MJPEG,                            // MJPEG����
    NET_ENUM_CONFLICT_TYPE_ROTATE_90,                        // ��ת90��
}NET_ENUM_CONFLICT_TYPE;

typedef struct tagNET_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE      emConflict1;                 // ��ͻ��1              
    NET_ENUM_CONFLICT_TYPE      emConflict2;                 // ��ͻ��2
    char                        reserved[64];
}NET_CONFLICT_TYPE;
// CLIENT_GetDevCaps NET_VIDEOIN_CAPS �������
typedef struct tagNET_VIDEOIN_CONFLICT_CAPS
{
    BOOL                        bConflict;                  // �Ƿ������Դ��ͻ��
    int                         nConflictNum;               // ��ͻ������
    NET_CONFLICT_TYPE           stuConflict[MAX_VIDEOIN_CONFLICT_NUM];           // ��ͻ��
}NET_VIDEOIN_CONFLICT_CAPS;

typedef struct tagNET_OUT_VIDEOIN_CAPS
{
    DWORD                       dwSize;
    NET_VIDEOIN_CONFLICT_CAPS   stuConflictCap;             // ��Դ��ͻ�ṹ��
}NET_OUT_VIDEOIN_CAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS�������
typedef struct tagNET_IN_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;						// �û�ʹ��ʱ��ֵΪ�ṹ���С
} NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS�������
typedef struct tagNET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;									// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int					nSupportCount;							// ʵ��֧�ֵ��������˵�ͨ������
	short				snSupport[MAX_MOSAIC_CHANNEL_NUM];		// ֧�ֵ���������ͨ����[-1]��ʾȫ֧��
	int					nMosaicCount;							// ʵ��֧�ֵ������˿�������
	char				szMosaic[MAX_MOSAIC_NUM];				// ֧�ֵ������˿�����С
	DH_SIZE				stuRectMax;								// �������������ߴ�
	DH_SIZE				stuRectMin;								// ��������С����ߴ�
} NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS �������
typedef struct tagNET_IN_FACEBOARD_CAPS
{
    DWORD               dwSize;						            // �ýṹ���С
}NET_IN_FACEBOARD_CAPS;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS �������
typedef struct tagNET_IN_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               dwSize;									// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int					nChannel;								// ͨ����
} NET_IN_VIDEO_IMAGECONTROL_CAPS;

// ��������
typedef enum tagNET_EM_STABLE_CAPS_TYPE
{
	EM_STABLE_UNSPPORT,					// ��֧��ͼ�����
	EM_STABLE_ELEC,						// ֧�ֵ��ӷ���
	EM_STABLE_LIGHT,					// ֧�ֹ�ѧ����
	EM_STAVLE_ELEC_AND_LIGHT,			// ֧�ֵ��ӷ����͹�ѧ����
	EM_STABLE_CONTROL,					// ֧�ֿؼ�����
	EM_STABLE_ELEC_AND_CONTROL,			// ֧�ֵ��ӷ����Ϳؼ�����
	EM_STABLE_LIGHT_AND_CONTROL,		// ֧�ֹ�ѧ�����Ϳؼ�����
} NET_EM_STABLE_CAPS_TYPE;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS �������
typedef struct tagNET_OUT_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               			dwSize;							// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL							bSupport;						// Mirror,Flip,Rotate90������һ֧����true
	BOOL							bMirror;						// �Ƿ�֧�ֻ��澵����
	BOOL							bFlip;							// �Ƿ�֧�ֻ���180��ת����
	BOOL							bRotate90;						// ֧�ֵĻ���90/270����ת
	BOOL							bFreeze;						// �Ƿ�֧��ͼ�񶳽Ṧ��
	NET_EM_STABLE_CAPS_TYPE			emStable;						// ֧��ͼ������Ĺ���
} NET_OUT_VIDEO_IMAGECONTROL_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS �������
typedef struct tagNET_IN_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               dwSize;									// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int					nChannel;								// ͨ����
} NET_IN_VIDEOIN_EXPOSURE_CAPS;

#define MAX_EXPOSURE_COUNT	8

// �ع�ģʽ
typedef enum tagNET_EM_EXPOSURE_MODE
{
	NET_EM_EXPOSURE_AUTO,					// Ĭ���Զ�
	NET_EM_EXPOSURE_LOWNICE,				// ������
	NET_EM_EXPOSURE_ANTISHADOW,				// ����Ӱ
	NET_EM_EXPOSURE_MANUALRANGE	= 4,		// �ֶ�����
	NET_EM_EXPOSURE_APERTUREFIRST,			// ��Ȧ����
	NET_EM_EXPOSURE_MANUALFIXATION,			// �ֶ��̶�
	NET_EM_EXPOSURE_GIANFIRST,				// ��������
	NET_EM_EXPOSURE_SHUTTERFIRST,			// ��������
	NET_EM_EXPOSURE_FLASHMATCH,				// �����ƥ��ģʽ
} NET_EM_EXPOSURE_MODE;

// ����˸ģʽ
typedef enum tagNET_EM_ANTIFLICKER_MODE
{
	NET_EM_ANTIFLICKER_OUTDOOR,			// ����
	NET_EM_ANTIFLICKER_50HZ,			// 50Hz
	NET_EM_ANTIFLICKER_60HZ,			// 60Hz
} NET_EM_ANTIFLICKER_MODE;

// �ع��ٶȵȼ��������飬ֵ�Ƿ�ĸ����λ�롣����100��ʾ1/100����ع�ʱ��
// "-1"��ʾ֧���û�����ɵ�������������ֶΣ���ʾ��֧���û�����ɵ�
typedef struct tagNET_SPEED_CAPS
{
	int			nRetManual;								// �ֶ�ģʽ�µĿ���ʵ�ʸ���
	int			nManual[DH_COMMON_STRING_16];			// �ֶ�ģʽ�µĿ����б�
	int			nRetManual50Hz;							// ����˸50HZ ģʽ�£��ֶ�ģʽ��Ӧ�Ŀ���ʵ�ʸ���
	int			nManual50Hz[DH_COMMON_STRING_16];		// ����˸50HZ ģʽ�£��ֶ�ģʽ��Ӧ�Ŀ����б�
	int			nRetManual60Hz;							// ����˸60HZ ģʽ�£��ֶ�ģʽ��Ӧ�Ŀ���ʵ�ʸ���
	int			nManual60Hz[DH_COMMON_STRING_16];		// ����˸60HZ ģʽ�£��ֶ�ģʽ��Ӧ�Ŀ����б�
	int			nRetShutterPAL;							// ���������µ�P�ƿ���ʵ�ʸ���
	int			nShutterPAL[DH_COMMON_STRING_16];		// ���������µ�P�ƿ����б�
	int			nRetShutterNTSC;						// ���������µ�N�ƿ���ʵ�ʸ���
	int			nShutterNTSC[DH_COMMON_STRING_16];		// ���������µ�N�ƿ����б�
	BYTE		bReserved[128];							// Ԥ���ֶ�
} NET_SPEED_CAPS;

typedef struct tagNET_SLOW_SPEED_CAPS
{
	int			nRetPal;
	int			nPal[DH_COMMON_STRING_16];
	int			nRetNtsc;
	int			nNtsc[DH_COMMON_STRING_16];
	BYTE		bReserved[128];					// Ԥ���ֶ�
} NET_SLOW_SPEED_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               		dwSize;									// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL						bSupport;								// �Ƿ�֧���ع���������
	int							nExposureMode;							// ʵ��֧�ֵ��ع�ģʽ����
	NET_EM_EXPOSURE_MODE		emExposureMode[MAX_EXPOSURE_COUNT];		// ֧�ֵ��ع�ģʽ
	BOOL						bAntiFlicker;							// �Ƿ�֧�ַ���˸
	int							nAntiFlicker;							// ʵ��֧�ֵķ���˸���ܸ���
	NET_EM_ANTIFLICKER_MODE		emAntiFlicker[MAX_ANTIFLICKERMODE_COUNT];	// ����˸�����б�
	int							nMinCompensation;						// �عⲹ����Сֵ
	int							nMaxCompensation;						// �عⲹ�����ֵ
	BOOL						bGainUpperLimit;						// ֧����������ѡ������
																		// true:���Զ�����Ȧ���ȣ���������ģʽ��ʾ��������ѡ�
																		// false: ���Զ�����Ȧ���ȣ���������ģʽ������������ѡ��
	int							nMinGain;								// ������Сֵ
	int							nMaxGain;								// �������ֵ
	BOOL						bSlowAutoExposure;						// �Ƿ�֧�����ع���������, Ĭ��֧��
																		// ����и��ֶ���ֵΪfalse�����·����ع����ã����û�д�ֵ����ֵΪtrue�����·����ع�����
	int							nMinSlowAutoExposure;					// ���ع���Сֵ
	int							nMaxSlowAutoExposure;					// ���ع����ֵ
	BOOL						bSlowShutter;							// �Ƿ�֧��������
	float						fMinValueLow;							// �Զ��ع�ʱ��������Сֵ
	float						fMaxValueLow;							// �Զ��ع�ʱ���������ֵ
	float						fMinValueUp;							// �Զ��ع�ʱ��������Сֵ
	float						fMaxValueUp;							// �Զ��ع�ʱ���������ֵ
	NET_SPEED_CAPS				stuSpeedCaps;							// �ع��ٶȵȼ�����
	NET_SLOW_SPEED_CAPS			stuSlowSpeedCaps;						// ���ع��ٶȵȼ�����
	BOOL						bIrisAuto;								// �Ƿ�֧���Զ���Ȧ
	int							nIrisMin;								// �ֶ���Ȧ������Сֵ
	int							nIrisMax;								// �ֶ���Ȧ�������ֵ
	BOOL						bSupportIrisRange;						// ֧�ֹ�Ȧ����ɵ�����
	BOOL						bDoubleExposure;						// �Ƿ�֧��ITC˫���ŵ���
	BOOL						bRecoveryTime;							// �Ƿ�֧���Զ��ع�ָ�
} NET_OUT_VIDEOIN_EXPOSURE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS �������
typedef struct tagNET_IN_VIDEOIN_DENOISE_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_DENOISE_CAPS;

// ֧�ֵ�3D��������
typedef enum tagNET_EM_3DSUPPORT_TYPE
{
	NET_EM_3DSUPPORT_UNKOWN,									// δ֪
	NET_EM_3DSUPPORT_OFF,										// �ر�
	NET_EM_3DSUPPORT_AUTO,										// �Զ�
	NET_EM_3DSUPPORT_MANUAL,									// �ֶ�
} NET_EM_3DSUPPORT_TYPE;

// 3D����֧�ֵ��㷨ģʽ
typedef struct tagNET_3D_ALGORITHM_MODE
{
	// ���������ʾ��bit0,bit1,bit2...�ֱ��ʾ�����㷨bit0�������㷨bit1��
	// �����㷨bit2���Դ�����.ȫΪ0����ʾ����֧�ֽ����㷨
	DWORD	dwSingleExposure;				// �����Ž�������
	DWORD	dwDoubleExposureFullRate;		// ITC˫����ȫ֡�ʽ�������
	DWORD	dwDoubleExposureHalfRate;		// ITC˫���Ű�֡�ʽ�������
	DWORD	dsThreeExposure;				// �����Ž�������
	BYTE	bReserved[128];					// Ԥ���ֶ�
} NET_3DALGORITHM_MODE;

#define		MAX_3DTYPE_COUNT			8			// ���֧�ֵ�3D�������͸��� 
#define		MAX_GROUP_COUNT				2			// ����������ֵ
#define		MAX_PROGRAM_COUNT			8			// �������ÿ��֧�ֵ���󷽰���

// 2D��������
typedef struct tagNET_SUPPORT2D_CAPS
{
	BOOL						bSupport2D;								// �Ƿ�֧��2D����
	int							n2DLevelMin;							// 2D����ȼ���Сֵ
	int							n2DLevelMax;							// 2D����ȼ����ֵ
	int							nMaxRAWLevel;							// �����RAW���2D����ֵ, 0 ��ʾ��֧��
	BYTE						bReserved[128];							// Ԥ���ֶ�
} NET_SUPPORT2D_CAPS;

// ÿ�齵�����֧�ֵķ�����Ϣ
typedef struct tagNET_DENOISEGROUP_PROGRAM
{
	int							nProgramCount;								// ʵ�ʵķ�������
	int							nProgram[MAX_PROGRAM_COUNT];			// ֧�ֵķ����б�
} NET_DENOISEGROUP_PROGRAM;

// 3D��������
typedef struct tagNET_SUPPORT3D_CAPS
{
	BOOL						bSupport3D;								// �Ƿ�֧��3D����
	int							n3DTypeCount;							// ֧�ֵ�3D�������͸���
	NET_EM_3DSUPPORT_TYPE		em3DSupportType[MAX_3DTYPE_COUNT];		// ֧�ֵ�3D��������
	int							n3DLevelMin;							// 3D����ȼ���Сֵ
	int							n3DLevelMax;							// 3D����ȼ����ֵ
	int							nAutoLevelMin;							// 3D�Զ�����ģʽ��Сֵ
	int							nAutoLevelMax;							// 3D�Զ�����ģʽ���ֵ
	NET_3DALGORITHM_MODE		stuAlgorithmSDMode;						// 3D����֧�ֵ��㷨ģʽ
	int							nGroupCount;							// ʵ�ʷ������
	NET_DENOISEGROUP_PROGRAM	stuDenoiseGroup[MAX_GROUP_COUNT]; 		// ������飬�л�ǰ�󷽰�����ͬһ�������������Ч������������Ч����ֵn��Ӧ, DenoiseMode��bit(n)��Ӧ�ķ���
	int							nDenoiseScheme;							// ���뷽��, 1��ʾ�����·�����ʽ���ý������,0��ʾֱ�����ò�����ʽ���ý���������ɷ�����
	BYTE						bReserved[128];							// Ԥ���ֶ�
} NET_SUPPORT3D_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_DENOISE_CAPS
{
	DWORD						dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL						bSupport;								// �Ƿ�֧�ֽ�������
	NET_SUPPORT2D_CAPS			stu2DCaps;								// 2D�������� 
	NET_SUPPORT3D_CAPS			stu3DCaps;								// 3D��������
	BOOL						bSupportAlgorithm1;						// �Ƿ�֧�ֽ����㷨1
	int							nTnfLevelRangeMin;						// ʱ��ȼ���Сֵ
	int							nTnfLevelRangeMax;						// ʱ��ȼ����ֵ
	int							nSnfLevelRangeMin;						// ����ȼ���Сֵ
	int							nSnfLevelRangeMax;						// ����ȼ����ֵ
	int							nSeniotTypeCount;						// ֧�ֵĸ߼��������͸���
	NET_EM_3DSUPPORT_TYPE		emSeniorType[MAX_3DTYPE_COUNT];		// ֧�ֵĸ߼���������
} NET_OUT_VIDEOIN_DENOISE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS �������
typedef struct tagNET_IN_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_BACKLIGHT_CAPS;

// ����ģʽ
typedef enum tagNET_EM_BACK_MODE
{
	NET_EM_BACKLIGHT_MODE_UNKNOW,					// δ֪ģʽ
	NET_EM_BACKLIGHT_MODE_OFF,						// �ر�
	NET_EM_BACKLIGHT_MODE_BACKLIGHT,				// ���ⲹ��
	NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC,				// ��̬
	NET_EM_BACKLIGHT_MODE_GLAREINHIBITION,			// ǿ������
	NET_EM_BACKLIGHT_MODE_SSA,						// ��������Ӧ
} NET_EM_BACK_MODE;

// ���ⲹ��ģʽ
typedef enum tagNET_EM_BLACKLIGHT_MODE
{
	NET_EM_BLACKLIGHT_UNKNOW,						// δ֪ģʽ
	NET_EM_BLACKLIGHT_DEFAULT,						// Ĭ��ģʽ
	NET_EM_BLACKLIGHT_REGION,						// �Զ�������ģʽ
} NET_EM_BLACKLIGHT_MODE;

// ��������Ӧ�Աȶ�ǿ�ȵ���ģʽ
typedef enum tagNET_EM_BACK_INTENSITY_MODE
{
	NET_EM_INTENSITY_UNKNOWN,			// δ֪
	NET_EM_INTENSITY_OFF,				// �ر�
	NET_EM_INTENSITY_AUTO,				// �Զ�
	NET_EM_INTENSITY_MANUAL,			// �ֶ�
} NET_EM_BACK_INTENSITY_MODE;

// ֧��ǿ������ģʽ�Ĳ������÷�ʽ
typedef enum tagNET_EM_GLAREINHIBITION_MODE
{
	NET_EM_GLAREINHIBITION_UNKNOWN,		// δ֪
	NET_EM_GLAREINHIBITION_DEFAULT,		// ��ͨģʽ(Ĭ��ֵ)
	NET_EM_GLAREINHIBITION_FPGA,		// Fpgaǿ������
} NET_EM_GLAREINHIBITION_MODE;

#define MAX_MODE_COUNT		8		// ģʽ���֧����

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD						dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL						bSupport;								// �Ƿ�֧�ֱ�����������
	int							nBackModeCount;							// ����ģʽʵ��֧������
	NET_EM_BACK_MODE			emBackMode[MAX_MODE_COUNT];				// ֧�ֵı���ģʽ
	int							nBackLightModeCount;					// ���ⲹ��ģʽʵ��֧����
	NET_EM_BLACKLIGHT_MODE		emBackLightMode[MAX_MODE_COUNT];		// ֧�ֵı��ⲹ��ģʽ
	int							nWideDynamicRange;						// �Ƿ�֧�ֿ�̬
	int							nSSAIntensity;							// ��������Ӧ�Աȶ�ǿ�ȵ���֧�ֵ�ģʽ����
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode[MAX_MODE_COUNT];		// ��������Ӧ�Աȶ�ǿ�ȵ���֧�ֵ�ģʽ
	NET_EM_GLAREINHIBITION_MODE	emGlareInhibition[MAX_MODE_COUNT];		// ֧��ǿ������ģʽ�Ĳ������÷�ʽ
} NET_OUT_VIDEOIN_BACKLIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS �������
typedef struct tagNET_IN_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_WHITEBALANCE_CAPS;

// ��ƽ��ģʽ
typedef enum tagNET_EM_WHITEBALANCE_TYPE
{
	NET_EM_WHITEBALANCE_UNKNOW,					// δ֪����
	NET_EM_WHITEBALANCE_DISABLE,				// Disable
	NET_EM_WHITEBALANCE_AUTO,					// Auto
	NET_EM_WHITEBALANCE_SUNNY,					// Sunny����,6500K����
	NET_EM_WHITEBALANCE_CLOUDY,					// Cloudy����,7500K����
	NET_EM_WHITEBALANCE_HOME,					// Home���� 5000K����
	NET_EM_WHITEBALANCE_OFFICE,					// Office�칫 4400K���� 
	NET_EM_WHITEBALANCE_NIGHT,					// Nightҹ�� 2800K����
	NET_EM_WHITEBALANCE_CUSTOM,					// Custom�Զ���
	NET_EM_WHITEBALANCE_HIGHCOLORTEMP,			// HighColorTemperature��ɫ������
	NET_EM_WHITEBALANCE_LOWCOLORTEMP,			// LowColorTemperature��ɫ������
	NET_EM_WHITEBALANCE_AUTOCOLORTEMP,			// AutoColorTemperature�Զ�ɫ������
	NET_EM_WHITEBALANCE_CUSTOMCOLORTEMP,		// CustomColorTemperature�Զ���ɫ�µȼ�
	NET_EM_WHITEBALANCE_INDOOR,					// Indoor����
	NET_EM_WHITEBALANCE_OUTDOOR,				// Outdoor����,�ص㱣֤������̲ݵز�ƫɫ
	NET_EM_WHITEBALANCE_ATW,					// ATW����
	NET_EM_WHITEBALANCE_MANUAL,					// Manual�ֶ�
	NET_EM_WHITEBALANCE_AUTOOUTDOOR,			// AutoOutdoor
	NET_EM_WHITEBALANCE_SODIUMAUTO,				// SodiumAuto�Ƶ��Զ�
	NET_EM_WHITEBALANCE_SODIUM,					// Sodium�Ƶ�, 2000K����
	NET_EM_WHITEBALANCE_MANUALDATUM,			// ManualDatum�Զ��嵥�����ƽ��
	NET_EM_WHITEBALANCE_PARTWHITEBALANCE,		// PartWhiteBalance�Զ���������ƽ��
	NET_EM_WHITEBALANCE_NATURAL,				// Natural��Ȼ��, 2000K-12000K ��������+�����賿
	NET_EM_WHITEBALANCE_STREETLAMP,				// StreetLamp·��, 1000K-5000K
} NET_EM_WHITEBALANCE_TYPE;

#define MAX_BALANCEMODES_COUNT			16		// ��ƽ��ģʽ������

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD								dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL								bSupport;								// �Ƿ�֧�ְ�ƽ������
	int									nWhiteBalance;							// ʵ��֧�ֵİ�ƽ��ģʽ����
	NET_EM_WHITEBALANCE_TYPE			emWhiteBalance[MAX_BALANCEMODES_COUNT];	// ֧�ֵİ�ƽ��ģʽ�б�
} NET_OUT_VIDEOIN_WHITEBALANCE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS �������
typedef struct tagNET_IN_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_DAYNIGHT_CAPS;

// ICR�л�����
typedef enum tagNET_EM_ICR_TYPE
{
	NET_EM_ICR_UNKONOW,			// δ֪
	NET_EM_ICR_ELECTRON,		// ����
	NET_EM_ICR_MECHANISM,		// ��е
} NET_EM_ICR_TYPE;

// ��ת��ģʽ
typedef enum tagNET_EM_COLORBLACK_MODE
{
	NET_EM_COLORBLACK_UNKNOWN,					// δ֪
	NET_EM_COLORBLACK_COLOR,					// ���ǲ�ɫ
	NET_EM_COLORBLACK_BRIGHTNESS,				// ���������Զ��л�
	NET_EM_COLORBLACK_BLACKWHITE,				// ���Ǻڰ�
	NET_EM_COLORBLACK_PHOTORESISTOR,			// �������
	NET_EM_COLORBLACK_GAIN,						// ���������л�
	NET_EM_COLORBLACK_ALARMINPUT,				// �ⲿ��������
	NET_EM_COLORBLACK_IO,						// �ⲿIO����
} NET_EM_COLORBLACK_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD						dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL						bSupport;								// �����о��ҹ��������
	int							nICRType;								// ʵ��֧�ֵ�ICR�л����͸���
	NET_EM_ICR_TYPE				emICRType[MAX_MODE_COUNT];				// ICR�л������б�
	int							nColorBlackMode;						// ʵ��֧�ֵĲ�ת��ģʽ����
	NET_EM_COLORBLACK_MODE		emColorBlackMode[MAX_MODE_COUNT];		// ֧�ֵĲ�ת��ģʽ�б�
	int							nSensitivityRangeMin;					// ��ת���������Сֵ
	int							nSensitivityRangeMax;					// ��ת����������ֵ
	int							nDelayRangeMin;							// ��ҹģʽ�л���ʱ��Сֵ
	int							nDelayRangeMax;							// ��ҹģʽ�л���ʱ���ֵ
} NET_OUT_VIDEOIN_DAYNIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS �������
typedef struct tagNET_IN_VIDEOIN_ZOOM_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_ZOOM_CAPS
{
	DWORD						dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С

	BOOL						bSupport;								// �Ƿ�֧�ֱ䱶����
	int							nSpeedRangeMin;							// �䱶������Сֵ
	int 						nSpeedRangeMax;							// �䱶�������ֵ
	BOOL						bDigitalZoomSupport;					// �Ƿ�֧�����ֱ䱶
	int							nZoomLimitRangeMin;						// ��ǰ���������䱶���޷�Χ��Сֵ	
	int							nZoomLimitRangeMax;						// ��ǰ���������䱶���޷�Χ���ֵ
} NET_OUT_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS �������
typedef struct tagNET_IN_VIDEOIN_FOCUS_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_FOCUS_CAPS;

// �۽�ģʽ
typedef enum tagNET_EM_FOCUS_MODE
{
	NET_EM_FOCUS_OFF,				// �ر�
	NET_EM_FOCUS_ASSIST,			// �����۽�
	NET_EM_FOCUS_AUTO,				// �Զ��۽�
	NET_EM_FOCUS_SEMI_AUTO,			// ���Զ��۽�
	NET_EM_FOCUS_MANUAL,			// �ֶ��۽�
} NET_EM_FOCUS_MODE;

// �۽�����ѡȡģʽ
typedef enum tagNET_EM_FOCUS_LIMITSELECT_MODE
{
	NET_EM_FOCUS_LIMITSELECT_UNKNOW,			// δ֪ģʽ
	NET_EM_FOCUS_LIMITSELECT_MANUAL,			// �ֶ�
	NET_EM_FOCUS_LIMITSELECT_AUTO,				// �Զ�
} NET_EM_FOCUS_LIMITSELECT_MODE;

// �۽�����
typedef enum tagNET_EM_FOCUS_TYPE
{
	NET_EM_FOCUS_UNKNOWN,						// δ֪����
	NET_EM_FOCUS_AUTOTRACE,						// �Զ��佹����
} NET_EM_FOCUS_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_FOCUS_CAPS
{
	DWORD							dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL							bSupport;								// �Ƿ�֧�־۽�����
	int								nFcousMode;								// ʵ��֧�ֵľ۽�ģʽ��ʽ
	NET_EM_FOCUS_MODE				emFocusMode[MAX_MODE_COUNT];			// ֧�ֵľ۽�ģʽ�б�
	int								nLimitMode;								// ʵ��֧�ֵľ۽�����ѡȡģʽ����
	NET_EM_FOCUS_LIMITSELECT_MODE	emLimitMode[MAX_MODE_COUNT];			// ֧�ֵľ۽�����ѡȡģʽ�б�
	BOOL							bSupportFocusRegion;					// �Ƿ�֧����۽�
	BOOL							bSensitivity;							// �Ƿ�֧�־۽������
	BOOL							bIRCorrection;							// �Ƿ�֧�ֺ����۽�����
	BOOL							bFocusLimit;							// �Ƿ�֧�־۽�����
	int								nFocusTypeCount;						// ʵ��֧�ֵľ۽����͸���
	NET_EM_FOCUS_TYPE				emFocusType[MAX_MODE_COUNT];			// ֧�ֵľ۽������б�
} NET_OUT_VIDEOIN_FOCUS_CAPS;

//// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS �������
typedef struct tagNET_IN_VIDEOIN_SHARPNESS_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_SHARPNESS_CAPS;

// ���ģʽ
typedef enum tagNET_EM_SHARPNESS_MODE
{
	NET_EM_SHARPNESS_AUTO,				//�Զ�
	NET_EM_SHARPNESS_MANAUL,			// �ֶ�
}NET_EM_SHARPNESS_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_SHARPNESS_CAPS
{
	DWORD						dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL						bSupport;								// �Ƿ�֧���������
	int							nSharpnessMode;							// ʵ��֧�ֵ����ģʽ����
	NET_EM_SHARPNESS_MODE		emSharpnessMode[MAX_MODE_COUNT];		// ֧�ֵ����ģʽ�б�
	int							nSharpnessMin;							// �����Сֵ
	int							nSharpnessMax;							// ������ֵ

	BOOL						bSupportRestrain;						// �Ƿ�֧���������
	int							nRestrainLevelMin;						// ������Ƶȼ���Сֵ
	int							nRestrainLevelMax;						// ������Ƶȼ����ֵ
} NET_OUT_VIDEOIN_SHARPNESS_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS �������
typedef struct tagNET_IN_VIDEOIN_COLOR_CAPS
{
	DWORD				dwSize; 								// �û�ʹ��ʱ��ֵΪ�ṹ���С
	int 				nChannel;								// ͨ����
} NET_IN_VIDEOIN_COLOR_CAPS;

// ͼ������������
typedef enum tagNET_EM_STYLE_TYPE
{
	NET_EM_STYLE_UNKONWON,			// δ֪
	NET_EM_STYLE_GENTLE,			// ���
	NET_EM_STYLE_STANDARD,			// ��׼
	NET_EM_STYLE_FLAMBOYANT,		// ����
} NET_EM_STYLE_TYPE;

// ͼ������������
typedef struct tagNET_COLOR_STYLE_CAPS
{
	BOOL				bSupport;								// �Ƿ�֧��ͼ��������
	int					nStyleType;								// ʵ��֧�ֵ�ͼ������������
	NET_EM_STYLE_TYPE	emStyleType[MAX_MODE_COUNT];			// ֧�ֵ�ͼ���������б�
	BYTE				bReserved[128];							// Ԥ���ֶ�
} NET_COLOR_STYLE_CAPS;

#define MAX_GRAYVALUE_COUNT			8  // �Ҷ�ֵ��������

// �Ҷȷ�Χ����
typedef struct tagNET_GRAY_SCALE_CAPS
{
	BOOL				bSupport;								// �Ƿ�֧�ֻҶȷ�Χ����
	int					nValueCount;							// ʵ��֧�ֵĻҶȷ�Χ����
	int					nValue[MAX_GRAYVALUE_COUNT][2];		// �Ҷȷ�Χ��������ֵ
	BYTE				bReserved[128];							// Ԥ���ֶ�
} NET_GRAY_SCALE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_COLOR_CAPS
{
	DWORD					dwSize; 							// �û�ʹ��ʱ��ֵΪ�ṹ���С
	BOOL					bSupport;							// �Ƿ�֧��ͼ����������
	BOOL					bBrightness;						// �Ƿ�֧������
	BOOL					bContrast;							// �Ƿ�֧�ֶԱȶ�
	BOOL					bSaturation;						// �Ƿ�֧�ֱ��Ͷ�
	BOOL					bHue;								// �Ƿ�֧��ɫ��
	BOOL					bGamma;								// �Ƿ�֧��Gamma
	BOOL					bChromaSuppress;					// �Ƿ�֧��ɫ������
	NET_COLOR_STYLE_CAPS	stuColorStype;						// ͼ��������
	NET_GRAY_SCALE_CAPS		stuGrayScale;						// �Ҷȷ�Χ����
} NET_OUT_VIDEOIN_COLOR_CAPS;

// CLIENT_GetDevCaps �ӿ� NET_VIDEOIN_RAWFRAME_CAPS �������
typedef struct tagNET_IN_VIDEOIN_RAWFRAME_CAPS
{
	DWORD					dwSize;
}NET_IN_VIDEOIN_RAWFRAME_CAPS;

// YUV���ݸ�ʽ������
typedef struct tagNET_RAWFRAMETYPE_DATA
{
	int						nListNum;										// ʵ�ʷ��ص����ݸ�ʽ����
	char					szList[DH_COMMON_STRING_16][DH_COMMON_STRING_8];// ֧�ֵ�YUV���ݸ�ʽ�б�
	BYTE					byReserved[1024];
}NET_RAWFRAMETYPE_DATA;

// CLIENT_GetDevCaps �ӿ� NET_VIDEOIN_RAWFRAME_CAPS �������
typedef struct tagNET_OUT_VIDEOIN_RAWFRAME_CAPS
{
	DWORD								dwSize;
	NET_RAWFRAMETYPE_DATA				stuFrameData;
}NET_OUT_VIDEOIN_RAWFRAME_CAPS;

// �¶ȵ�λ
typedef enum tagEM_TEMPERATURE_UNIT
{
	EM_TEMPERATURE_CENTIGRADE,			// ���϶�
	EM_TEMPERATURE_FAHRENHEIT,			// ���϶�
	EM_TEMPERATURE_KELVIN,				// ������
} EM_TEMPERATURE_UNIT;

#define MAX_UNIT_COUNT		8		// ���֧�ֵ����ⵥλ����

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS �������
typedef struct tagNET_OUT_FACEBOARD_CAPS
{
    DWORD               	dwSize;						            // �ýṹ���С
    BOOL                	bHasBattery;                            // �Ƿ��е��
    BOOL                	bSupportPowerVoltageDetect;             // �Ƿ�֧�ֵ�Դ��ѹ���
    BOOL					bTemperatures;							// �Ƿ�֧���¶ȴ�����
    BOOL					bOSDTemperatureUnit;					// �Ƿ�֧���¶ȵ�λѡ��
    int						nRetUnitCount;							// ʵ��֧�ֵ��¶ȵ�λ����
    EM_TEMPERATURE_UNIT		emTempreatureUnit[MAX_UNIT_COUNT];		// OSD����ʱ֧�ֵ��¶ȵ�λ
}NET_OUT_FACEBOARD_CAPS;

typedef enum tagEM_DETECT_VERSION_TYPE
{
    EM_DETECT_VERSION_UNKNOW = 0 , 
    EM_DETECT_VERSION_V1_0 ,           //��һ�涯�췽��
    EM_DETECT_VERSION_V3_0 ,           //�����涯�췽��
}EM_DETECT_VERSION_TYPE;
#define    MAX_DETECT_VERSION_NUM           64

typedef enum tagEM_BLIND_DETECT_VERSION_TYPE
{
    EM_BLIND_DETECT_VERSION_UNKNOW = 0 ,
    EM_BLIND_DETECT_VERSION_FULL_SCREEN ,   //ȫ���ڵ����
    EM_BLIND_DETECT_VERSION_MULTI_WINDOW ,  //�ര�ڼ��
}EM_BLIND_DETECT_VERSION_TYPE;
#define    MAX_BLIND_DETECT_VERSION_NUM     64

typedef struct tagNET_OUT_VIDEO_DETECT_CAPS
{
        DWORD                       dwSize;         
        BOOL                        bSupportBlind;          //�Ƿ�֧�ֺ������
        BOOL                        bSupportLoss;           //�Ƿ�֧����Ƶ��ʧ���
        BOOL                        bSupportMotion;         //�Ƿ�֧�ֶ�̬���
        BOOL                        bMotionResult;          //�Ƿ��ܹ��õ�ÿ������ļ����
        DWORD                       nMotionColumns;         //��̬������򻮷ֵ�����
        DWORD                       nMotionRows;            //��̬������򻮷ֵ�����
        DWORD                       nMotionDetectWindow;    //����֧�ֵ���Ƶ������
        DWORD                       nBlindColumns;          //��Ƶ�ڵ�������򻮷ֵ�����
        DWORD                       nBlindRows;             //��Ƶ�ڵ�������򻮷ֵ�����
        DWORD                       nBlindDetectWindow;     //��Ƶ�ڵ�֧�ֵĴ�����
        BOOL                        bPositionDetect;        //�Ƿ�֧���ƶ�λ�����
        DWORD                       nDetectVersionNum;      //֧�ֵĶ��췽����
        EM_DETECT_VERSION_TYPE      emDetectVersions[MAX_DETECT_VERSION_NUM];               //֧�ֵĶ��췽����Ϣ
        DWORD                       nBlindDetectVersionNum; //֧�ֵ���Ƶ�ڵ����汾��
        EM_BLIND_DETECT_VERSION_TYPE emBlindDetectVersions[MAX_BLIND_DETECT_VERSION_NUM];   //֧�ֵ���Ƶ�ڵ����汾��Ϣ
        BOOL                        bMotionLinkPtzPreset;   //�����Ƿ�֧��������̨Ԥ�õ�
        BOOL                        bMotionLinkPtzTour;     //�����Ƿ�֧��������̨Ѳ��
        BOOL                        bMotionLinkPtzPattern;  //�����Ƿ�֧��������̨Ѳ��
        BOOL                        bUnFocusDetect;         //�Ƿ�֧���齹���
        BOOL                        bAlarmDetect;           //�Ƿ�֧�ֶ���ͬʱ��ⱨ��������
		BOOL						bSupportMoveDetect;		// �Ƿ�֧�ֳ���������
}NET_OUT_VIDEO_DETECT_CAPS;

// �����¼�����
typedef struct tagALARM_FALLING_INFO
{
    DWORD               dwStructSize;                               // �ṹ���С
    BYTE                bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                byRserved[3];                               // ����                                                                                                                                                                                                                                                                        
}ALARM_FALLING_INFO;

//����Bus״̬�ص�����ԭ��
typedef void (CALLBACK *fBusStateCallBack)(LLONG lAttachHandle, LONG lCommand, char *pBuf, DWORD dwBufLen, LDWORD dwUser);

// ˢ������
typedef enum tagNET_DRIVER_CHECK_TYPE
{
    NET_DRIVER_CHECK_TYPE_UNKNOWN,                                  // δ֪
    NET_DRIVER_CHECK_TYPE_SIGNIN,                                   // ǩ��
    NET_DRIVER_CHECK_TYPE_SIGNOUT,                                  // ǩ��
} NET_DRIVER_CHECK_TYPE;

// ˢ����ʽ
typedef enum tagNET_DRIVER_CHECK_METHOD
{
    NET_DRIVER_CHECK_METHOD_UNKNOWN,                                // δ֪
    NET_DRIVER_CHECK_METHOD_POS,                                    // POS��
    NET_DRIVER_CHECK_METHOD_HAND,                                   // �ֶ�����
} NET_DRIVER_CHECK_METHOD;

// �����¼�����DH_ALARM_BUS_DRIVER_CHECK( ˾��ʶ�𿨼���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_DRIVER_CHECK_INFO
{
    DWORD                   dwSize;
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // ����
    char                    szDriverName[DH_COMMON_STRING_16];      // ˾������
    char                    szDriverID[DH_MAX_PERSON_ID_LEN];       // ����
    char                    szOrganize[DH_COMMON_STRING_128];       // ��ʻ֤��֤��������
    NET_TIME_EX             stUsefulLife;                           // ֤����Ч��
    NET_GPS_STATUS_INFO     stGPSStatusInfo;                        // GPS��Ϣ
    NET_TIME_EX             stCheckTime;                            // ��ʱ��
    NET_DRIVER_CHECK_METHOD emCheckMethod;                          // �򿨷�ʽ
    NET_DRIVER_CHECK_TYPE   emCheckType;                            // ������
}ALARM_BUS_DRIVER_CHECK_INFO;

// �����¼�����DH_ALARM_DEVICE_MSG_NOTIFY(�豸��ƽ̨��֪ͨ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_DEVICE_MSG_NOTIFY_INFO
{
    DWORD                   dwSize;
    char                    szMsg[DH_COMMON_STRING_256];            // ��Ϣ����
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS��Ϣ
} ALARM_DEVICE_MSG_NOTIFY_INFO;

// �����¼�����DH_ALARM_VEHICLE_STANDING_OVER_TIME(ͣ����ʱ����)��Ӧ������������Ϣ
typedef struct tagALARM_VEHICLE_STANDING_OVER_TIME_INFO
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS��Ϣ
    NET_TIME_EX             stuTime;                                // ��һ�η�����ʱ��
    NET_TIME_EX             stuUtc;                                 // �����¼�������ʱ��
    DWORD                   dwUtc;                                  // �����¼�������ʱ��, ��stuUtcֵһ��,��ʽ��ͬ,�����¼�ȷ�Ͻӿ����
    BOOL                    bEventConfirm;                          // �Ƿ���Ҫ�ظ�
} ALARM_VEHICLE_STANDING_OVER_TIME_INFO;

// ��·����
typedef enum tagNET_LINE_DIRECTION
{
    NET_LINE_DIRECTION_UNKNOWN,                                     // δ֪
    NET_LINE_DIRECTION_POSTIVE,                                     // ����
    NET_LINE_DIRECTION_NEGATIVE,                                    // ����
    NET_LINE_DIRECTION_AROUND,                                      // ����
    NET_LINE_DIRECTION_DISPERSE,                                    // ��ɢ
} NET_LINE_DIRECTION;

// ��վ��վ״̬
typedef enum tagNET_BUS_STATE
{
    NET_BUS_STATE_UNKNOWN,                                         // δ֪
    NET_BUS_STATE_ILLEGAL,                                         // �Ƿ�
    NET_BUS_STATE_LEGAL,                                           // �Ϸ�
} NET_BUS_STATE;

// ��վ��ʽ
typedef enum tagNET_PORT_TYPE
{
    NET_PORT_TYPE_UNKOWN,                                           // δ֪
    NET_PORT_TYPE_MANUAL,                                           // �ֶ���վ
    NET_PORT_TYPE_GPS,                                              // GPS��վ
} NET_PORT_TYPE;

// ���ؿ����¼�����������
typedef enum tagEM_VEHICLE_DATA_TYPE
{
    EM_VEHICLE_DOOR_OPEN_DATA_UNKNOWN = 0,
    EM_VEHICLE_DOOR_OPEN_DATA_REALTIME,                             // ʵʱ������
    EM_VEHICLE_DOOR_OPEN_DATA_HISTORY,                              // �ط�������
}EM_VEHICLE_DATA_TYPE;

// �����¼�����DH_ALARM_BUS_IMPORT_SITE(��վ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_IMPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // վ���ʶ
    DWORD                   dwSiteNum;                              // վ��
    NET_LINE_DIRECTION      emDirection;                            // ��·����
    char                    szLineID[DH_COMMON_STRING_64];          // ��·��ʶ
    NET_TIME_EX             stuTime;                                // ��վ��վʱ��
    int                     nTime;                                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    NET_BUS_STATE           emState;                                // �Ƿ񰴹涨ʱ���վ
    NET_PORT_TYPE           emType;                                 // ��վ��ʽ
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS��Ϣ
    DWORD                   dwSiteCount;                            // ��վ����
    char                    szSiteName[DH_COMMON_STRING_64];        // վ������
    char                    szDesignation[DH_COMMON_STRING_64];     // ��·����
    EM_VEHICLE_DATA_TYPE    emDataType;                             // �¼����ݵ�����
    BOOL                    bNeedConfirm;                           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
} ALARM_BUS_IMPORT_SITE_INFO;

// �����¼�����DH_ALARM_BUS_EXPORT_SITE(��վ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_EXPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // վ���ʶ
    DWORD                   dwSiteNum;                              // վ��
    NET_LINE_DIRECTION      emDirection;                            // ��·����
    char                    szLineID[DH_COMMON_STRING_64];          // ��·��ʶ
    NET_TIME_EX             stuTime;                                // ��վ��վʱ��
    int                     nTime;                                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    NET_BUS_STATE           emState;                                // �Ƿ񰴹涨ʱ����վ
    NET_PORT_TYPE           emType;                                 // ��վ��ʽ
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS��Ϣ
    DWORD                   dwSiteCount;                            // ��վ����
    char                    szSiteName[DH_COMMON_STRING_64];        // վ������
    char                    szDesignation[DH_COMMON_STRING_64];     // ��·����
    EM_VEHICLE_DATA_TYPE    emDataType;                             // �¼����ݵ�����
    BOOL                    bNeedConfirm;                           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
} ALARM_BUS_EXPORT_SITE_INFO;

// �쳣�¼�����
typedef enum tagEM_ALARM_BUS_ABNORMAL_EVENT_TYPE
{
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_UNKNOWN,           // δ֪
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RUNNING,           // �ָ�Ӫ��,"Running"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MEAL,              // �Է�,"Meal"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BLOCK,             // ·��,"Block"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CALL,              // ͨ��,"Call"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BREAKDOWN,         // ����,"Breakdown"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISCONTINUED,      // ֹͣӪ��,"Discontinued"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ROBING,            // ����,"Robing"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERLOAD,          // ����,"Overload"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISPUTE,           // ����,"Dispute"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ACCIDENT,          // �¹�,"Accident"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERSPEED,         // ����,"OverSpeed"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RENTAL,            // ����,"Rental"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MAINTENANCE,       // ����,"Maintenance"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CLOSURE,           // �ѱ�ͣ��,"Closure"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_PUBSECURITY,       // �ΰ��¼�, "PubSecurity"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ENTER_PARK,        // ����ͣ����, "EnterPark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_LEAVE_PARK,        // �뿪ƽ����, "LeavePark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_REFUEL,            // ����, "Refuel"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_FIRE,              // ���ֱ���, "Fire"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_HELP,              // �˿;���, "Help"
}EM_ALARM_BUS_ABNORMAL_EVENT_TYPE;

// �����¼�����DH_ALARM_BUS_ABNORMAL(�����쳣�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_ABNORMAL_INFO
{
    DWORD                                   dwSize;
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE        emEventType;                            // �쳣�¼�����
    char                                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // ����
    char                                    szLineID[DH_COMMON_STRING_64];          // ��·��ʶ
    NET_LINE_DIRECTION                      emLineDirection;                        // ��·����
    NET_TIME_EX                             stuTime;                                // ����ʱ��
    NET_GPS_STATUS_INFO                     stuGPSStatusInfo;                       // GPS��Ϣ
} ALARM_BUS_ABNORMAL_INFO;

// �����¼�����DH_ALARM_ENCLOSURE_ALARM(����Χ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_ENCLOSURE_ALARM_INFO
{
    DWORD                   dwSize;
    DWORD                   dwAlarmType;                            // ��������, ��λ�ֱ��ʾ,
                                                                    // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
    DWORD                   dwAlarmDetail;                          // ��������, ��λ�ֱ��ʾ,
                                                                    // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
    NET_BUS_STATE           emState;                                // �Ƿ񰴹涨ʱ�䴥���¼�
    DWORD                   dwDriverNo;                             // ˾�����
    DWORD                   dwEnclosureID;                          // Χ��ID
    DWORD                   dwLimitSpeed;                           // ����
    DWORD                   dwCurrentSpeed;                         // ��ǰ�ٶ�
    NET_TIME_EX             stuTime;                                // ��ǰʱ��
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS��Ϣ
} ALARM_ENCLOSURE_ALARM_INFO;

// ���ص��ŵ�״̬
typedef NET_ACCESS_CTL_STATUS_TYPE NET_VEHICLE_DOOR_STATUS;

// ���ؿ����¼�, ��Ӧ�¼����� DH_VEHICLE_DOOR_OPEN
typedef struct tagALARM_VEHICLE_DOOR_OPEN_INFO 
{
    DWORD                       dwSize;
    NET_VEHICLE_DOOR_STATUS     emStatus;               // ��״̬
    int                         nDoor;                  // �����, 1:ǰ��,2:����,3:����
    NET_TIME                    stuTime;                // �¼�ʱ��, UTC��
    int                         nTime;                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS��Ϣ
    EM_VEHICLE_DATA_TYPE        emDataType;             // �¼����ݵ�����
    BOOL                        bNeedConfirm;           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
}ALARM_VEHICLE_DOOR_OPEN_INFO;

// ��ǰ����¼�, ��Ӧ�¼����� DH_ALARM_BUS_CUR_MILEAGE
typedef struct tagALARM_BUS_CUR_MILEAGE_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
    int                         nTime;                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    EM_VEHICLE_DATA_TYPE        emDataType;             // �¼����ݵ�����
    NET_TIME                    stuTime;                // �¼�ʱ��, UTC��
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    NET_TIME                    stuStartTime;           // ��ǰʱ��εĿ�ʼʱ��, UTC��
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // ��ǰʱ��εĿ�ʼʱ��ʱ��GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    unsigned int                nMileage;               // ��ǰʱ��ε������, ��λ:0.1km
}ALARM_BUS_CUR_MILEAGE_INFO;

// ��ǰ�ͺ�����¼�, ��Ӧ�¼����� DH_ALARM_BUS_CUR_OIL
typedef struct tagALARM_BUS_CUR_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
    int                         nTime;                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    EM_VEHICLE_DATA_TYPE        emDataType;             // �¼����ݵ�����
    NET_TIME                    stuTime;                // �¼�ʱ��, UTC��
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    NET_TIME                    stuStartTime;           // ��ǰʱ��εĿ�ʼʱ��, UTC��
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // ��ǰʱ��εĿ�ʼʱ��ʱ��GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    unsigned int                nCurOil;                // ��ǰ����, ��λ: 0.1L
    unsigned int                nOilTankage;            // �����ݻ�, ��λ: 0.1L
    int                         nOilChange;             // ��ǰʱ����������仯, ��λ: 0.1L, ������ʾ����, ������ʾ����
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // ������Ϣ
}ALARM_BUS_CUR_OIL_INFO;

// �����������¼�, ��Ӧ�¼����� DH_ALARM_BUS_LOW_OIL
typedef struct tagALARM_BUS_LOW_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
    int                         nTime;                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    EM_VEHICLE_DATA_TYPE        emDataType;             // �¼����ݵ�����
    NET_TIME                    stuTime;                // �¼�ʱ��, UTC��
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    unsigned int                nCurOil;                // ��ǰ����, ��λ: 0.1L
    unsigned int                nOilLine;               // ������ֵ, ��λ: 0.1L
    unsigned int                nOilTankage;            // �����ݻ�, ��λ: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // ������Ϣ
}ALARM_BUS_LOW_OIL_INFO;

// ͵�ͱ����¼�, ��Ӧ�¼����� DH_ALARM_BUS_STEAL_OIL
typedef struct tagALARM_BUS_STEAL_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // �Ƿ���Ҫȷ��, ͨ������CLIENT_BusConfirmEvent�ӿ�ȷ��
    int                         nTime;                  // ����ȷ���¼��õ�ʱ��, UTC��, ��λΪ��
    EM_VEHICLE_DATA_TYPE        emDataType;             // �¼����ݵ�����
    NET_TIME                    stuTime;                // �¼�ʱ��, UTC��
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS��Ϣ, ֻ�о�γ�ȡ��ٶȡ�������ֶ���Ч
    unsigned int                nCurOil;                // ��ǰ����, ��λ: 0.1L
    unsigned int                nOilTankage;            // �����ݻ�, ��λ: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // ������Ϣ
}ALARM_BUS_STEAL_OIL_INFO;

// ����Bus״̬����νṹ
typedef struct tagNET_IN_BUS_ATTACH
{
    DWORD                   dwSize;
    fBusStateCallBack       cbBusState;                             // ״̬�ص�����
    LDWORD                  dwUser;                                 // �û�����
}NET_IN_BUS_ATTACH;

// ����Bus״̬����νṹ
typedef struct tagNET_OUT_BUS_ATTACH
{
    DWORD                dwSize;
}NET_OUT_BUS_ATTACH;

// ��չģ�鱨��ͨ����Ϣ
typedef struct tagNET_EXALARMCHANNELS_INFO
{
    DWORD           dwSize;
    int             nExAlarmBoxNum;                                 // ��չ������ͨ����
    int             nChannelNum;                                    // ��ͨ������չ�������ϵ�ͨ����
    char            szChannelName[DH_MAX_EXALARMCHANNEL_NAME_LEN];  // ����ͨ������
} NET_EXALARMCHANNELS_INFO;

// CLIENT_QueryDevState �ӿ��������
typedef struct tagNET_EXALARMCHANNELS
{
    DWORD                       dwSize;
    int                         nExAlarmInCount;                    // ��չģ�鱨������ͨ������,���û�ָ����ѯ����
    int                         nRetExAlarmInCount;                 // ��չģ�鱨������ͨ�����ظ���
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmInInfo;                  // ��չģ�鱨������ͨ����Ϣ
																	// ���û������ڴ棬��СΪsizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmInCount
    int                         nExAlarmOutCount;                   // ��չģ�鱨�����ͨ������,���û�ָ����ѯ����
    int                         nRetExAlarmOutCount;                // ��չģ�鱨�����ͨ�����ظ���
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmOutInfo;                 // ��չģ�鱨�����ͨ����Ϣ
																	// ���û������ڴ棬��СΪsizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmOutCount
} NET_EXALARMCHANNELS;

// ����ķ�����Ϣ
typedef struct tagNET_ACTIVATEDDEFENCEAREA_INFO
{
    DWORD                       dwSize;
    int                         nChannel;                           // ����ͨ����
    NET_TIME                    stuActivationTime;                  // ��������ʱ�� 
}NET_ACTIVATEDDEFENCEAREA_INFO;
// CLIENT_QueryDevState �ӿ��������
typedef struct tagNET_ACTIVATEDEFENCEAREA
{
    DWORD                       dwSize;
    int                         nAlarmInCount;                      // ��ѯ���ر�������ͨ���������,���û�ָ������
    int                         nRetAlarmInCount;                   // ���ر�������ͨ��ʵ�ʼ������
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuAlarmInDefenceAreaInfo;      // ���ر�������ͨ����Ϣ
																	// ���û������ڴ棬��СΪsizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nAlarmInCount
    int                         nExAlarmInCount;                    // ��ѯ��չģ�鱨������ͨ������,���û�ָ������
    int                         nRetExAlarmInCount;                 // ��չģ�鱨������ͨ��ʵ�ʼ������
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuExAlarmInDefenceAreaInfo;    // ��չģ�鱨������ͨ����Ϣ
																	// ���û������ڴ棬��СΪsizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nExAlarmInCount
}NET_ACTIVATEDDEFENCEAREA;

// �Ž�״̬����
typedef enum tagEM_NET_DOOR_STATUS_TYPE
{
    EM_NET_DOOR_STATUS_UNKNOWN,
    EM_NET_DOOR_STATUS_OPEN,                            // �Ŵ�
    EM_NET_DOOR_STATUS_CLOSE,                           // �Źر�
    EM_NET_DOOR_STATUS_BREAK,                           // ���쳣��
}EM_NET_DOOR_STATUS_TYPE;

// �Ž�״̬��Ϣ(CLIENT_QueryDevState �ӿ��������)
typedef struct tagNET_DOOR_STATUS_INFO
{
    DWORD                       dwSize;
    int                         nChannel;               // �Ž�ͨ����
    EM_NET_DOOR_STATUS_TYPE     emStateType;            // �Ž�״̬��Ϣ
}NET_DOOR_STATUS_INFO;

// CLIENT_QueryRecordCount�ӿ��������
typedef struct _NET_IN_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // �ṹ���С
    LLONG                       lFindeHandle;           // ��ѯ���
}NET_IN_QUEYT_RECORD_COUNT_PARAM;

// CLIENT_QueryRecordCount�ӿ��������
typedef struct _NET_OUT_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // �ṹ���С
    int                         nRecordCount;           // �豸���صļ�¼����
}NET_OUT_QUEYT_RECORD_COUNT_PARAM;

// ģ������������ͨ����Ϣ
typedef struct tagNET_ANALOGALARM_CHANNELS_INFO 
{
    DWORD               dwSize;
    int                 nSlot;										// ����ַ, 0��ʾ����ͨ��, 1��ʾ�����ڵ�һ�������ϵ���չͨ��, 2��3...�Դ�����
    int                 nLevel1;									// ��һ��������ַ, ��ʾ�����ڵ�nSlot�����ϵĵ�nLevel1��̽����, ��0��ʼ
    int                 nLevel2;									// �ڶ���������ַ, ��ʾ�����ڵ�nLevel1�ڵ��ϵĵ�nLevel2��̽����,��0��ʼ,-1��ʾ�����ڸýڵ�
    char                szName[DH_COMMON_STRING_128];				// ͨ������
	char				szSenseMethod[DH_COMMON_STRING_32];			// ��������Ӧ��ʽ
	BYTE				byIsNull;									// �жϸ�ͨ���Ƿ��ÿգ�0Ϊδ���ã�1Ϊ����
}NET_ANALOGALARM_CHANNELS_INFO;

// ģ������������ͨ��ӳ���ϵ(��ӦDH_DEVSTATE_ANALOGALARM_CHANNELS����)
typedef struct tagNET_ANALOGALARM_CHANNELS 
{
    DWORD                          dwSize;	
    int                            nMaxAnalogAlarmChannels;						// ���ͨ����
    int                            nRetAnalogAlarmChannels;						// ���ص�ͨ����
    NET_ANALOGALARM_CHANNELS_INFO* pstuChannelInfo;								// ͨ����Ϣ,�û������ڴ�,��СΪsizeof(NET_ANALOGALARM_CHANNELS_INFO)*nMaxAnalogAlarmChannels
	int							   nVideoChannel;								// ָ����Ƶͨ����
}NET_ANALOGALARM_CHANNELS;

// ������������Ϣ
typedef struct tagNET_ANALOGALARM_SENSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ͨ����(��0��ʼ)
    NET_SENSE_METHOD        emSense;                        // ����������
    float                   fData;                          // ��������ֵ
    NET_TIME                stuTime;                        // �ɼ�ʱ��
    int                     nStatus;                        // ����״̬, -1:δ֪,0:����,1:������Ч(��������),
                                                            // 2:������ֵ1,3:������ֵ2,4:������ֵ3,5:������ֵ4,
                                                            // 6:������ֵ1,7:������ֵ2,8:������ֵ3,9:������ֵ4
    NET_GPS_STATUS_INFO     stuGpsSatus;                    // GPS״̬
    int                     nUint;                          // ��������ֵ�ĵ�λ,�� emSense Ϊ����ֵʱ��Ч��
                                                            // NET_SENSE_TEMP,��ʱ��ȡֵ�� NET_TEMPERATURE_UNIT
	int						nVideoChannel;					// ��Ƶͨ����
}NET_ANALOGALARM_SENSE_INFO;

//����ģ��������ͨ�����ݻص�����ԭ��
typedef void (CALLBACK *fAnalogAlarmDataCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachAnalogAlarmData()�ӿ��������
typedef struct tagNET_IN_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelId;                 // ��0��ʼ, -1��ʾȫ��ͨ��
    fAnalogAlarmDataCallBack    cbCallBack;                 // ���ݻص�����
    LDWORD                      dwUser;                     // �û��������
	
}NET_IN_ANALOGALARM_DATA;

// CLIENT_AttachAnalogAlarmData()�ӿ��������
typedef struct tagNET_OUT_ANALOGALARM_DATA 
{
    DWORD    dwSize;
}NET_OUT_ANALOGALARM_DATA;

// ���ļ�¼����ӿ���ض���
#define DH_MAX_RECORD_INSERT_NUM                            128
#define DH_MAX_RECORD_DELETE_NUM                            128
#define DH_MAX_RECORD_UPDATE_NUM                            128

typedef struct tagNET_RECORDUPDATER_INFO
{
    DWORD                       dwSize;
    int                         nInsertNum;                                     // ��¼��Ϣ��,����ļ�¼����
    int                         nInsertNumberList[DH_MAX_RECORD_INSERT_NUM];    // ��ʾ�����ļ�¼������            
    int                         nDeleteNum;                                     // ��¼��Ϣ��,ɾ���ļ�¼����
    int                         nDeleteNumberList[DH_MAX_RECORD_DELETE_NUM];    // ��ʾɾ���ļ�¼������,-1��ʾɾ�����м�¼         
    int                         nUpdateNum;                                     // ��¼��Ϣ��,���µļ�¼����
    int                         nUpdateNumberList[DH_MAX_RECORD_UPDATE_NUM];    // ��ʾ���µļ�¼������          
}NET_RECORDUPDATER_INFO;

//���ļ�¼����ӿ�
typedef void (CALLBACK *fRecordUpdaterCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_RECORDUPDATER_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordUpdater()�ӿ��������
typedef struct tagNET_IN_RECORDUPDATER_DATA
{
    DWORD                       dwSize;
    EM_NET_RECORD_TYPE          emType;                     // ��¼����Ϣ����
    fRecordUpdaterCallBack      cbRecordUpdater;                 // ��¼���»ص�����
    LDWORD                      dwUser;                     // �û��������
}NET_IN_RECORDUPDATER_DATA;

// CLIENT_AttachRecordUpdater()�ӿ��������
typedef struct tagNET_OUT_RECORDUPDATER_DATA
{
    DWORD                       dwSize;
}NET_OUT_RECORDUPDATER_DATA;

// ��ѯ�豸֧�ֵĴ������豸���� 
// CLIENT_QueryDevState�ӿڵ� DH_DEVSTATE_GET_SENSORLIST  �������
#define MAX_SUPPORT_SENSORTYPE_NUM    128                   // ���֧�ִ������豸���͸���

typedef struct tagNET_SENSOR_LIST 
{
    DWORD       dwSize;
    int         nSupportSensorNum;                          // ����֧�ִ������豸���͸���
    char        szSensorList[MAX_SUPPORT_SENSORTYPE_NUM][DH_COMMON_STRING_64];
}NET_SENSOR_LIST;

// CLIENT_QueryDevLogCount��ȡ��־�����������
typedef struct tagNET_IN_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    QUERY_DEVICE_LOG_PARAM      stuQueryCondition;          // ��ѯ��¼������
} NET_IN_GETCOUNT_LOG_PARAM;

// CLIENT_QueryDevLogCount��ȡ��־�����������
typedef struct tagNET_OUT_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    int                         nLogCount;                  // ��־��(�豸����)
} NET_OUT_GETCOUNT_LOG_PARAM;


// SDKȫ����־��ӡ��Ϣ
typedef struct tagLogSetPrintInfo
{
    DWORD           dwSize;
    BOOL            bSetFilePath;                           // �Ƿ�������־·��
    char            szLogFilePath[MAX_LOG_PATH_LEN];        // ��־·��(Ĭ��"./sdk_log/sdk_log.log")
    BOOL            bSetFileSize;                           // �Ƿ�������־�ļ���С
    unsigned int    nFileSize;                              // ÿ����־�ļ��Ĵ�С(Ĭ�ϴ�С10240), ��λ:����
    BOOL            bSetFileNum;                            // �Ƿ�������־�ļ�����
    unsigned int    nFileNum;                               // �ƽ���־�ļ�����(Ĭ�ϴ�С10)
    BOOL            bSetPrintStrategy;                      // �Ƿ�������־��ӡ�������
    unsigned int    nPrintStrategy;                         // ��־�������, 0:������ļ�(Ĭ��); 1:���������
}LOG_SET_PRINT_INFO;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network ��������˽���� begin
//////////////////////////////////////////////////////////////////////////

// �����豸����
typedef enum tagNET_WIRELESS_DEVICE_TYPE
{
    NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0,               
    NET_WIRELESS_DEVICE_TYPE_KEYBOARD,          // ���߼���
    NET_WIRELESS_DEVICE_TYPE_DEFENCE,           // ���߷��� 
    NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL,     // ����ң�� 
    NET_WIRELESS_DEVICE_TYPE_MAGNETOMER,        // �����Ŵ�
	NET_WIRELESS_DEVICE_TYPE_ALARMBELL,			// ���߾���
	NET_WIRELESS_DEVICE_TYPE_SWITCHER,          // ���߲���
    NET_WIRELESS_DEVICE_TYPE_SMARTLOCK,         // ����������
    NET_WIRELESS_DEVICE_TYPE_REPEATER,          // �����м���
} NET_WIRELESS_DEVICE_TYPE;

// �����豸����ģʽ
typedef enum tagEM_WIRELESS_DEVICE_MODE
{
    EM_WIRELESS_DEVICE_MODE_UNKNOWN = 0,                // ģʽδʶ��
    EM_WIRELESS_DEVICE_MODE_NORMAL,                     // Normal ��ͨģʽ 
    EM_WIRELESS_DEVICE_MODE_POLLING,                    // Polling Ѳ��ģʽ ֻ��TypeΪRemoteControlʱ���ܴ���Ѳ��ģʽ
} EM_WIRELESS_DEVICE_MODE;

// ��������ʽ
typedef enum tagEM_CODEID_SENSE_METHOD_TYPE
{
    EM_CODEID_SENSE_METHOD_TYPE_UNKOWN,         // δ֪��
    EM_CODEID_SENSE_METHOD_TYPE_DOOR_MAGNETISM, // �Ŵ�
    EM_CODEID_SENSE_METHOD_TYPE_GAS_SENSOR,     // ȼ������
    EM_CODEID_SENSE_METHOD_TYPE_CURTAIN_SENSOR, // Ļ��������
    EM_CODEID_SENSE_METHOD_TYPE_MOBILE_SENSOR,  // �ƶ�������
    EM_CODEID_SENSE_METHOD_TYPE_PASSIVEINFRA,   // �������⴫����
    EM_CODEID_SENSE_METHOD_TYPE_URGENCY_BUTTON, // ���ť
    EM_CODEID_SENSE_METHOD_TYPE_SMOKING_SENSOR, // ��������
    EM_CODEID_SENSE_METHOD_TYPE_DOUBLEMETHOD,   // ˫��������(����+΢��)
    EM_CODEID_SENSE_METHOD_TYPE_WATER_SENSOR,   // ˮ��������
    EM_CODEID_SENSE_METHOD_TYPE_THREEMETHOD,    // ������
}EM_CODEID_SENSE_METHOD_TYPE;

#define DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN 32    // �����豸���к���󳤶�

// ������Ϣ
typedef struct tagNET_CODEID_INFO
{
    DWORD                       dwSize;
    TP_U64                      nWirelessId;                        // ����ID��
    NET_WIRELESS_DEVICE_TYPE    emType;                             // �����豸����
    char                        szName[DH_USER_NAME_LENGTH];        // �û���
    BOOL                        bEnable;                            // �Ƿ������˴��豸
    char                        szCustomName[DH_COMMON_STRING_64];  // �Զ�������
    int                         nChannel;                           // ���߷�����alarmͨ����,Alarm���õ��±�,ֻ��TypeΪDefenceʱ���ֶβ���Ч��
    EM_WIRELESS_DEVICE_MODE     emMode;                             // �����豸����ģʽ
    EM_CODEID_SENSE_METHOD_TYPE emSenseMethod;                      // ��������ʽ
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // �����豸���к�
}NET_CODEID_INFO;

// �����������
typedef enum tagNET_CODEID_ERROR_TYPE
{   
    NET_CODEID_ERROR_TYPE_RIGHT = 0,            // ������ȷ
    NET_CODEID_ERROR_TYPE_ALREADYEXIST,         // �Ѿ�����
    NET_CODEID_ERROR_TYPE_OTHER,                // ��������
} NET_CODEID_ERROR_TYPE;

// �������߶�����Ϣ�ص�����ԭ��,lAttachHandle��CLIENT_AttachLowRateWPAN����ֵ
typedef void (CALLBACK *fAttachLowRateWPANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CODEID_INFO* stuBuf, NET_CODEID_ERROR_TYPE emError, LDWORD dwUser);

// CLIENT_AttachLowRateWPAN()�������
typedef struct tagNET_IN_ATTACH_LOWRATEWPAN
{
    DWORD                   dwSize;
    fAttachLowRateWPANCB    cbAttachLowRateWPANCB;         // �������ݻص�
    LDWORD                  dwUser;                        // �û�����
}NET_IN_ATTACH_LOWRATEWPAN;

// CLIENT_AttachLowRateWPAN()�������
typedef struct tagNET_OUT_ATTACH_LOWRATEWPAN
{
    DWORD               dwSize;
}NET_OUT_ATTACH_LOWRATEWPAN;

// ɾ��ָ�������豸
// CLIENT_ControlDevice�ӿڵ� DH_CTRL_LOWRATEWPAN_REMOVE�������
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVE
{
    DWORD                   dwSize;
    TP_U64                  nWirelessId;                // �����豸ID
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // �����豸���к� ���߶�������������кŵķ�ʽ                                                                                        
}NET_CTRL_LOWRATEWPAN_REMOVE;

// ɾ��ȫ�������豸
// CLIENT_ControlDevice�ӿڵ� DH_CTRL_LOWRATEWPAN_REMOVEALL�������
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVEALL
{
    DWORD                   dwSize;
}NET_CTRL_LOWRATEWPAN_REMOVEALL;

// �޸������豸��Ϣ
// CLIENT_ControlDevice�ӿڵ� DH_CTRL_LOWRATEWPAN_MODIFY�������
typedef struct tagNET_CTRL_LOWRATEWPAN_MODIFY
{
    DWORD                   dwSize;
    NET_CODEID_INFO         stuCodeIDInfo;          // ����CodeIDInfo�е�CodeID,�޸���User��Enable��Ϣ,���������޸�
}NET_CTRL_LOWRATEWPAN_MODIFY;

//����̽�����Ĺ���ģʽ
//CLIENT_ControlDevice�ӿڵ� DH_CTRL_LOWRATEWPAN_SETWORKMODE�������
typedef struct tagNET_IN_CTRL_LOWRATEWPAN_SETWORKMODE
{
	DWORD                   dwSize;
	int                     nMode;                 		//����ģʽ 0 :ʡ��ģʽ,  1 :������ģʽ

}NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE;

// ����״̬
typedef enum tagEM_CARPASS_STATUS
{
	EM_CARPASS_STATUS_UNKNOWN,     // δ֪״̬     
	EM_CARPASS_STATUS_CARPASS,     // ����״̬
	EM_CARPASS_STATUS_NORMAL,      // �޳�״̬
}EM_CARPASS_STATUS;

// ����ͣ����Ϣ,��ӦDH_CTRL_SET_PARK_INFO�������
typedef struct tagNET_CTRL_SET_PARK_INFO
{
	DWORD				   dwSize;
	char				   szPlateNumber[MAX_PLATE_NUMBER_LEN];         // ���ƺ���
	unsigned int		   nParkTime;									// ͣ��ʱ��,��λ:����
	char				   szMasterofCar[MAX_MASTER_OF_CAR_LEN];		// ��������
	char				   szUserType[MAX_USER_TYPE_LEN];				// �û�����,��ͨ��,���ڳ����ץ��һ���
																		// monthlyCardUser��ʾ�¿��û�,yearlyCardUser��ʾ�꿨�û�,longTimeUser��ʾ�����û�/VIP,casualUser��ʾ��ʱ�û�/Visitor
	unsigned int		   nRemainDay;									// ��������
	char				   szParkCharge[MAX_PARK_CHARGE_LEN];			// ͣ����
	unsigned int		   nRemainSpace;								// ͣ������λ��
	unsigned int		   nPassEnable;									// 0:��������ͨ�� 1:������ͨ��
	NET_TIME			   stuInTime;									// �����볡ʱ��
	NET_TIME			   stuOutTime;									// ��������ʱ��
	EM_CARPASS_STATUS	   emCarStatus;									// ����״̬
	char				   szCustom[MAX_CUSTOM_LEN];					// �Զ�����ʾ�ֶΣ�Ĭ�Ͽ� 
	char				   szSubUserType[MAX_SUB_USER_TYPE_LEN];		// �û����ͣ�szUserType�ֶΣ��������� 
	char				   szRemarks[MAX_REMARKS_LEN];					// ��ע��Ϣ
}NET_CTRL_SET_PARK_INFO;

// �����ǰʱ���������ͳ����Ϣ, ���´�0��ʼ����
//CLIENT_ControlDevice�ӿڵ� DH_CTRL_CLEAR_SECTION_STAT�������
typedef struct tagNET_CTRL_CLEAR_SECTION_STAT_INFO
{
	DWORD                   dwSize;
	int						nChannel;		// ��Ƶͨ����
} NET_CTRL_CLEAR_SECTION_STAT_INFO;

// ��ȡ����ɹ���������
typedef struct tagNET_GET_CODEID_COUNT
{
    DWORD               dwSize;
    int                 nCodeIDCount;       // ����ɹ���������
}NET_GET_CODEID_COUNT;

// ��ȡ������Ϣ
typedef struct tagNET_GET_CODEID_LIST
{
    DWORD               dwSize;
    int                 nStartIndex;            // ��ʼ��������,��ʼ��һ�β�ѯ����Ϊ0
    int                 nQueryNum;              // ���λ�ȡ�Ķ�������,��ֵС�ڵ�����������nMaxPageSize�ֶε�ֵ
    int                 nRetCodeIDNum;          // ʵ�ʷ��صĶ�������
    NET_CODEID_INFO*    pstuCodeIDInfo;         // ��ȡ���������,�ڴ����û�����,����С��nQueryNum*sizeof(NET_CODEID_INFO)
}NET_GET_CODEID_LIST;

// ���Ӷ�����Ϣ 
typedef struct tagNET_CTRL_LOWRATEWPAN_ADD
{
	DWORD dwSize;
	NET_CODEID_INFO stuCodeIDInfo;             // ��������
}NET_CTRL_LOWRATEWPAN_ADD;

// �����豸����״̬ 
typedef enum tagEM_WIRELESS_DEVICE_ONLINE_STATE
{   
    EM_WIRELESS_DEVICE_STATE_UNKNOWN = 0,       // δ֪
    EM_WIRELESS_DEVICE_STATE_OUTLINE,           // ����
    EM_WIRELESS_DEVICE_STATE_ONLINE,            // ����
} EM_WIRELESS_DEVICE_ONLINE_STATE;

// �����豸����״̬
typedef enum tagEM_WIRELESS_DEVICE_POWER_STATE
{   
    EM_WIRELESS_DEVICE_POWER_UNKNOWN = 0,      // ����δ֪
    EM_WIRELESS_DEVICE_POWER_NORMAL,           // ��������
    EM_WIRELESS_DEVICE_POWER_LOW,              // �͵���
} EM_WIRELESS_DEVICE_POWER_STATE;

// �����豸״̬��Ϣ
typedef struct tagNET_WIRELESS_DEVICE_INFO
{
    char                            szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // �豸���к� 
    EM_WIRELESS_DEVICE_ONLINE_STATE emOnlineState; // ����״̬
    EM_WIRELESS_DEVICE_POWER_STATE  emPowerState;  // ����״̬  
    BYTE                            byReserved[128]; // �����ֶ�
}NET_WIRELESS_DEVICE_INFO;

// ��ȡ�����豸״̬
typedef struct tagNET_GET_WIRELESS_DEVICE_STATE
{
    DWORD               dwSize;
    int                 nStartIndex;           // ��ʼ��������,��ʼ��һ�β�ѯ����Ϊ0, ���û�����
    int                 nQueryNum;             // ���λ�ȡ���豸״̬����, ��ֵС�ڵ�����������nMaxPageSize�ֶε�ֵ, �û�����
    int                 nRetQueryNum;          // ��ȡ����ʵ�ʷ��ص��豸״̬����, С�ڵ���nQueryNum
    NET_WIRELESS_DEVICE_INFO *pstuDeviceInfo;  // ��ȡ�豸״̬������, �ڴ����û�����, ����С��nQueryNum*sizeof(NET_WIRELESS_DEVICE_INFO)
}NET_GET_WIRELESS_DEVICE_STATE;

// �����Դ״̬
typedef enum tagEM_REDUNDANCE_POWER_STATE
{   
    EM_REDUNDANCE_POWER_STATE_UNKNOWN = 0,       // ״̬δ֪
    EM_REDUNDANCE_POWER_STATE_ON,                // ��
    EM_REDUNDANCE_POWER_STATE_OFF,               // �ر�
    EM_REDUNDANCE_POWER_STATE_ON_FAULT,          // ����
} EM_REDUNDANCE_POWER_STATE;

#define MAX_REDUNDANCE_POWER_NUM 16              // ��������Դ����

// ��ȡ�����Դ��Ϣ
typedef struct tagNET_GET_REDUNDANCE_POWER_INFO
{
    DWORD                     dwSize;                                   // �ṹ���С
    int                       nPowerNum;                                // ��Դ����
    EM_REDUNDANCE_POWER_STATE emPowerState[MAX_REDUNDANCE_POWER_NUM];   // ��Դ״̬��Ϣ����
}NET_GET_REDUNDANCE_POWER_INFO;

// �����ʼ�, CLIENT_ControlDeviceEx ��� ��Ӧ DH_CTRL_TEST_MAIL
typedef struct tagNET_IN_TEST_MAIL
{
    DWORD dwSize;
}NET_IN_TEST_MAIL;

// �����ʼ�, CLIENT_ControlDeviceEx ���� ��Ӧ DH_CTRL_TEST_MAIL
typedef struct tagNET_OUT_TEST_MAIL
{
    DWORD dwSize;
}NET_OUT_TEST_MAIL;

// �������ܿ���, CLIENT_ControlDeviceEx ��� ��Ӧ DH_CTRL_CONTROL_SMART_SWITCH
typedef struct tagNET_IN_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // �豸���к� 
    BOOL                        bEnable; // TRUE - ��, FALSE - ��
    int                         nDelayTime; // ��ʱʱ��, ����0ʱ����ʾ�����򿪻�ر�. unit: min
}NET_IN_CONTROL_SMART_SWITCH;

// �������ܿ���, CLIENT_ControlDeviceEx ���� ��Ӧ DH_CTRL_CONTROL_SMART_SWITCH
typedef struct tagNET_OUT_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
}NET_OUT_CONTROL_SMART_SWITCH;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network ��������˽���� end
//////////////////////////////////////////////////////////////////////////

// ģ����ͨ�����ݲ�ѯ(��Ӧ DH_DEVSTATE_ANALOGALARM_DATA ����)
typedef struct tagNET_GET_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int							nChannelID;     // ����ѯ��ģ����ͨ����(��0��ʼ)
    NET_ANALOGALARM_SENSE_INFO  stuInfo;        // ��õ�ģ����ͨ������
}NET_GET_ANALOGALARM_DATA;

// �����ƺ����ݲɼ��豸���豸����
typedef enum tagEM_NET_SCADA_DEV_TYPE
{
    EM_NET_SCADA_DEV_TYPE_UNKNOWN = 0,                         // δ֪
    EM_NET_SCADA_DEV_TYPE_ALL,                                 // ���������豸
    EM_NET_SCADA_DEV_TYPE_UPS,                                 // UPS
} EM_NET_SCADA_DEV_TYPE;

// �����ƺ����ݲɼ��豸�ĵ�λ��·����Ϣ�������, ��ѯ����
typedef struct tagNET_IN_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    char                            szDevType[DH_COMMON_STRING_64]; // �豸����
}NET_IN_SCADA_POINT_LIST_INFO;

#define MAX_SCADA_POINT_LIST_INDEX          8               // ���SCADADev�����±����, �����ͨ��

// ��λ��·����Ϣ
typedef struct tagNET_SCADA_POINT_LIST
{
    DWORD                           dwSize;
    int                             nIndexValidNum;         // ��Ч�������±����
    int                             nIndex[MAX_SCADA_POINT_LIST_INDEX];// SCADADev�����±�ֵ, ��0��ʼ
    char                            szPath[DH_COMMON_STRING_256];// ��������·��
}NET_SCADA_POINT_LIST;

#define MAX_SCADA_POINT_LIST_INFO_NUM       256               // ����λ��·������
#define MAX_SCADA_POINT_LIST_ALARM_INFO_NUM 256				  // ����λ��������

// �����ƺ����ݲɼ��豸�ĵ�λ��·����Ϣ�������, ��ѯ���
typedef struct tagNET_OUT_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    int                             nList;                  // ��Ч��λ��·����Ϣ����
    NET_SCADA_POINT_LIST            stuList[MAX_SCADA_POINT_LIST_INFO_NUM];// ��λ��·����Ϣ
}NET_OUT_SCADA_POINT_LIST_INFO;

// �����ƺ����ݲɼ��豸�ĵ�λ����Ϣ, (��Ӧ DH_DEVSTATE_SCADA_POINT_LIST ����)
typedef struct tagNET_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    NET_IN_SCADA_POINT_LIST_INFO    stuIn;                  // ��ѯ����
    NET_OUT_SCADA_POINT_LIST_INFO   stuOut;                 // ��ѯ���
}NET_SCADA_POINT_LIST_INFO;

// ��λ����
typedef enum tagEM_NET_SCADA_POINT_TYPE
{
    EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0,                       // δ֪
    EM_NET_SCADA_POINT_TYPE_ALL,                               // ��������
    EM_NET_SCADA_POINT_TYPE_YC,                                // ң�� ģ��������
    EM_NET_SCADA_POINT_TYPE_YX,                                // ң�� ����������
    EM_NET_SCADA_POINT_TYPE_YT,                                // ң�� ģ�������
    EM_NET_SCADA_POINT_TYPE_YK,                                // ң�� ���������
} EM_NET_SCADA_POINT_TYPE;

// SCADA����λ��ѯ����
typedef struct tagNET_IN_SCADA_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                    // ����ѯ�ĵ�λ����
}NET_IN_SCADA_INFO;

#define MAX_SCADA_YX_NUM                128                 // ���ң�Ÿ���
#define MAX_SCADA_YC_NUM                128                 // ���ң�����
#define MAX_SCADA_POINT_INFO_NUM        8                   // ��������

// �����Ϣ
typedef struct tagNET_SCADA_POINT_INFO 
{
    DWORD                   dwSize;
    char                    szDevName[DH_COMMON_STRING_64];// �豸����
    int                     nYX;                            // ��Чң�Ÿ���
    unsigned int            anYX[MAX_SCADA_YX_NUM];         // ң����Ϣ
    int                     nYC;                            // ��Чң�����
    float                   afYC[MAX_SCADA_YC_NUM];         // ң����Ϣ
}NET_SCADA_POINT_INFO;

// SCADA����λ��ѯ���
typedef struct tagNET_OUT_SCADA_INFO 
{
    DWORD                   dwSize;
    int                     nPointInfoNum;                  // ��Ч������
    NET_SCADA_POINT_INFO    stuPointInfo[MAX_SCADA_POINT_INFO_NUM];// �����Ϣ
}NET_OUT_SCADA_INFO;

// �����ƺ����ݲɼ��豸�ļ���λ��Ϣ(��Ӧ DH_DEVSTATE_SCADA_INFO ����)
typedef struct tagNET_SCADA_INFO
{
    DWORD                   dwSize;
    NET_IN_SCADA_INFO       stuIn;                          // ��ѯ����
    NET_OUT_SCADA_INFO      stuOut;                         // ��ѯ���
}NET_SCADA_INFO;

// SCADA��������
typedef enum tagEM_NET_SCADA_CAPS_TYPE
{
    EM_NET_SCADA_CAPS_TYPE_UNKNOWN,
    EM_NET_SCADA_CAPS_TYPE_ALL,                                // ��������
    EM_NET_SCADA_CAPS_TYPE_DEV,                                // DevInfo
} EM_NET_SCADA_CAPS_TYPE;

// �����ƺ����ݲɼ��豸������Ϣ��ѯ����
typedef struct tagNET_IN_SCADA_CAPS
{
    DWORD                   dwSize;
    EM_NET_SCADA_CAPS_TYPE  emType;                         // ��ѯ����
} NET_IN_SCADA_CAPS;

#define MAX_NET_SCADA_CAPS_TYPE (16)
#define MAX_NET_SCADA_CAPS_NAME (16)

// �����ƺ����ݲɼ��豸����������Ϣ
typedef struct tagNET_OUT_SCADA_CAPS_ITEM
{
    DWORD                   dwSize;
    char                    szDevType[DH_COMMON_STRING_32];    // �豸����
    int                     nValidName;                         // ��Ч�豸���Ƹ���
    char                    szDevName[MAX_NET_SCADA_CAPS_NAME][DH_COMMON_STRING_32];// �豸����, Ψһ��ʾ�豸
} NET_OUT_SCADA_CAPS_ITEM;

// �����ƺ����ݲɼ��豸������Ϣ��ѯ���
typedef struct tagNET_OUT_SCADA_CAPS
{
    DWORD                   dwSize;
    int                     nValidType;                         // ��Ч�豸���͸���
    NET_OUT_SCADA_CAPS_ITEM stuItems[MAX_NET_SCADA_CAPS_TYPE];  // ���16������
} NET_OUT_SCADA_CAPS;

// �����ƺ����ݲɼ��豸������Ϣ(��Ӧ DH_DEVSTATE_SCADA_CAPS ����)
typedef struct tagNET_SCADA_CAPS
{
    DWORD                   dwSize;
    NET_IN_SCADA_CAPS       stuIn;                          // ��ѯ����
    NET_OUT_SCADA_CAPS      stuOut;                         // ��ѯ���
} NET_SCADA_CAPS;

// ��λ��Ϣ(ͨ���豸����������λ��ȡ)
typedef struct tagNET_SCADA_POINT_BY_ID_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emType;                         // ��λ����
    char                    szID[DH_COMMON_STRING_64];      // ����λID
    int                     nMeasuredVal;                   // ��λ����ΪYXʱ��Ч
    float                   fMeasureVal;                    // ��λ����ΪYCʱ��Ч
    int                     nSetupVal;                      // ��λ����ΪYKʱ��Ч
    float                   fSetupVal;                      // ��λ����ΪYTʱ��Ч
    int                     nStatus;                        // ����״̬, -1:δ֪, 0:����, 1:1���澯, 2:2���澯, 3:3���澯, 4:4���澯, 5:�����¼�, 6:��Ч����
    NET_TIME                stuTime;                        // ��¼ʱ��
}NET_SCADA_POINT_BY_ID_INFO;

#define MAX_SCADA_ID_OF_SENSOR_NUM  128                     // ������λID����

// ͨ���豸����ȡ����λ��Ϣ(��Ӧ NET_SCADA_INFO_BY_ID)
typedef struct tagNET_SCADA_INFO_BY_ID
{
    DWORD                   dwSize;
    char                    szSensorID[DH_COMMON_STRING_64];// �������, ̽����ID
    int                     nIDs;                           // �������, ��Ч��λID����
    char                    szIDs[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_64];// �������, ��λID
    int                     nMaxCount;                      // �������, pstuInfo��Ӧ�������
    int                     nRetCount;                      // �������, pstInfoʵ�ʷ�����Ч����, ���ܴ����û��������nMaxCount
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;                   // �����������, �û����仺��,��СΪsizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxCount
}NET_SCADA_INFO_BY_ID;

// ����豸��Ϣ
typedef struct tagNET_SCADA_DEVICE_ID_INFO 
{
    char                    szDeviceID[DH_COMMON_STRING_64];// �豸id
    char                    szDevName[DH_COMMON_STRING_64]; // �豸����, ��CFG_SCADA_DEV_INFO�����е�szDevNameһ��
    BYTE                    reserve[1024];
}NET_SCADA_DEVICE_ID_INFO;

// ��ȡ��ǰ������������ⲿ�豸ID
typedef struct tagNET_SCADA_DEVICE_LIST
{
    DWORD                       dwSize;
    int                         nMax;                       // �û�����Ľṹ�����
    int                         nRet;                       // �豸ʵ�ʷ��ص���Ч�ṹ�����
    NET_SCADA_DEVICE_ID_INFO*   pstuDeviceIDInfo;           // ����豸��Ϣ,�û������ڴ�,��СΪsizeof(NET_SCADA_DEVICE_ID_INFO)*nMax
}NET_SCADA_DEVICE_LIST;

// ����λ��Ϣ
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO
{
    DWORD                       dwSize; 
    char                        szDevName[DH_COMMON_STRING_64];     // �豸����,��getInfo��ȡ������һ��
    EM_NET_SCADA_POINT_TYPE     emPointType;                        // ��λ����
    char                        szPointName[DH_COMMON_STRING_64];   // ��λ��,���λ���ȡֵһ��
    float                       fValue;                             // TypeΪYCʱΪ������
    int                         nValue;                             // TypeΪYXʱΪ����
    char                        szFSUID[DH_COMMON_STRING_64];       // �ֳ���ص�ԪID(Field Supervision Unit), ���豸����
    char                        szID[DH_COMMON_STRING_64];          // ��λID
    char                        szSensorID[DH_COMMON_STRING_64];    // ̽����ID
    NET_TIME_EX                 stuCollectTime;                     // �ɼ�ʱ��
} NET_SCADA_NOTIFY_POINT_INFO;

// ����λ��Ϣ�б�
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO_LIST
{
    DWORD                           dwSize;
    int                             nList;                        // ����λ��Ϣ����
    NET_SCADA_NOTIFY_POINT_INFO     stuList[MAX_SCADA_POINT_LIST_INFO_NUM]; // ����λ��Ϣ
} NET_SCADA_NOTIFY_POINT_INFO_LIST;

// ���ļ���λ��Ϣ�ص�����ԭ��
typedef void (CALLBACK *fSCADAAttachInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAttachInfo()�ӿ��������
typedef struct tagNET_IN_SCADA_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAttachInfoCallBack        cbCallBack;                 // ���ݻص�����
    EM_NET_SCADA_POINT_TYPE         emPointType;                // ��λ����
    LDWORD                          dwUser;                     // �û��������
} NET_IN_SCADA_ATTACH_INFO;

// CLIENT_SCADAAttachInfo()�ӿ��������
typedef struct tagNET_OUT_SCADA_ATTACH_INFO
{
    DWORD    dwSize;
} NET_OUT_SCADA_ATTACH_INFO;

//////////////////////////////////////////////////////////////////////////
#define MAX_SCADA_ID_NUM                            1024    // ����λid��������

// ��λ��ֵ��Ϣ
typedef struct tagNET_SCADA_ID_THRESHOLD_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                // ��λ����
    char                    szID[DH_COMMON_STRING_32];  // ��λID
    float                   fThreshold;                 // �澯����
    float                   fAbsoluteValue;             // ������ֵ
    float                   fRelativeValue;             // �����ֵ
    int                     nStatus;                    // ����״̬, -1:δ֪, 0:����, 1:1���澯, 2:2���澯, 3:3���澯, 4:4���澯, 5:�����¼�, 6:��Ч����
}NET_SCADA_ID_THRESHOLD_INFO;

// CLIENT_SCADAGetThreshold�������
typedef struct tagNET_IN_SCADA_GET_THRESHOLD 
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_64];                // ����豸id
    int             nIDs;                                           // ��Ч����λ����
    char            szIDs[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];   // ����ȡ�ļ���λID
}NET_IN_SCADA_GET_THRESHOLD;

// CLIENT_SCADAGetThreshold�������
typedef struct tagNET_OUT_SCADA_GET_THRESHOLD 
{
    DWORD                           dwSize;
    int                             nMax;               // �û�����ĵ�λ��ֵ��Ϣ����
    int                             nRet;               // ʵ�ʷ��صĵ�λ��ֵ��Ϣ
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // ��λ��ֵ��Ϣ, �û������ڴ�,��СΪsizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_OUT_SCADA_GET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_SCADASetThreshold�������
typedef struct tagNET_IN_SCADA_SET_THRESHOLD 
{
    DWORD                           dwSize;
    char                            szDeviceID[DH_COMMON_STRING_64];// ����豸id
    int                             nMax;               // �û�����ĵ�λ��ֵ��Ϣ����
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // ��λ��ֵ��Ϣ, �û������ڴ�,��СΪsizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_IN_SCADA_SET_THRESHOLD;

// CLIENT_SCADASetThreshold�������
typedef struct tagNET_OUT_SCADA_SET_THRESHOLD 
{
    DWORD           dwSize;
    int             nSuccess;                                           // ��Ч�Ĵ��������ֵ�ɹ���id����
    char            szSuccessID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32]; // ������ֵ�ɹ���id,�û������ڴ�
    int             nFail;                                              // �û�����Ĵ��������ֵʧ�ܵ�id����
    char            szFailID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];    // ������ֵʧ�ܵ�id, �û������ڴ�
}NET_OUT_SCADA_SET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_StartFindSCADA�������
typedef struct tagNET_IN_SCADA_START_FIND 
{
    DWORD           dwSize;
    NET_TIME        stuStartTime;                   // ��ʼʱ��, ����
    BOOL            bEndTime;                       // �Ƿ����ƽ���ʱ��, TRUE: ����stuEndTime, FLASE: �����ƽ���ʱ��
    NET_TIME        stuEndTime;                     // ����ʱ��
    char            szDeviceID[DH_COMMON_STRING_64];// DeviceID, ����
    char            szID[DH_COMMON_STRING_32];      // ����λID, ����
}NET_IN_SCADA_START_FIND;

// CLIENT_StartFindSCADA�������
typedef struct tagNET_OUT_SCADA_START_FIND 
{
    DWORD           dwSize;
    DWORD           dwTotalCount;                   // ���ϲ�ѯ����������
}NET_OUT_SCADA_START_FIND;

// CLIENT_DoFindSCADA�������
typedef struct tagNET_IN_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nStartNo;           // ��ʼ���
    int                         nCount;             // ��������ý���ĸ���
}NET_IN_SCADA_DO_FIND;

// CLIENT_DoFindSCADA�������
typedef struct tagNET_OUT_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nRetNum;            // ���β�ѯ���ĸ���
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;           // ��ѯ���, �û������ڴ�,��СΪsizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxNum
    int	                        nMaxNum;            // �û������ڴ�ĸ���
}NET_OUT_SCADA_DO_FIND;

//����λ������Ϣ
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO
{
    DWORD           dwSize;
    char            szDevID[DH_COMMON_STRING_16];               // �豸ID
    char            szPointID[DH_COMMON_STRING_128];            // ��λID
    BOOL            bAlarmFlag;                                 // ������־
    NET_TIME        stuAlarmTime;                               // ����ʱ��
    int	            nAlarmLevel;                                // ��������0~6��
    int             nSerialNo;                                  // �������,ͬһ���澯�Ŀ�ʼ�ͽ����ı������ͬ�ġ�
    char            szAlarmDesc[DH_COMMON_STRING_128];          // ��������
} NET_SCADA_NOTIFY_POINT_ALARM_INFO;

// ����λ������Ϣ�б�
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST
{
    DWORD                               dwSize;
    int	                                nList;                                          // ����λ������Ϣ����
    NET_SCADA_NOTIFY_POINT_ALARM_INFO   stuList[MAX_SCADA_POINT_LIST_ALARM_INFO_NUM];   // ����λ������Ϣ
} NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST;

// ������㱨����Ϣ�ص�����ԭ��
typedef void (CALLBACK *fSCADAAlarmAttachInfoCallBack)(LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAlarmAttachInfo()�ӿ��������
typedef struct tagNET_IN_SCADA_ALARM_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAlarmAttachInfoCallBack   cbCallBack;                 // ���ݻص�����
    LDWORD                          dwUser;	                    // �û��������
} NET_IN_SCADA_ALARM_ATTACH_INFO;

// CLIENT_SCADAAlarmAttachInfo()�ӿ��������
typedef struct tagNET_OUT_SCADA_ALARM_ATTACH_INFO
{
    DWORD                       dwSize;
} NET_OUT_SCADA_ALARM_ATTACH_INFO;

// ��ص�ֵ���ò���
typedef struct tagNET_SCADA_POINT_SET_INFO
{
    DWORD                       dwSize;
    EM_NET_SCADA_POINT_TYPE	    emType;                         // ��ص�λ����,ȡYK��YT��������
    char                        szPointID[DH_COMMON_STRING_64];	// ��ص�λID
    int	                        nSetupVal;                      // ��λ����ΪYKʱ��Ч
    float                       fSetupVal;                      // ��λ����ΪYTʱ��Ч
} NET_SCADA_POINT_SET_INFO;

// ��ص�ֵ���ò����б�,CLIENT_SetSCADAInfo()�ӿ��������
typedef struct tagNET_IN_SCADA_POINT_SET_INFO_LIST
{
    DWORD                       dwSize;
    char                        szDevID[DH_COMMON_STRING_32];           // �豸ID
    int	                        nPointNum;                              // ��ص����
    NET_SCADA_POINT_SET_INFO    stuList[MAX_SCADA_ID_OF_SENSOR_NUM];    // ��ص��б���Ϣ
} NET_IN_SCADA_POINT_SET_INFO_LIST;

// ���ü�ص�ֵ���صĽ���б�,CLIENT_SetSCADAInfo()�ӿ��������
typedef struct tagNET_OUT_SCADA_POINT_SET_INFO_LIST
{
    DWORD                   dwSize;
    int                     nSuccess;                                                       // ��Ч�Ŀ��ƻ���ڳɹ���ID����
    char                    szSuccessID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];   // ���ƻ���ڳɹ���ID���б�
    int                     nFail;                                                          // ��Ч�Ŀ��ƻ����ʧ�ܵ�ID����
    char                    szFailID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];      // ���ƻ����ʧ�ܵ�ID���б�
} NET_OUT_SCADA_POINT_SET_INFO_LIST;


// ��ȡ��ǰ��ϵͳ����״̬(��ӦDH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS����)
typedef struct tagNET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES
{
    DWORD               dwSize;
    int                 nChannelId;                         // ��ϵͳ��
    BOOL                bActive;                            // ��ϵͳ����״̬, TRUE ��ʾ����,FALSE��ʾ������
}NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES;

// ������ϵͳ�������ò���(��ӦDH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET����)
typedef struct tagNET_CTRL_ALARM_SUBSYSTEM_SETACTIVE 
{
    DWORD               dwSize;
    int                 nChannelId;                         // ��ϵͳ��
    BOOL                bActive;                            // ��ϵͳ����״̬,TRUE ��ʾ����,FALSE��ʾ������
}NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE;

// ��ֹ��բ����(��Ӧ DH_CTRL_FORBID_OPEN_STROBE)
typedef struct tagNET_CTRL_FORBID_OPEN_STROBE
{
    DWORD               dwSize;             
    int                 nChannelID;                         // ͨ����    
    int                 nTime;                              // ��ֹ��բ�ĳ���ʱ��,��λ:s,���ڴ˲���֮��Ķ�Ӧʱ���ڲ������豸��բ 
}NET_CTRL_FORBID_OPEN_STROBE;

#define MAX_PLATENUMBER_LEN    64                           // ����ƺ��볤��

// �����բ����(��ӦDH_CTRL_OPEN_STROBE����)
typedef struct tagNET_CTRL_OPEN_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // ͨ����
    char                szPlateNumber[MAX_PLATENUMBER_LEN]; // ���ƺ���
}NET_CTRL_OPEN_STROBE;

// �첽�����բ�ص�����
// nError = 0 ��ʾ��ѯ�ɹ�;
// nError = 1 ��ʾ�ڴ�����ʧ��;
// nError = 2 ��ʾ��ʱ, ����ʱʱ�����豸δ������Ϣ
// nError = 3 ��ʾ�豸��������У�鲻ͨ��;
// nError = 4 ���Ͳ�ѯ����ʧ��
typedef void (CALLBACK *fOpenStrobeCallBack)(LLONG lLoginID, NET_CTRL_OPEN_STROBE stuOpenStrobe, int nError, LDWORD dwUser);

// �첽�����բ����(��ӦDH_CTRL_OPEN_STROBE����)
typedef struct tagNET_CTRL_OPEN_STROBE_ASYN
{
    DWORD					dwSize;
	NET_CTRL_OPEN_STROBE	stuOpenStrobe;						// �����բ����
	fOpenStrobeCallBack		cbCallBack;							// ���ݻص�����
	LDWORD					dwUser;								// �û��������
	int						nWaitTime;							// ��ʱʱ��
} NET_CTRL_OPEN_STROBE_ASYN;

// �رյ�բ����(��ӦDH_CTRL_CLOSE_STROBE����)
typedef struct tagNET_CTRL_CLOSE_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // ͨ����
}NET_CTRL_CLOSE_STROBE;

// ǿ�Ʋ���Υ�²���(��ӦDH_CTRL_FORCE_BREAKING����)
typedef struct tagNET_CTRL_FORCE_BREAKING
{
	DWORD               dwSize;
    int                 nChannelId;                         // ͨ����
	int                 nLaneMask;                          // ��������λ
	DWORD               dwBreakingType;                     // Υ������, ���dhnetsdk.h��"���ܷ����¼�����"                
}NET_CTRL_FORCE_BREAKING;

// �طžܾ���������(��ӦDH_CTRL_TALKING_REFUSE����)
typedef struct tagNET_CTRL_TALKING_REFUSE 
{
    DWORD           dwSize;
    int             nChannelID;                             // �Խ�ͨ����
}NET_CTRL_TALKING_REFUSE;


// Զ�̶Խ���������
typedef enum tagEM_REMOTETALK_CTRL_STATE
{
    EM_REMOTETALK_CTRL_STATE_UNKNOWN = 0,                                // δ��������
    EM_REMOTETALK_CTRL_STATE_INVITE,                                     // �豸��ƽ̨����Խ�
}EM_REMOTETALK_CTRL_STATE;

// Զ�̶Խ����Ʋ���
typedef struct tagNET_CTRL_REMOTETALK_PARAM
{
    DWORD                       dwSize;                 // ���ṹ���С
    EM_REMOTETALK_CTRL_STATE    emAction;               // Զ�̶Խ����ƵĲ�������
}NET_CTRL_REMOTETALK_PARAM;

// ��λԤ��״̬
typedef enum tagEM_NET_ORDER_STATE
{
    EM_NET_ORDER_STATE_UNKNOWN,
    EM_NET_ORDER_STATE_FREE,                            // ����Free
    EM_NET_ORDER_STATE_ORDERED,                         // Ԥ��Ordered
}EM_NET_ORDER_STATE;

// ��λԤ��״̬��Ϣ
typedef struct tagNET_ORDER_STATE_INFO
{
    DWORD               dwSize;
    unsigned int        nLane;                          // ��λ��
    EM_NET_ORDER_STATE  emOrderState;                   // Ԥ�����
}NET_ORDER_STATE_INFO;

// ���ó�λԤ��״̬����(��ӦDH_CTRL_SET_ORDER_STATE����)
typedef struct tagNET_CTRL_SET_ORDER_STATE
{
    DWORD                   dwSize;
    NET_ORDER_STATE_INFO*   pOrderStateInfo;              // ��λԤ����Ϣ,�û�����ռ�,��СΪsizeof(NET_ORDER_STATE_INFO)*nStateCount
    unsigned int            nStateCount;                  // ��ЧԤ������
}NET_CTRL_SET_ORDER_STATE;

// ͣ��������ڿ�����LED������Ļ��Ļ�����ٶ�
typedef enum tagNET_ECK_LED_SPEED_TYPE 
{
    NET_ECK_LED_SPEED_UNKNOWN = 0,
    NET_ECK_LED_SPEED_LOW,                              // ��
    NET_ECK_LED_SPEED_NORMAL,                           // ����
    NET_ECK_LED_SPEED_HIGH,                             // ��
}NET_ECK_LED_SPEED_TYPE;

// ͣ��������ڿ�����LED���� ����DH_CTRL_ECK_LED_SET
typedef struct tagNET_CTRL_ECK_LED_SET_PARAM 
{
    DWORD                   dwSize;
    NET_ECK_LED_SPEED_TYPE  emLEDSpeed;                 // ��Ļ�����ٶ�
    int                     nCount;                     // ��Ч��ʾ����, ��Χ0-255, 0��ʾ����
    char                    szCustomData[DH_COMMON_STRING_512];// LED��������ʼ�Զ����ַ�, 0-256�ֽ�
}NET_CTRL_ECK_LED_SET_PARAM;


// ����ͣ��ϵͳ����ڻ�IC���û�����
typedef enum tagNET_ECK_IC_CARD_USER_TYPE
{
    NET_ECK_IC_CARD_USER_UNKNOWN,
    NET_ECK_IC_CARD_USER_ALL,                           // ȫ������
    NET_ECK_IC_CARD_USER_TEMP,                          // ��ʱ�û�
    NET_ECK_IC_CARD_USER_LONG,                          // �����û�
    NET_ECK_IC_CARD_USER_ADMIN,                         // ����Ա
    NET_ECK_IC_CARD_USER_BLACK_LIST,                    // ������
}NET_ECK_IC_CARD_USER_TYPE;

// ����ͣ��ϵͳ����ڻ��쳣������¼����
typedef enum tagNET_ECK_CAR_PASS_FLAG
{
    NET_ECK_CAR_PASS_FLAG_NORMAL = 0,                   // ����
    NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1,                 // �쳣
    NET_ECK_CAR_PASS_FLAG_ALL,                          // ȫ��
} NET_ECK_CAR_PASS_FLAG;

// ����ͣ��ϵͳ����ڻ�IC����Ϣ
typedef struct tagNET_ECK_IC_CARD 
{
    DWORD                   dwSize;
    DWORD                   dwCard;                     // ����
    NET_ECK_IC_CARD_USER_TYPE emUserType;               // �û�����
}NET_ECK_IC_CARD;

#define NET_MAX_ECK_IC_CARD_IMPORT_NUM      50          // ����ͣ��ϵͳ����ڻ����ɵ���IC������Ŀ

// ����ͣ��ϵͳ����ڻ�IC����Ϣ���� ����DH_CTRL_ECK_IC_CARD_IMPORT
typedef struct tagNET_CTRL_ECK_IC_CARD_IMPORT_PARAM
{
    DWORD               dwSize;
    int                 nCardNum;                       // IC������
    NET_ECK_IC_CARD     stuCardInfo[NET_MAX_ECK_IC_CARD_IMPORT_NUM];// IC����Ϣ
}NET_CTRL_ECK_IC_CARD_IMPORT_PARAM;

// ����ͣ��ϵͳ����ڻ�IC����Ϣͬ��ָ�� ���� DH_CTRL_ECK_SYNC_IC_CARD
typedef struct tagNET_CTRL_ECK_SYNC_IC_CARD_PARAM
{
    DWORD               dwSize;
    int                 nCount;                         // �ͻ���IC����Ϣ������
}NET_CTRL_ECK_SYNC_IC_CARD_PARAM;

#define ECK_SCREEN_NUM_MAX (8)                         // ����ͣ��ϵͳ����ڻ����������

// ����ͣ��ϵͳ����ڻ����ó�λ��Ϣ ���� DH_CTRL_ECK_SET_PARK_INFO
typedef struct tagNET_CTRL_ECK_SET_PARK_INFO_PARAM
{
    DWORD           dwSize;
    int             nScreenNum;                             // ������, ������ ECK_SCREEN_NUM_MAX
    int             nScreenIndex[ECK_SCREEN_NUM_MAX];       // ����, ÿ��Ԫ�ر�ʾ�����
    int             nFreeParkNum[ECK_SCREEN_NUM_MAX];       // ��Ӧ�������µĿ��೵λ��
                                                            // ���Ⱥ��±���nScreenIndexһ��,ÿ��Ԫ�ر�ʾ��Ӧ�����µĿ��೵λ
}NET_CTRL_ECK_SET_PARK_INFO_PARAM;

// ָ�Ʋɼ�(��ӦDH_CTRL_CAPTURE_FINGER_PRINT����)
typedef struct tagNET_CTRL_CAPTURE_FINGER_PRINT 
{
    DWORD           dwSize;
    int             nChannelID;                             // �Ž����(��0��ʼ)
    char            szReaderID[DH_COMMON_STRING_32];        // ������ID
}NET_CTRL_CAPTURE_FINGER_PRINT;

// �Ҷ���Ƶ�绰(��Ӧ DH_CTRL_VTP_DISCONNECT ����)
typedef struct tagNET_CTRL_VTP_DISCONNECT 
{
    DWORD                   dwSize;
    const char*             szTargetID;                     // ��ת�����豸ID, ΪNULL��ʾ��ת��
    EM_NET_VTP_CALL_TYPE    emCallType;                     // �������
    char                    szCallID[DH_COMMON_STRING_128]; // �Խ�Ψһ��ʶ
}NET_CTRL_VTP_DISCONNECT;

// �Խ��ͻ�����Ӧ
typedef enum tagNET_EM_VTP_ACK
{
    NET_EM_VTP_OK,                              // �ͻ��˽����¼�,���Ϻ��
    NET_EM_VTP_BUSY,                            // �ͻ���æ,�����
}NET_EM_VTP_ACK;

// ���ת����Ӧ
typedef struct tagNET_CTRL_VTP_DIVERTACK
{
    DWORD                   dwSize;
    EM_NET_VTP_CALL_TYPE    emCallType;                     // ����ѯ�ĺ������
    const char*             szCallID;                       // ���Ωһ��ʶ��
    NET_EM_VTP_ACK          emAck;                          // �ͻ��˽��ܺ����Ӧ����
}NET_CTRL_VTP_DIVERTACK;

// Զ�̶�ý���ļ�������ʽ
typedef enum tagNET_EM_SPEAK_FILE_ACTION
{
    NET_EM_SPEAK_FILE_ACTION_UPDATE = 0,                    // ����ԭ���ļ�
    NET_EM_SPEAK_FILE_ACTION_ADD,                           // �����ļ�
    NET_EM_SPEAK_FILE_ACTION_DEL,                           // ɾ���ļ�
}NET_EM_SPEAK_FILE_ACTION;

// Զ�̶�ý���ļ�Ͷ�Ų�����Ϣ
typedef struct tagNET_SPEAK_FILE_INFO
{
    DWORD                       dwSize;
    char                        szFilePath[MAX_PATH];       // �ļ�·��, ��Ԥ����CFG_CMD_NASEX���úõĵ�ַ
    NET_EM_SPEAK_FILE_ACTION    emAction;                   // ��������, ����szFilePathָ�����ļ��Ĳ���
    BOOL                        bSave;                      // �豸�����Ƿ���±�����ļ�
}NET_SPEAK_FILE_INFO;

#define MAX_SPEAK_FILE_NUM      32                          // Զ��Ͷ�ŵĶ�ý���ļ�������

// Զ��Ͷ�Ŷ�ý���ļ�����
typedef struct tagNET_CTRL_UPDATE_FILES
{
    DWORD                   dwSize;
    DWORD                   dwFileNum;                      // ��Ч���ļ�����
    NET_SPEAK_FILE_INFO     stuFileInfo[MAX_SPEAK_FILE_NUM];// ��ý���ļ���Ϣ
}NET_CTRL_UPDATE_FILES;

// ��ˢ����ˢһ��,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ���� DH_CTRL_RAINBRUSH_MOVEONCE)
typedef struct tagNET_CTRL_RAINBRUSH_MOVEONCE
{
    DWORD           dwSize;
    int             nChannel;       // ��ʾ��ˢ������
}NET_CTRL_RAINBRUSH_MOVEONCE;

// ��ˢ����ѭ��ˢ,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ���� DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
typedef struct tagNET_CTRL_RAINBRUSH_MOVECONTINUOUSLY
{
    DWORD           dwSize;
    int             nChannel;       // ��ʾ��ˢ������
    unsigned int    nInterval;      // ��ˢ���
}NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY;

// ��ˢֹͣˢ,��ˢģʽ����Ϊ�ֶ�ģʽʱ��Ч(��Ӧ���� DH_CTRL_RAINBRUSH_STOPMOVE)
typedef struct tagNET_CTRL_RAINBRUSH_STOPMOVE
{
    DWORD           dwSize;
    int             nChannel;       // ��ʾ��ˢ������
}NET_CTRL_RAINBRUSH_STOPMOVE;

// �����¼�ȷ��(��Ӧ DH_CTRL_ALARM_ACK ����)
typedef struct tagNET_CTRL_ALARM_ACK
{
    DWORD                   dwSize;
    int                     nEventID;   // �¼����,����Ψһ��־һ���¼�
}NET_CTRL_ALARM_ACK;

////////////////////////////////ϵͳ������//////////////////////////////////////////
// ����״̬
typedef struct __NET_PARTITION_STATE
{
    DWORD             dwSize;
    int               nStatus;                  // ����״̬,0-����,1-���� 
    double            dbTotalSize;              // ����������,�ֽ�Ϊ��λ
    double            dbRemainSize;             // ʣ������,�ֽ�Ϊ��λ
    
}NET_PARTITION_STATE;

// Ӳ��״̬
typedef struct __NET_HDD_STATE
{
    DWORD             dwSize; 
    int               nState;                   // Ӳ��״̬,0-����,1-����   
    double            dbTotalSize;              // Ӳ��������,�ֽ�Ϊ��λ
    NET_PARTITION_STATE stuPartitions[DH_MAX_STORAGE_PARTITION_NUM]; // ����״̬
    int               nPartitionNum;              // ������
}NET_HDD_STATE;

// ͨ��״̬
typedef struct __NET_CHANNLE_STATE
{
    DWORD             dwSize;
    BYTE              byRecState;               // ¼��״̬,1-¼��,0-�ر�
    BYTE              byVideoInState;           // ��Ƶ����״̬,1-����Ƶ����,0-����Ƶ  
    BYTE              byReserved[2];            // �ֽڶ���
}NET_CHANNLE_STATE;

// PAD/DVR����״̬
typedef enum tagNET_PAD_CONNECT_STATE
{
    NET_PAD_CONNECT_STATE_UNKNOWN,             // δ֪
    NET_PAD_CONNECT_STATE_UNCONNECTED,         // δ����
    NET_PAD_CONNECT_STATE_CONNECTED,           // ����
} NET_PAD_CONNECT_STATE;

// Home��״̬
typedef enum tagNET_HOME_STATE
{
    NET_HOME_STATE_UNKNOWN,                    // δ֪
    NET_HOME_STATE_UNPRESSED,                  // δ����
    NET_HOME_STATE_PRESSED,                    // ����
} NET_HOME_STATE;

// �豸�Լ���Ϣ
typedef struct __NET_SELFCHECK_INFO
{
    DWORD             dwSize;
    int               nAlarmIn;                 // ��������ͨ����
    int               nAlarmOut;                // �������ͨ����  
    NET_TIME          stuTime;                  // �ϱ�ʱ��
    char              szPlateNo[DH_MAX_PLATE_NUMBER_LEN]; // ����
    char              szICCID[DH_MAX_SIM_LEN];  // SIM����,����ʹ��szICCIDExInfo�ֶ�
    BYTE              byOrientation;            // ��λ״̬,0-δ��λ,1-��λ 
    BYTE              byACCState;               // ACC ״̬,0-�ر�,1-��
    BYTE              byConstantElecState;      // ����״̬,0-��������,1-�Ͽ�,2-Ƿѹ,3-��ѹ
    BYTE              byAntennaState;           // ͨ���ź�״̬,0-����,1-δ֪����,2-δ��,3-��·
    
    // �ⲿ�豸״̬
    BYTE              byReportStation;          // ��վ��״̬,0-δ��,1-����,2-�쳣
    BYTE              byControlScreen;          // ������״̬,0-δ��,1-����,2-�쳣
    BYTE              byPOS;                    // POS��״̬,0-δ��,1-����,2-�쳣
    BYTE              byCoinBox;                // Ͷ����״̬,0-δ��,1-����,2-�쳣
    
    // ������
    BOOL              bTimerSnap;               // ��ʱץͼ,TRUE-֧��,FALSE-��֧��
    BOOL              bElectronEnclosure;       // ����Χ��,TRUE-֧��,FALSE-��֧��
    BOOL              bTeleUpgrade;             // Զ������,TRUE-֧��,FALSE-��֧��   
    
    NET_HDD_STATE     stuHddStates[DH_MAX_DISKNUM]; // Ӳ��״̬
    int               nHddNum;                  // Ӳ�̸���
    
    NET_CHANNLE_STATE* pChannleState;           // ͨ��״̬,��һ������, 
                                                // CLIENT_AttachMission�ӿ�,NET_MISSION_TYPE_SELFCHECK����,�ص�����,�ڴ���SDK����,SDK�ͷ�
                                                // CLIENT_GetSelfCheckInfo�ӿ�,����,�ڴ����û�����,�û��ͷ�,��СΪsizeof(NET_CHANNLE_STATE)*nChannelMax
    int               nChannleNum;              // ʵ���ϱ���ͨ������
    int               nChannelMax;              // CLIENT_GetSelfCheckInfo�ӿ�,pChannleState�ڴ�����NET_CHANNLE_STATE����
    NET_PAD_CONNECT_STATE         emConnState;  // PAD/DVR����״̬
    NET_HOME_STATE                emHomeState;  // Home��״̬
	char              szICCIDExInfo[DH_COMMON_STRING_256];  // SIM������չ��Ϣ�������ֶ���չʹ��
	BYTE              by3GState;                // 3G/4G״̬, 0-δ���ӣ�1-���ӣ�2-ģ��δ�ҵ�
	BYTE              byWifiState;              // Wifi״̬, 0-δ���ӣ�1-���ӣ�2-ģ��δ�ҵ�
	BYTE              byGpsState;               // Gps״̬, 0-δ���ӣ�1-���ӣ�2-ģ��δ�ҵ�
	BYTE              byBlackBoxState;          // BlackBox״̬, 0-δ�ӣ�1-����
	int               nCpuUsage;                // CPUʹ�ðٷֱ�, ��λ%
	int               nTemperature;             // �豸�ڲ��¶�, ���϶�
}NET_SELFCHECK_INFO;

typedef void (CALLBACK *fMissionInfoCallBack)(LLONG lAttachHandle, DWORD dwType, void* pMissionInfo, void* pReserved, LDWORD dwUserData);

typedef enum EM_MISSION_TYPE
{
    NET_MISSION_TYPE_UNKOWN,                    // δ֪
    NET_MISSION_TYPE_SELFCHECK,                 // �豸�Լ�,��Ӧ�ṹ�� NET_SELFCHECK_INFO
}EM_MISSION_TYPE;

//CLIENT_AttachMission�ӿ��������
typedef struct __NET_IN_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    EM_MISSION_TYPE   emMissionType;            // ��������
    fMissionInfoCallBack cbMissionInfofunc;     // ������Ϣ�ص�����
    LDWORD            dwUser;                   // �û����� 
}NET_IN_ATTACH_MISSION_PARAM;

// CLIENT_DetachMission�ӿ��������
typedef struct NET_OUT_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    LLONG             lAttachHandle;           // ���ľ��
}NET_OUT_ATTACH_MISSION_PARAM;

#define MAX_EVENT_TO_CONFIRM_NUM        8       // ����ȷ�ϵ��¼��ĸ���

// ��ȷ�ϵ��¼�����Ϣ
typedef struct tagNET_EVENT_INFO_TO_CONFIRM 
{
    DWORD               dwSize;
    DWORD               dwEventType;            // �¼�����, ��ӦCLIENT_AttachBusState�ӿڵ��¼�����
    NET_TIME            stuTime;                // �¼�ʱ��, UTC��
    LONG                lTime;                  // �¼�ʱ��, UTC��, ��λ��
}NET_EVENT_INFO_TO_CONFIRM;

// ���������ȷ�� �������
typedef struct tagNET_IN_BUS_CONFIRM_EVENT 
{
    DWORD                       dwSize;
    int                         nEvent;         // ��ȷ���¼�����Ч��Ŀ
    NET_EVENT_INFO_TO_CONFIRM   stuEventInfo[MAX_EVENT_TO_CONFIRM_NUM];// ��ȷ���¼�����Ϣ
}NET_IN_BUS_CONFIRM_EVENT;

// ���������ȷ�� �������
typedef struct tagNET_OUT_BUS_CONFIRM_EVENT 
{
    DWORD                       dwSize;
}NET_OUT_BUS_CONFIRM_EVENT;

// CLIENT_SetDevicePosition�����豸��ַ��Ϣ�������
typedef struct tagNET_IN_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
    char                    szPosition[DH_COMMON_STRING_512];   // ��ַ��Ϣ
}NET_IN_SET_DEVICE_POSITION;

// CLIENT_SetDevicePosition�����豸��ַ��Ϣ�������
typedef struct tagNET_OUT_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
}NET_OUT_SET_DEVICE_POSITION;

// CLIENT_GetDevicePosition��ȡ�豸��ַ��Ϣ�������
typedef struct tagNET_IN_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
}NET_IN_GET_DEVICE_POSITION;

// CLIENT_GetDevicePosition��ȡ�豸��ַ��Ϣ�������
typedef struct tagNET_OUT_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
    char                    szPosition[DH_COMMON_STRING_512];   // ��ַ��Ϣ
}NET_OUT_GET_DEVICE_POSITION;

// CLIENT_SnapPictureByEvent�������
typedef struct tagNET_IN_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
    int                     nChannel;                           // ��Ƶͨ����, ��0��ʼ
    DWORD                   dwEventID;                          // �ο�CLIENT_RealLoadPicEx���¼�����
}NET_IN_SNAP_BY_EVENT;

// CLIENT_SnapPictureByEvent�������
typedef struct tagNET_OUT_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // ���ṹ���С, ��ʼ��ʱ������д
}NET_OUT_SNAP_BY_EVENT;

// CLIENT_StartQueryLog �������
typedef struct tagNET_IN_START_QUERYLOG
{
    DWORD               dwSize;
} NET_IN_START_QUERYLOG;

// CLIENT_StartQueryLog �������
typedef struct tagNET_OUT_START_QUERYLOG
{
    DWORD               dwSize;
}NET_OUT_START_QUERYLOG;

// ��־��ϸ��Ϣ
typedef struct tagNET_LOG_MESSAGE
{
    DWORD               dwSize;
    char                szLogMessage[DH_COMMON_STRING_1024];    // ��־����
} NET_LOG_MESSAGE;

// ��־��Ϣ
typedef struct tagNET_LOG_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // ʱ�� 
    char                szUserName[DH_COMMON_STRING_32];// ������
    char                szLogType[DH_COMMON_STRING_128];// ����
    NET_LOG_MESSAGE     stuLogMsg;                      // ��־��Ϣ
} NET_LOG_INFO;

// CLIENT_QueryNextLog �������
typedef struct tagNET_IN_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nGetCount;      // ��Ҫ��ѯ����־����
}NET_IN_QUERYNEXTLOG;

// CLIENT_QueryNextLog �������
typedef struct tagNET_OUT_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nMaxCount;      // �û�ָ������ṹ�����,����ڵ���NET_IN_GETNEXTLOG��nGetCount
    NET_LOG_INFO*       pstuLogInfo;    // ������־��Ϣ,�����С���û�ָ��,��СΪnMaxCount*sizeof(NET_LOG_INFO)
    int                 nRetCount;      // ʵ�ʷ�����־����
}NET_OUT_QUERYNEXTLOG;

// �첽ע���豸�ص�����ԭ��(��nError����11ʱ,�����ֶ�reservedΪint���Ͳ��������ڵ���CLIENT_StartLoginEx��½ʱ�Ķ˿ں�)
// ������ʧ��ʱ��   nError �Ĵ������Ӧ��˵���ο� CLIENT_Login �е� error˵��
typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// CLIENT_StartLoginEx �������
typedef struct tagNET_IN_STARTLOGINEX 
{
    DWORD               dwSize;
    const char*         szIp;           // �豸ip
    DWORD               dwPort;         // ��½�˿�
    const char*         szName;         // �û���
    const char*         szPwd;          // ����
    fHaveLogin          cbLogin;        // ��½����ص�
    LDWORD              dwUser;         // �ص��û�����
}NET_IN_STARTLOGINEX;

// CLIENT_StartLoginEx �������
typedef struct tagNET_OUT_STARTLOGINEX 
{
    DWORD       dwSize;
}NET_OUT_STARTLOGINEX;

// �豸֧�ֵ�Э������
typedef enum tagEM_DEV_PROTOCOL_TYPE
{
	EM_DEV_PROTOCOL_UNKNOWN,			// δ֪
	EM_DEV_PROTOCOL_V2,					// ˽�ж���
	EM_DEV_PROTOCOL_V3,					// ˽������
} EM_DEV_PROTOCOL_TYPE;

// ��Ƶƴ�Ӳ�������
typedef enum tagNET_VIDEOJOIN_OPERATE_TYPE
{
    NET_VIDEOJOIN_GET_STATUS,                   // ��ȡƴ��״̬, ��Ӧ NET_IN_VIDEOJOIN_GET_STATUS �� NET_OUT_VIDEOJOIN_GET_STATUS
	NET_VIDEOJOIN_GET_CALIBRATE_POINTS,			// ��ȡ����, ��Ӧ tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS �� tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
    NET_VIDEOJOIN_CALIBRATE,					// �궨,  ��Ӧ NET_IN_VIDEOJOIN_CALIBRATE �� NET_OUT_VIDEOJOIN_CALIBRATE
}NET_VIDEOJOIN_OPERATE_TYPE;

// ��Ƶƴ��״̬
typedef enum tagNET_VIDEOJOIN_STATUS
{
    NET_VIDEOJOIN_STATUS_UNKNOWN,               // δ֪
    NET_VIDEOJOIN_STATUS_NOTSTART,              // δ��ʼ
    NET_VIDEOJOIN_STATUS_DOING,                 // ������
    NET_VIDEOJOIN_STATUS_FINISH,                // ���
}NET_VIDEOJOIN_STATUS;

// ��Ƶƴ�ӱ궨ģʽ
typedef enum tagNET_VIDEOJOIN_MODE
{
    NET_VIDEOJOIN_MODE_UNKNOWN,                 // δ֪
    NET_VIDEOJOIN_MODE_AUTO,                    // �Զ�
    NET_VIDEOJOIN_MODE_MANUAL,                  // �ֶ�
}NET_VIDEOJOIN_MODE;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_IN_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_STATUS;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_OUT_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
    NET_VIDEOJOIN_STATUS emStatus;              // ƴ��״̬
}NET_OUT_VIDEOJOIN_GET_STATUS;

// ����궨���, ��ʾһ�������
typedef struct tagNET_POINT_PAIR 
{
    DH_POINT        stuPoints[POINT_NUM_IN_PAIR];           // ����궨��
}NET_POINT_PAIR;

// ��Ƶƴ�ӱ궨����, ÿһ���ʾ����ͨ���Ͷ���궨���
typedef struct tagNET_VIDEOJOIN_POINT_GROUP
{
    DWORD           dwSize;
    int             nPointPairNum;                          // �궨������
    NET_POINT_PAIR  stuPointPairs[MAX_POINT_PAIR_NUM];      // �궨��
    int             nChannels[CHANNEL_NUM_IN_POINT_GROUP];  // ��Ƶͨ����, ͨ�������±�����Ӧ,�±�0ͨ����ӦNET_POINT_PAIR���±�0�ĵ�
}NET_VIDEOJOIN_POINT_GROUP;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // �궨ģʽ
    int                 nPointGroupNum;                         // �궨��������
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // �궨����, �ֶ�ģʽ����Ч
}NET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_IN_VIDEOJOIN_CALIBRATE
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // �궨ģʽ
    int                 nPointGroupNum;                         // �궨��������
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // �궨����, �ֶ�ģʽ��Ч
}NET_IN_VIDEOJOIN_CALIBRATE;

// CLIENT_OperateVideoJoin �������, ��ӦNET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_OUT_VIDEOJOIN_CALIBRATE
{
    DWORD           dwSize;
}NET_OUT_VIDEOJOIN_CALIBRATE;

// ��ȡ���ڴ�����Ϣ�������, ��ӦNET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_IN_SPLIT_GET_SCENE 
{
    DWORD               dwSize;
    int                 nChannel;                       // ���ͨ���Ż��ں�������ͨ����, pszCompositeIDΪNULLʱ��Ч
    const char*         pszCompositeID;                 // �ں���ID
}NET_IN_SPLIT_GET_SCENE;

// ��ȡ���ڴ�����Ϣ�������, ��ӦNET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_OUT_SPLIT_GET_SCENE 
{
    DWORD               dwSize;
    DH_SPLIT_SCENE      stuScene;                       // ������Ϣ
}NET_OUT_SPLIT_GET_SCENE;

// ����ǽ��Ѳ״̬
typedef enum tagEM_NET_WM_TOUR_STATUS
{
    EM_NET_WM_TOUR_STATUS_UNKNOWN,              // δ֪
        EM_NET_WM_TOUR_STATUS_START,                // ��Ѳ��
        EM_NET_WM_TOUR_STATUS_STOP,                 // ��Ѳֹͣ
} EM_NET_WM_TOUR_STATUS;

// ����ǽԤ����Ѳ״̬��Ϣ
typedef struct tagNET_WM_TOUR_STATUS_INFO 
{
    DWORD                   dwSize;
    EM_NET_WM_TOUR_STATUS   emStatus;           // ��Ѳ״̬
    DH_MONITORWALL_SCENE    stuScene;           // Ԥ����Ϣ
} NET_WM_TOUR_STATUS_INFO;

// ����ǽԤ����Ѳ״̬�ص�����ԭ��, lAttachHandle��CLIENT_MonitorWallAttachTour�ķ���ֵ
typedef void (CALLBACK *fMonitorWallTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WM_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_MonitorWallAttachTour �ӿ��������
typedef struct tagNET_IN_WM_ATTACH_TOUR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // ����ǽID
    fMonitorWallTourStatusCallBack cbStatus;    // ��Ѳ״̬�ص�����
    LDWORD          dwUser;                     // ��Ѳ״̬�ص�����
} NET_IN_WM_ATTACH_TOUR;

// CLIENT_MonitorWallAttachTour �ӿ��������
typedef struct tagNET_OUT_WM_ATTACH_TOUR 
{
    DWORD           dwSize;
} NET_OUT_WM_ATTACH_TOUR;

// CLIENT_SnapManagerConfirmUpload �ӿ��������
typedef struct tagNET_IN_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];       // �ļ�·��,����Ψһ��ʶ����һ��ͼƬ
    BOOL            bResult;                                // ͼƬ�Ƿ��ϴ����
}NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD;

// CLIENT_SnapManagerConfirmUpload �ӿ��������
typedef struct tagNET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
}NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD;

// ��Ƶ�绰״̬��Ϣ
typedef struct tagNET_VTP_CALL_STATE_INFO 
{
    DWORD                       dwSize;
    char                        szNumber[DH_COMMON_STRING_128]; // ��к���
    char                        szCallID[DH_COMMON_STRING_128]; // �Խ�Ψһ��ʶ
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // ���״̬
}NET_VTP_CALL_STATE_INFO;

// ������Ƶ�绰״̬��Ϣ�ص�����ԭ��
typedef void (CALLBACK *fVTPCallStateCallBack)(LLONG lAttachHandle, NET_VTP_CALL_STATE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// ������Ƶ�绰״̬��Ϣ �������
typedef struct tagNET_IN_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // ����ѯ�ĺ������
    fVTPCallStateCallBack       cbCallState;                    // ״̬�ص�����
    LDWORD                      dwUser;                         // �û�����
    const char*                 szTargetID;                     // ��ת�����豸ID, ΪNULL��ʾ��ת��
}NET_IN_VTP_CALL_STATE_ATTACH;

// ������Ƶ�绰״̬��Ϣ �������
typedef struct tagNET_OUT_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
}NET_OUT_VTP_CALL_STATE_ATTACH;


//////////////////////////////////////////////////////////////////////////
// ����ҵ����ؽӿڲ���
//////////////////////////////////////////////////////////////////////////

// ��鹫����·CLIENT_CheckBusLine()�������
typedef struct tagNET_IN_CHECK_BUS_LINE 
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // ��·��ʾ
    char            szDesignation[DH_COMMON_STRING_32];     // ��·����
    NET_LINE_DIRECTION  emDirection;                        // ��·����
    int             nSiteCount;                             // ��·��վ��
    char            szDirectionName[DH_COMMON_STRING_32];   // ��·��������
    char            szVersion[DH_COMMON_STRING_32];         // ��·�汾��
}NET_IN_CHECK_BUS_LINE;


// ������·�Ƿ���Ҫ����״̬����
typedef enum tagNET_BUS_LINE_UPDATE_TYPE
{
    NET_BUS_LINE_UPDATE_UNKNOWN = 0,
    NET_BUS_LINE_UPDATE_UPDATED,                            // ��Ҫ����
    NET_BUS_LINE_UPDATE_NOT_UPDATED,                        // ����Ҫ����
}NET_BUS_LINE_UPDATE_TYPE;

// ��鹫����·CLIENT_CheckBusLine()�������
typedef struct tagNET_OUT_CHECK_BUS_LINE
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_32];        // �豸ID
    char            szLineID[DH_COMMON_STRING_32];          // ��·��ʾ
    NET_BUS_LINE_UPDATE_TYPE emUpdate;                      // �Ƿ���Ҫ����״ָ̬ʾ
}NET_OUT_CHECK_BUS_LINE;
#define MAX_SITE_GPS_POINT_NUM                      64      // ����һ������վ�����GPS�����

// ����վ��������״����
typedef enum tagNET_SITE_AREA_TYPE
{
    NET_SITE_AREA_ENCLOSURE = 0,                            // Χ����
    NET_SITE_AREA_CIRCLE,                                   // Բ��
}NET_SITE_AREA_TYPE;

// ����վ����Ϣ
typedef struct tagNET_BUS_SITE_INFO
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // ��·��ʾ
    int             nSiteCount;                             // ��·��վ��
    NET_LINE_DIRECTION  emDirection;                        // ��·����
    int             nStopSequence;                          // վ�����
    char            szSiteID[DH_COMMON_STRING_32];          // վ��ID
    char            szSiteName[DH_COMMON_STRING_32];        // վ������
    NET_SITE_AREA_TYPE emAreaType;                          // վ����������
    int             nGPSPointNum;                           // ��ЧGPS����
    GPS_POINT       stuPoint[MAX_SITE_GPS_POINT_NUM];       // վ��GPS��Ϣ
    int             nRadius;                                // վ��뾶, ��λ: ��, ��Բ��վ����Ч
    int             nSpeedLimit;                            // վ������, ��λ: km/H
    int             nDriveTime;                             // ����վ����վʱ��, ��λ:����
    int             nTicketPrice;                           // ����Ʊ��
    DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // ����ʱ���, ��һά��Ԫ�ر�ʾ����~�����ͽڼ���
    char            szDesignation[DH_COMMON_STRING_64];     // ��·����
    char            szDirectionName[DH_COMMON_STRING_64];   // ��·��������
    char            szVersion[DH_COMMON_STRING_32];
    BOOL            bUseExName;                             // �Ƿ�ʹ����չվ������
    char            szSiteNameEx[DH_COMMON_STRING_128];     // վ��������չ, ���ȱ��
}NET_BUS_SITE_INFO;

#define MAX_BUS_STOP_NUM                            32      // һ��������·���վ����Ŀ

// �·�������·CLIENT_DispatchBusLineInfo()�ӿ��������
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
    int             nBusStopNum;                            // ������·վ�����
    NET_BUS_SITE_INFO   stuStopInfo[MAX_BUS_STOP_NUM];      // ������·��Ϣ
}NET_IN_DISPATCH_BUS_LINE_INFO;

// �·�������·CLIENT_DispatchBusLineInfo()�ӿ��������
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO;

// ������Ӫ����CLIENT_BusSchedule()�ӿ��������
typedef struct tagNET_IN_BUS_SCHEDULE_INFO 
{
    DWORD               dwSize;
    char                szLineID[DH_COMMON_STRING_64];      // ��Ӫ��·��ʶ
    NET_LINE_DIRECTION  emDirection;                        // ��Ӫ��·����
    NET_TIME_EX         stuStartTime;                       // ����ʱ��
}NET_IN_BUS_SCHEDULE_INFO;

// ������Ӫ����CLIENT_BusSchedule()�ӿ��������
typedef struct tagNET_OUT_BUS_SCHEDULE_INFO 
{
    DWORD           dwSize;
}NET_OUT_BUS_SCHEDULE_INFO;

// �����Ű�ƻ���Ϣ
typedef struct tagNET_BUS_WORK_PLAN 
{
    DWORD               dwSize;
    char                szID[DH_COMMON_STRING_32];          // �Ű��¼Ψһ��ʾ, ���16���ַ�
    NET_TIME_EX         stuTime;                            // ����ʱ��
    char                szDriverName[DH_COMMON_STRING_64];  // ˾������
    char                szStartSite[DH_COMMON_STRING_64];   // ʼ��վ����
    char                szEndSite[DH_COMMON_STRING_64];     // �յ�վ����
    BOOL                bRunning;                           // ��Ӫ״̬, TRUE:��Ӫ, FALSE:ͣ��
}NET_BUS_WORK_PLAN;

// �·������Ű�ƻ�CLIENT_DispatchWorkPlan�ӿ��������
typedef struct tagNET_IN_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
    NET_BUS_WORK_PLAN   stuWorkPlan;                        // �����Ű�ƻ���Ϣ
}NET_IN_BUS_DISPATCH_WORK_PLAN;

// �·������Ű�ƻ�CLIENT_DispatchWorkPlan�ӿ��������
typedef struct tagNET_OUT_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
}NET_OUT_BUS_DISPATCH_WORK_PLAN;

// �ȳ���ɫ��
typedef enum tagNET_THERMO_COLORIZATION 
{
    NET_THERMO_COLORIZATION_UNKNOWN,                        // δ֪
    NET_THERMO_COLORIZATION_WHITE_HOT,                      // ����
    NET_THERMO_COLORIZATION_BLACK_HOT,                      // ����
    NET_THERMO_COLORIZATION_IRONBOW2,                       // ����2
    NET_THERMO_COLORIZATION_ICEFIRE,                        // ����
	NET_THERMO_COLORIZATION_FUSION,                         // �ں�
	NET_THERMO_COLORIZATION_RAINBOW,                        // �ʺ�
	NET_THERMO_COLORIZATION_GLOBOW,                         // 
	NET_THERMO_COLORIZATION_IRONBOW1,                       // ����1
	NET_THERMO_COLORIZATION_SEPIA,                          // ���
	NET_THERMO_COLORIZATION_COLOR1,                         // ��ɫ1
	NET_THERMO_COLORIZATION_COLOR2,                         // ��ɫ2
	NET_THERMO_COLORIZATION_RAIN,                           // ����
	NET_THERMO_COLORIZATION_RED_HOT,                        // ����
	NET_THERMO_COLORIZATION_GREEN_HOT,                      // ����
} NET_THERMO_COLORIZATION;

// �ȳ������Ȥ����ģʽ
typedef enum tagNET_THERMO_ROI 
{
    NET_THERMO_ROI_UNKNOWN,                                 // δ֪
    NET_THERMO_ROI_FULL_SCREEN,                             // ȫ��
    NET_THERMO_ROI_SKY,                                     // ����
    NET_THERMO_ROI_GROUND,                                  // �в�
    NET_THERMO_ROI_HORIZONTAL,                              // �ײ�
    NET_THERMO_ROI_CENTER_75,                               // ���ĵ� 75%
    NET_THERMO_ROI_CENTER_50,                               // ���ĵ� 50%
    NET_THERMO_ROI_CENTER_25,                               // ���ĵ� 25%
    NET_THERMO_ROI_CUSTOM,                                  // �Զ���
} NET_THERMO_ROI;

// �ȳ���ģʽ
typedef enum tagNET_THERMO_MODE 
{
    NET_THERMO_MODE_UNKNOWN,                                // δ֪
    NET_THERMO_MODE_DEFAULT,                                // Ĭ��
    NET_THERMO_MODE_INDOOR,                                 // ����
    NET_THERMO_MODE_OUTDOOR,                                // ����
} NET_THERMO_MODE;

// �ȳ����Ż�����
typedef struct tagNET_THERMO_GRAPHY_OPT_REGION 
{
    BOOL                bOptimizedRegion;                   // �Ƿ����Ż�����
    int                 nOptimizedROIType;                  // �Ż���������,��NET_THERMO_ROI
    int                 nCustomRegion;                      // �Զ����������
    NET_RECT            stCustomRegions[64];                // �Զ�������,���� nOptimizedROIType Ϊ NET_THERMO_ROI_CUSTOM ʱ��Ч
    char                Reserved[256];
} NET_THERMO_GRAPHY_OPTREGION;

// �ȳ�����Ϣ
typedef struct tagNET_THERMO_GRAPHY_INFO 
{
    int                         nBrightness;                // ����
    int                         nSharpness;                 // ���
    int                         nEZoom;                     // ����
    int                         nThermographyGamma;         // ٤��ֵ
    int                         nColorization;              // ɫ��,��NET_THERMO_COLORIZATION
    int                         nSmartOptimizer;            // �Ż�ָ��
    NET_THERMO_GRAPHY_OPTREGION stOptRegion;                // �Ż�����
    int                         nAgc;                       // �Զ��������
    int                         nAgcMaxGain;                // ����Զ�����
    int                         nAgcPlateau;                // �������
    char                        reserved[244];
} NET_THERMO_GRAPHY_INFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_PRESET �������
typedef struct tagNET_IN_THERMO_GET_PRESETINFO 
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
    NET_THERMO_MODE     emMode;                             // ģʽ
} NET_IN_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_PRESET �������
typedef struct tagNET_OUT_THERMO_GET_PRESETINFO 
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_INFO      stInfo;                     // �ȳ�����Ϣ
} NET_OUT_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO �������
typedef struct tagNET_IN_THERMO_GET_EXTSYSINFO
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
} NET_IN_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_LINKCHANNELS �������
typedef struct tagNET_IN_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nChannel;	                        // ͨ����,��ѯ����Ƶͨ�����Ƿ��й�������Ƶͨ��
} NET_IN_GET_LINKCHANNELS;

#define NET_LINKCHANNEL_MAX     512                         // ����������Ƶͨ������
#define NET_LINKGROUP_MAX       64                          // ����������Ƶͨ�������

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_LINKCHANNELS �������
typedef struct tagNET_OUT_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nLinkedCnt;                         // ��������Ƶͨ���Ÿ���
    int                 nLinked[NET_LINKCHANNEL_MAX];	    // ��������Ƶͨ����,��������ͨ��������
} NET_OUT_GET_LINKCHANNELS;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_ALLLINKCHANNELS �������
typedef struct tagNET_IN_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
} NET_IN_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_ALLLINKCHANNELS �������
typedef struct tagNET_OUT_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
    int                 nGroupCnt;                                              // ��������Ƶͨ�������
    int                 nLinkedCnt[NET_LINKGROUP_MAX];                          // ÿ���������Ƶͨ���Ÿ���
    int                 nLinked[NET_LINKGROUP_MAX][NET_LINKCHANNEL_MAX];	    // ��������Ƶͨ����,��������ͨ��������
                                                                                // ��һά��ʾͨ����,�ڶ�ά��ʾͨ����
                                                                                // ����,nLinked[1][2] ��ʾ�ڶ���ͨ����ĵ���������ͨ��
} NET_OUT_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_CAMERA_STATE �������
typedef struct tagNET_IN_GET_CAMERA_STATEINFO
{
    DWORD               dwSize;
    BOOL                bGetAllFlag;                                // �Ƿ��ѯ���������״̬,��ó�ԱΪ TRUE,�� nChannels ��Ա��������
    int                 nValidNum;                                  // �ó�Ա,bGetAllFlag Ϊ FALSEʱ��Ч,��ʾ nChannels ��Ա��Ч����
    int                 nChannels[DH_MAX_CAMERA_CHANNEL_NUM];       // �ó�Ա,bGetAllFlag Ϊ FALSEʱ��Ч,����Ҫ��ѯ��ͨ������������
} NET_IN_GET_CAMERA_STATEINFO;

typedef enum tagEM_CAMERA_STATE_TYPE
{
    EM_CAMERA_STATE_TYPE_UNKNOWN,       // δ֪
    EM_CAMERA_STATE_TYPE_CONNECTING,    // ��������
    EM_CAMERA_STATE_TYPE_CONNECTED,     // ������
    EM_CAMERA_STATE_TYPE_UNCONNECT,     // δ����
    EM_CAMERA_STATE_TYPE_EMPTY,         // ͨ��δ����,����Ϣ
    EM_CAMERA_STATE_TYPE_DISABLE,       // ͨ��������,��������
}EM_CAMERA_STATE_TYPE;

typedef struct tagNET_CAMERA_STATE_INFO
{
    int                     nChannel;           // �����ͨ����, -1��ʾͨ������Ч
    EM_CAMERA_STATE_TYPE    emConnectionState;  // ����״̬
    char                    szReserved[1024];   // �����ֽ�
}NET_CAMERA_STATE_INFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_CAMERA_STATE �������
typedef struct tagNET_OUT_GET_CAMERA_STATEINFO 
{
    DWORD                       dwSize;
    int                         nValidNum;              // ��ѯ���������ͨ��״̬��Ч����,��sdk����
    int                         nMaxNum;                // pCameraStateInfo ����������,���û���д
    NET_CAMERA_STATE_INFO*      pCameraStateInfo;       // �����ͨ����Ϣ����,���û�����,��СΪsizeof(NET_CAMERA_STATE_INFO)*nMaxNum
} NET_OUT_GET_CAMERA_STATEINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE �������
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD               dwSize;
    int                 nChannel;                                   // ͨ����
    int                 nStreamType;                                // ��������,0����������1��������1��2��������2��3��������3��4���Խ���
} NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE �������
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD                       dwSize;
    int                         nValidNum;                                  // ��Ч��Ƶ�������
    DHDEV_TALKDECODE_INFO       stuListAudioEncode[MAX_AUDIO_ENCODE_NUM];   // ��Ƶ�����б�
} NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;


// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_COMM_PORT_INFO �������
typedef struct tagNET_IN_GET_COMM_PORT_INFO
{
    DWORD               dwSize;
} NET_IN_GET_COMM_PORT_INFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_COMM_PORT_INFO �������
//��������
typedef enum tagEM_COMM_PORT_TYPE_INFO
{
    EM_COMM_PORT_TYPE_UNKNOW = 0    ,
    EM_COMM_PORT_TYPE_RS232         ,
    EM_COMM_PORT_TYPE_RS485         ,
    EM_COMM_PORT_TYPE_RS422         ,
    EM_COMM_PORT_TYPE_RS485_422     ,
}EM_COMM_PORT_TYPE_INFO;

//������Ϣ
typedef struct  tagNET_COMM_PORT_INFO
{
    EM_COMM_PORT_TYPE_INFO  emCommPortType;     //��������
    int                     nCommPortNum;       //��������
    BYTE                    bReserved[1024];    //�����ֽ�
}NET_COMM_PORT_INFO;

#define MAX_COMM_PORT_NUM       8
typedef struct tagNET_OUT_GET_COMM_PORT_INFO
{
    DWORD                       dwSize;
    int                         nPortInfosNum;                          //������Ϣ��
    NET_COMM_PORT_INFO          stCommPortInfos[MAX_COMM_PORT_NUM];     //������Ϣ
} NET_OUT_GET_COMM_PORT_INFO;

// �ⲿϵͳ��Ϣ
typedef struct tagNET_THERMO_SYSINFO 
{
    char                szSerialNumber[64];                 // ���к�
    char                szSoftwareVersion[64];              // ����汾
    char                szFirmwareVersion[64];              // �̼��汾
    char                szLibVersion[64];                   // ��汾
    char                reserved[256];
} NET_THERMO_SYSINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO �������
typedef struct tagNET_OUT_THERMO_GET_EXTSYSINFO
{
    DWORD                       dwSize;
    NET_THERMO_SYSINFO          stInfo;                     // �ⲿϵͳ��Ϣ
} NET_OUT_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION �������
typedef struct tagNET_IN_THERMO_GET_OPTREGION
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
} NET_IN_THERMO_GET_OPTREGION;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION �������
typedef struct tagNET_OUT_THERMO_GET_OPTREGION
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_OPTREGION stInfo;                     // �Ż�������Ϣ
} NET_OUT_THERMO_GET_OPTREGION;


// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_VIDEOOUTPUTCHANNELS �������
typedef struct tagNET_IN_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_IN_GET_VIDEOOUTPUTCHANNELS)
} NET_IN_GET_VIDEOOUTPUTCHANNELS;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_VIDEOOUTPUTCHANNELS �������
typedef struct tagNET_OUT_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_OUT_GET_VIDEOOUTPUTCHANNELS)
    int                 nMaxLocal;          // ��󱾵����ͨ������,������Ϳɲ���ӿ�ͨ��
} NET_OUT_GET_VIDEOOUTPUTCHANNELS;


// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_VIDEOINFO �������
typedef struct tagNET_IN_GET_VIDEOINFO
{
    DWORD               dwSize;             // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_IN_GET_VIDEOINFO)
} NET_IN_GET_VIDEOINFO;

// ����ͨ��״̬
typedef enum  tagNET_VIDEOCHANNEL_STATE
{
    NET_VIDEOCHANNEL_STATE_UNKNOWN,        // δ֪״̬
    NET_VIDEOCHANNEL_STATE_IDLE,           // ����
    NET_VIDEOCHANNEL_STATE_PLAY,           // ����
    NET_VIDEOCHANNEL_STATE_MONITOR,        // ����
    NET_VIDEOCHANNEL_STATE_TOUR,           // ��ѯ
} NET_VIDEOCHANNEL_STATE;

// ����ͨ����Ϣ
typedef struct tagNET_VIDEOCHANNELINFO
{
    BOOL                         bEnable;                // ͨ��ʹ��״̬, ״̬Ϊtrueʱ,GB28181Э��Ὣ���ͨ���ϱ�������
    NET_VIDEOCHANNEL_STATE       emVideoChannelState;    // ����ͨ��״̬
    int                          nNetflow;               // ��������(��λ��kbps)
    int                          nBitrate;               // ����(��λ��kbps)
    int                          nFrame;                 // ֡��
    CAPTURE_SIZE                 emResolution;           // �ֱ���
    BYTE                         byReserved[512];        // Ԥ���ֽ� 
} NET_VIDEOCHANNELINFO;


// CLIENT_QueryDevInfo �ӿ� NET_QUERY_GET_VIDEOINFO �������
typedef struct tagNET_OUT_GET_VIDEOINFO
{
    DWORD                    dwSize;                // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof(NET_OUT_GET_VIDEOINFO)
    int                      nVideoInfoNum;         // �û���Ҫ��ȡ�Ľ���ͨ����Ϣ����,��0��ʼ��ȡ,�û�ָ��
    NET_VIDEOCHANNELINFO*    pNetVideoChannelInfo;  // ����ͨ����Ϣ�б�,�û�����ռ�,�û������б������nVideoInfoNumһ��,�����ڴ��СΪsizeof(NET_VIDEOCHANNELINFO)*nVideoInfoNum
    int                      nRetVideoInfoNum;      // ����ʵ�ʻ�ȡ���Ľ���ͨ����Ϣ����,SDK����
} NET_OUT_GET_VIDEOINFO;



// CLIENT_ControlDeviceEx �ӿ� NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER �������
typedef struct tagNET_IN_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
    BOOL                bEnable;                            // ����shutter,TRUE ��,FALSE ��
} NET_IN_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx �ӿ� NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER �������
typedef struct tagNET_OUT_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
} NET_OUT_THERMO_EN_SHUTTER;

// CLIENT_GetDevCaps �ӿ� NET_THERMO_GRAPHY_CAPS �������
typedef struct tagNET_IN_THERMO_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
} NET_IN_THERMO_GETCAPS;

// CLIENT_GetDevCaps �ӿ� NET_THERMO_GRAPHY_CAPS �������
typedef struct tagNET_OUT_THERMO_GETCAPS
{
    DWORD               dwSize;
    DWORD               dwModes;                            // ֧�ֵ�Ԥ��ģʽ����
    DWORD               dwColorization;                     // Ԥ����ɫģʽ����
    DWORD               dwROIModes;                         // Ԥ�ø���Ȥ����ģʽ����
    RANGE               stBrightness;                       // �����������
    RANGE               stSharpness;                        // ����������
    RANGE               stEZoom;                            // �����������
    RANGE               stThermographyGamma;                // ٤���������
    RANGE               stSmartOptimizer;                   // �Ż������������
} NET_OUT_THERMO_GETCAPS;

// CLIENT_GetDevCaps �ӿ� NET_RADIOMETRY_CAPS �������
typedef struct tagNET_IN_RADIOMETRY_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
} NET_IN_RADIOMETRY_GETCAPS;

// ����ģʽ������
typedef enum tagNET_RADIOMETRY_METERTYPE 
{
    NET_RADIOMETRY_METERTYPE_UNKNOWN,
    NET_RADIOMETRY_METERTYPE_SPOT,                          // ��
    NET_RADIOMETRY_METERTYPE_LINE,                          // ��
    NET_RADIOMETRY_METERTYPE_AREA,                          // ����
} NET_RADIOMETRY_METERTYPE;

// ��,��,�����ܸ�������
typedef struct tagNET_RADIOMETRY_TOTALNUM 
{
    DWORD               dwMaxNum;                           // ���֧�ָ���
    DWORD               dwMaxSpots;                         // ����ĸ���
    DWORD               dwMaxLines;                         // ��໮�ߵ�����
    DWORD               dwMaxAreas;                         // �������ĸ���
    char				reserved[32]; 
} NET_RADIOMETRY_TOTALNUM;

// CLIENT_GetDevCaps �ӿ� NET_RADIOMETRY_CAPS �������
typedef struct tagNET_OUT_RADIOMETRY_GETCAPS
{
    DWORD                       dwSize;
    NET_RADIOMETRY_TOTALNUM     stTotalNum;                 // ��,��,�����ܸ�������
    DWORD                       dwMaxPresets;               // ������Ԥ�õ�ĸ���
    DWORD                       dwMeterType;                // ����ģʽ����������,��NET_RADIOMETRY_METERTYPE
    RANGE                       stObjectEmissivity;         // ����ϵ���������
    RANGE                       stObjectDistance;           // �����������
    RANGE                       stReflectedTemperature;     // �����¶��������
    RANGE                       stRelativeHumidity;         // ���ʪ���������
    RANGE                       stAtmosphericTemperature;   // �����¶��������
    int                         nStatisticsMinPeriod;       // ���µ�ͳ�ƹ�����С�洢���ݼ��  ��λΪ��
    float                       fIsothermMaxTemp;           // ɫ��������¶�ֵ
    float                       fIsothermMinTemp;           // ɫ��������¶�ֵ
} NET_OUT_RADIOMETRY_GETCAPS;

// ������Ϣ
typedef struct tagNET_RADIOMETRYINFO
{
    int                 nMeterType;                         // ���ز�������,��NET_RADIOMETRY_METERTYPE
    int                 nTemperUnit;                        // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
    float               fTemperAver;                        // ����¶Ȼ���ƽ���¶�   ���ʱ�� ֻ���ش��ֶ�
    float               fTemperMax;                         // ����¶� 
    float               fTemperMin;                         // ����¶� 
    float               fTemperMid;                         // �м��¶�ֵ    
    float               fTemperStd;                         // ��׼����ֵ
    char                reserved[64];
} NET_RADIOMETRYINFO;

// ��ȡ�������¶ȵ�����   
typedef struct tagNET_RADIOMETRY_CONDITION
{
    int                 nPresetId;                          // Ԥ�õ���    
    int                 nRuleId;                            // ������ 
    int                 nMeterType;                         // ���������,��NET_RADIOMETRY_METERTYPE
    char                szName[64];                         // �����������,�Ӳ������ù���������ѡȡ
    int                 nChannel;                           // ͨ����
    char                reserved[256];
} NET_RADIOMETRY_CONDITION;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER �������
typedef struct tagNET_IN_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����
    DH_POINT            stCoordinate;                       // ���µ������,����ֵ 0~8192
} NET_IN_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER �������
typedef struct tagNET_OUT_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stPointTempInfo;                    // ��ȡ���µ�Ĳ���ֵ
} NET_OUT_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_RADIOMETRY_TEMPER �������
typedef struct tagNET_IN_RADIOMETRY_GETTEMPER
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // ��ȡ�������¶ȵ�����
} NET_IN_RADIOMETRY_GETTEMPER;

// CLIENT_QueryDevInfo �ӿ� NET_QUERY_DEV_RADIOMETRY_TEMPER �������
typedef struct tagNET_OUT_RADIOMETRY_GETTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stTempInfo;                         // ��ȡ���²���ֵ
} NET_OUT_RADIOMETRY_GETTEMPER;

// CLIENT_ControlDeviceEx �ӿ� NET_CTRL_DEV_RADIOMETRY_SETOSDMARK �������
typedef struct tagNET_IN_RADIOMETRY_SETOSDMARK
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // ��Ҫ���� osd �Ĳ������ƥ������
} NET_IN_RADIOMETRY_SETOSDMARK;

// CLIENT_ControlDeviceEx �ӿ� NET_CTRL_DEV_RADIOMETRY_SETOSDMARK �������
typedef struct tagNET_OUT_RADIOMETRY_SETOSDMARK
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_SETOSDMARK;

//�ȳ����ѯ��������
typedef enum tagEM_RADIOMETRY_PERIOD
{
	EM_RADIOMETRY_PERIOD_UNKNOWN,			// δ֪
    EM_RADIOMETRY_PERIOD_5  = 5,			// 5���Ӽ�¼��Ĭ��
	EM_RADIOMETRY_PERIOD_10 = 10,           // 10���Ӽ�¼��
	EM_RADIOMETRY_PERIOD_15 = 15,           // 15���Ӽ�¼��
	EM_RADIOMETRY_PERIOD_30 = 30,           // 30���Ӽ�¼��
}EM_RADIOMETRY_PERIOD;

// CLIENT_StartFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_IN_RADIOMETRY_STARTFIND
{   
    DWORD                  dwSize;
    NET_TIME               stStartTime;                       // ��ѯ��ʼʱ��
    NET_TIME               stEndTime;                         // ��ѯ����ʱ��
    int                    nMeterType;                        // ��ѯ���,��ö��NET_RADIOMETRY_METERTYPE
    int                    nChannel;                          // ͨ����
    EM_RADIOMETRY_PERIOD   emPeriod;                          // ����ѯ��ı�������
} NET_IN_RADIOMETRY_STARTFIND;

// CLIENT_StartFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_OUT_RADIOMETRY_STARTFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // ȡ���Ĳ�ѯ���
    int                 nTotalCount;                       // ���ϴ˴β�ѯ�����Ľ��������
} NET_OUT_RADIOMETRY_STARTFIND;

#define NET_RADIOMETRY_DOFIND_MAX 32

// CLIENT_DoFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_IN_RADIOMETRY_DOFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // ��ѯ���
    int                 nBeginNumber;                      // ���β�ѯ��ʼ��������
    int                 nCount;                            // ���β�ѯ����,���ΪNET_IN_RADIOMETRY_DOFIND_MAX
} NET_IN_RADIOMETRY_DOFIND;

// ���ز�ѯ���
typedef struct tagNET_RADIOMETRY_QUERY
{
    NET_TIME            stTime;                            // ��¼ʱ��
    int                 nPresetId;                         // Ԥ�õ���
    int                 nRuleId;                           // ������
    char                szName[64];                        // ��ѯ������
    DH_POINT            stCoordinate;                      // ��ѯ���µ�����
    int                 nChannel;                          // ͨ����
    NET_RADIOMETRYINFO  stTemperInfo;                      // ������Ϣ,ĿǰnTemperMid, nTemperStd ��Ա��Ч
    char                reserved[256];
} NET_RADIOMETRY_QUERY;

// CLIENT_DoFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_OUT_RADIOMETRY_DOFIND
{   
    DWORD                       dwSize;
    int                         nFound;                             // ʵ�ʲ�ѯ���ĵ���
    NET_RADIOMETRY_QUERY        stInfo[NET_RADIOMETRY_DOFIND_MAX];  // �¶�ͳ����Ϣ
} NET_OUT_RADIOMETRY_DOFIND;

// CLIENT_StopFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_IN_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                       // ��ѯ���
} NET_IN_RADIOMETRY_STOPFIND;

// CLIENT_StopFind �ӿ� NET_FIND_RADIOMETRY �������
typedef struct tagNET_OUT_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_STOPFIND;

// �ȳ�����µ㱨�����ֵ����
typedef enum tagNET_RADIOMETRY_RESULT 
{
    NET_RADIOMETRY_RESULT_UNKNOWN,
    NET_RADIOMETRY_RESULT_VAL,                  // ����ֵ
    NET_RADIOMETRY_RESULT_MAX,                  // ���
    NET_RADIOMETRY_RESULT_MIN,                  // ��С
    NET_RADIOMETRY_RESULT_AVR,                  // ƽ��
    NET_RADIOMETRY_RESULT_STD,                  // ��׼
    NET_RADIOMETRY_RESULT_MID,                  // �м�
    NET_RADIOMETRY_RESULT_ISO,                  // ISO
    NET_RADIOMETRY_RESULT_DIFF,                 // �²�
    NET_RADIOMETRY_RESULT_SLOPE,                // б��
} NET_RADIOMETRY_RESULT;

// �ȳ�����µ㱨������
typedef enum tagNET_RADIOMETRY_ALARMCONTION 
{
    NET_RADIOMETRY_ALARMCONTION_UNKNOWN,
    NET_RADIOMETRY_ALARMCONTION_BELOW,          // С��
    NET_RADIOMETRY_ALARMCONTION_MATCH,          // ����
    NET_RADIOMETRY_ALARMCONTION_ABOVE,          // ����
} NET_RADIOMETRY_ALARMCONTION;

// �¶ȵ�λ
typedef enum tagNET_TEMPERATURE_UNIT
{
    NET_TEMPERATURE_UNIT_UNKNOWN,
    NET_TEMPERATURE_UNIT_CENTIGRADE,                // ���϶�
    NET_TEMPERATURE_UNIT_FAHRENHEIT,                // ���϶�
} NET_TEMPERATURE_UNIT;

// �ȳ�����µ��¶��쳣����
typedef struct tagALARM_HEATIMG_TEMPER_INFO
{
    char                szName[64];                         // �¶��쳣������  �Ӳ��¹�����������ѡ��
    int                 nAlarmId;                           // ��������    
    int                 nResult;                            // �������ֵ fTemperatureValue ������,��ö�� NET_RADIOMETRY_RESULT
    int                 nAlarmContion;                      // ��������,��ö�� NET_RADIOMETRY_ALARMCONTION
    float               fTemperatureValue;                  // �����¶�ֵ
    int                 nTemperatureUnit;                   // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
    DH_POINT            stCoordinate;                       // �����������   ���������ϵ,ȡֵ��Ϊ0~8191
    int                 nPresetID;                          // Ԥ�õ�
    int                 nChannel;                           // ͨ����
    int                 nAction;                            // 0:��ʼ 1:ֹͣ -1:������
	DH_POLY_POINTS      stuAlarmCoordinates;				// ��������, �����Ϳ����ǵ㣬�߻����Ρ��滻stCoordinate�ֶ�  
    char                reserved[156];
} ALARM_HEATIMG_TEMPER_INFO;

// �ȳ����Ż�㱨��
typedef struct tagALARM_FIREWARNING_INFO
{
    int                 nPresetId;                          // ���ֶη���������DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ
    int                 nState;                             // 0 - ��ʼ,1 - ����,-1:������
    DH_RECT             stBoundingBox;                      // ���ֶη���,����DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ	
    int                 nTemperatureUnit;                   // ���ֶη���,����DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ
    float               fTemperature;                       // ���ֶη���,����DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ 
    unsigned            nDistance;                          // ���ֶη���,����DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ
	GPS_POINT           stGpsPoint;                         // ���ֶη���,����DH_ALARM_FIREWARNING_INFO�¼���ȡ����Ϣ
    int                 nChannel;                           // ��Ӧ��Ƶͨ����
    char                reserved[252];
} ALARM_FIREWARNING_INFO;

//��̨�������굥Ԫ
typedef struct tagPTZ_POSITION_UNIT
{
    int                  nPositionX;                        // ��̨ˮƽ����Ƕ�,��һ����-1~1
    int                  nPositionY;                        // ��̨��ֱ����Ƕ�,��һ����-1~1
    int                  nZoom;                             // ��̨��Ȧ�Ŵ���,��һ���� 0~1
    char                 szReserve[32];                     // Ԥ��32�ֽ�
}PTZ_POSITION_UNIT;

//�ȳ�����鱨����Ϣ
typedef struct tagNET_FIREWARNING_INFO
{
    int                 nPresetId;                          // Ԥ�õ���	�Ӳ��¹�������CFG_RADIOMETRY_RULE_INFO��ѡ��
    NET_RECT            stuBoundingBox;                     // �Ż����ο�	
    int                 nTemperatureUnit;                   // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
    float               fTemperature;                       // ��ߵ��¶�ֵ	ͬ֡���Ͳ�ּ���ṩ
    unsigned            nDistance;                          // �Ż�����,��λ�� 0��ʾ��Ч
    GPS_POINT           stuGpsPoint;                        // �Ż�㾭γ��
    PTZ_POSITION_UNIT   stuPTZPosition;                     // ��̨������Ϣ
    float               fAltitude;                          // �߶�(��λ����)
    BYTE                reserved[208];
}NET_FIREWARNING_INFO;


// �ȳ�����鱨����Ϣ�ϱ��¼�
typedef struct tagALARM_FIREWARNING_INFO_DETAIL
{
    int                     nChannel;                                           // ��Ӧ��Ƶͨ����
    int                     nWarningInfoCount;                                  // ������Ϣ����
    NET_FIREWARNING_INFO    stuFireWarningInfo[MAX_FIREWARNING_INFO_NUM];       // ���屨����Ϣ
    BYTE                    reserved[256];
}ALARM_FIREWARNING_INFO_DETAIL;

//�ȳ������巢��Ԥ���¼�
typedef struct tagALARM_FACE_OVERHEATING_INFO
{
    int                     nRelativeId;                                        // ����ͼƬID,�� NET_FACE_INFO->nRelativeID��ͬ
    int                     nTemperatureUnit;                                   // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
    float                   fTemperature;                                       // �����¶�ֵ
    int                     nChannelID;                                         // ��Ƶͨ��
    BYTE                    reserved[124];                                      
}ALARM_FACE_OVERHEATING_INFO;

// ̽����״̬
typedef enum tagEM_SENSOR_ABNORMAL_STATUS
{
    NET_SENSOR_ABNORMAL_STATUS_UNKNOWN,
    NET_SENSOR_ABNORMAL_STATUS_SHORT,                                   // ��·
    NET_SENSOR_ABNORMAL_STATUS_BREAK,                                   // ��·
    NET_SENSOR_ABNORMAL_STATUS_INTRIDED,                                // ����
} EM_SENSOR_ABNORMAL_STATUS;

//�¼�����(DH_ALARM_SENSOR_ABNORMAL) ̽����״̬�쳣����
typedef struct tagALARM_SENSOR_ABNORMAL_INFO
{
    int                                 nAction;                        // 0:��ʼ 1:ֹͣ
    int                                 nChannelID;                     // ��Ƶͨ����
    NET_TIME_EX                         stuTime;                        // �¼�������ʱ��
    EM_SENSOR_ABNORMAL_STATUS           emStatus;                       // ̽����״̬
    BYTE                                byReserved[128];                // Ԥ���ֶ� 
}ALARM_SENSOR_ABNORMAL_INFO;

// ��ͼԪ������Ϣ
typedef struct tagNET_RADIOMETRY_METADATA
{
    int                 nHeight;                            // ��
    int                 nWidth;                             // ��
    int                 nChannel;                           // ͨ��
    NET_TIME            stTime;                             // ��ȡ����ʱ��
    int                 nLength;                            // ���ݴ�С
    char                szSensorType[64];                   // ��о����
    int                 nUnzipParamR;                       // ��ѹ������R
    int                 nUnzipParamB;                       // ��ѹ������B
    int                 nUnzipParamF;                       // ��ѹ������F
    int                 nUnzipParamO;                       // ��ѹ������O
    char                Reserved[256];
} NET_RADIOMETRY_METADATA;

// ��ͼ����
typedef struct tagNET_RADIOMETRY_DATA
{
    NET_RADIOMETRY_METADATA     stMetaData;                 // Ԫ����
    BYTE*                       pbDataBuf;                  // ��ͼ���ݻ�������ѹ����������,������ÿ�����ص���¶�����,����ʹ��Ԫ������Ϣ��ѹ��
    DWORD                       dwBufSize;                  // ��ͼ���ݻ�������С
    char                        reserved[512];
} NET_RADIOMETRY_DATA;

//////////////////////////////////////////////////////////////////////////
/// \fn �¶ȷֲ�����״̬�ص�����
/// \brief 
/// \param  LLONG lAttachHandle [OUT] ���ľ��, CLIENT_RadiometryAttach �ķ���ֵ 
/// \param  NET_RADIOMETRY_DATA* pBuf [OUT] ��ͼ������Ϣ
/// \param  int nBufLen [OUT] ״̬��Ϣ����
/// \param  LDWORD dwUser �û�����
/// \return ��
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachCB)(LLONG lAttachHandle, NET_RADIOMETRY_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttach ���
typedef struct tagNET_IN_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
    int                 nChannel;                           // ��Ƶͨ����	-1 ��ʾȫ��
    fRadiometryAttachCB cbNotify;                           // ״̬�ص�����ָ��
    LDWORD              dwUser;                             // �û�����
} NET_IN_RADIOMETRY_ATTACH;

// CLIENT_RadiometryAttach ����
typedef struct tagNET_OUT_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_ATTACH;

// �����¶ȷֲ����ݣ���ͼ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttach(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH* pInParam, NET_OUT_RADIOMETRY_ATTACH* pOutParam, int nWaitTime);

// ȡ�������¶ȷֲ�����,lAttachHandle�� CLIENT_RadiometryAttach �ķ���ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetach(LLONG lAttachHandle);

// CLIENT_RadiometryFetch ���
typedef struct tagNET_IN_RADIOMETRY_FETCH
{
    DWORD               dwSize;
    int                 nChannel;                           // ͨ����, ͨ����Ҫ�붩��ʱһ��, -1����
} NET_IN_RADIOMETRY_FETCH;

// CLIENT_RadiometryFetch ����
typedef struct tagNET_OUT_RADIOMETRY_FETCH 
{
    DWORD               dwSize;
    int                 nStatus;                            // 0: δ֪, 1: ����, 2: ��ȡ��ͼ��
} NET_OUT_RADIOMETRY_FETCH;

// ֪ͨ��ʼ��ȡ��ͼ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryFetch(LLONG lLoginID, const NET_IN_RADIOMETRY_FETCH* pInParam, NET_OUT_RADIOMETRY_FETCH* pOutParam, int nWaitTime);

// ��ͼ���ݽ�ѹ��ת���ӿ�
/// \brief 
/// \param  pRadiometryData [IN] ��ͼ���ݣ� �� fRadiometryAttachCB ���
/// \param  pGrayImg [IN, OUT] ��ѹ������ݣ���һ�ŻҶ�ͼ��
///			����ָ���ʾ����Ҫ������
///         �û��豣֤����Ļ������㹻�󣨲�С�� ͼ��������*sizeof(unsigned short)��
///         ÿ�����ض�Ӧһ�� unsigned short �����ݣ���ʾͼ��ĳ�����ص��ȳ���Ҷȣ���Χ 0 ~ 16383����
///         �͵�ַ��Ӧ�������Ͻǣ��ߵ�ַ��Ӧ�������½�
/// \param  pTempForPixels [IN, OUT] ÿ�����ص��¶�����
///			����ָ���ʾ����Ҫ������
///         �û��豣֤����Ļ������㹻�󣨲�С�� ͼ��������*sizeof(float)��
///         ÿ�����ض�Ӧһ�� float �����ݣ���ʾ������λ�õ������¶�
///         �͵�ַ��Ӧ�������Ͻǣ��ߵ�ַ��Ӧ�������½�
/// \return TRUE �ɹ���FALSE ʧ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDataParse(const NET_RADIOMETRY_DATA* pRadiometryData, unsigned short* pGrayImg, float* pTempForPixels);

// CLIENT_GetRadiometryYImage ���
typedef struct tagNET_IN_RADIOMETRY_Y_IMAGE
{
    DWORD                       dwSize;
    int                         nChannel;                               // ͨ����
}NET_IN_RADIOMETRY_Y_IMAGE;

// CLIENT_GetRadiometryYImage ����
typedef struct tagNET_OUT_RADIOMETRY_Y_IMAGE
{   
    DWORD                       dwSize; 
    UINT                        nWidth;                                 // ͼ���
    double                      PTS;                                    // ʱ���(��λ�Ǻ���)
    UINT                        nHeight;                                // ͼ���
    char*                       pbDataBuf;                              // Y���ݻ��������û������ڴ棬��СΪBuflen��
    int                         nBufLen;                                // pbDataBuf��󳤶�
    int                         nBufRet;                                // ʵ�ʷ��صĳ���
}NET_OUT_RADIOMETRY_Y_IMAGE;

// ��ȡ�ȳ����豸�ĵ�ǰY����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRadiometryYImage(LLONG lLoginID, const NET_IN_RADIOMETRY_Y_IMAGE* pInParam, NET_OUT_RADIOMETRY_Y_IMAGE* pOutParam,int nWaitTime);

//////////////////////////////////////////////////////////////////////////
// ��ѯ������Ϣ
//////////////////////////////////////////////////////////////////////////

// ��ȡ������Ϣ����Σ�
typedef struct tagNET_IN_SIM_CARD_FLUX_INFO
{	
	DWORD dwSize;                 // �ṹ���С
	int nCardIndex;               // sim��� ��0��ʼ
}NET_IN_SIM_CARD_FLUX_INFO;

#define NET_FLUX_RECORD_MAX_NUM 7      // ������Ϣ��¼���ֵ

// ������¼�ṹ��
typedef struct tagNET_SIM_CARD_FLUX_RECORD
{
	NET_TIME stuDate;            // ����
	UINT nDaySendFlux;           // ������������ Uint32��λ��0.1kb
	UINT nDayRecvFlux;           // ������������ Uint32��λ��0.1kb
	BYTE byReserved[512];        // �����ֽ�

}NET_SIM_CARD_FLUX_RECORD;

// ��ȡ��������Ϣ�����Σ�
typedef struct tagNET_OUT_SIM_CARD_FLUX_INFO
{
	DWORD dwSize;                                        // �ṹ���С         
	UINT nTotalFlux;                                     // �ܵ�����=��������+�������� Uint32��λ��0.1kb  
	UINT nSendFlux;                                      // �������� Uint32��λ��0.1kb 
	UINT nRecvFlux;                                      // �������� Uint32��λ��0.1kb
	NET_TIME stuTime;                                    // ������д��ʱ��
	int nRecordNum;                                      // ��¼���� ���ֵ��Ӧ�ô��� NET_RECORD_MAX_NUM
	NET_SIM_CARD_FLUX_RECORD stuRecord[NET_FLUX_RECORD_MAX_NUM];  // ��������������¼
	UINT nLastMonthTotalFlux;                                     // �ϸ��������� Uint32��λ��0.1kb 

}NET_OUT_SIM_CARD_FLUX_INFO;

// ��ȡSIM��������Ϣ,pNetDataIn��pNetDataOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSimCardFlux(LLONG lLoginID,const NET_IN_SIM_CARD_FLUX_INFO* pNetDataIn,NET_OUT_SIM_CARD_FLUX_INFO* pNetDataOut,int nWaitTime = 1000);

// ���÷������Ž�����ģʽ,pNetDataIn��pNetDataOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDoorWorkMode(LLONG lLoginID,const NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataIn,NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ������LED����,pInParam��pOutParam���û������ڴ�,����emType��Ӧ�Ľṹ��,����ȷ�������ڴ��С
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlCabinLED(LLONG lLoginID, EM_CABIN_LED_CONTROL_TYPE emType,const void *pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);


#define NET_SELECT_UPDATE_LOCK_MAX_NUM 32               // ������ʱ���ͬʱָ���ĸ���

// Զ������������ͨ����Ϣ(���)
typedef struct tagNET_IN_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;
    int nChannelNum;                                    // ��Ҫѡ����������ĸ���
    int nChannel[NET_SELECT_UPDATE_LOCK_MAX_NUM];       // ��������ͨ����
}NET_IN_SELECT_UPDATE_LOCK_INFO;

// Զ������������ͨ����Ϣ(����)
typedef struct tagNET_OUT_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;   
}NET_OUT_SELECT_UPDATE_LOCK_INFO;

// ��������ͨ����ѡ��Զ��������,pNetDataIn��pNetDataOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SelectLockToUpdate(LLONG lLoginID,const NET_IN_SELECT_UPDATE_LOCK_INFO* pNetDataIn,NET_OUT_SELECT_UPDATE_LOCK_INFO* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

typedef enum tagEM_AUTHORITY_SUB_TYPE
{
    EM_AUTHORITY_SUB_TYPE_UNKNOWN,                            // Unknown
    EM_AUTHORITY_SUB_TYPE_SHUT_DOWN,                          // �ر��豸
    EM_AUTHORITY_SUB_TYPE_MONITOR,                            // ʵʱ��������ͨ��
    EM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,                // ʵʱ����ͨ��
    EM_AUTHORITY_SUB_TYPE_REPLAY,                             // �ط�����ͨ��
    EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,                 // �ط�ͨ��
    EM_AUTHORITY_SUB_TYPE_BACKUP,                             // ¼���ļ�����
    EM_AUTHORITY_SUB_TYPE_MHARDISK,                           // Ӳ�̹���
    EM_AUTHORITY_SUB_TYPE_MPTZ,                               // ��̨��X��Y��Z�ĵ�����ƣ���Ȩ���ܲ�Ʒ�����HasPtz���ƣ���HasPtzΪfalse����Ȩ����Ч
    EM_AUTHORITY_SUB_TYPE_ACCOUNT,                            // �û��ʺ�
    EM_AUTHORITY_SUB_TYPE_QUERY_LOG,                          // ��־��ѯ
    EM_AUTHORITY_SUB_TYPE_DEL_LOG,                            // ɾ����־
    EM_AUTHORITY_SUB_TYPE_SYS_UPDATE,                         // ����ϵͳ
    EM_AUTHORITY_SUB_TYPE_AUTO_MAINTAIN,                      // �Զ�ά��
    EM_AUTHORITY_SUB_TYPE_GENERAL_CONF,                       // ��ͨ����
    EM_AUTHORITY_SUB_TYPE_ENCODE_CONF,                        // ��������
    EM_AUTHORITY_SUB_TYPE_RECORD,                             // ¼��ģʽ�ֶ����Զ�����(RecordMode����)
    EM_AUTHORITY_SUB_TYPE_RECORD_CONF,                        // ¼�����ʱ�䡢�ļ���ʽ������(Record����)
    EM_AUTHORITY_SUB_TYPE_COM_CONF,                           // ��������
    EM_AUTHORITY_SUB_TYPE_NET_CONF,                           // ��������
    EM_AUTHORITY_SUB_TYPE_ALARM,                              // �������IO����
    EM_AUTHORITY_SUB_TYPE_ALARM_CONF,                         // ��������
    EM_AUTHORITY_SUB_TYPE_VIDEO_CONFIG,                       // ��Ƶ�����ڵ���ʧ
    EM_AUTHORITY_SUB_TYPE_PTZ_CONFIG,                         // ��̨����
    EM_AUTHORITY_SUB_TYPE_OUTPUT_CONFIG,                      // ��Ƶ�������
    EM_AUTHORITY_SUB_TYPE_VIDEO_INPUT_CONFIG,                 // ��Ƶ��������
    EM_AUTHORITY_SUB_TYPE_DEFAULT_CONFIG,                     // �ָ�Ĭ��
    EM_AUTHORITY_SUB_TYPE_BK_CONFIG,                          // �洢���������뵼������
    EM_AUTHORITY_SUB_TYPE_INTELLI_CONFIG,                     // ��������
    EM_AUTHORITY_SUB_TYPE_REMOTE_DEVICE,                      // ���ɾ��Զ���豸
    EM_AUTHORITY_SUB_TYPE_ATM_POS,                            // ���ڵ���
    EM_AUTHORITY_SUB_TYPE_OFFLINE_LOGINED_USER,               // �߳��û�
    EM_AUTHORITY_SUB_TYPE_AUDIO_AUTH,                         // �洢ʹ�ã�����Ͷ��
    EM_AUTHORITY_SUB_TYPE_SPOT_SET,                           // �洢ʹ�ã���Ƶ����
    EM_AUTHORITY_SUB_TYPE_TVSET,                              // �洢ʹ�ã�TV�߾����
    EM_AUTHORITY_SUB_TYPE_IPSAN,                              // IPSAN����
    EM_AUTHORITY_SUB_TYPE_CONFIG,                             // �洢ʹ�ã������ģ����������ʹ��
    EM_AUTHORITY_SUB_TYPE_ARMING,                             // ����
    EM_AUTHORITY_SUB_TYPE_DISARM,                             // ����
    EM_AUTHORITY_SUB_TYPE_BYPASS,                             // ��·������ͨ����
    EM_AUTHORITY_SUB_TYPE_BYPASS_PARTIAL,                     // ��·������ͨ����
    EM_AUTHORITY_SUB_TYPE_ALARM_BELL,                         // �������
    EM_AUTHORITY_SUB_TYPE_ALARM_CONFIRM_PARTIAL,              // ����������ͨ����
    EM_AUTHORITY_SUB_TYPE_DEFENCE_CONFIG_PARTIAL,             // �������ã�����ͨ����
    EM_AUTHORITY_SUB_TYPE_ALARM_OUT_PARITAL,                  // �������������ͨ����
    EM_AUTHORITY_SUB_TYPE_TALK,                               // ����Խ�
    EM_AUTHORITY_SUB_TYPE_WIRELESS_CONFIG,                    // ����������
    EM_AUTHORITY_SUB_TYPE_MOBILE_CONFIG,                      // �ƶ�ҵ������
    EM_AUTHORITY_SUB_TYPE_AUDIO_DETECT_CONFIG,                // ��Ƶ�������
    EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL,            // Ԥ��ͨ��

    EM_AUTHORITY_SUB_TYPE_REBOOT,                             // �豸����
    EM_AUTHORITY_SUB_TYPE_SYS_LENS,                           // ���ƻ������оû����̨������Ҫ���Ʊ䱶���۽�����Ȧ�ȹ��ܣ����Ӵ�Ȩ����
    EM_AUTHORITY_SUB_TYPE_RAIN_BRUSH_CONFIG,                  // ��ˢ����
    EM_AUTHORITY_SUB_TYPE_LIGHTING_CONFIG,                    // �ƹ�����
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL,                     // �Ž����ƣ�����ͨ����
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL_PARTIAL,             // �Ž����ƣ�����ͨ����
    EM_AUTHORITY_SUB_TYPE_DECODE_TOUR,                        // ������Ѳ
    EM_AUTHORITY_SUB_TYPE_VIDEO_OUT,                          // ��Ƶ���
    EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL,                    // ��̨����ͨ��
    EM_AUTHORITY_SUB_TYPE_MODIFY_LANGUANGE,                   // �޸�����
    EM_AUTHORITY_SUB_TYPE_MODIFY_VIDEO,                       // �޸���Ƶ��ʽ
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_CONTROL,              // ��������
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_SCHEDULE,             // ��ѯ�γ̱�
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_SCHEDULE,      // �޸Ŀγ̱�
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_INTELL_PARAM,         // ¼�����ܲ���
    EM_AUTHORITY_SUB_TYPE_CAMERA_PERIPHERAL,                  // ����ͷ���裬������ˢ�����ȡ���������
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DOWNLOAD_MEDIA_FILE,  // ���ؿγ�¼���ļ�
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_MEDIA_FILE,    // �޸Ŀγ�¼���ļ�
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DELETE_MEDIA_FILE,    // ɾ���γ�¼���ļ�
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_USB,        // ���ݿγ�¼���ļ����豸�˵�USB�ϣ���Backup����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_FTP,        // ���ݿγ�¼���ļ���FTP����������Backup����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_EXPORT_ACCONUT,       // �����û���Ϣ����Account����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_QUERY_ACCOUNT,        // ��ѯ�˻�����Account����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_ACCOUNT,       // �޸��˻�����Account����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_RESET_PASSWORD,       // �������ã���Account����ͬʱ��Ч��
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_AUTHORITY,            // Ȩ�޹�����Account����ͬʱ��Ч��
}EM_AUTHORITY_SUB_TYPE;

typedef enum tagEM_AUTHORITY_MAIN_TYPE
{
    EM_AUTHORITY_MAIN_TYPE_UNKNOWN,            // Unknown
    EM_AUTHORITY_MAIN_TYPE_AUTH_USER_MAG,      // �û�����
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_CFG,       // ϵͳ����
    EM_AUTHORITY_MAIN_TYPE_AUTH_OFFLINE_USER,  // �����û�
    EM_AUTHORITY_MAIN_TYPE_AUTH_DF_UD,         // Ĭ��&����
    EM_AUTHORITY_MAIN_TYPE_AUTH_PTZ_CTR,       // ��̨����
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_INFO,      // ϵͳ��Ϣ
    EM_AUTHORITY_MAIN_TYPE_AUTH_MANU_CTR,      // �ֶ�����
    EM_AUTHORITY_MAIN_TYPE_AUTH_BACKUP,        // �ļ�����
    EM_AUTHORITY_MAIN_TYPE_AUTH_COLOR_SET,     // ͼ����ɫ
    EM_AUTHORITY_MAIN_TYPE_AUTH_STORE_CFG,     // �洢����
    EM_AUTHORITY_MAIN_TYPE_AUTH_EVENT_CFG,     // �¼�����
    EM_AUTHORITY_MAIN_TYPE_AUTH_NET_CFG,       // ��������
    EM_AUTHORITY_MAIN_TYPE_AUTH_RMT_DEVICE,    // ����ͷ���
    EM_AUTHORITY_MAIN_TYPE_AUTH_DEL_LOG,       // ɾ����־
    EM_AUTHORITY_MAIN_TYPE_AUTH_SHUTDOWN,      // �ر��豸
}EM_AUTHORITY_MAIN_TYPE;

#define NET_AUTHORITY_CLASS_MAX_NUM 256      // �û�Ȩ���������ֵ

// Ȩ��������Ϣ
typedef struct tagNET_AUTH_CLASSIFY_INFO
{	   
    EM_AUTHORITY_MAIN_TYPE  emMainAuthority;    // ��Ȩ������
    EM_AUTHORITY_SUB_TYPE   emSubAuthority;     // ��Ȩ������
    int                     nChannel;           // ͨ����
                                                // emSubAuthorityΪEM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,
                                                // EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL,EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL ʱ���ֶ���Ч
                                                //
    BYTE                    byReserved[128];    // �����ֽ�
}NET_AUTH_CLASSIFY_INFO;

// ��ȡȨ��������Ϣ����Σ�
typedef struct tagNET_IN_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
}NET_IN_GET_AUTHORITY_INFO_LIST;

// ��ȡȨ��������Ϣ�����Σ�
typedef struct tagNET_OUT_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
    int nRetAuthInfoCount;                                          // ���ص�Ȩ��������Ϣ����
    NET_AUTH_CLASSIFY_INFO stuAuthInfo[NET_AUTHORITY_CLASS_MAX_NUM];// ���ص�Ȩ��������Ϣ����

}NET_OUT_GET_AUTHORITY_INFO_LIST;

// ��ȡȨ��������Ϣ�б�,pNetDataIn��pNetDataOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAuthClassifyList(LLONG lLoginID,const NET_IN_GET_AUTHORITY_INFO_LIST* pNetDataIn,NET_OUT_GET_AUTHORITY_INFO_LIST* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

//////////////////////////////////////////////////////////////////////////
// ������Ϣ
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//  ��ѯ����
typedef enum
{
    ABILITY_DYNAMIC_CONNECT = 1,        // ��ѯ��̬����������,��Ӧ�������ΪBOOL
    ABILITY_WATERMARK_CFG = 17,         // ˮӡ������������Ӧ�ṹ��ΪDH_WATERMAKE_EN
    ABILITY_WIRELESS_CFG = 18,          // wireless��������,��Ӧ�ṹ��ΪDH_WIRELESS_EN
    ABILITY_DEVALL_INFO = 26,           // �豸�������б���Ӧ�ṹ��ΪDH_DEV_ENABLE_INFO
    ABILITY_CARD_QUERY = 0x0100,        // ���Ų�ѯ��������Ӧ�ṹ��ΪDH_CARD_QUERY_EN
    ABILITY_MULTIPLAY = 0x0101,         // �໭��Ԥ������,��Ӧ�ṹ��ΪDH_MULTIPLAY_EN
    ABILITY_QUICK_QUERY_CFG = 0x0102,   // ���ٲ�ѯ������������Ӧ�ṹ��ΪDH_QUICK_QUERY_CFG_EN
    ABILITY_INFRARED = 0x0121,          // ���߱�������,��Ӧ�ṹ��ΪDH_WIRELESS_ALARM_INFO
    ABILITY_TRIGGER_MODE = 0x0131,      // �������������ʽ��������Ӧ�������Ϊint
    ABILITY_DISK_SUBAREA = 0x0141,      // ����Ӳ�̷�����������Ӧ�ṹ��ΪDH_DISK_SUBAREA_EN
    ABILITY_DSP_CFG = 0x0151,           // ��ѯDSP��������Ӧ�ṹ��ΪDH_DSP_CFG
    ABILITY_STREAM_MEDIA = 0x0161,      // ��ѯSIP,RTSP��������Ӧ�ṹ��ΪDH_STREAM_MEDIA_EN
    ABILITY_INTELLI_TRACKER = 0x0171,   // ��ѯ���ܸ�����������Ӧ�ṹ��ΪDH_INTELLI_TRACKER_EN
} DH_SYS_ABILITY;

//////////////////////////////////////////////////////////////////////////
//  �豸֧�ֹ����б�
enum 
{
    EN_FTP = 0,                         // FTP ��λ,1������¼���ļ� 2������ץͼ�ļ�
    EN_SMTP,                            // SMTP ��λ,1�����������ı��ʼ� 2����������ͼƬ 3:֧�ֽ����ʼ�����
    EN_NTP,                             // NTP  ��λ��1������ϵͳʱ��
    EN_AUTO_MAINTAIN,                   // �Զ�ά�� ��λ��1������ 2���ر� 3:ɾ���ļ�
    EN_VIDEO_COVER,                     // �����ڵ� ��λ��1���������ڵ�
    EN_AUTO_REGISTER,                   // ����ע�� ��λ��1��ע���sdk������½
    EN_DHCP,                            // DHCP ��λ��1��DHCP
    EN_UPNP,                            // UPNP ��λ��1��UPNP
    EN_COMM_SNIFFER,                    // ����ץ�� ��λ��1:CommATM
    EN_NET_SNIFFER,                     // ����ץ�� ��λ�� 1��NetSniffer
    EN_BURN,                            // ��¼���� ��λ��1����ѯ��¼״̬
    EN_VIDEO_MATRIX,                    // ��Ƶ���� ��λ��1���Ƿ�֧����Ƶ���� 2:�Ƿ�֧��SPOT��Ƶ���� 3:�Ƿ�֧��HDMI��Ƶ����
    EN_AUDIO_DETECT,                    // ��Ƶ��� ��λ��1���Ƿ�֧����Ƶ���
    EN_STORAGE_STATION,                 // �洢λ�� ��λ��1��Ftp������(Ips) 2��SMB 3��NFS 4��ISCSI 16��DISK 17��U��
    EN_IPSSEARCH,                       // IPS�洢��ѯ ��λ��1��IPS�洢��ѯ 
    EN_SNAP,                            // ץͼ  ��λ��1���ֱ���2��֡��3��ץͼ��ʽ4��ץͼ�ļ���ʽ5��ͼ������
    EN_DEFAULTNIC,                      // ֧��Ĭ��������ѯ ��λ 1��֧��
    EN_SHOWQUALITY,                     // CBRģʽ����ʾ���������� ��λ 1:֧��
    EN_CONFIG_IMEXPORT,                 // ���õ��뵼���������� ��λ 1:֧��
    EN_LOG,                             // �Ƿ�֧�ַ�ҳ��ʽ����־��ѯ ��λ 1��֧��
    EN_SCHEDULE,                        // ¼�����õ�һЩ���� ��λ 1:���� 2:Ԥ¼ 3:¼��ʱ���
    EN_NETWORK_TYPE,                    // �������Ͱ�λ��ʾ 1:��̬�� 2:���߾��� 3:CDMA/GPRS 4:CDMA/GPRS����������
    EN_MARK_IMPORTANTRECORD,            // ��ʶ��Ҫ¼�� ��λ:1��������Ҫ¼���ʶ
    EN_ACFCONTROL,                      // �֡�ʿ��� ��λ��1��֧�ֻ֡�ʿ���, 2:֧�ֶ�ʱ�������ͻ֡�ʿ���(��֧�ֶ���),��������ACF��������
    EN_MULTIASSIOPTION,                 // ��·������ ��λ��1��֧����·������, 2:֧�ָ���������ѹ����ʽ��������
    EN_DAVINCIMODULE,                   // �����ģ�� ��λ��1,ʱ���ֿ����� 2:��׼I֡�������
    EN_GPS,                             // GPS���� ��λ��1��Gps��λ����
    EN_MULTIETHERNET,                   // ֧�ֶ�������ѯ ��λ 1��֧��
    EN_LOGIN_ATTRIBUTE,                 // Login���� ��λ��1��֧��Login���Բ�ѯ
    EN_RECORD_GENERAL,                  // ¼����� ��λ��1,��ͨ¼��2������¼��3����̬���¼��4�����ش洢��5��Զ�̴洢��6������洢��7�����ؽ�洢��8��֧����������������Զ�̴洢
    EN_JSON_CONFIG,                     // Json��ʽ����:��λ��1֧��Json��ʽ, 2: ʹ��F6��NAS����, 3: ʹ��F6��Raid����, 4��ʹ��F6��MotionDetect����, 5������֧����������(V3),ͨ��F6�������
    EN_HIDE_FUNCTION,                   // ���ι��ܣ���λ��1,����PTZ��̨����, 2: ����3G�ı���ʱ�ι���
    EN_DISK_DAMAGE,                     // Ӳ�̻�����Ϣ֧������: ��λ��1,Ӳ�̻�����Ϣ��ѯ֧������
    EN_PLAYBACK_SPEED_CTRL,             // ֧�ֻط������ٶȿ���:��λ:1,֧�ֻطż���
    EN_HOLIDAYSCHEDULE,                 // ֧�ּ���ʱ�������:��λ:1,֧�ּ���ʱ�������
    EN_FETCH_MONEY_TIMEOUT,             // ATMȡǮ��ʱ
    EN_BACKUP_VIDEO_FORMAT,             // ����֧�ֵĸ�ʽ,��λ��1:DAV, 2:ASF
    EN_QUERY_DISK_TYPE,                 // ֧��Ӳ�����Ͳ�ѯ
    EN_CONFIG_DISPLAY_OUTPUT,           // ֧���豸��ʾ�����VGA�ȣ�����,��λ: 1:����ָ���Ѳ����
    EN_SUBBITRATE_RECORD_CTRL,          // ֧����չ����¼���������, ��λ��1-������¼���������
    EN_IPV6,                            // ֧��IPV6����, ��λ��1-IPV6����
    EN_SNMP,                            // SNMP�����������Э�飩
    EN_QUERY_URL,                       // ֧�ֻ�ȡ�豸URL��ַ, ��λ: 1-��ѯ����URL��ַ
    EN_ISCSI,                           // ISCSI��InternetС�ͼ����ϵͳ�ӿ����ã�
    EN_RAID,                            // ֧��Raid����
    EN_HARDDISK_INFO,                   // ֧�ִ�����ϢF5��ѯ
    EN_PICINPIC,                        // ֧�ֻ��л����� ��λ:1,���л�����; 2,���л�Ԥ����¼��洢����ѯ������;3,֧�ֻ��л���������,ͬʱ֧�ֻ��л�ͨ����ѯ
    EN_PLAYBACK_SPEED_CTRL_SUPPORT,     // ͬ EN_PLAYBACK_SPEED_CTRL ,ֻΪ�˼���Э��
    EN_LF_XDEV,                         // ֧��24��32��64·LF-Xϵ��,��ע�����豸����ı����������㷽ʽ
    EN_DSP_ENCODE_CAP,                  // F5 DSP����������ѯ
    EN_MULTICAST,                       // �鲥������ѯ
    EM_NET_LIMIT,                       // ��������������ѯ,��λ,1-���緢��������С����,2-֧���û��������ݼ���,4-֧���������ݼ���                          
    EM_COM422,                          // ����422
    EM_PROTOCAL_FRAMEWORK,              // �Ƿ�֧������Э���ܣ���Ҫʵ��listMethod(),listService()��,ͨ��F6�������
    EM_WRITE_DISK_OSD,                  // ��¼OSD����, ��λ, 1-��¼OSD��������
    EM_DYNAMIC_MULTI_CONNECT,           // ��̬������, ��λ, 1-������Ƶ����Ӧ��
    EM_CLOUDSERVICE,                    // �Ʒ���,��λ,1-֧��˽���Ʒ���
    EM_RECORD_INFO,                     // ¼����Ϣ�ϱ�, ��λ, 1-¼����Ϣ�����ϱ�, 2-֧��¼��֡����ѯ
    EN_DYNAMIC_REG,                     // ����ע������,��λ,1-֧�ֶ�̬����ע��, 2-����ע�ᶯ̬������֧��SDK����IP,port��0������
    EM_MULTI_PLAYBACK,                  // ��ͨ��Ԥ���ط�,��Ϊ,1-֧�ֶ�ͨ��Ԥ���ط�
    EN_ENCODE_CHN,                      // ����ͨ��, ��λ, 1-֧�ִ���Ƶͨ��, 2-����֧������Ƶ�ֿ���ȡ
    EN_SEARCH_RECORD,                   // ¼���ѯ, ��λ, 1-֧���첽��ѯ¼��, 2-֧������Э���ѯ¼��
    EN_UPDATE_MD5,                      // ֧�������ļ�������ɺ���MD5��֤,1-֧��MD5��֤2-֧����������
	EN_PROTOCOL3ToF6,                   // ������F6,��λ��1-Log��־����2.DeleteFile �ָ�Ĭ������֧��ʹ��configManager.deleteFileЭ��
};

typedef struct 
{
    DWORD IsFucEnable[512];             // �����б�������,�±��Ӧ������ö��ֵ,��λ��ʾ�ӹ���
} DH_DEV_ENABLE_INFO;

//////////////////////////////////////////////////////////////////////////
//  ���Ų�ѯ�����ṹ��
typedef struct 
{
    char        IsCardQueryEnable;
    char        iRev[3];
} DH_CARD_QUERY_EN;

//////////////////////////////////////////////////////////////////////////
//  wireless�����ṹ��
typedef struct 
{
    char        IsWirelessEnable;
    char        iRev[3];
} DH_WIRELESS_EN;

//////////////////////////////////////////////////////////////////////////
//  ͼ��ˮӡ�����ṹ��
typedef struct 
{
    char        isSupportWM;            // 1 ֧�֣�0 ��֧��
    char        supportWhat;            // 0������ˮӡ��1��ͼƬˮӡ��2��ͬʱ֧������ˮӡ��ͼƬˮӡ
    char        reserved[2];
} DH_WATERMAKE_EN;

//////////////////////////////////////////////////////////////////////////
//  �໭��Ԥ�������ṹ��
typedef struct  
{
    int         nEnable;                // 1 ֧�֣�0 ��֧��
    DWORD       dwMultiPlayMask;        // �໭��Ԥ������
    char        reserved[4];            // ����
} DH_MULTIPLAY_EN;

//////////////////////////////////////////////////////////////////////////
//  ���߱��������ṹ��
typedef struct  
{
    BOOL        bSupport;               // �Ƿ�֧��
    int         nAlarmInCount;          // �������
    int         nAlarmOutCount;         // �������
    int         nRemoteAddrCount;       // ң��������
    BYTE        reserved[32];
} DH_WIRELESS_ALARM_INFO;

//////////////////////////////////////////////////////////////////////////
//  ����Ӳ�̷��������ṹ��
typedef struct 
{
    BOOL        bSupported;             // �Ƿ�֧������Ӳ�̷���
    int         nSupportNum;            // ֧�ַ�������Ŀ
    BYTE        bReserved[32];          // �����ֽ�
} DH_DISK_SUBAREA_EN;

//  DSP������ѯ,��DSP�����㷨��ʶΪ2ʱʹ�á�
typedef struct  
{
    BYTE        bMainFrame[32];         // �Էֱ���ö��ֵ(CAPTURE_SIZE)Ϊ����,�������ֱ��ʶ�Ӧ֧�ֵ����֡��,�����֧�ִ˷ֱ���,��ֵΪ0.
    BYTE        bExtraFrame_1[32];      // ������1,ʹ��ͬbMainFrame
    BYTE        bReserved[128];         // Ԥ���������2��3.       
} DH_DSP_CFG_ITEM;

typedef struct  
{
    int         nItemNum;               // DH_DSP_CFG_ITEM����Ч����,����ͨ����
    DH_DSP_CFG_ITEM stuDspCfgItem[32];  // ����������Ϣ
    BYTE        bReserved[128];         // ����
} DH_DSP_CFG; 

//////////////////////////////////////////////////////////////////////////
//  ���ٲ�ѯ���������ṹ��
typedef struct 
{
    char        IsQuickQueryEnable;     // 1���豸֧������������ٷ���,����������ʱ���㹻���Ա�֤խ�������õ�������ȡ����������60S
    char        iRev[3];
} DH_QUICK_QUERY_CFG_EN;

typedef struct  
{
    int         nStreamType;            // 0,�� 1,SIP 2,RTSP
    BYTE        bReserved[16];          // ����
} DH_STREAM_MEDIA_EN;

//���������������ѯ
typedef struct
{
    char        IsIntelliTrackerEnable;     // ����0��ʾ�����������������
    BYTE        bReserved[3];
}DH_INTELLI_TRACKER_EN;

#define NET_MAX_COMPOSITE_CHANNEL       256                 // ����ں�����ͨ���������

// ��ȡ�ں����������������, ��ӦNET_COMPOSITE_CAPS
typedef struct tagNET_IN_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nChannelCount;                          // ��Ҫ�ںϵĴ�������
    int             nChannels[NET_MAX_COMPOSITE_CHANNEL];   // ��Ҫ�ںϵĴ��ں��б�
    int             nLayoutX;                               // ˮƽ���򴰿�����
    int             nLayoutY;                               // ��ֱ���򴰿�����
} NET_IN_COMPOSITE_CAPS;

// ��ȡ�ں����������������, ��ӦNET_COMPOSITE_CAPS
typedef struct tagNET_OUT_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nSplitModeCount;                        // ֧�ֵķָ�ģʽ����
    DH_SPLIT_MODE   emSplitModes[DH_MAX_SPLIT_MODE_NUM];    // ֧�ֵķָ�ģʽ�б�
    int             nMaxFreeWindow;                         // ��󿪴���
} NET_OUT_COMPOSITE_CAPS;

#define MAX_REGISTER_ID_LEN       (256)
#define MAX_APP_ID_LEN            (256)
#define MAX_URL_LEN               (1024)
#define MAX_IOS_CERTIFICATE_LEN   (1024 * 14)
#define MAX_IOS_SECRET_KEY_LEN    (512)
#define MAX_MOBILE_CHANNEL_NUM    (256)

// ƽ̨����
typedef enum tagEM_MOBILE_SERVER_TYPE
{
    EM_MOBILE_SERVER_TYPE_UNKNOWN,             // δ֪
    EM_MOBILE_SERVER_TYPE_APPLE,               // Apple
    EM_MOBILE_SERVER_TYPE_ANDROID,             // Android
    EM_MOBILE_SERVER_TYPE_SDKCLOUD,            // DAHUA_CLOUD
} EM_MOBILE_SERVER_TYPE;

// ���ͷ���������
typedef struct tagNET_PUSH_SERVER_INFO
{
    char                            szAddress[MAX_URL_LEN];                    // ��ַ
    int                             nPort;                                     // �˿�
} NET_PUSH_SERVER_INFO;

// �¼�������
typedef enum tagEM_EVENT_SUB_CODE
{
    EM_EVENT_SUB_CODE_UNKNOWN = -1,            // δ֪
    EM_EVENT_SUB_CODE_LOSS,                    // Loss
    EM_EVENT_SUB_CODE_COVER,                   // Cover
    EM_EVENT_SUB_CODE_FROZEN,                  // Frozen
    EM_EVENT_SUB_CODE_LIGHT,                   // Light
    EM_EVENT_SUB_CODE_DARK,                    // Dark
    EM_EVENT_SUB_CODE_SCENECHANGE,             // SceneChange
} EM_EVENT_SUB_CODE;

// ��������
typedef struct tagNET_SUBSCRIBE_INFO
{
    int                             nCode;                                     // �¼���
    EM_EVENT_SUB_CODE               emSubCode;                                 // �¼�������, EM_EVENT_SUB_CODE_UNKNOWNΪ��Ч
                                                                               // ����VideoAbnormalDetection,AlarmLocal�Ȱ����������͵ı����¼���Ч
    int                             nChnNum;                                   // ���ĵ�ͨ������, ����ͨ��������Ϊ0
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];           // ͨ���ż���
    char                            szNumber[DH_COMMON_STRING_16];             // ����"CallNoAnswered "�¼�ʱ��Ч
                                                                               // ��Ӧ����루�豸�����Щ����,��Ӧ��ʱ,�����ֻ�������Ϣ��
                                                                               // CFG_CMD_MOBILE_PUSH_NOFITY_CFGʱ��Ч
    char                            szSound[DH_COMMON_STRING_64];              // �ֻ����յ����¼�ʱ�����貥�ŵ������ļ�
} NET_SUBSCRIBE_INFO;

// ������������
typedef enum tagEM_PUSH_GATEWAY_TYPE
{
    EM_PUSH_GATEWAY_TYPE_UNKNOWN,              // δ֪
    EM_PUSH_GATEWAY_TYPE_APPLE_PUSH,           // ƻ����������, ApplePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_SDKPUSH,      // ��׿����������, AndroidDahuaPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_JPUSH,        // ��׿������������, AndroidJPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_GCM,          // ��׿GCM����, AndroidGCM
} EM_PUSH_GATEWAY_TYPE;

// �ֻ�push notification����, ʹ��RegisterID����
typedef struct tagNET_MOBILE_PUSH_NOTIFY
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // �ֻ���Appple/ Android������ע�᷵�ص�,ÿ�β�ͬ
    EM_MOBILE_SERVER_TYPE           emServerType;                              // ƽ̨����
    int                             nPeriodOfValidity;                         // ��Чʱ��,��λΪ��
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android��֤��������ַ
    int                             nAuthServerPort;                           // Android��֤�������˿�
    char                            szPushServerAddr[MAX_URL_LEN];             // ���ͷ�������ַ(�󻪴���,ĩѡ������,������)
                                                                               // �ɴ󻪷��������ٷ�������Ҫ��,ѡ�����µļ����㷨��ת�����ٷ�������
    int                             nPushServerPort;                           // ���ͷ������˿�(�󻪴���)
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // ���ͷ���������, �ٷ�����ѡ������,�������ʧ��,�ٳ����ض������������
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // ���ͷ���������(���ض���,��ѡ������)
    char                            szDevName[DH_COMMON_STRING_64];            // �豸����,�ֻ���������ʾ
    char                            szDevID[DH_COMMON_STRING_64];              // �豸��ʶ,�ֻ�������ʹ��
    char                            szUser[DH_COMMON_STRING_64];               // ��½�û���
    char                            szPassword[DH_COMMON_STRING_64];           // ����
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios֤����Ϣ,base64֮����ַ���,��Ҫ����TLS����ʱ��Ч
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios��Կ,base64֮���ַ���
    int                             nSubScribeMax;                             // ��������͸���, ��ʾpstuSubscribes�Ķ�������
    int                             nSubScribeNum;                             // ʵ�ʵĶ������͸���, ��ȡ������Ч
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ��������,���û������ڴ棬��СΪsizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
} NET_MOBILE_PUSH_NOTIFY;

// ɾ���ֻ�����������Ϣ���, CLIENT_DelMobilePushNotify
typedef struct tagNET_MOBILE_PUSH_NOTIFY_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // �ֻ���Appple/ Android������ע�᷵�ص�,ÿ�β�ͬ
} NET_MOBILE_PUSH_NOTIFY_DEL;

// �ֻ�push notification����,  ʹ��RegisterID+AppID����
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // �ֻ���Appple/ Android������ע�᷵�ص�,ÿ�β�ͬ
    char                            szAppID[MAX_APP_ID_LEN];                   // �ֻ�ÿ��һ���ͻ���,�����һ��
    EM_MOBILE_SERVER_TYPE           emServerType;                              // ƽ̨����
    EM_PUSH_GATEWAY_TYPE            emPushGatewayType;                         // ������������, emServerTypeΪEM_MOBILE_SERVER_TYPE_SDKCLOUDʱ��Ч
    int                             nPeriodOfValidity;                         // ��Чʱ��,��λΪ��
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android��֤��������ַ
    int                             nAuthServerPort;                           // Android��֤�������˿�
    char                            szPushServerAddr[MAX_URL_LEN];             // ���ͷ�������ַ(�󻪴���,ĩѡ������,������)
                                                                               // �ɴ󻪷��������ٷ�������Ҫ��,ѡ�����µļ����㷨��ת�����ٷ�������
    int                             nPushServerPort;                           // ���ͷ������˿�(�󻪴���)
    char                            szDevName[DH_COMMON_STRING_64];            // �豸����,�ֻ���������ʾ
    char                            szDevID[DH_COMMON_STRING_64];              // �豸��ʶ,�ֻ�������ʹ��
    char                            szUser[DH_COMMON_STRING_64];               // ��½�û���
    char                            szPassword[DH_COMMON_STRING_64];           // ����
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios֤����Ϣ,base64֮����ַ���,��Ҫ����TLS����ʱ��Ч
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios��Կ,base64֮���ַ���
    int                             nSubScribeMax;                             // ��������͸���, ��ʾpstuSubscribes�Ķ�������
    int                             nSubScribeNum;                             // ʵ�ʵĶ������͸���, ��ȡ������Ч
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ��������,���û������ڴ棬��СΪsizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // ���ͷ���������, �ٷ�����ѡ������,�������ʧ��,�ٳ����ض������������
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // ���ͷ���������(���ض���,��ѡ������)
} NET_MOBILE_PUSH_NOTIFY_CFG;

// ɾ���ֻ�����������Ϣ���, CLIENT_DelMobilePushNotify
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // �ֻ���Appple/ Android������ע�᷵�ص�,ÿ�β�ͬ
    char                            szAppID[MAX_APP_ID_LEN];                   // �ֻ�ÿ��һ���ͻ���,�����һ��
} NET_MOBILE_PUSH_NOTIFY_CFG_DEL;

// SDK�����ڲ��Ż�����
typedef enum tagEmOptimizeType
{
    EM_OPT_TYPE_DEFAULT     = 0,    // Ĭ�ϲ��Ż�
    EM_OPT_TYPE_MOBILE_V1   = 1,    // �ֻ�ʹ���Ż�
    EM_OPT_TYPE_P2P_NETPARAM_V1 = 2,    // P2P����������ã� pParam Ϊ NET_PARAM*
}EM_OPTIMIZE_TYPE;

typedef struct tagNET_IN_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // �ṹ���С , dwSize �踳ֵΪ sizeof(NET_IN_MOTIONMATCH_PARAM)
    BOOL                  bFileName;                // �ļ����Ƿ���Ϊ��Ч�Ĳ�ѯ����,���ļ�����Ч,��������ļ���Ϣ��stRecordInfo��
    char                  szFileName[MAX_PATH];     // �ļ���
    NET_RECORDFILE_INFO   stuRecordInfo;            // �ļ���Ϣ
    int                   nRegionNum;               // ���������򶥵���
    DH_POINT              stuRegion[DH_MAX_DETECT_REGION_NUM];    // ����������, ������0~21, ������0~17
} NET_IN_MOTIONMATCH_PARAM;
typedef struct tagNET_TIME_BEGIN_END
{
    NET_TIME              stuBegin;                 // ��ʼ
    NET_TIME              stuEnd;                   // ����
} NET_TIME_BEGIN_END;
#define NET_SMART_SEARTCH_TIME_SECTION_MAX (128)
typedef struct tagNET_OUT_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // �ṹ���С , dwSize �踳ֵΪ sizeof(NET_OUT_MOTIONMATCH_PARAM)
    int                   nTimeNum;                 // ��ѯ����ʱ�����Ŀ
    NET_TIME_BEGIN_END    stuTime[NET_SMART_SEARTCH_TIME_SECTION_MAX];   // ʱ���
} NET_OUT_MOTIONMATCH_PARAM;

// CLIENT_SnapPictureToFile�ӿ��������
typedef struct tagNET_IN_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    SNAP_PARAMS stuParam;               // ץͼ����, ����mode�ֶν�һ����ץͼ, ��֧�ֶ�ʱ�����ץͼ; ���˳���DVR, �����豸��֧��ÿ��һ�ŵ�ץͼƵ��
    char        szFilePath[MAX_PATH];   // д���ļ��ĵ�ַ
}NET_IN_SNAP_PIC_TO_FILE_PARAM;

// CLIENT_SnapPictureToFile�ӿ��������
typedef struct tagNET_OUT_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    char*       szPicBuf;               // ͼƬ����,�û������ڴ�,��СΪdwPicBufLen
    DWORD       dwPicBufLen;            // ͼƬ�����ڴ��С, ��λ:�ֽ�
    DWORD       dwPicBufRetLen;         // ���ص�ͼƬ��С, ��λ:�ֽ�
}NET_OUT_SNAP_PIC_TO_FILE_PARAM;

//�����¼�����DH_ALARM_BUS_SHARP_TURN(������ת�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_SHARP_TURN_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS��Ϣ
} ALARM_BUS_SHARP_TURN_INFO;

//�����¼�����DH_ALARM_BUS_SCRAM(������ͣ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_SCRAM_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS��Ϣ
} ALARM_BUS_SCRAM_INFO;

//�����¼�����DH_ALARM_BUS_SHARP_ACCELERATE(�����������¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_SHARP_ACCELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS��Ϣ
    NET_TIME_EX			stuTime;				// �¼�������ʱ��
} ALARM_BUS_SHARP_ACCELERATE_INFO;

//�����¼�����DH_ALARM_BUS_SHARP_DECELERATE(�����������¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_SHARP_DECELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS��Ϣ
    NET_TIME_EX			stuTime;				// �¼�������ʱ��
} ALARM_BUS_SHARP_DECELERATE_INFO;


//�Ž������ݲ�������       
typedef enum tagNET_ACCESS_ACTION_TYPE        
{       
    NET_ACCESS_ACTION_TYPE_UNKNOWN  = 0,    // δ֪       
    NET_ACCESS_ACTION_TYPE_INSERT   = 1,    // ����       
    NET_ACCESS_ACTION_TYPE_UPDATE   = 2,    // ����       
    NET_ACCESS_ACTION_TYPE_REMOVE   = 3,    // ɾ��       
}NET_ACCESS_ACTION_TYPE;   
        
//�Ž������ݲ����¼�       
typedef struct tagALARM_ACCESS_CARD_OPERATE_INFO       
{       
    DWORD                   dwSize;       
    NET_ACCESS_ACTION_TYPE  emActionType;                    // �Ž������ݲ�������       
    char                    szCardNo[DH_MAX_CARDINFO_LEN];   // �Ž�������       
    NET_THREE_STATUS_BOOL   emResult;                        // �������,-1Ϊδ֪,0Ϊʧ��,1Ϊ�ɹ�,
    int                     nChannelID;                      // ��ͨ����(��������,�ź�����һһ��Ӧ), ��0��ʼ
}ALARM_ACCESS_CARD_OPERATE_INFO;

// �����¼�����DH_EVENT_TAKENAWAYDETECTION(��Ʒ�����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_TAKENAWAY_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // ͨ����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    int                 nOccurrenceCount;               // ���򱻴���������
    int                 nLevel;                         // �¼�����,GB30147������, 0 ��ʾ1 ��ͨ2 ����
	short				nPreserID;						// �¼�������Ԥ�õ�ţ���1��ʼ��û�б�ʾδ֪��
	char				szPresetName[64];				// �¼�������Ԥ������
} ALARM_TAKENAWAY_DETECTION_INFO;

// �����¼����� DH_EVENT_VIDEOABNORMALDETECTION (��Ƶ�쳣�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VIDEOABNORMAL_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // ͨ����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    int                 nType;                          // �������,0-��Ƶ��ʧ, 1-��Ƶ�ڵ�, 2-���涳��, 3-����, 4-����, 5-�����仯
                                                        // 6-���Ƽ�� , 7-������� , 8-ƫɫ��� , 9-��Ƶģ����� , 10-�Աȶ��쳣���
                                                        // 11-��Ƶ�˶�, 12-��Ƶ��˸, 13-��Ƶ��ɫ, 14-�齹���, 15-���ؼ��
    int                 nValue;                         // ���ֵ,ֵԽ�߱�ʾ��Ƶ����Խ��, GB30147����
    int                 nOccurrenceCount;               // ���򱻴���������
} ALARM_VIDEOABNORMAL_DETECTION_INFO;

// �����¼�����DH_EVENT_LOCALALARM(�ⲿ�����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_LOCAL_ALARM_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // ͨ����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

    int                 nSenseType;                     // ����������
    int                 nDefenceAreaType;               // ��������, ���EM_NET_DEFENCE_AREA_TYPE
} ALARM_LOCAL_ALARM_INFO;

// �����¼�����DH_EVENT_MOTIONDETECT(��Ƶ�ƶ�����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_MOTIONDETECT_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // ͨ����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
} ALARM_MOTIONDETECT_INFO;

// �����¼�����DH_ALARM_POLICE_CHECK(��Աǩ��ǩ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_POLICE_CHECK_INFO
{
    DWORD               dwSize;
    int                 nChannelID;                     // ͨ����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventID;                       // �¼�ID
    int                 nEventAction;                   // �¼�����

    char                szId[32];                       // ǩ����ID��
    char                szName[32];                     // ǩ��������,UTF8
    int                 nSignType;                      // ����, ����鿴NET_DRIVER_CHECK_TYPE
    NET_GPS_STATUS_INFO stuGPSStatusInfo;               // GPS��Ϣ
    char                szComment[1024];                // ��ע��Ϣ
} ALARM_POLICE_CHECK_INFO;

// �����¼�����DH_ALARM_NEW_FILE(new file�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_NEW_FILE_INFO
{
    DWORD           dwSize;
    int             nChannel;                           // ץͼͨ����
    int             nEventID;                           // �¼�ID
    DWORD           dwEvent;                            // �¼�����
    int             FileSize;                           // �ļ���С,��λ���ֽ�
    int             nIndex;                             // �¼�Դͨ��
    DWORD           dwStorPoint;                        // �洢��
    char            szFileName[DH_COMMON_STRING_128];   // �ļ���
}ALARM_NEW_FILE_INFO;

// ��̨���״̬����
typedef enum tagEM_PTZ_STATUS_TYPE
{
	EM_PTZ_STATUS_UNKNOW,                    // δ֪״̬,����״ֵ̬����
    EM_PTZ_STATUS_NORMAL,                    // ����
    EM_PTZ_STATUS_PANOC_FAILED,              // ˮƽ�����쳣
    EM_PTZ_STATUS_TILEOC_FAILED,             // ��ֱ�����쳣
    EM_PTZ_STATUS_OC_FAILED                  // ȫ������쳣
} EM_PTZ_STATUS_TYPE;


// ��̨״̬����¼���Ϣ(��ӦDH_ALARM_PTZ_DIAGNOSES)
typedef struct tagALARM_PTZ_DIAGNOSES_INFO
{
	int 				nChannel;			// ��Ƶͨ����(������ڵ�ͨ����)
	NET_TIME_EX			UTC;				// �¼�����ʱ��
	EM_PTZ_STATUS_TYPE	emPtzStat;			// ��̨���״̬
	BYTE                Reserved[512];      // �����ֽ�
} ALARM_PTZ_DIAGNOSES_INFO;

// ������(�����)�����¼����� DH_ALARM_FLASH_LIGHT_FAULT
typedef struct tagALARM_FLASH_LIGHT_FAULT_INFO
{
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventAction;                   // �¼�����, 1-��ʾ�¼���ʼ, 2-��ʾ�¼�����; 
    int                 nLightNum;                      // ����Ƹ���
    int                 nDevID[MAX_FLASH_LIGHT_NUM];    // ���ϵ�������豸ID
    int                 nLane;                          // ������
    BYTE			    bReserved[512];				    // �����ֽ�
}ALARM_FLASH_LIGHT_FAULT_INFO;

// Ƶ���Ʊ����¼����� DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT
typedef struct tagALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO
{
    double              PTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                // �¼�������ʱ��
    int                 nEventAction;                       // �¼�����, 1-��ʾ�¼���ʼ, 2-��ʾ�¼�����; 
    int                 nLightNum;                          // Ƶ���Ƹ���
    int                 nDevID[MAX_STROBOSCOPIC_LIGHT_NUM]; // ���ϵ�Ƶ�����豸ID
    int                 nLane;                              // ������
    BYTE			    bReserved[512];				        // �����ֽ�
}ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO;

// ����Խ��������
typedef enum tagEM_UPPER_LIMIT_TYPE
{
    EM_UPPER_LIMIT_TYPE_UNKNOWN,                             // δ֪
    EM_UPPER_LIMIT_TYPE_ENTER_OVER,                          // ����Խ����
    EM_UPPER_LIMIT_TYPE_EXIT_OVER,                           // ����Խ����
    EM_UPPER_LIMIT_TYPE_INSIDE_OVER,                         // �ڲ�Խ����
} EM_UPPER_LIMIT_TYPE;

// �¼����� DH_ALARM_HUMAM_NUMBER_STATISTIC (������/������ͳ���¼�NumberStat��Ӧ������������Ϣ)
typedef struct tagALARM_NUMBER_STATISTIC_INFO 
{
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                            // �¼�������ʱ��
    int                 nEventAction;                   // �¼�����,0-�¼�����, 1-��ʾ�¼���ʼ, 2-��ʾ�¼�����;
    int                 nNumber;                        // ����������ĸ���
    int                 nEnteredNumber;                 // ����������߳�����ڵ��������
    int                 nExitedNumber;                  // ����������߳�����ڵ��������
    EM_UPPER_LIMIT_TYPE emUpperLimitType;               // ����Խ��������(EnterOver, ExitOver, InsideOver)
    BYTE                reserved[512];                  // Ԥ��       
}ALARM_HUMAN_NUMBER_STATISTIC_INFO;

// �¼����� DH_ALARM_VIDEOUNFOCUS(��Ƶ�齹�����¼�)
typedef struct tagALARM_VIDEOUNFOCUS_INFO
{
    int                 nEventAction;                   // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                reserved[64];                   // Ԥ���ֽ�
}ALARM_VIDEOUNFOCUS_INFO;

// ������������״̬����
typedef enum tagEM_DEFENCEMODE
{
    EM_DEFENCEMODE_UNKNOWN,             // "unknown"   δ֪
    EM_DEFENCEMODE_ARMING,              // "Arming"    ����
    EM_DEFENCEMODE_DISARMING,           // "Disarming" ����
}EM_DEFENCEMODE;

// �¼����� DH_ALARM_DEFENCE_ARMMODECHANGE (����������״̬�ı��¼�)
typedef struct tagALARM_DEFENCE_ARMMODECHANGE_INFO 
{
   EM_DEFENCEMODE       emDefenceStatus;            //������״̬
   int                  nDefenceID;                 //������
   NET_TIME_EX          stuTime;                    //ʱ��
   BYTE                 reserved[512];              //Ԥ��
}ALARM_DEFENCE_ARMMODECHANGE_INFO;

// ����״̬
typedef enum tagEM_SUBSYSTEMMODE
{
    EM_SUBSYSTEMMODE_UNKNOWN,             // "unknown"   δ֪
    EM_SUBSYSTEMMODE_ACTIVE,              // "active"    ����
    EM_SUBSYSTEMMODE_INACTIVE,            // "inactive"  δ����
    EM_SUBSYSTEMMODE_UNDISTRIBUTED,       // "undistributed" δ����
    EM_SUBSYSTEMMODE_ALLARMING,           // "AllArming" ȫ������
    EM_SUBSYSTEMMODE_ALLDISARMING,        // "AllDisarming" ȫ������
    EM_SUBSYSTEMMODE_PARTARMING,          // "PartArming" ���ֲ���
}EM_SUBSYSTEMMODE;

// �¼����� DH_ALARM_SUBSYSTEM_ARMMODECHANGE (��ϵͳ������״̬�ı��¼�)
typedef struct tagALARM_SUBSYSTEM_ARMMODECHANGE_INFO 
{
    EM_SUBSYSTEMMODE    emSubsystemMode;            //������״̬ (ֻ֧��AllArming��AllDisarming��PartArming����״̬)
    NET_TIME_EX         UTC;                        //�¼�������ʱ��
    char                szSubSystemname[64];        //��ϵͳ����
    int                 nSubSystemID;               //��ϵͳ���
    BYTE                reserved[512];              //Ԥ��
}ALARM_SUBSYSTEM_ARMMODECHANGE_INFO;

// �����߼����Ϣ�¼� (��Ӧ DH_ALARM_RFID_INFO)
typedef struct tagALARM_RFID_INFO
{
    int                         nAction;                // 0:��ʼ 1:ֹͣ
    int                         nIndex;                 // ͨ����
    NET_TIME_EX                 stuEventTime;           // �¼�������ʱ��
    int                         nValidCount;            // RFID ���������Ч����
    char                        szRfid[10][12];         // RFID �������
}ALARM_RFID_INFO;

// �����ⱨ���¼� (DH_ALARM_SMOKE_DETECTION)
typedef struct tagALARM_SMOKE_DETECTION_INFO
{
    int                 nAction;                        // 0:��ʼ 1:ֹͣ
    char                szName[128];                    // �¼�����
    double              PTS;                            // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         stuTime;                        // �¼�������ʱ��
	int					nChannel;						// ͨ����
    BYTE                reserved[124];                  // Ԥ���ֶ�                
}ALARM_SMOKE_DETECTION_INFO;

// ���˻״̬����������
typedef enum TagEM_PATIENTDETECTION_TYPE
{
    EM_PATIENTDETECTION_TYPE_UNKNOWN,                       // δ֪����
    EM_PATIENTDETECTION_TYPE_CROSS_REGION,                  // �������򱨾��������ǲ����뿪������������������
    EM_PATIENTDETECTION_TYPE_LIGHT_OFF,                     // ������Ʊ�Ϩ��
    EM_PATIENTDETECTION_TYPE_STOP_DETECTION,                // ���������ټ�ز���
    EM_PATIENTDETECTION_TYPE_START_DETECTION,               // ��ʼ����
    EM_PATIENTDETECTION_TYPE_ESCAPE,                        // ������Ѻ�����������
	EM_PATIENTDETECTION_TYPE_ESCAPE_RELEASE,                // ����������뱨��
}EM_PATIENTDETECTION_TYPE;

// ���˻״̬��ⱨ���¼� (DH_ALARM_PATIENTDETECTION)
typedef struct tagALARM_PATIENTDETECTION_INFO
{
    BYTE                        bEventAction;               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    NET_TIME                    stuTime;                    // �¼�����ʱ��
    EM_PATIENTDETECTION_TYPE    emDetectionType;            // ��ǰ�¼���������
    BYTE                        byReserved[256];            // Ԥ���ֶ� 
}ALARM_PATIENTDETECTION_INFO;

// �״��ⳬ�ٱ����¼� ����¥��ר�� (DH_ALARM_RADAR_HIGH_SPEED)
typedef struct tagALARM_RADAR_HIGH_SPEED_INFO
{
    NET_TIME_EX                 stuTime;                    // �¼�����ʱ��
    float                       fSpeed;                     // �ٶ�(��λ:km/h)
	char						szPlateNumber[16];			// ����
    BYTE                        byReserved[1008];           // Ԥ���ֶ� 
}ALARM_RADAR_HIGH_SPEED_INFO;

// �豸Ѳ�챨���¼� ����ר�� (DH_ALARM_POLLING_ALARM)
typedef struct tagALARM_POLLING_ALARM_INFO
{
    NET_TIME_EX                 stuTime;                    // �¼�����ʱ��
    BYTE                        byReserved[1024];           // Ԥ���ֶ� 
}ALARM_POLLING_ALARM_INFO;

// ��բ��״̬
typedef enum tagEM_TRAFFICSTROBE_STATUS
{
    NET_TRAFFICSTROBE_STATUS_UNKNOWN,
	NET_TRAFFICSTROBE_STATUS_CLOSE_COMPLETE,                               // ��բ���ر�
	NET_TRAFFICSTROBE_STATUS_OPEN_COMPLETE,                                // ��բ����
	NET_TRAFFICSTROBE_STATUS_NOT_CLOSE_COMPLETE,                           // ��բ��δ��ȫ�ر�
	NET_TRAFFICSTROBE_STATUS_NOT_OPEN_COMPLETE,							   // ��բ��δ��ȫ��
} EM_TRAFFICSTROBE_STATUS;

// ��բ��״̬�¼� ( DH_ALARM_TRAFFICSTROBESTATE )
typedef struct tagALARM_TRAFFICSTROBESTATE_INFO
{
	BYTE                        bEventAction;               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����
    NET_TIME                    stuTime;                    // �¼�����ʱ��
	int                         nChannelID;                 // ��Ƶͨ����
    EM_TRAFFICSTROBE_STATUS		emStatus;                   // ��բ��״̬
    BYTE                        byReserved[1024];           // Ԥ���ֶ� 
}ALARM_TRAFFICSTROBESTATE_INFO;

// �����¼�(��Ӧ�¼� DH_ALARM_PASTE_DETECTION)
typedef struct tagALARM_PASTE_DETECTION_INFO
{
    int                     nChannelID;                                 // ͨ����
    char                    szName[128];                                // �¼�����
    double                  PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                                        // �¼�������ʱ��
    DH_MSG_OBJECT           stuObject;                                  // ��⵽������
    int                     nDetectRegionNum;                           // ���������򶥵���
    DH_POINT                stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // ����������
    DH_MSG_HANDLE_EX        stuEventHandler;                            // ������Ϣ
    BYTE                    bEventAction;                               // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    BYTE                    bReserved[1023];                            // �����ֽ�,�����չ.
}ALARM_PASTE_DETECTION_INFO;

// �ȳ��������²��쳣���� (DH_ALARM_BETWEENRULE_TEMP_DIFF)
typedef struct tagALARM_BETWEENRULE_DIFFTEMPER_INFO
{
    int                             nAction;                        // 0:��ʼ 1:ֹͣ
    int                             nOsdId;                         // �²�OSD�����е�OSD���
    int                             nChannelID;                     // ��Ƶͨ����
    NET_RADIOMETRY_ALARMCONTION     emAlarmContion;                 // �������� 0:С�� 1:���� 2:����
    int                             nRuleId1;                       // ���¹���1,�ο�����CFG_RADIOMETRY_RULE_INFO
    int                             nRuleId2;                       // ���¹���2,�ο�����CFG_RADIOMETRY_RULE_INFO
    float                           fDiffValue;                     // ������²�ֵ
    int                             nTemperatureUnit;               // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
    UINT                            nPresetID;                      // Ԥ�õ�
    BYTE                            reserved[128];                  // Ԥ���ֶ�  
}ALARM_BETWEENRULE_DIFFTEMPER_INFO;

// �ȳ����ȵ��쳣�����¼�(��Ӧ DH_ALARM_HOTSPOT_WARNING)
typedef struct tagALARM_HOTSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:��ʼ 1:ֹͣ
    int                 nChannelID;                     // ��Ƶͨ����
    DH_POINT            stuCoordinate;                   // �ȵ������,����ֵ 0~8192
    float               fHotSpotValue;                  // �ȵ��¶�ֵ
    int                 nTemperatureUnit;               // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
}ALARM_HOTSPOT_WARNING_INFO;

// �ȳ�������쳣�����¼�(��Ӧ DH_ALARM_COLDSPOT_WARNING)
typedef struct tagALARM_COLDSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:��ʼ 1:ֹͣ
    int                 nChannelID;                     // ��Ƶͨ����
    DH_POINT            stuCoordinate;                   // ��������,����ֵ 0~8192
    float               fColdSpotValue;                  // ����¶�ֵ
    int                 nTemperatureUnit;               // �¶ȵ�λ(��ǰ���õ��¶ȵ�λ),�� NET_TEMPERATURE_UNIT
}ALARM_COLDSPOT_WARNING_INFO;

// ˮ��������Ϣ (��Ӧ DH_ALARM_FLOW_METER)
typedef struct tagALARM_FLOW_METER_INFO 
{
    DWORD                   dwSize;
    float                   fInstantRate;                       // ˲ʱ���� m/s
    float                   fInstantFlow;                       // ˲ʱ���� m^3/h
    float                   fTotalFlow;                         // ������ m^3
    float                   fCurDayFlow;                        // �������� m^3
    UINT                    unCurDayWorkingTime;                // ���콵����ҵʱ��,��λ: ��
    UINT                    unTotalWorktingTime;                // �ۼƽ�����ҵʱ��,��λ: ��
    NET_GPS_STATUS_INFO     stuGPS;                             // GPS��Ϣ
    float                   fCurTemp;                           // �豸��ǰ�¶�ֵ,��λ: ���϶�
} ALARM_FLOW_METER_INFO;

// ¼��֡����
typedef enum tagEM_BUF_DROP_FRAME_TYPE
{
    EM_BUF_DROP_FRAME_UNKOWN = 0,                       // ��֡����Ϊ δ֪¼��
    EM_BUF_DROP_FRAME_DEVBUF,                           // ��֡����Ϊ ������¼��
    EM_BUF_DROP_FRAME_EXTBUF,                           // ��֡����Ϊ ������¼��
    EM_BUF_DROP_FRAME_NETBUF,                           // ��֡����Ϊ ����������¼��
    EM_BUF_DROP_FRAME_EXTRA1NETBUF                      // ��֡����Ϊ ������1����¼��
}EM_BUF_DROP_FRAME_TYPE;

// ¼�񻺳�����֡�¼�(��Ӧ DH_ALARM_BUF_DROP_FRAME)
typedef struct tagALARM_BUF_DROP_FRAME_INFO
{
    int                         nAction;                // 0:��ʼ 1:ֹͣ
    EM_BUF_DROP_FRAME_TYPE      emDropFrameType;        // ¼��֡����
    BYTE                        reserved[1024];         // Ԥ���ֶ�
}ALARM_BUF_DROP_FRAME_INFO;


// �����л��¼� ��Ⱥ�л����� (��Ӧ DH_ALARM_DCSSWITCH)
typedef struct tagALARM_DCSSWITCH_INFO
{
    int                         nAction;                // 0:��ʼ 1:ֹͣ
    char                        strMasterIP[32];        // ���滻�����û�IP
    char                        strSlaveIP[32];         // ִ���滻�ı��û�IP
    NET_TIME_EX                 stuStartTime;           // �滻�Ŀ�ʼʱ��
    BYTE                        reserved[1024];         // Ԥ���ֶ�
}ALARM_DCSSWITCH_INFO;

// ˫���豸�����뱸��֮��汾��Ϣ��һ���쳣�¼� (��Ӧ DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL)
typedef struct tagALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO
{
    int                         nAction;                // 0:��ʼ 1:ֹͣ
    char                        strMasterVer[64];       // ����İ汾��Ϣ(��nAction Ϊ0ʱ ��ֵ��Ч)
    char                        strSlaveVer[64];        // ����İ汾��Ϣ(��nAction Ϊ0ʱ ��ֵ��Ч)
    BYTE                        reserved[1024];         // Ԥ���ֶ�
}ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO;

// �״�����״̬
typedef enum tagEM_RADAR_CONNECT_STATE
{
    EM_RADAR_CONNECT_STATE_UNKNOWN,     // δ֪
    EM_RADAR_CONNECT_STATE_NORMAL,      // ����
    EM_RADAR_CONNECT_STATE_EXCEPTION,   // �쳣
}EM_RADAR_CONNECT_STATE;

// �״�����״̬�¼� (��Ӧ DH_ALARM_RADAR_CONNECT_STATE)
typedef struct tagALARM_RADAR_CONNECT_STATE_INFO
{
    EM_RADAR_CONNECT_STATE      emRadarConnectState;    // �״�����״̬
    BYTE                        reserved[1024];         // Ԥ���ֶ�
}ALARM_RADAR_CONNECT_STATE_INFO;

typedef enum tagEM_MARKFILE_MODE
{
	EM_MARK_FILE_BY_TIME_MODE,                              // ͨ��ʱ�䷽ʽ��¼�����
	EM_MARK_FILE_BY_NAME_MODE,                              // ͨ���ļ�����ʽ��¼�����
}EM_MARKFILE_MODE;
typedef enum tagEM_MARKFILE_NAMEMADE_TYPE
{
	EM_MARKFILE_NAMEMADE_DEFAULT,							// Ĭ�Ϸ�ʽ����Ҫ�û�����¼���ļ�������szFilename
	EM_MARKFILE_NAMEMADE_JOINT,								// ƴ���ļ�����ʽ���û����ݴ��̺�(nDriveNo)����ʼ�غ�(nStartCluster)������Ҫ����¼���ļ���
}EM_MARKFILE_NAMEMADE_TYPE;
typedef struct tagNET_IN_SET_MARK_FILE
{
    DWORD                                   dwSize;									// 
	EM_MARKFILE_MODE	                    emLockMode;								// ¼�������ʽ��
	EM_MARKFILE_NAMEMADE_TYPE				emFileNameMadeType;						// �ļ��������ķ�ʽ
    int										nChannelID;								// ͨ����
    char									szFilename[MAX_PATH];	                // �ļ���
    unsigned int							nFramenum;								// �ļ���֡��
    unsigned int							nSize;									// �ļ�����
    NET_TIME								stuStartTime;							// ��ʼʱ��
    NET_TIME								stuEndTime;								// ����ʱ��
    unsigned int							nDriveNo;								// ���̺�(��������¼��ͱ���¼�������,0��127��ʾ����¼��,����64��ʾ����1,128��ʾ����¼��)
    unsigned int							nStartCluster;							// ��ʼ�غ�
    BYTE									byRecordFileType;						// ¼���ļ�����  0����ͨ¼��1������¼��2���ƶ���⣻3������¼��4��ͼƬ, 5: ����¼��
    BYTE									byImportantRecID;						// 0:��ͨ¼�� 1:��Ҫ¼��
    BYTE									byHint;									// �ļ���λ����(nRecordFileType==4<ͼƬ>ʱ,bImportantRecID<<8 +bHint ,���ͼƬ��λ���� )
    BYTE									byRecType;								// 0-������¼��  1-������1¼�� 2-������2¼�� 3-������3¼��
} NET_IN_SET_MARK_FILE;
typedef struct tagNET_OUT_SET_MARK_FILE
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE;
//CLIENT_SetMarkFileByTime�������
typedef struct tagNET_IN_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize;
    int                 nChannel;                             //��Ҫ������ͨ����,��0��ʼ,Ԫ��Ϊ-1ʱ,��ʾȫͨ����
    NET_TIME_EX         stuStartTime;                         //��ʼʱ��
    NET_TIME_EX         stuEndTime;                           //����ʱ��
    BOOL                bFlag;                                //��Ƕ���	true : ���, false : ���
} NET_IN_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTime�������
typedef struct tagNET_OUT_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTimeEx�������

//CLIENT_SetMarkFileByTimeEx�������

//CLIENT_GetMarkInfo�������
typedef struct tagNET_IN_GET_MARK_INFO
{
    DWORD               dwSize;
} NET_IN_GET_MARK_INFO;

//CLIENT_GetMarkInfo�������
typedef struct tagNET_OUT_GET_MARK_INFO
{
    DWORD               dwSize;
    int                 nTotalSpace;  //����������λM��
    int                 nMarkSpace;   //¼������������ ��λM
} NET_OUT_GET_MARK_INFO;

//������Ǳ�������
typedef struct tagNET_IN_CLEAR_REPEAT_ENTER
{
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // �û�����
    BYTE         bReserved[1024];
}NET_IN_CLEAR_REPEAT_ENTER;

//������Ǳ��������
typedef struct tagNET_OUT_CLEAR_REPEAT_ENTER
{
    BYTE         bReserved[1024];
}NET_OUT_CLEAR_REPEAT_ENTER;

// �����¼�����DH_ALARM_RECORD_LOSS(¼��ʧ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_RECORD_LOSS_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����, 0:Pulse, 1:Start, 2:Stop
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // ������¼����豸IP  
    int                 nPort;                          // ������¼����豸�˿�
    BYTE                byReserved[1024];               // Ԥ��
} ALARM_RECORD_LOSS_INFO;

// �����¼�����DH_ALARM_VIDEO_FRAME_LOSS(��Ƶ��֡�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_VIDEO_FRAME_LOSS_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����, 0:Pulse, 1:Start, 2:Stop
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // ������֡���豸IP
    int                 nPort;                          // ������֡���豸�˿�
    BYTE                byReserved[1024];               // Ԥ��
} ALARM_VIDEO_FRAME_LOSS_INFO;

// �����¼�����DH_ALARM_RECORD_VOLUME_FAILURE(���̾��쳣)��Ӧ������������Ϣ
typedef struct tagALARM_RECORD_VOLUME_FAILURE_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����, 0:Pulse, 1:Start, 2:Stop
    BYTE                byReserved[1024];               // Ԥ��
} ALARM_RECORD_VOLUME_FAILURE_INFO;

// �¼����� DH_EVENT_SNAP_UPLOAD(ͼ�ϴ�����¼�)��Ӧ������������Ϣ
typedef struct tagEVENT_SNAP_UPLOAD_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����, 0:Pulse, 1:Start, 2:Stop
    BOOL                bSnapResult;                    // ͼƬ�Ƿ��ϴ��ɹ�
    char                szFilePath[MAX_PATH];           // �ϴ��ı���ͼƬ����
    BYTE                byReserved[1024];               // Ԥ��
}EVENT_SNAP_UPLOAD_INFO;

// �����¼�����DH_ALARM_UPLOADPIC_FAILCOUNT(�ϴ�����ʧ�����ݸ���)��Ӧ������������Ϣ
typedef struct tagALARM_UPLOADPIC_FAILCOUNT_INFO
{
    int                 nFailCount;                     // �ϴ�ʧ�ܸ���
    BYTE                byReserved[1024];               // Ԥ��
} ALARM_UPLOADPIC_FAILCOUNT_INFO;


// �����¼����� DH_ALARM_HUMAN_INSIDE(���������¼�) ��Ӧ������������Ϣ
typedef struct tagALARM_HUMAN_INSIDE_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����,-1��ʾδ֪�¼�,0��ʾ�������¼���ʼ,1��ʾ�������¼�����
    int                 nHumanNumber;                   // ��������
    NET_TIME            stuUtcTime;                     // �¼�������ʱ��
    BYTE                byReserved[1000];               // Ԥ��  
} ALARM_HUMAN_INSIDE_INFO;
 
// �����¼����� DH_ALARM_HUMAN_TUMBLE_INSIDE(��������ˤ���¼�) ��Ӧ������������Ϣ
typedef struct tagALARM_HUMAN_TUMBLE_INSIDE_INFO
{
    int                 nChannelID;                     // ͨ����
    int                 nEventAction;                   // �¼�����,-1��ʾδ֪�¼�,0��ʾ�������¼���ʼ,1��ʾ�������¼�����
    NET_TIME            stuUtcTime;                     // �¼�������ʱ��
    BYTE                byReserved[1000];               // Ԥ��
} ALARM_HUMAN_TUMBLE_INSIDE_INFO;

// �����¼����� DH_ALARM_DISABLE_LOCKIN(�������Ű�ť�����¼�) ��Ӧ������������Ϣ
typedef struct tagALARM_DISABLE_LOCKIN_INFO
{
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuUtcTime;                     // �¼�������ʱ��
    BYTE                byReserved[1000];               // Ԥ��
} ALARM_DISABLE_LOCKIN_INFO;


// �����¼����� DH_ALARM_DISABLE_LOCKOUT(�������Ű�ť�����¼�) ��Ӧ������������Ϣ
typedef struct tagALARM_DISABLE_LOCKOUT_INFO
{
    int                 nChannelID;                     // ͨ����
    NET_TIME            stuUtcTime;                     // �¼�������ʱ��
    BYTE                byReserved[1000];               // Ԥ��
} ALARM_DISABLE_LOCKOUT_INFO;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CLIENT_GetOperatorName �������
typedef struct tagNET_IN_GET_OPERATOR_NAME
{
    BYTE                byReserved[1024];               // Ԥ��
} NET_IN_GET_OPERATOR_NAME;

//CLIENT_GetOperatorName �������
typedef struct tagNET_OUT_GET_OPERATOR_NAME
{
    char                szOpearatorName[DH_COMMON_STRING_64]; //����Ա�û���
    BYTE                byReserved[1024];                     // Ԥ��
} NET_OUT_GET_OPERATOR_NAME;

// CLIENT_GetSelfCheckInfo �������
typedef struct tagNET_IN_GET_SELTCHECK_INFO
{
    DWORD               dwSize;                  // �û�ʹ�øýṹ��ʱ,dwSize �踳ֵΪ sizeof (NET_IN_GET_SELTCHECK_INFO)
} NET_IN_GET_SELTCHECK_INFO;

//�¼�����EVENT_IVS_PTZ_PRESET(��̨ת����Ԥ�õ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_PTZ_PRESET_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
    char                szPresetName[PTZ_PRESET_NAME_LEN];          // Ԥ�õ�����
    PTZ_SPEED_UNIT      stuPos;                                     // Ԥ�õ������ͷŴ���
    int                 nPresetID;                                  // Ԥ�õ�ID
    BYTE                bReserved[1024];                            // �����ֽ�
} DEV_EVENT_ALARM_PTZ_PRESET_INFO;

//�¼�����EVENT_IVS_RFID_INFO(�����߼����Ϣ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_ALARM_RFID_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
    int                 nAction;                                    // 0:��ʼ 1:ֹͣ
    int                 nValidCount;                                // RFID ���������Ч����
    char                szRfid[10][12];                             // RFID �������
    BYTE                bReserved[1024];                            // �����ֽ�
} DEV_EVENT_ALARM_RFID_INFO;



// ����ϵͳ������Ϣ
typedef struct tagNET_CAR_WEIGTH_INFO
{
	unsigned int		nAxleNum;									// ������
	unsigned int		nMaxAxleDistance;							// ������, ��λ�Ǻ���
    unsigned int        nAxleWeightInfo[MAX_AXLE_NUM];              // ÿ�����������, ��λKg, ��һ��Ԫ�ر�ʾ��һ��������, ��������
    unsigned int        nAxleDistanceInfo[MAX_AXLE_NUM-1];          // ������ļ��, ��λ����, ��һ��Ԫ�ر�ʾһ������, �ڶ���Ԫ�ر�ʾ��������, ��������
    unsigned int        nOverWeight;                                // ������Ϣ, ��λǧ��
    BYTE                byReserved[512];                            // �����ֽ�
}NET_CAR_WEIGHT_INFO;

// �¼����� EVENT_IVS_QSYTRAFFICCARWEIGHT (��ͨ���ڳ����¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_QSYTRAFFICCARWEIGHT_INFO  
{
    NET_CAR_WEIGHT_INFO                 stCarWeightInfo;		    // ����ϵͳ������Ϣ
    DEV_EVENT_TRAFFICJUNCTION_INFO      stJunctionInfo;             // ��ͨ������Ϣ
}DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO;

// ǰ������Ϣ
typedef struct tagNET_PLATE_INFO
{
	char						szFrontPlateNumber[DH_MAX_PLATE_NUMBER_LEN];	// ǰ���ƺ���
	EM_NET_PLATE_COLOR_TYPE		emFrontPlateColor;								//ǰ������ɫ
	char						szBackPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// ���ƺ���
	EM_NET_PLATE_COLOR_TYPE		emBackPlateColor;								// ������ɫ
	BYTE						bReserved[1024];								// �����ֽ�
} NET_PLATE_INFO;

// ��¼���ſ���ͼƬ��ץ��ʱ��
typedef struct tagNET_SNAP_TIME_INFO
{
    NET_TIME_EX stFrontGateSnapTime;    // ǰ����ͼƬץ��ʱ��(��ȷ������)
    NET_TIME_EX stBackGateSnapTime;     // �󿨿�ͼƬץ��ʱ��(��ȷ������) 
    BYTE  bReserved[128];               // �����ֽ�
}NET_SNAP_TIME_INFO;

// �¼�����EVENT_IVS_TRAFFIC_COMPAREPLATE(���ڳ��ƺϳ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_COMPAREPLARE_INFO
{
	int					nChannelID;							// ͨ����
	char				szName[DH_EVENT_NAME_LEN];			// �¼�����
	int                 nTriggerType;                   	// TriggerType:��������,0������,1�״�,2��Ƶ
	double				dbPTS;								// ʱ���(��λ�Ǻ���)
	NET_TIME_EX			stuUTC;								// �¼�������ʱ��
	int					nEventID;							// �¼�ID

	DH_MSG_OBJECT		stuObject;							// ������Ϣ
	DH_MSG_OBJECT		stuVehicle;							// ������Ϣ
	DH_EVENT_FILE_INFO  stuFileInfo;                        // �¼���Ӧ�ļ���Ϣ 
	int					nMark;								// ���ڱ��ץ��֡
	int					nSource;							// ��Ƶ����������Դ��ַ
	int					nFrameSequence;						// ��Ƶ֡���
	int					nSpeed;								// ����ʵ���ٶ�(��λ: km/h)
	int					nLane;								// ��Ӧ�ĳ����� 
	int					nSequence;							// ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;         // ��ͨ������Ϣ
	NET_PLATE_INFO		stuPlateInfo;						// ǰ������Ϣ
	EVENT_COMM_INFO     stCommInfo;                         // ������Ϣ
	DWORD               dwSnapFlagMask;                     // ץͼ��־(��λ),�����NET_RESERVED_COMMON

    NET_SNAP_TIME_INFO  stSnapTimeInfo;                     // ��¼���ſ���ͼƬ��ץ��ʱ��
	BYTE				bReserved[820];					    // ������Ϣ
} DEV_EVENT_TRAFFIC_COMPAREPLATE_INFO;
typedef struct tagDEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO
{
    int							nChannelID;									// ͨ����
    char						szName[DH_EVENT_NAME_LEN];					// �¼�����
    double						dbPTS;										// ʱ���(��λ�Ǻ���)
    NET_TIME_EX					stuUTC;										// �¼�������ʱ��
    int							nEventID;									// �¼�ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// �¼���Ӧ�ļ���Ϣ
    BYTE						bEventAction;								// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
	DH_POINT					stuDetectRegion;								// ����������
	int							nValidBulletHolesNum;						// ��⵽����Ч���׸���
	NET_BULLET_HOLES_INFO       stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// ��⵽�ĵ���
    BYTE						byImageIndex;								// ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD						dwSnapFlagMask;								// ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE						bReserved[1024];							// �����ֽ�,�����չ. 
} DEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO;

// �¼����� EVENT_IVS_TRAFFIC_TRANSFINITE(Υ�³���ץͼ�ϱ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_TRANSFINITE_INFO
{
    int							nChannelID;									// ͨ����
    char						szName[DH_EVENT_NAME_LEN];					// �¼�����
    double						dbPTS;										// ʱ���(��λ�Ǻ���)
    NET_TIME_EX					stuUTC;										// �¼�������ʱ��
    int							nEventID;									// �¼�ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// �¼���Ӧ�ļ���Ϣ
    BYTE						bEventAction;								// �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

	char						szPlateNumber[16];							// ����
    char                        szTime[20];									// Υ��ʱ��
	double						dbLong;										// ������λ��
    double						dbWidth;									// ����λ��
	double						dbHeight;									// ��, ��λ��
	char						szViolationCode[16];						// Υ�´���
	char						szDescribe[132];						    // Υ������

    BYTE						byImageIndex;								// ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD						dwSnapFlagMask;								// ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE						bReserved[4096];							// �����ֽ�,�����չ. 
} DEV_EVENT_TRAFFIC_TRANSFINITE_INFO;

// ����ץ��ͼƬ��Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_FCC_IMAGE
{
    DWORD           dwOffSet;                       // ͼƬ�ļ��ڶ��������ݿ��е�ƫ��λ��, ��λ:�ֽ�
    DWORD           dwLength;						// ͼƬ��С, ��λ:�ֽ�
    WORD            wWidth;                         // ͼƬ���, ��λ:����
    WORD            wHeight;                        // ͼƬ�߶�, ��λ:����
}DEV_EVENT_TRAFFIC_FCC_IMAGE;

// ����ץͼ��Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_FCC_OBJECT
{
	DEV_EVENT_TRAFFIC_FCC_IMAGE	stuImage;							// ����ץ��ͼƬ��Ϣ
}DEV_EVENT_TRAFFIC_FCC_OBJECT;

// �¼�����EVENT_IVS_TRAFFIC_FCC_INFO
typedef struct tagDEV_EVENT_TRAFFIC_FCC_INFO
{
	int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    DWORD				nTriggerID;									// ��������: 1��ʾ��ǹ, 2��ʾ��ǹ
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////

	DWORD				dwNum;										// ����ǹ��
	DWORD				dwLitre;									// ��������,��λ 0.01��
	EM_REFUEL_TYPE		emType;										// ��������: ȡֵ��Χ{"90#","93#","10#","-20#"}
	DWORD				dwMoney;									// ���ͽ��,��λ 0.01Ԫ
	char				szPlateNumber[DH_COMMON_STRING_16];			// ���ƺ�
	char				szTime[DH_COMMON_STRING_32];				// �¼�����ʱ��: "2016-05-23 10:31:17"
	DEV_EVENT_TRAFFIC_FCC_OBJECT	stuObject;						// ����ץͼ��Ϣ
	BYTE				bReserved[1024];					        // �����ֽ�,�����չ
}DEV_EVENT_TRAFFIC_FCC_INFO;



typedef enum tagEM_PARKINGSPACE_STATUS
{
    EM_PARKINGSPACE_STATUS_UNKNOWN,
    EM_PARKINGSPACE_STATUS_BUSY,                            // ռ��
    EM_PARKINGSPACE_STATUS_FREE,                            // ����
    EM_PARKINGSPACE_STATUS_OVERLINE,                        // ѹ��
}EM_PARKINGSPACE_STATUS;

// ��λ��ͼ��Ϣ
typedef struct tagNET_FEATUREPIC_AREA
{
	int					nRetCount;									// ʵ�ʷ����������																
	DH_POINT			stuFeaturePicArea[10];						// ��λ��Ϣ��ͼ����							
	BYTE				bReserved[256];					            // �����ֽ�
}NET_FEATUREPIC_AREA;

//�¼�����EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP(����Ԥ����ץƬͼƬ�¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[128];                                // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         stuTime;                                    // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    int					nGroupID;									// �¼���ID��ͬһ����ץ�Ĺ�����GroupID��ͬ
    int					nCountInGroup;								// һ���¼����ڵ�ץ������
    int					nIndexInGroup;								// һ���¼����ڵ�ץ�����
    DH_MSG_OBJECT       stuObject;                                  // ������Ϣ
    DH_MSG_OBJECT       stuVehicle;                                 // ������Ϣ
    int					nMark;								        // ���ڱ��ץ��֡
    int					nSource;							        // ��Ƶ����������Դ��ַ
    int					nFrameSequence;						        // ��Ƶ֡���
    int					nLane;								        // ��Ӧ�ĳ����� 
    int					nSequence;							        // ��ʾץ�����,��3,2,1,1��ʾץ�Ľ���,0��ʾ�쳣����
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ��ͨ������Ϣ
    EM_PARKINGSPACE_STATUS   emParkingSpaceStatus;                  // �豸��������г�λ���ۺ�״̬
	EVENT_COMM_INFO     stCommInfo;                                 // ������Ϣ
	EM_PARKINGSPACE_STATUS   emCurParkingSpaceStatus;				// ��Ӧ��ǰ��λ�ŵĳ�λ״̬
	NET_FEATUREPIC_AREA		 stuParkingInfo;						// ��λ��ͼ��Ϣ���꣬����֧��4�����㣬�������ֵ꣬����ͼƬ�ķֱ��ʾ���
    BYTE				bReserved[720];								// ������Ϣ
}DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO;

//�¼�����EVENT_IVS_NEAR_DISTANCE_DETECTION(������Ӵ��¼�)��Ӧ�����ݿ�������Ϣ
typedef struct tagDEV_EVENT_NEAR_DISTANCE_DETECTION_INFO
{
    int                 nChannelID;                                 // ͨ����
    char                szName[DH_EVENT_NAME_LEN];                  // �¼�����
    char                bReserved1[4];                              // �ֽڶ���
    double              PTS;                                        // ʱ���(��λ�Ǻ���)
    NET_TIME_EX         UTC;                                        // �¼�������ʱ��
    int                 nEventID;                                   // �¼�ID
    ///////////////////////////////����Ϊ�����ֶ�//////////////////////////////
    int                 nAction;                                    // 0:���� 1:��ʼ 2:ֹͣ
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // �����¼�������Ϣ
    BYTE                bReserved[2048];                            // �����ֽ�
} DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO;

// ��ʼ������
typedef struct tagNETSDK_INIT_PARAM
{
    int                 nThreadNum;         // ָ��NetSDK�������紦���߳���, ��ֵΪ0ʱ, ʹ���ڲ�Ĭ��ֵ
    BYTE                bReserved[1024];    // �����ֽ�
}NETSDK_INIT_PARAM, *LPNETSDK_INIT_PARAM;

// ��������
typedef enum tagNET_EM_OSD_BLEND_TYPE
{
    NET_EM_OSD_BLEND_TYPE_UNKNOWN,                                  //δ֪��������
    NET_EM_OSD_BLEND_TYPE_MAIN,                                     //���ӵ�������
    NET_EM_OSD_BLEND_TYPE_EXTRA1,                                   //���ӵ�������1
    NET_EM_OSD_BLEND_TYPE_EXTRA2,                                   //���ӵ�������2
    NET_EM_OSD_BLEND_TYPE_EXTRA3,                                   //���ӵ�������3
    NET_EM_OSD_BLEND_TYPE_SNAPSHOT,                                 //���ӵ�ץͼ
    NET_EM_OSD_BLEND_TYPE_PREVIEW,                                  //���ӵ�Ԥ����Ƶ
}NET_EM_OSD_BLEND_TYPE;

// �������-ͨ������
typedef struct tagNET_OSD_CHANNEL_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                 // �������ͣ������ǻ�ȡ�������ö�Ҫ���ø��ֶ�
    BOOL                    bEncodeBlend;                   // �Ƿ����
	NET_COLOR_RGBA		    stuFrontColor;					// ǰ��ɫ
	NET_COLOR_RGBA		    stuBackColor;					// ����ɫ
	NET_RECT		    	stuRect;						// ����, ����ȡֵ[0~8191], ��ʹ��left��topֵ, ��(left,top)Ӧ��(right,bottom)���ó�ͬ���ĵ�
} NET_OSD_CHANNEL_TITLE;

// �������-ʱ�����
typedef struct tagNET_OSD_TIME_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;             // �������ͣ������ǻ�ȡ�������ö�Ҫ���ø��ֶ�
    BOOL                    bEncodeBlend;               // �Ƿ����
	NET_COLOR_RGBA		    stuFrontColor;				// ǰ��ɫ
	NET_COLOR_RGBA		    stuBackColor;				// ����ɫ
	NET_RECT 			    stuRect;					// ����, ����ȡֵ[0~8191], ��ʹ��left��topֵ, ��(left,top)Ӧ��(right,bottom)���ó�ͬ���ĵ�
	BOOL 				    bShowWeek;					// �Ƿ���ʾ����
} NET_OSD_TIME_TITLE;

// �������-�Զ��������Ϣ
typedef struct tagNET_CUSTOM_TITLE_INFO
{
    BOOL                    bEncodeBlend;                   // �Ƿ����
	NET_COLOR_RGBA		    stuFrontColor;					// ǰ��ɫ
	NET_COLOR_RGBA		    stuBackColor;					// ����ɫ
	NET_RECT			    stuRect;						// ����, ����ȡֵ[0~8191], ��ʹ��left��topֵ, ��(left,top)Ӧ��(right,bottom)���ó�ͬ���ĵ�
	char				    szText[CUSTOM_TITLE_LEN];		// ��������
	BYTE                    byReserved[512];                // �����ֽ� 
} NET_CUSTOM_TITLE_INFO;

// �������-�Զ������
typedef struct tagNET_OSD_CUSTOM_TITLE
{
	DWORD					dwSize;
	NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                         // �������ͣ������ǻ�ȡ�������ö�Ҫ���ø��ֶ�
	int						nCustomTitleNum;						// �Զ����������
	NET_CUSTOM_TITLE_INFO	stuCustomTitle[MAX_CUSTOM_TITLE_NUM];	// �Զ������
} NET_OSD_CUSTOM_TITLE;

// �����ı����뷽ʽ
typedef enum tagEM_TITLE_TEXT_ALIGNTYPE
{
    EM_TEXT_ALIGNTYPE_INVALID,                              // ��Ч�Ķ��뷽ʽ
    EM_TEXT_ALIGNTYPE_LEFT,                                 // �����
    EM_TEXT_ALIGNTYPE_XCENTER,                              // X�����ж���
    EM_TEXT_ALIGNTYPE_YCENTER,                              // Y�����ж���
    EM_TEXT_ALIGNTYPE_CENTER,                               // ����
    EM_TEXT_ALIGNTYPE_RIGHT,                                // �Ҷ���
    EM_TEXT_ALIGNTYPE_TOP,                                  // ���ն�������
    EM_TEXT_ALIGNTYPE_BOTTOM,                               // ���յײ�����
    EM_TEXT_ALIGNTYPE_LEFTTOP,                              // �������ϽǶ���
    EM_TEXT_ALIGNTYPE_CHANGELINE,                           // ���ж���
}EM_TITLE_TEXT_ALIGNTYPE;

// �Զ�������ı�����
typedef struct tagNET_OSD_CUSTOM_TITLE_TEXT_ALIGN
{
	DWORD					dwSize;
	int						nCustomTitleNum;						// �Զ����������
    EM_TITLE_TEXT_ALIGNTYPE emTextAlign[MAX_CUSTOM_TITLE_NUM];      // �Զ�������ı����뷽ʽ
}NET_OSD_CUSTOM_TITLE_TEXT_ALIGN;

//�������-����������Ϣ
typedef struct tagNET_OSD_COMM_INFO
{
	DWORD					dwSize;
	double					fFontSizeScale;			//���������С�Ŵ����
													//��fFontSizeScale��0ʱ,nFontSize��������
													//��fFontSizeScale=0ʱ,nFontSize������
													//�豸Ĭ��fFontSizeScale=1.0
													//�����Ҫ�޸ı������޸ĸ�ֵ
													//�����Ҫ�����������ã����ø�ֵΪ0��nFontSize��ֵ��Ч
	int						nFontSize;				//���ӵ��������ϵ�ȫ�������С,��λ px, Ĭ��24.
													//��fFontSizeScale��ͬ����
	int						nFontSizeExtra1;		//���ӵ�������1�ϵ�ȫ�������С,��λ px
	int						nFontSizeExtra2;		//���ӵ�������2�ϵ�ȫ�������С,��λ px
	int						nFontSizeExtra3;		//���ӵ�������3�ϵ�ȫ�������С,��λ px
	int						nFontSizeSnapshot;		//���ӵ�ץͼ���ϵ�ȫ�������С, ��λ px
	int						nFontSizeMergeSnapshot; //���ӵ�ץͼ���Ϻϳ�ͼƬ�������С,��λ px
} NET_OSD_COMM_INFO;

// �������-�䱶��������
typedef struct tagNET_OSD_PTZZOOM_INFO
{
	DWORD					dwSize;
	BOOL					bMainBlend;				// �Ƿ���ӵ�������
	BOOL					bPreviewBlend;			// �Ƿ���ӵ�Ԥ������
	NET_COLOR_RGBA		    stuFrontColor;			// ǰ��ɫ
	NET_COLOR_RGBA		    stuBackColor;			// ����ɫ
	NET_RECT		    	stuRect;				// ����, ����ȡֵ0~8191, ��ʹ��left��topֵ, ��(left,top)Ӧ��(right,bottom)���ó�ͬ���ĵ�
	int						nDisplayTime;			// ��ʾʱ�䣬��λΪ�0��ʾһֱ��ʾ
} NET_OSD_PTZZOOM_INFO;

// �������-GPS������ʾ����
typedef struct tagNET_OSD_GPS_TITLE
{
	DWORD					dwSize; 
	BOOL					bEncodeBlend;            //���ӵ���������Ƶ����
}NET_OSD_GPS_TITLE;

#define MAX_COUNT_PLANE		32	// �������ͳ�Ƽƻ�����

// ÿ���ƻ���Ӧ������ͳ�Ƽƻ�OSD���� 
typedef struct tagNET_STATPLAN_INFO
{
	int						nPlanID;				// ����ͳ�Ƽƻ���
	BOOL					bEncodeBlend;			// �Ƿ���ӵ�������
	NET_COLOR_RGBA		    stuFrontColor;			// ǰ��ɫ
	NET_COLOR_RGBA		    stuBackColor;			// ����ɫ
	EM_TITLE_TEXT_ALIGNTYPE emTextAlign;			// ���뷽ʽ
	NET_RECT		    	stuRect;				// ����, ����ȡֵ0~8191
	BOOL					bShowEnterNum;			// �Ƿ���ʾ��������
	BOOL					bShowExitNum;			// �Ƿ���ʾ�뿪����
	BYTE                    byReserved[128];        // �����ֽ� 
} NET_STATPLAN_INFO;

// ����ͳ�Ƽƻ�����OSD����
typedef struct tagNET_OSD_NUMBER_STATPLAN
{
	DWORD					dwSize;
	int						nRetPlanCount;							// ʵ�ʵ�ͳ�Ƽƻ�����
	NET_STATPLAN_INFO		stuStatplanInfo[MAX_COUNT_PLANE];		// OSD����
} NET_OSD_NUMBER_STATPLAN;

// ��Ƶ����ģʽ
typedef enum tatNET_EM_AUDIO_FORAMT
{
	EM_AUDIO_FORMAT_UNKNOWN,							// unknown
	EM_AUDIO_FORMAT_G711A,                              // G711a
    EM_AUDIO_FORMAT_PCM,                                // PCM
    EM_AUDIO_FORMAT_G711U,                              // G711u
    EM_AUDIO_FORMAT_AMR,                                // AMR
    EM_AUDIO_FORMAT_AAC,                                // AAC
    
    EM_AUDIO_FORMAT_G726,								// G.726
    EM_AUDIO_FORMAT_G729,								// G.729
    EM_AUDIO_FORMAT_ADPCM,								// ADPCM
    EM_AUDIO_FORMAT_MPEG2,								// MPEG2
    EM_AUDIO_FORMAT_MPEG2L2,							// MPEG2-Layer2
    EM_AUDIO_FORMAT_OGG,								// OGG
    EM_AUDIO_FORMAT_MP3,								// MP3
    EM_AUDIO_FORMAT_G7221,								// G.722.1
} NET_EM_AUDIO_FORMAT;


// ��Ƶѹ����ʽ
typedef enum tagNET_EM_VIDEO_COMPRESSION
{
	EM_VIDEO_FORMAT_MPEG4,								// MPEG4
	EM_VIDEO_FORMAT_MS_MPEG4,							// MS-MPEG4
	EM_VIDEO_FORMAT_MPEG2,								// MPEG2
	EM_VIDEO_FORMAT_MPEG1,								// MPEG1
	EM_VIDEO_FORMAT_H263,								// H.263
	EM_VIDEO_FORMAT_MJPG,								// MJPG
	EM_VIDEO_FORMAT_FCC_MPEG4,							// FCC-MPEG4
	EM_VIDEO_FORMAT_H264,								// H.264
    EM_VIDEO_FORMAT_H265,								// H.265
	EM_VIDEO_FORMAT_SVAC,								// SVAC
} NET_EM_VIDEO_COMPRESSION;

// ��������ģʽ
typedef enum tagNET_EM_BITRATE_CONTROL
{
	EM_BITRATE_CBR,									// �̶�����
	EM_BITRATE_VBR,									// �ɱ�����
} NET_EM_BITRATE_CONTROL;

// ����
typedef enum tagNET_EM_IMAGE_QUALITY
{
	EM_IMAGE_QUALITY_Q10 = 1,							// ͼ������10%
	EM_IMAGE_QUALITY_Q30,								// ͼ������30%
	EM_IMAGE_QUALITY_Q50,								// ͼ������50%
	EM_IMAGE_QUALITY_Q60,								// ͼ������60%
	EM_IMAGE_QUALITY_Q80,								// ͼ������80%
	EM_IMAGE_QUALITY_Q100,								// ͼ������100%
} NET_EM_IMAGE_QUALITY;

// H264 ���뼶��
typedef enum tagNET_EM_H264_PROFILE_RANK
{
	EM_PROFILE_UNKNOWN,							   // δ֪����
	EM_PROFILE_BASELINE = 1,                       // �ṩI/P֡����֧��progressive(����ɨ��)��CAVLC
	EM_PROFILE_MAIN,                               // �ṩI/P/B֡��֧��progressiv��interlaced���ṩCAVLC��CABAC
	EM_PROFILE_EXTENDED,                           // �ṩI/P/B/SP/SI֡����֧��progressive(����ɨ��)��CAVLC
	EM_PROFILE_HIGH,                               // ��FRExt��Main_Profile������������8x8 intra prediction(8x8 ֡��Ԥ��), custom 
												   // quant(�Զ�������), lossless video coding(������Ƶ����), �����yuv��ʽ
}NET_EM_H264_PROFILE_RANK;

// ��������
typedef enum tagNET_EM_FORMAT_TYPE
{
	EM_FORMAT_TYPE_UNKNOWN,				// δ֪����
	/*������*/
	EM_FORMAT_MAIN_NORMAL,				// ��������ͨ����
	EM_FORMAT_MAIN_MOVEEXAMINE,			// �������������
	EM_FORMAT_MAIN_ALARM,				// ��������������

	/*������*/
	EM_FORMAT_EXTRA1,					// ������1
	EM_FORMAT_EXTRA2,					// ������2
	EM_FORMAT_EXTRA3,					// ������3
} NET_EM_FORMAT_TYPE;

// ���ģʽ
typedef enum tagNET_EM_PACK_TYPE
{
	EM_PACK_UNKOWN,				// UNKOWN
	EM_PACK_DHAV,				// DHAV
	EM_PACK_PS,					// ps
} NET_EM_PACK_TYPE;


// ��(��)������Ƶ��ʽ(f6/f5/bin)
typedef struct tagNET_ENCODE_VIDEO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	BOOL						bVideoEnable;				// ��Ƶʹ��
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// ��Ƶѹ����ʽ
	int							nWidth;						// ��Ƶ���
	int							nHeight;					// ��Ƶ�߶�
	NET_EM_BITRATE_CONTROL		emBitRateControl;			// ��������ģʽ
	int							nBitRate;					// ��Ƶ����(kbps)
	float						nFrameRate;					// ��Ƶ֡��
	int							nIFrameInterval;			// I֡���(1-100)������50��ʾÿ49��B֡��P֡������һ��I֡��
	NET_EM_IMAGE_QUALITY		emImageQuality;				// ͼ������
} NET_ENCODE_VIDEO_INFO;

// ��(��)������Ƶ��ʽ���ģʽ����(f6/f5)
typedef struct tagNET_ENCODE_VIDEO_PACK_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	NET_EM_PACK_TYPE			emPackType;					// ���ģʽ
} NET_ENCODE_VIDEO_PACK_INFO;

// ��(��)������Ƶ��ʽSVC����(f6)
typedef struct tagNET_ENCODE_VIDEO_SVC_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	int							nSVC;						// SVC-T����
} NET_ENCODE_VIDEO_SVC_INFO;

// ��(��)������Ƶ��ʽprofile����(f6/bin)
typedef struct tagNET_ENCODE_VIDEO_PROFILE_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	NET_EM_H264_PROFILE_RANK 	emProfile;                	// H.264���뼶��
} NET_ENCODE_VIDEO_PROFILE_INFO;

// ��(��)������Ƶѹ����ʽ����
typedef struct tagNET_ENCODE_AUDIO_COMPRESSION_INFO
{
	DWORD						dwSize;
	BOOL						bAudioEnable;			// ��Ƶʹ��
	NET_EM_FORMAT_TYPE			emFormatType;			// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	NET_EM_AUDIO_FORMAT			emCompression;			// ��Ƶѹ��ģʽ
} NET_ENCODE_AUDIO_COMPRESSION_INFO;

//��(��)������Ƶ��ʽ������������
typedef struct tagNET_ENCODE_AUDIO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;			// ��������,���úͻ�ȡʱ����Ҫ����ֵ
	int							nDepth;					// ��Ƶ�������
	int							nFrequency;				// ��Ƶ����Ƶ��
	int							nMode;					// ��Ƶ����ģʽ
	int							nFrameType;				// ��Ƶ���ģʽ, 0-DHAV, 1-PS
	int							nPacketPeriod;			// ��Ƶ�������, ms
} NET_ENCODE_AUDIO_INFO;

// ץͼ����
typedef enum tagNET_EM_SNAP_TYPE
{
	EM_SNAP_UNKNOWN,			// δ֪����
	EM_SNAP_NORMAL,				// ��ͨץͼ
	EM_SNAP_MOVEEXAMINE,		// ����ץͼ
	EM_SNAP_ALARM,				// ����ץͼ
} NET_EM_SNAP_TYPE;

// ץͼ����
typedef struct tagNET_ENCODE_SNAP_INFO
{
	DWORD						dwSize;
	NET_EM_SNAP_TYPE			emSnapType;					// ץͼ����
	BOOL						bSnapEnable;				// ��ʱץͼʹ��
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// ��Ƶѹ����ʽ
	int							nWidth;						// ��Ƶ���
	int							nHeight;					// ��Ƶ�߶�
	float						nFrameRate;					// ��Ƶ֡��
	int 						nQualityRange;				// ͼ������ȡֵ��Χ
	NET_EM_IMAGE_QUALITY		emImageQuality;				// ͼ������
} NET_ENCODE_SNAP_INFO;

// ץͼʱ������
typedef struct tagNET_ENCODE_SNAP_TIME_INFO
{
	DWORD				dwSize;
	short           	shPicTimeInterval;             	// ��ʱץͼʱ����,��λΪ��,Ŀǰ�豸֧������ץͼʱ����Ϊ30����                           
	BYTE            	bPicIntervalHour;              	// ��ʱץͼʱ����Сʱ��
	DWORD           	dwTrigPicIntervalSecond;       	// ����������ÿ��ץͼʱ����ʱ�� ��λ��
} NET_ENCODE_SNAP_TIME_INFO;

// ÿ��ͨ����Ӧ����������
typedef enum tagNET_EM_CONFIG_TYPE
{
	NET_EM_CONFIG_DAYTIME,			// ����
	NET_EM_CONFIG_NIGHT,			// ҹ��
	NET_EM_CONFIG_NORMAL,			// ��ͨ
} NET_EM_CONFIG_TYPE;


// ͨ����������
typedef struct tagNET_ENCODE_CHANNELTITLE_INFO
{
	DWORD				dwSize;
	char				szChannelName[MAX_CHANNEL_NAME_LEN];				// ͨ������
} NET_ENCODE_CHANNELTITLE_INFO;

// ��Ƶ��������
typedef enum tagNET_EM_AUDIOIN_SOURCE_TYPE
{
	NET_EM_AUDIOIN_SOURCE_UNKNOW,			// δ֪
	NET_EM_AUDIOIN_SOURCE_COAXIAL,			// Coaxial
	NET_EM_AUDIOIN_SOURCE_BNC,				// BNC
	NET_EM_AUDIOIN_SOURCE_HDCVI_BNC,		// HDCVI_BNC
	NET_EM_AUDIOIN_SOURCE_LINEIN,			// LineIn
	NET_EM_AUDIOIN_SOURCE_LINEIN1,			// LineIn1
	NET_EM_AUDIOIN_SOURCE_LINEIN2,			// LineIn2
	NET_EM_AUDIOIN_SOURCE_LINEIN3,			// LineIn3
	NET_EM_AUDIOIN_SOURCE_MIC,				// Mic
	NET_EM_AUDIOIN_SOURCE_MIC1,				// Mic1
	NET_EM_AUDIOIN_SOURCE_MIC2,				// Mic2
	NET_EM_AUDIOIN_SOURCE_MIC3,				// Mic3
	NET_EM_AUDIOIN_SOURCE_MICOUT,			// MicOut
	NET_EM_AUDIOIN_SOURCE_REMOTE,			// Remote
	NET_EM_AUDIOIN_SOURCE_REMOTE1,			// Remote1
	NET_EM_AUDIOIN_SOURCE_REMOTE2,			// Remote2
	NET_EM_AUDIOIN_SOURCE_REMOTE3,			// Remote3
} NET_EM_AUDIOIN_SOURCE_TYPE;

// ��Ƶ������������
typedef struct tagNET_ENCODE_AUDIO_SOURCE_INFO
{
	DWORD						dwSize;
	int 						nMaxAudioInSource;		// ��������������
	int							nRetAudioInSource;		// ��������ʵ�ʷ��ظ���
	NET_EM_AUDIOIN_SOURCE_TYPE	emAudioInSource[24];	// ����Դ����
} NET_ENCODE_AUDIO_SOURCE_INFO;

// ��Ƶ���뽵������
typedef struct tagNET_AUDIOIN_DENOISE_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// ����ʹ��
} NET_AUDIOIN_DENOISE_INFO;

// ��Ƶ������������
typedef struct tagNET_AUDIOIN_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// ��Ƶ��������
} NET_AUDIOIN_VOLUME_INFO;

// ��Ƶ�����������
typedef struct tagNET_AUDIOOUT_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// ��Ƶ�������
} NET_AUDIOOUT_VOLUME_INFO;

// �л�ģʽ
typedef enum tagNET_EM_SWITCH_MODE
{
	NET_EM_SWITCH_MODE_WIGHT,		// ���л�������ʹ�ð�������
	NET_EM_SWITCH_MODE_LIGHT,		// ���������л�
	NET_EM_SWITCH_MODE_TIME,		// ����ʱ���л�
	NET_EM_SWITCH_MODE_NIGHT,		// ���л�������ʹ��ҹ������
	NET_EM_SWITCH_MODE_NORMAL,		// ʹ����ͨ����
} NET_EM_SWITCH_MODE;

// �����ճ�/����ʱ��
typedef struct tagNET_SUN_TIME
{
	int				nHour;				// ʱ
	int				nMinute;			// ��
	int				nSecond;			// ��
} NET_SUN_TIME;

// �л�ģʽ����
typedef struct tagNET_VIDEOIN_SWITCH_MODE_INFO
{
	DWORD				dwSize;
	NET_EM_SWITCH_MODE	emSwitchMode;			// �л�ģʽ

	/*�����ճ�������ʱ�䣬����֮���ճ�֮ǰ��
	������ҹ�����������,emSwitchModeΪNET_EM_SWITCH_MODE_TIME����Ч*/
	NET_SUN_TIME		stuSunRiseTime;			// �����ճ�ʱ��
	NET_SUN_TIME		stuSunSetTime;			// ��������ʱ��
} NET_VIDEOIN_SWITCH_MODE_INFO;

// ��Ƶ������ɫ����
typedef struct tagNET_VIDEOIN_COLOR_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// �������ͣ���ȡ������ʱ��Ҫ�ƶ�
	int					nBrightness;			// ����0-100
	int					nContrast;				// �Աȶ�0-100
	int					nSaturation;			// ���Ͷ�0-100
	int					nGamma;					// ٤��ֵ0-100
} NET_VIDEOIN_COLOR_INFO;

// ͼ����������
typedef struct tagNET_VIDEOIN_IMAGE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// �������ͣ���ȡ������ʱ��Ҫ�ƶ�
	BOOL				bMirror;				// �Ƿ����澵����
	BOOL				bFlip;					// �Ƿ����淭ת����
	int					nRotate90;				// 0-����ת��1-˳ʱ��90�㣬2-��ʱ��90��
} NET_VIDEOIN_IMAGE_INFO;

// ͼ�����ģʽ
typedef enum tagNET_EM_STABLE_TYPE
{
	NET_EM_STABLE_OFF,				// �ر�
	NET_EM_STABLE_ELEC,				// ���ӷ���
	NET_EM_STABLE_LIGHT,			// ��ѧ����
	NET_EM_STABLE_CONTORL = 4,		// �ؼ�����
} NET_EM_STABLE_TYPE;

// ͼ���������
typedef struct tagNET_VIDEOIN_STABLE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;			// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_STABLE_TYPE	emStableType;		// ��������
} NET_VIDEOIN_STABLE_INFO;

// �Զ���Ȧ����
typedef struct tagNET_VIDEOIN_IRISAUTO_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;		// �������ͣ���ȡ������ʱ��Ҫָ��
	BOOL				bIrisAuto;		//�Ƿ�ʹ���Զ���Ȧ
} NET_VIDEOIN_IRISAUTO_INFO;

// ͼ����ǿ����
typedef struct tagNET_VIDEOIN_IMAGEENHANCEMENT_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// ʹ��
	int					nLevel;				// ͼ����ǿ�ȼ�
}NET_VIDEOIN_IMAGEENHANCEMENT_INFO;

//ͨ���ع���������
typedef struct tagNET_VIDEOIN_EXPOSURE_NORMAL_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_EXPOSURE_MODE	emExposureMode;			// �ع�ģʽ
	int						nAntiFlicker;			// ����˸0-Outdoor  1-50Hz����˸ 2-60Hz����˸
	int						nCompensation;			// �عⲹ��0-100
	int						nGain;					// ����ֵ
	int						nGainMin;				// ��������0-100
	int						nGainMax;				// ��������0-100
	int						nExposureIris;			// ��Ȧֵ��ģʽΪ��Ȧ����ʱ��Ч��0-100
	double					dbExposureValue1;		// �Զ��ع�ʱ�����޻����ֶ��ع��Զ���ʱ��,����Ϊ��λ��ȡֵ0.1ms~80ms
	double					dbExposureValue2;		// �Զ��ع�ʱ������,����Ϊ��λ��ȡֵ0.1ms~80ms���ұ��벻С��"ExposureValue1"ȡֵ
} NET_VIDEOIN_EXPOSURE_NORMAL_INFO;

// �����ع���������
typedef struct tagNET_VIDEOIN_EXPOSURE_OTHER_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	BOOL					bSlowShutter;			// ������ʹ��
	int						nSlowSpeed;				// ���ع��ٶȵȼ�
	int						nSlowAutoExposure;		// ���ع�
	int						nRecoveryTime;			// 0-��ʾ���ָ���������ʾ�ָ���ʱ�䣬��λΪ��
	int						nIrisMin;				// ��Ȧ�������ޣ�SupportIrisRange����Ϊtrueʱ������,0~100 ����Ȧ���������ã���Iris���⣩
	int						nIrisMax;				// ��Ȧ��������,0~100,ȡֵ��С��"IrisMin"��ȡֵ����Ȧ���������ã���Iris���⣩
} NET_VIDEOIN_EXPOSURE_OTHER_INFO;

// �ع������������
typedef struct tagNET_VIDEOIN_EXPOSURE_SHUTTER_INFO
{
	DWORD					dwSize;
	BOOL					bAutoSyncPhase;			// �Զ���λ����ʹ��
	float					fShutter;				// ����ֵ��AutoSyncPhaseΪtrueʱ��Ч������Ϊ��λ��ȡֵ0.1ms~80ms��
													// �ұ��벻С��NET_VIDEOIN_EXPOSURE_NORMAL_INFO�е�"ExposureValue1"��������"ExposureValue2"
	int						nPhase;					// ��λֵ,ȡֵ0~360��
} NET_VIDEOIN_EXPOSURE_SHUTTER_INFO;


// ��������
typedef struct tagNET_VIDEOIN_BACKLIGHT_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_BACK_MODE		emBlackMode;			// ����ģʽ
	NET_EM_BLACKLIGHT_MODE	emBlackLightMode;		// ���ⲹ��ģʽ
	NET_RECT				stuBacklightRegion;     // ���ⲹ������   
	int						nWideDynamicRange;		// ��ֵ̬��emBlackModeΪNET_EM_BACKLIGHT_MODE_WIDEDYNAMICʱ��Ч
	int						nGlareInhibition;		// ǿ������0-100��emBlackModeΪNET_EM_BACKLIGHT_MODE_GLAREINHIBITIONʱ��Ч
} NET_VIDEOIN_BACKLIGHT_INFO;


//��������Ӧ�Աȶ�ǿ�����ã�����ģʽΪ��������Ӧʱ��Ч
typedef struct tagNET_VIDEOIN_INTENSITY_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode;		// ��������Ӧ�Աȶ�ǿ�ȵ���ģʽ
	int							nIntensity;				// SSA�ֶ�����ǿ��0-100, emIntensityModeΪNET_EM_INTENSITY_MANUALʱ��Ч
} NET_VIDEOIN_INTENSITY_INFO;

// ��ƽ������
typedef struct tagNET_VIDEOIN_WHITEBALANCE_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_WHITEBALANCE_TYPE	emWhiteBalanceType;			//��ƽ��ģʽ
	int							nGainRed;					// ��ɫ�������0-100����ƽ��Ϊ"Custom"ģʽ����Ч
	int							nGainBlue;					// ��ɫ�������0-100����ƽ��Ϊ"Custom"ģʽ����Ч
	int							nGainGreen;					// ��ɫ�������0-100����ƽ��Ϊ"Custom"ģʽ����Ч
	int							nColorTemperature;			// ɫ�µȼ�, ��ƽ��Ϊ"CustomColorTemperature"ģʽ����Ч
} NET_VIDEOIN_WHITEBALANCE_INFO;

// ��ҹ�л�ģʽ
typedef enum tagNET_EM_DAYNIGHT_TYPE
{
	NET_EM_DAYNIGHT_COLOR,				// ���ǲ�ɫ
	NET_EM_DAYNIGHT_AUTO,				// ���������Զ��л�
	NET_EM_DAYNIGHT_WHITEBLACK,			// ���Ǻڰ�
} NET_EM_DAYNIGHT_TYPE;

//��ҹģʽ����
typedef struct tagNET_VIDEOIN_DAYNIGHT_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_DAYNIGHT_TYPE		emDayNightType;				// ��ҹ�л�ģʽ
	int							nDayNightSensitivity;		// ��ҹģʽ�л������,��Χ1-3
	int							nDayNightSwitchDelay;		// ��ҹģʽ�л��ӳ�ʱ��,��λ�룬��Χ2-10
} NET_VIDEOIN_DAYNIGHT_INFO;

// ��ҹģʽICR�л���������
typedef struct tagNET_VIDEOIN_DAYNIGHT_ICR_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_ICR_TYPE				emType;						// ICR�л�����
} NET_VIDEOIN_DAYNIGHT_ICR_INFO;

//�ƹ�ģʽ
typedef enum tagNET_EM_LIGHTING_MODE
{
	NET_EM_LIGHTING_UNKNOW,			// δ֪ģʽ
	NET_EM_LIGHTING_MANUAL,			// �ֶ�ģʽ
	NET_EM_LIGHTING_AUTO,			// �Զ�ģʽ
	NET_EM_LIGHTING_OFF,			// �ر�ģʽ
	NET_EM_LIGHTING_ZOOMPRIO,		// ��������ģʽ
	NET_EM_LIGHTING_TIMING,			// ��ʱģʽ����ģʽʱLightingSchedule������Ч	
	NET_EM_LIGHTING_SMARTLIGHT,		// ���ܵƹ�ģʽ(�����ʹ��),�����ģʽѡ��ģʽ��ʹ���¼ӵ�SmartLighting����
} NET_EM_LIGHTING_MODE;

// ���������
typedef struct tagNET_VIDEOIN_LIGHTING_INFO
{
	DWORD						dwSize;
	NET_EM_LIGHTING_MODE		emLightMode;			// �ƹ�ģʽ
	int							nCorrection;			// �ƹⲹ��ֵ����������ʱ��Ч0-4
	int							nSensitive;				// �ƹ�����ȣ���������ʱ��Ч��0-5��Ĭ��Ϊ3
	int							nNearLight;				// ���������0-100
	int							nFarLight;				// Զ�������0-100
} NET_VIDEOIN_LIGHTING_INFO;

// ͸��ģʽ
typedef enum tagNET_EM_DEFOG_MODE
{
	NET_EM_DEFOG_UNKNOW,			// δ֪ģʽ
	NET_EM_DEFOG_OFF,				// �ر�
	NET_EM_DEFOG_AUTO,				// �Զ�
	NET_EM_DEFOG_MANAUL,			// �ֶ�
}NET_EM_DEFOG_MODE;

//������ģʽö��
typedef enum tagNET_EM_INTENSITY_MODE
{
	NET_EM_INTENSITY_MODE_UNKNOW,//δ֪��ʽ
	NET_EM_INTENSITY_MODE_AUTO,  //�Զ�
	NET_EM_INTENSITY_MODE_MANUAL, //�ֶ�
}NET_EM_INTENSITY_MODE;


// ͸������
typedef struct tagNET_VIDEOIN_DEFOG_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_DEFOG_MODE				emDefogMode;				// ͸��ģʽ
	int								nIntensity;					// ǿ��0-100
	NET_EM_INTENSITY_MODE			emIntensityMode;			//������ģʽ
	int								nLightIntensityLevel;		//������ǿ��(0-15)
	BOOL							bCamDefogEnable;			//��ѧȥ��ʹ�� (TRUEʹ�ܣ�FALSEȥʹ��)
} NET_VIDEOIN_DEFOG_INFO;

// �۽�ģʽ����
typedef struct tagNET_VIDEOIN_FOCUSMODE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_FOCUS_MODE				emFocusMode;			// �۽�ģʽ
} NET_VIDEOIN_FOCUSMODE_INFO;

// �۽������
typedef enum tagNET_EM_SENSITIVITY_TYPE
{
	NET_EM_SENSITIVITY_HIGH,				// ��
	NET_EM_SENSITIVITY_DEFAULT,				// Ĭ��
	NET_EM_SENSITIVITY_LOW,					// ��
} NET_EM_SENSITIVITY_TYPE;

// �����۽�����ģʽ
typedef enum tagNET_EM_IRC_TYPE
{
	NET_EM_IRC_DONOT,			// ������
	NET_EM_IRC_DOIT,			// ����
	NET_EM_IRC_AUTO,			// �Զ�����
} NET_EM_IRC_TYPE;

// �۽���Ϣ����
typedef struct tagNET_VIDEOIN_FOCUSVALUE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_SENSITIVITY_TYPE			emSensitivity;			// �۽������
	NET_EM_IRC_TYPE					emIRCorrection;			// �����۽�����
	NET_EM_FOCUS_LIMITSELECT_MODE	emFocusLimitSelectMode;	// �۽�����ѡȡģʽ
	int								nFocusLimit;			// ���˾۽����޽���ֵ,��λ����
	BOOL							bAutoFocusTrace;		// �佹����ʹ��
} NET_VIDEOIN_FOCUSVALUE_INFO;

// �������
typedef struct tagNET_VIDEOIN_SHARPNESS_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_SHARPNESS_MODE			emSharpnessMode;			// ���ģʽ
	int								nSharpness;					// ���ֵ0-100���ֶ�ʱ��Ч
	int								nLevel;						// ������Ƶȼ���0-100��0��ʾ������
} NET_VIDEOIN_SHARPNESS_INFO;

// 3D�����������
typedef enum tagNET_EM_3D_TYPE
{
	NET_EM_3D_UNKONW,		// δ֪
	NET_EM_3D_OFF,			// �ر�
	NET_EM_3D_AUTO,			// �Զ�
} NET_EM_3D_TYPE;

// �߼���������
typedef enum tagNET_EM_ALGORITHM_TYPE
{
	NET_EM_ALGORITHM_UNKNOW,		// δ֪
	NET_EM_ALGORITHM_OFF,			// �ر�
	NET_EM_ALGORITHM_MANUAL,		// �ֶ�
}NET_EM_ALGORITHM_TYPE;

// �߼���������
typedef struct tagNET_DENOISE_ALGORITHM
{
	NET_EM_ALGORITHM_TYPE	emAlgorithmType;		// �߼�����ȼ�,	NET_EM_ALGORITHM_MANUALʱ�����ʱ����Ч
	int						nTnfLevel;				// ʱ��ȼ�
	int						nSnfLevel;				//����ȼ�
	BYTE					bReserved[256];			// �����ֽ�
} NET_DENOISE_ALGORITHM;

// ͨ�ý�������
typedef struct tagNET_VIDEOIN_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	BOOL							b2DEnable;					// 2D����ʹ��
	int								n2DLevel;					// 2D����ȼ�0-100, b2DEnableΪTRUEʱ��Ч
	NET_DENOISE_ALGORITHM			stuAlgorithm;				// �߼���������
} NET_VIDEOIN_DENOISE_INFO;

// 3D��������
typedef struct tagNET_VIDEOIN_3D_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// �������ͣ���ȡ������ʱ��Ҫָ��
	NET_EM_3D_TYPE					em3DType;					// 3D�����������
	int								nAutoLevel;					// 3D����ȼ���em3DTypeΪNET_EM_3D_AUTOʱ��Ч
} NET_VIDEOIN_3D_DENOISE_INFO;

// ץͼģʽ����
typedef struct tagNET_SNAP_MODE
{
    DWORD                           dwSize;
    int                             nMode;                      // 0�Զ�ץͼ��1�ֶ�ץͼ��2�ر�ץͼ
    BOOL                            bDirectStorageMode;         // ֱ��ģʽ��TRUE�򿪣�FALSE�ر�
}NET_SNAP_MODE;

// ��¼���̱���ƻ�(��Ӧ���� CFG_CMD_ENCODEPLAN)��ÿ��ͨ��(�������л�ͨ��)һ�����ýṹ��
typedef struct tagNET_ENCODE_PLAN_INFO
{
	DWORD				dwSize;
	BOOL                bEnable;                        // ͨ���Ƿ���Ҫ����,FALSE:û�д�ͨ��,TRUE:��ͨ������
	unsigned int        nExpectTime;                    // ҵ��Ԥ��ʱ��	 ����,��λ������
	CAPTURE_SIZE		emResolution;                   // ��Ƶ�ֱ���
	unsigned int        nBitRate;                       // ��Ƶ�̶�����ֵ(kbps)
	unsigned int		nPacketSize;					// ������¼�ļ������С(KB)
}NET_ENCODE_PLAN_INFO;

// ������ӵƹ�����(NET_EM_CFG_YUEQING_SUPPLYLIGHTING)
typedef struct tagNET_YUEQING_SUPPLYLIGHTING_INFO
{
	DWORD				dwSize;
	BOOL				bTimeEnable;					// ��ʱ����ʹ��
	BOOL				bManualEnable;					// �ֶ�����ʹ��
	DH_TSECT			stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// ������ʱ���
}NET_YUEQING_SUPPLYLIGHTING_INFO;

// ��ҳ��ȡ��Ϣ��ע��Ϣ�б��������(CLIENT_ScenicSpotGetPointInfos)
typedef struct tagNET_IN_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nChannelID;						// ͨ����
	int					nOffset;						// �ӵڼ�λ��ʼ��ȡ����� 255��
	int					nLimit;							// ��ȡ������Ϣ��ṹ���� 0 ��ʼ�� 
}NET_IN_SCENICSPOT_GETPOINTINFOS_INFO;


typedef struct tagNET_POINT_INFO
{
	DH_POINT	stuMasterPoint;		// ������궨��
	DH_POINT	stuSlavePoint;		// �����(���)�궨��
	BYTE        byReserved[256];	// �����ֶ�
}NET_POINT_INFO;

typedef struct
{
    int                nHorizontalAngle;               // ˮƽ�Ƕ� 
    int                nVerticalAngle;                 // ��ֱ�Ƕ�
    int                nMagnification;                 // �Ŵ���
} POSTION;

typedef struct tagNET_POINT_PAIR_EX
{
    int					nCaliSceneID;           // �궨������ţ�ƴ�Ӻ��ȫ��������Էֳɶ���������б궨
	PTZ_SPACE_UNIT		stuSlaveCenter;			// �궨��һĿʱ�����ת���͵�һĿ�������Ƶĵط������´�ʱ������ĵ�����
	NET_POINT_INFO		stuPoint[16];			// �ڸó����̶�����󣬼�¼������������ص������Ӧ��ϵ 
	int					nEffectiveNumber;		// stuPoint ��Ч����
	BYTE                byReserved[256];		// �����ֶ�
} NET_POINT_PAIR_EX;

// ��Ŀ����궨����
typedef struct tagNET_CALIBRATE_MATRIX_ELEMENT_EX
{
	char                szMasterSN[48];							// ���豸���к�
    char                szSlaveSN[48];							// ���豸���к�
	PTZ_SPACE_UNIT		stuExpectRatio;							// ��������(��ѡ)
	NET_POINT_PAIR_EX	stuPointPairEx[8];						// ��Ŀ���Ӹ��ٱ궨���
	int					nEffectiveNumber;						// stuPointPairEx ��Ч����
	BYTE                byReserved[256];						// �����ֶ�
} NET_CALIBRATE_MATRIX_ELEMENT_EX;

//����ʽ�������궨������չ���� ��Ŀ�����ʹ��(��Ӧ NET_EM_CFG_CALIBRATE_MATRIX ����)
typedef struct tagNET_MULTI_SENSOR_INFO
{
	DWORD							 dwSize;
    DWORD							 nMaxCalibElement;			// ���Ӹ������궨��������Ԫ��������(�û���д)
	DWORD							 nRetCalibElement;			// ���Ӹ������궨��������Ԫ��ʵ�ʸ���(���ǻ�ȡʱ��Ч)
	NET_CALIBRATE_MATRIX_ELEMENT_EX	*pstCaliMatrixElementEx;	// �ڴ����û�����		  
} NET_MULTI_SENSOR_INFO;


typedef struct
{								
    int                nX;								// ��һ��Ԫ�ر�ʾ������x����(0~8191) 
    int                nY;								// �ڶ���Ԫ�ر�ʾ������y����(0~8191)
} POINTCOORDINATE;											

typedef struct
{
	int					nIndex;									// ��Ϣ����
	bool				bEnable;								// ��Ϣ���Ƿ���Ч
	bool				bTitleAttribute;						// ����Ϣ���Ƿ����ӱ���
	POSTION				stuPostion;								// ��̨������Ŵ�������һ��Ԫ��Ϊˮƽ�Ƕȣ�0~3600���ڶ���Ԫ��Ϊ��ֱ�Ƕȣ�-1800~1800��������Ԫ��Ϊ�Ŵ�����0~127��
	POINTCOORDINATE		stuPoint;								// �����λ�ã�ʹ�����������ϵ��ȡֵ��Ϊ0-8191��������Ļ�ϵ�λ�ã�
	char				szTitleName[MAX_COMMON_STRING_64];		// һ����������
	BYTE				byTitleType;							// һ��������������	
	BYTE                byReserved[256];						// �����ֶ�
}POINTINFOS;

// ��ҳ��ȡ��Ϣ��ע��Ϣ�б��������(CLIENT_ScenicSpotGetPointInfos)
typedef struct tagNET_OUT_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nTotal;										// �豸�ܹ����ٸ��������Ϣ
	int					nRetSceneNum;								// ��ǰ��ȡ����������
	POINTINFOS			stuPointInfos[MAX_SCENICSPOT_POINTS_NUM];	// ���鳤�ȵ���limit,���һ���ѯ����С��limit		
}NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO;

// ���þ���㣬ԭ��ŵľ���㽫�ᱻ���� �������(CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_IN_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
	int					nChannel;										// ͨ����
	int					nIndex;											// ��Ϣ����
	bool				bEnable;										// ��Ϣ���Ƿ���Ч
	bool				bTitleAttribute;								// ����Ϣ���Ƿ����ӱ���
	POSTION				stuPosition;									// ��̨������Ŵ���
	POINTCOORDINATE		stuPoint;										// �����λ��
	char				szTitleName[MAX_COMMON_STRING_64];				// һ����������
	BYTE				byTitleType;									// һ��������������
}NET_IN_SCENICSPOT_SETPOINTINFO_INFO;

// ���þ���㣬ԭ��ŵľ���㽫�ᱻ���� �������(CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_OUT_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
}NET_OUT_SCENICSPOT_SETPOINTINFO_INFO;

// ��ȡ�����֧�ֵ�����(CLIENT_ScenicSpotGetCaps �������) 
typedef struct tagNET_IN_SCENICSPOT_GETCAPS_INFO
{
	DWORD				dwSize;
	int					nChannel;					// ͨ����
}NET_IN_SCENICSPOT_GETCAPS_INFO;

// ������
typedef struct tagNET_SCENICSPOT_CAPS_INFO
{
	BOOL						bEnable;			// �Ƿ�֧�־���㹦��
	unsigned int				nTotalNum;			// �ܹ����֧�ֶ��ٸ������
	unsigned int				nRegionNum;			// ���������֧�ֶ��ٸ������
	BYTE                		byReserved[256];	// �����ֶ�
}NET_SCENICSPOT_CAPS_INFO;

// ��ȡ�����֧�ֵ�����(CLIENT_ScenicSpotGetCaps �������)
typedef struct tagNET_OUT_SCENICSPOT_GETCAPS_INFO
{
	DWORD						dwSize;
	NET_SCENICSPOT_CAPS_INFO	stuCaps;			// ��������Ϣ
}NET_OUT_SCENICSPOT_GETCAPS_INFO;


// ��������Ч��
typedef enum tagEM_ALARM_SOUND_EFFECT
{
    EM_ALARM_SOUND_EFFECT_UNKNOWN,                      // δ֪����Ч
    EM_ALARM_SOUND_EFFECT_MUTE,                         // ����
    EM_ALARM_SOUND_EFFECT_NOTICE,                       // ��Ϊ����ı�����, ����ʾ����
    EM_ALARM_SOUND_EFFECT_ALERT,                        // ���������ı�����, �𵽾�ʾ����
}EM_ALARM_SOUND_EFFECT;

// ����������������
typedef struct tagNET_ALARM_SOUND_INFO
{
    DWORD				dwSize;
    EM_ALARM_SOUND_EFFECT emSoundEffect;                // ����Ч��
}NET_ALARM_SOUND_INFO;

// ˫Ŀ�궨�������
typedef struct tagNET_STEREO_CALIBRATE_INFO
{
	DWORD				dwSize;
	int					nCameraHeight;					// �����ϴα궨�߶ȣ���λcm
	float				fCameraAngle;					// �����ϴα궨�Ƕȣ���λ�Ƕ�
} NET_STEREO_CALIBRATE_INFO;

// ��������ģʽ
typedef enum tagEM_LINK_MODE
{
    EM_LINK_MODE_UNKNOWN,                                       // δ֪ģʽ
    EM_LINK_MODE_AUTO,                                          // �Զ�ѡ����ʵ�ģʽ
    EM_LINK_MODE_ADHOC,                                         // ��һ���������������Ӧ��ģʽ, һȺ����������������翨, �����໥����, ��Դ����, ����͸��Access Point
    EM_LINK_MODE_INFRASTRUCTURE,                                // ��һ���������������߾�������ܹ���Ӧ��ģʽ, ����������Դ����, ��Ӧ����͸��Access Point��
}EM_LINK_MODE;

// AP���ܷ�ʽ
typedef enum tagEM_AP_DATA_ENCRYPT
{
    EM_AP_DATA_ENCRYPT_UNKNOWN,                           // UnKnown
    EM_AP_DATA_ENCRYPT_NONE,                              // NONE
    EM_AP_DATA_ENCRYPT_AUTO,                              // AUTO
    EM_AP_DATA_ENCRYPT_SHARED,                            // SHARED
    EM_AP_DATA_ENCRYPT_OPEN,                              // OPEN
    EM_AP_DATA_ENCRYPT_TKIP,                              // TKIP
    EM_AP_DATA_ENCRYPT_AES,                               // AES
} EM_AP_DATA_ENCRYPT;

// ����ģʽ
typedef enum tagEM_AP_POWER_MODE
{
    EM_AP_POWER_MODE_UNKNOWN,                             // UnKnown
    EM_AP_POWER_MODE_LOW,                                 // Low
    EM_AP_POWER_MODE_MIDDLE,                              // Middle
    EM_AP_POWER_MODE_HIGH,                                // High
}EM_AP_POWER_MODE;

// DHCP ����
typedef struct tagNET_DHCP_INFO
{
    char                    szStartIP[NET_IPADDRSTR_LEN];       // �������ʼIP
    char                    szStopIP[NET_IPADDRSTR_LEN];        // ����Ľ���IP
    int                     nLeaseTime;                         // ����ʱ�� ��λ: ����
    BYTE                    byReserved[512];                    // �����ֶ�
}NET_DHCP_INFO;

// WEP��֤����
typedef struct tagNET_WEP_INFO
{
    int                     nKeyID;                             // ��Կ����, ȡֵ0~3
    char                    szKeys[MAX_WEP_KEY_NUM][MAX_COMMON_STRING_64];// ��������
    BYTE                    byReserved[256];                    // �����ֶ�
}NET_WEP_INFO;


// WPA/WPA2 PSK����
typedef struct tagNET_WPA_PSK_INFO
{
    char                    szPassword[MAX_COMMON_STRING_64];  // ����
    BYTE                    byReserved[256];                   // �����ֶ�
}NET_WPA_PSK_INFO;

// EAP����
typedef enum tagEM_EAP_METHOD
{
    EM_EAP_METHOD_UNKNOWN,                                      // UnKnown
    EM_EAP_METHOD_PEAP,                                         // PEAP
    EM_EAP_METHOD_TLS,                                          // TLS
    EM_EAP_METHOD_TTLS,                                         // TTLS
} EM_EAP_METHOD;

// EAP�����֤����
typedef enum tagEM_EAP_AUTH_TYPE
{
    EM_EAP_AUTH_TYPE_UNKNOWN,                                   // UnKnown
    EM_EAP_AUTH_TYPE_NONE,                                      // NONE
    EM_EAP_AUTH_TYPE_PAP,                                       // PAP
    EM_EAP_AUTH_TYPE_MSCHAP,                                    // MSCHAP
    EM_EAP_AUTH_TYPE_MSCHAPV2,                                  // MSCHAPV2
    EM_EAP_AUTH_TYPE_GTC,                                       // GTC
} EM_EAP_AUTH_TYPE;

// AP��֤��ʽ
typedef enum tagEM_AP_AUTHENTICATION
{
    EM_AP_AUTHENTICATION_UNKNOWN,                         // UnKnown
    EM_AP_AUTHENTICATION_OPEN,                            // OPEN
    EM_AP_AUTHENTICATION_WEP,                             // WEP
    EM_AP_AUTHENTICATION_WPAPSK,                          // WPA PSK
    EM_AP_AUTHENTICATION_WPA2PSK,                         // WPA2 PSK
    EM_AP_AUTHENTICATION_WPA,                             // WPA
    EM_AP_AUTHENTICATION_WPA2,                            // WPA2
} EM_AP_AUTHENTICATION;

// WPA/WPA2����
typedef struct tagNET_EAP_INFO
{
    EM_EAP_METHOD           emMethod;                           // EAP����
    EM_EAP_AUTH_TYPE        emAuthType;                         // EAP�����֤����
    char                    szIdentity[MAX_COMMON_STRING_64];   // ���
    char                    szAnonymousID[MAX_COMMON_STRING_64];// �������
    char                    szPassword[MAX_COMMON_STRING_64];   // ����
    char                    szCaCert[MAX_COMMON_STRING_512];    // CA֤��
    char                    szUserCert[MAX_COMMON_STRING_512];  // �û�֤�� 
    BYTE                    byReserved[256];                    // �����ֶ�
}NET_EAP_INFO;

// WIFI ���ӷ�ʽ
typedef enum tagEM_WIFI_CONNECT_TYPE
{
    EM_WIFI_CONNECT_TYPE_UNKNOWN,                               // δ֪
    EM_WIFI_CONNECT_TYPE_PUSH_BUTTON,                           // ��ť��ʽ
    EM_WIFI_CONNECT_TYPE_PIN_ENROLLEE,                          // PIN �뷽ʽ
    EM_WIFI_CONNECT_TYPE_PIN_REG,                               // PIN REG��ʽ Ŀǰ�ݲ�֧��
}EM_WIFI_CONNECT_TYPE;

// WIFI ��ȫ��������
typedef struct tagNET_WPS_INFO
{
    EM_WIFI_CONNECT_TYPE   emConnType;                          // ���ӷ�ʽ
    char                   szPIN[MAX_COMMON_STRING_32];         // PIN��, �����ӷ�ʽΪPIN�뷽ʽʱ��Ҫ��д
    BYTE                   byReserved[256];                    // �����ֶ�
}NET_WPS_INFO;

// ��ַ�����б�
typedef struct tagNET_FILTER_ADDRESS_LIST
{
    BOOL                    bEffective;                         // ���б�����Ч�� true��Ч��false��Ч
    char                    szMAC[DH_MACADDR_LEN];              // �豸MAC��ַ
    char                    szDescribeText[DH_COMMON_STRING_256]; // �Ը�MAC��������Ϣ    
    BYTE                    byReserved[256];                    // �����ֶ�
}NET_FILTER_ADDRESS_LIST;

// ��ַ�б���˲���
typedef enum tagEM_ADDRLIST_FILTER_POLICY
{
    EM_ADDRLIST_FILTER_POLICY_UNKNOWN,                          // δ֪
    EM_ADDRLIST_FILTER_POLICY_WHITE,                            // "white" : �����б��е���Ч��ַ�豸�����ȵ㣬��������
    EM_ADDRLIST_FILTER_POLICY_BLACK,                            // "black" : ��ֹ�б��е���Ч��ַ�豸�����ȵ㣬��������
}EM_ADDRLIST_FILTER_POLICY;

// AccessPoint �����������
typedef struct tagNET_AP_FILTER
{
    BOOL                    bEnable;                            // �Ƿ�����˹���
    int                     nMaxAccessNum;                      // ���Wifi�豸���Ӹ���
    EM_ADDRLIST_FILTER_POLICY emPolicy;                         // ���˲���
    NET_FILTER_ADDRESS_LIST *pstuAddrList;                      // ��ַ�����б����û������ڴ���ͷ�                     
    int                     nMaxListNum;                        // ��ַ������
    int                     nRetListNum;                        // ���صĵ�ַ����
    BYTE                    byReserved[256];                    // �����ֶ�
}NET_AP_FILTER;

//Accesspoint ����ģʽ
typedef enum tagEM_WORKPATTERN
{
    EM_WORKPATTERN_UNKNOWN,                          // δ֪
    EM_WORKPATTERN_2_4G,                             // Ĭ��Ϊ2.4G����ģʽ������
    EM_WORKPATTERN_5G,                               // 5Gģʽ������
}EM_WORKPATTERN;

// AP ����ģʽ����
typedef struct tagNET_AP_WORKPATTERN
{
    EM_WORKPATTERN          emWorkPatternType;                  // ����ģʽ:2.4G/5G
    BOOL                    bEnable;                            // WIFI����ʹ�ܿ���, TRUE��, FALSE�ر�
    BOOL                    bHideSSID;                          // �Ƿ�����SSID, TRUE ����, FALSE ��ʾ
    char                    szSSID[DH_COMMON_STRING_32];        // ��������(SSID)
    EM_LINK_MODE            emLinkMode;                         // ��������ģʽ
    int                     nPriority;                          // ���ȼ� (��Χ 1-32)
    int                     nChannel;                           // �ŵ��� (��Χ 1-13)
    int                     nChannelBandwidth;                  // �ŵ����� ��λ: M
    EM_AP_AUTHENTICATION    emAuthentication;                   // ��֤��ʽ
    EM_AP_DATA_ENCRYPT      emDataEncryption;                   // ���ݼ��ܷ�ʽ
    EM_AP_POWER_MODE        emPowerMode;                        // ����ģʽ
    BOOL                    bDHCPEnable;                        // �Ƿ���DHCP��ʽ����IP��ַ
    NET_DHCP_INFO           stuDHCP;                            // DHCP��ϸ������Ϣ
    char                    szIPAddresss[NET_IPADDRSTR_LEN];    // IP��ַ
    char                    szSubnetMask[MAX_COMMON_STRING_16]; // ��������
    char                    szDefaultGateway[MAX_COMMON_STRING_16]; // Ĭ������
    NET_WEP_INFO            stuWEP;                             // WEP��֤����
    NET_WPA_PSK_INFO        stuWPAPSK;                          // WPA/WPA2 PSK����
    NET_EAP_INFO            stuEAP;                             // WPA/WPA2 ����
    NET_WPS_INFO            stuWPS;                             // WPS ��ȫ��������
    NET_AP_FILTER           stuFilter;                          // �����������
    BYTE                    byReserved[1024];                   // �����ֶ�
}NET_AP_WORKPATTERN;

// �ȵ㹦�ܵ�����������
typedef enum tagEM_ACCESSPOINT_NAME
{
    EM_ACCESSPOINT_NAME_UNKNOWN,                          // δ֪
    EM_ACCESSPOINT_NAME_ETH2,                             // "eth2" : ǰ��ʹ�õ���AP������
    EM_ACCESSPOINT_NAME_WALN0,                            // "wlan0" : �洢ʹ�õ���AP������
    EM_ACCESSPOINT_NAME_APRA0,                            // "apra0" :  �ṩӲAP���ܵ�������
}EM_ACCESSPOINT_NAME;

// AccessPoint ������Ϣ
typedef struct tagNET_ACCESSPOINT_INFO
{
    EM_ACCESSPOINT_NAME     emAccessPointName;                  // �ṩ�ȵ㹦�ܵ�����������
    int                     nValidPatternNum;                   // ��Ч����ģʽ����
    NET_AP_WORKPATTERN      stuWorkPattern[MAX_WORKPATTERN_NUM];// ����ģʽ����:2.4G(Ĭ��)/5G
    BYTE                    byReserved[1024];                   // �����ֶ�
}NET_ACCESSPOINT_INFO;

// WIFI������������ (�ȵ㹦��)
typedef struct tagNET_NETAPP_ACCESSPOINT
{
    DWORD                   dwSize;
    int                     nValidAPNum;                        // AccessPoints ��Ч����
    NET_ACCESSPOINT_INFO    stuAccessPoints[NET_MAX_AP_NUM];    // AP ������Ϣ
}NET_NETAPP_ACCESSPOINT;

// ��·��¼��Ϣ
typedef struct tagNET_DEV_CAR_COACH_INFO
{
    DWORD                   dwSize;                         
    char                    szCarNo[MAX_CARNO_LEN];              // ������
    char                    szCoachNo[MAX_COACHNO_LEN];          // �����
}NET_DEV_CAR_COACH_INFO;

// ץͼ�������ʽ���ո�ʽ
typedef enum tagEM_MEDIA_GLOBAL_SNAP_FORMAT_AS
{
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_UNKNOWN,
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_MAIN_FORMAT,                  // ����������
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA_FORMAT,				 // ���ո�����1
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA2_FORMAT,				 // ���ո�����2
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA3_FORMAT,				 // ���ո�����3
}EM_MEDIA_GLOBAL_SNAP_FORMAT_AS;

// ý�����ȫ������
typedef struct tagNET_MEDIA_GLOBAL_INFO
{
	DWORD               dwSize;
	int                 nPacketType;                          // 0:��ʱ��,1������С
	BYTE                byPacketLength;                       // ¼����ʱ�䳤��,��λ���ӡ�1-255
	BYTE                byAlign[3];                           // ����
	DWORD				dwPacketSize;                   	  // ¼�����ļ�����,��λKB
	BOOL				bLogRecord;                           // �Ƿ��¼¼����־
	BOOL				bLogEncode;                           // �Ƿ��¼�����쳣��־
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS  emSnapFormatAs;           // ץͼ�������ʽ���ո�ʽ���豸��֧�ֶ�������ץͼ���ֱ��ʸ�ʽʱ��ץͼ��ʽ���ݲ��ո�ʽ����
}NET_MEDIA_GLOBAL_INFO;

// NAS Protocol ����
typedef enum __EM_NAS_PROTOCOL
{
	NAS_PROTOCOL_UNKNOW = 0,
	NAS_PROTOCOL_FTP,		// FTP
	NAS_PROTOCOL_SMB,		// SMB
	NAS_PROTOCOL_NFS,		// NFS
	NAS_PROTOCOL_ISCSI,		// ISCSI
	NAS_PROTOCOL_CLOUD,		// CLOUD
}EM_NAS_PROTOCOL;

// NAS ������Ϣ
typedef struct tagNET_NAS_INFO
{
	DWORD               dwSize;
    BOOL                bEnable;										// �Ƿ�����	
	char				szName[MAX_COMMON_STRING_128];					// ����
    char                szHostIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];			// IP��ַ��������
    WORD                wHostPort;										// �����˿�
	char				reserved[2];									// �����ֶ�
    char                szDirName[DH_FTP_MAX_PATH];						// FTPĿ¼·��
    char                szUserName[DH_FTP_USERNAME_LEN];				// �û���
    char                szPassword[DH_FTP_PASSWORD_LEN];				// ����    
    int                 nInterval;										// �����ļ�ʱ����(1~600),��λ��   
	BOOL				bAnonymity;										// ����ʹ��,����ʹ�ܣ�ProtocolΪFTPʱ��Ч��
	EM_NAS_PROTOCOL     emProtocol;										// Э������	
}NET_NAS_INFO;

// PPPoE������Ϣ
typedef struct tagNET_PPPOE_INFO
{
	DWORD               dwSize; 
	BOOL				bEnable;								// �Ƿ�ʹ��	
    char                szUserName[MAX_USER_NAME_LEN];			// �û���
	char				szPasswd[MAX_PWD_LEN];					// ����	
}NET_PPPOE_INFO;

// Email������Ϣ
typedef struct tagNET_EMAIL_INFO
{
	DWORD               dwSize;		
	BOOL                bEnable;									// ʹ��0:false,    1:true
	char                szMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];		// �ʼ���������ַ(IP��������)   
    WORD                wMailPort;									// �ʼ��������˿�   
	char				reserved[2];								// �����ֶ�
    char                szSenderAddr[DH_MAX_MAIL_ADDR_LEN];			// ���͵�ַ
    char                szUserName[DH_MAX_MAIL_NAME_LEN];			// �û���
    char                szUserPsw[DH_MAX_MAIL_NAME_LEN];			// �û�����
    char                szDestAddr[DH_MAX_MAIL_ADDR_LEN];			// Ŀ�ĵ�ַ    
    char                szSubject[DH_MAX_MAIL_SUBJECT_LEN];			// ����
	char				*szReceivers[DH_MAX_MAIL_ADDR_LEN];			// �ռ����б��û������ڴ� 
	unsigned int		nReceiversNum;								// �ռ�������
	unsigned int		nReceiversNumRet;							// �豸���ص��ռ�������    
    BOOL                bSSLEnable;									// SSLʹ��
	BOOL				bTLSEnable;									// TLSʹ��
    WORD                wSendInterval;								// ����ʱ����,[0,3600]��
    BYTE                bAnonymous;									// ����ѡ��[0,1], 0��ʾFALSE,1��ʾTRUE.
    BYTE                bAttachEnable;								// ����ʹ��[0,1], 0��ʾFALSE,1��ʾTRUE.
	BOOL				bHealthReport;								// �����ʼ�ʹ��
	int					nHealthReportInterval;						// �����ʼ����   
}NET_EMAIL_INFO;

// DDNS������Ϣ
typedef struct tagNET_DDNS_INFO
{
	DWORD                dwSize;
    DWORD                dwDdnsServerNum; // DDNS ����������
    DH_DDNS_SERVER_CFG   stuDdnsServer[DH_MAX_DDNS_NUM];
}NET_DDNS_INFO;

// Э�����������Ϣ�б�
typedef struct tagNET_PROTOCOLS_MANAGER
{
	char				szDesc[DH_COMMON_STRING_128];       // Э������,��:�̸�̽����_DI_SMK
	BOOL				bEnable;							// ʹ�ܱ�־
	char				szProtocol[DH_COMMON_STRING_128];   // Э������,��:DI_SMK
	char				szShowType[DH_COMMON_STRING_128];	// Э������,��:SmokingSensor
	BYTE				byReserved[256];					// �����ֽ�
}NET_PROTOCOLS_MANAGER;

// Э�����������Ϣ
typedef struct tagNET_SCADA_PROTOCOLS_MANAGER
{
	DWORD					dwSize;
	NET_PROTOCOLS_MANAGER*	pstProtocolsManager;		     // Э�����������Ϣ
	int						nProtocolsManagerNum;		     // Э�����������Ϣ����
	int						nRetProtocolsManagerNum;		 // ʵ�ʷ��ص�Э�����������Ϣ����
															 // �����һ�λ�ȡ����Э���������ʱ��nRetProtocolsManagerNum����nProtocolsManagerNum
															 // ��ô����һ�λ�ȡ����Э���������ʱ��nProtocolsManagerNum��ֵ����ȡnRetProtocolsManagerNum
}NET_SCADA_PROTOCOLS_MANAGER;

// �豸��Ϣ�����б�
typedef struct tagNET_DEVICEIDSETS
{
	char			  szDevName[DH_COMMON_STRING_32];		// �豸����
	char			  szDevType[DH_COMMON_STRING_32];		// �豸����
	char			  szNewDeviceId[DH_COMMON_STRING_32];   // �û������ʲ�����,szNewDeviceIdʵ�ʴ�СҪ��szOldDeviceId��ʵ�ʴ�С��ͬ
	char			  szOldDeviceId[DH_COMMON_STRING_32];	// Ĭ���ʲ�����
	BYTE			  byReserved[128];						// �����ֽ�
}NET_DEVICEIDSETS;

// �豸��Ϣ����
typedef struct tagNET_SCADA_DEVICEINFO_CFG
{
	DWORD			    dwSize;
	char			    szCity[DH_COMMON_STRING_32];         // ���ڳ���
	char			    szProvince[DH_COMMON_STRING_32];     // ����ʡ��
	int				    nStation;							 // ��վ����
	NET_DEVICEIDSETS*	pstDeviceIdSets;					 // �����豸��Ϣ
	int					nDeviceIdSetsNum;					 // �����豸����
	int					nRetDeviceIdSetsNum;				 // ���صĽ����豸����
}NET_SCADA_DEVICEINFO_CFG;
//��·��VPN����
typedef enum tagNET_EM_LINK_LAYER_VPN_TYPE
{
	NET_EM_TYPE_UNKNOWN = 0,    // δ֪����
	NET_EM_TYPE_PPTP,           // PPTP���͵���·��VPN
	NET_EM_TYPE_L2TP,		    // L2TP���͵���·��VPN
}NET_EM_LINK_LAYER_VPN_TYPE;

//��·��VPN�����б�
typedef struct tagNET_NETAPP_LINK_LAYER_VPN
{
	char						szName[MAX_LINK_NAME_LEN];				// ��������
	NET_EM_LINK_LAYER_VPN_TYPE  emLinkLayerVPNType;						// ��·��VPN����
	BOOL						bEnable;								// ʹ�ܿ���
	char						szAddress[MAX_SERVER_ADDRESS_LEN];				// ������IP
	char						szUserName[MAX_USER_NAME_LEN];			// �û���
	char						szPassword[MAX_PWD_LEN];				// ����
	BYTE						byReserved[1024];						// �����ֽ�
}NET_NETAPP_LINK_LAYER_VPN;

//��·��VPN����
typedef struct tagNET_NETAPP_LINK_LAYER_VPN_CFG
{
	DWORD			            dwSize;
	int							nRetLinkLayerVPNNum;					 //���ص���·��VPN���ø���
	NET_NETAPP_LINK_LAYER_VPN   stLinkLayerVPN[LINK_LAYER_VPN_NUM];   //��·��VPN��������
}NET_NETAPP_LINK_LAYER_VPN_CFG;

// �й�����ƽ̨��������
typedef struct tagNET_VSP_CHINA_TOWER
{
	DWORD			dwSize;
	BOOL			bEnable;                              // ����ʹ��,TRUEΪ����,FALSEΪ�ر�
	char			szServerIP[MAX_SERVER_IP_LEN];		  // ������IP
	int				nServerPort;						  // �������˿�,ȡֵ��Χ0~65535
	int				nLoginInterval;						  // ע��ʱ����,��λΪ��,ȡֵ��Χ60~180
}NET_VSP_CHINA_TOWER;

// ��Ƶ�Խ��绰ͨ������(��ӦNET_EM_CFG_VTH_PASSWORD)
typedef struct tagNET_CFG_VTH_PASSWORD_INFO
{
	DWORD		   dwSize;
	char		   szUser[8];					            // �û����룬����Ϊ6λ������
}NET_CFG_VTH_PASSWORD_INFO;

// sipע���������Ϣ
typedef struct tagNET_CFG_SIPSERVER_INFO
{
    DWORD                   dwSize;                 
    char                    szAccoutName[MAX_COMMON_STRING_64];         // �˻�����
    char                    szAddres[DH_MAX_IPADDR_EX_LEN];             // sip��������ַ
    int                     nPort;                                      // sip�������˿ں�
    char                    szProxyAdress[DH_MAX_IPADDR_EX_LEN];        // �����������ַ
    char                    szProxyID[MAX_COMMON_STRING_64];            // ���������ID
    int                     nProxyPort;                                 // ����������˿ں�
    char                    szUserID[MAX_COMMON_STRING_64];             // �û�ID��һ���ǵ绰����
    int                     nUserType;                                  // �û����͡�0:SIP�ͻ���,2:�ſڻ���������,3:VTNC��������
    char                    szAuthID[MAX_USER_NAME_LEN];                // ��ݼ���ID
    char                    szAuthPassword[MAX_PWD_LEN];                // ��ݼ�������
    char                    szSTUNServer[DH_MAX_IPADDR_EX_LEN];         // UDP���ݱ��򵥴�Խ�����ַת����������
    char                    szRegisterRealm[MAX_COMMON_STRING_64];      // ע����
    int                     nRegExpiration;                             // ע����ʱ�䣬��λ����
    int                     nSipPort;                                   // ����Sip�˿�
    int                     nRTPPort;                                   // ����RTP�˿�
    BOOL                    bUnregisterOnReboot;                        // ����ɾ��ע����Ϣʹ��
    char                    szDefaultCallNumber[MAX_COMMON_STRING_64];  // Ĭ�Ϻ�к���
    UINT                    nVideoStreamType;                           // ��Ƶ��������������,0����������1��������1��2��������2��3��������3��
    UINT                    nAudioStreamType;                           // ��Ƶ��������������,0����������1��������1��2��������2��3��������3��
    BOOL                    bRouteEnable;                               // �Ƿ���Sip��·�ɹ���
    int                     nRouteCount;                                // ·��������
    char                    szRouteAddress[DH_MAX_IPADDR_EX_LEN][MAX_ROUTE_NUM]; // ·�ɵ�ַ
    char                    szSIPServerLoginUserName[MAX_USER_NAME_LEN];// ��½VTNC���û���
    char                    szSIPServerLoginPWD[MAX_PWD_LEN];           // ��¼VTNC������
    BOOL                    bMainVTO;                                   // �Ƿ��Ǳ��÷�����ʹ��
    char                    szRedundancyServer[DH_MAX_IPADDR_EX_LEN];   // ����sip��������ַ
    char                    szRedundancyUserName[MAX_USER_NAME_LEN];    // ���÷�������½�û���
    char                    szRedundancyPassword[MAX_PWD_LEN];          // ���÷�������½����
    char                    szAnalogNumberStart[MAX_COMMON_STRING_64];  // ģ��ϵͳ��֧�ֵ�ģ�����ڻ���ʼ����
    char                    szAnalogNumberEnd[MAX_COMMON_STRING_64];    // ģ��ϵͳ��֧�ֵ�ģ�����ڻ���������
	BOOL					bUserEnable;								// ע��ʹ��
}NET_CFG_SIPSERVER_INFO; 

// ��ͷǰ�ڵ�������(��ӦNET_EM_CFG_AELENSMASK)
typedef struct tagNET_CFG_AELENSMASK_INFO
{
	DWORD          dwSize;
	BOOL           bEnable;                       // ʹ����(trueʱ��֧���ڵ��ǵĿ��͹ز���)
	char           szName[MAX_COMMON_STRING_128]; // �Զ�������
	BOOL           bStatus;                       // ����״̬true:��ʾ���ڵ���false:�ڵ�����ס��ͷ
}NET_CFG_AELENSMASK_INFO;

//��������������
typedef struct tagNET_CFG_SINGLE_ULTRASONIC
{
	BOOL      bEnable;              //�Ƿ�������ʹ��
	UINT      nFreq;                //������̽ͷƵ�ʣ���λhz
	int       nBurst;               //̽��һ�η������������
	int       nGain;                //������̽ͷ���淶Χ[0,100]
	int       nDriveCurrent;        //������̽ͷ������������λmA
	int       nMinValidDistance;    //�������ź���Сֵ��λcm
	int       nMaxValidDistance;    //�������ź����ֵ��λcm����ʾ���˴���������С����С������
	int       nMinVaildSignalIntensity;   //��С������ǿ�� ����С�����֮����ź���Ч
	int       nMaxVaildSignalIntensity;   //�������ǿ��
	BYTE      byReserved[512];      //�����ֽ�
}NET_CFG_SINGLE_ULTRASONIC;

//��������Ϣ
typedef struct tagNET_CFG_ULTRASONIC_INFO
{
	DWORD                      dwSize;
	int                        nMaxCount;         //����������ø���
	int                        nRetCount;         //���صĳ��������ø���
	NET_CFG_SINGLE_ULTRASONIC  *pstuULTRASONIC;   //������������Ϣ�����û������ͷ�
}NET_CFG_ULTRASONIC_INFO;

// �Ž���ԤǷ������
typedef struct tagNET_CFG_ACCESS_DELAYSTRATEGY
{
    DWORD                   dwSize;
    BOOL                    bEnable;                                    // �Ƿ�����
    int                     nPreArrearsTerm;                            // ԤǷ�����ޣ���λ����
    int                     nArrearsTerm;                               // Ƿ�����ޣ���λ����
}NET_CFG_ACCESS_DELAYSTRATEGY;

// ����������
typedef enum tagNET_EM_REGISTAR_SERVER_TYPE
{
    NET_EM_REGISTAR_SERVER_TYPE_UNKNOWN,
    NET_EM_REGISTAR_SERVER_TYPE_VTO,
    NET_EM_REGISTAR_SERVER_TYPE_H500,
    NET_EM_REGISTAR_SERVER_TYPE_VTNC,
    NET_EM_REGISTAR_SERVER_TYPE_ZYCOO,
    NET_EM_REGISTAR_SERVER_TYPE_THIRDPARTY,
    NET_EM_REGISTAR_SERVER_TYPE_3CXSYSTEM,
    NET_EM_REGISTAR_SERVER_TYPE_ASTERISK,
}NET_EM_REGISTAR_SERVER_TYPE;

// ע�������������Ϣ
typedef struct tagNET_CFG_REGISTAR_INFO
{
    DWORD                   dwSize;
    char                    szRegistarName[MAX_COMMON_STRING_64];    // ע����������ƣ�Ψһ
    NET_EM_REGISTAR_SERVER_TYPE emServerType;                        // ע�����������
    BOOL                    bRegistarEnable;                         // �Ƿ�ע��
    char                    szAddress[DH_MAX_IPADDR_EX_LEN];         // ע���ַ
    int                     nPort;                                   // ע��˿�
    char                    szPassword[MAX_COMMON_STRING_64];        // ע������
}NET_CFG_REGISTAR_INFO;


// ������¼������ʱ���
typedef struct tagNET_CFG_RECORDEXTRA_INFO
{
	DWORD					dwSize;
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];   // ��һάǰ7��Ԫ�ض�Ӧÿ��7�죬��8��Ԫ�ض�Ӧ�ڼ��գ�ÿ�����6��ʱ���
}NET_CFG_RECORDEXTRA_INFO;

// �Զ�������ʱ���
typedef struct tagNET_CFG_ARMSCHEDULE_INFO
{
   DWORD					dwSize;
   BOOL                     bEnable;                                               // ����ʹ��
   DH_TSECT                 stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];   // ��һάǰ7��Ԫ�ض�Ӧÿ��7�죬��8��Ԫ�ض�Ӧ�ڼ��գ�ÿ�����6��ʱ���
}NET_CFG_ARMSCHEDULE_INFO;

// ��Ƶ�������
typedef struct tagNET_PROJECT_TASK
{
	BOOL							bEnable;									// �����Ƿ�ʹ��
	char							szTaskName[MAX_PATH];						// ��������Ansi����
	DH_TSECT                		stuTimeSection[DH_N_WEEKS][DH_N_REC_TSECT]; // ����ʱ���
	BOOL                            bIsCycle;                                   // �����Ƿ�ѭ��,TRUE��ʾѭ��,FALSE��ʾ��ѭ��
	BYTE      						byReserved[512];      						// �����ֽ�
}NET_PROJECT_TASK;

// ��Ƶ��ϼƻ�����
typedef struct tagNET_VIDEODIAGNOSIS_PROJECT_INFO
{
	DWORD					dwSize;	
	char					szProjectName[MAX_PATH];		// �ƻ�����
	int						nTotalTaskNum;					// �����߷��������б����, ������������ȡ
	int						nReturnTaskNum;					// ����ʵ�������б����
	NET_PROJECT_TASK*		pstProjectTasks;				// �����б� , �����߷����ڴ�nTotalTaskNum��
} NET_VIDEODIAGNOSIS_PROJECT_INFO;

// ʱ�����Ϣ
typedef struct tagNET_CFG_TIME_SCHEDULE
{
	BOOL                    bEnableHoliday;                                                 // �Ƿ�֧�ֽڼ������ã�Ĭ��Ϊ��֧�֣����ǻ�ȡ���ú󷵻�ΪTRUE����Ҫʹ�ܼ�������
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];            // ��һάǰ7��Ԫ�ض�Ӧÿ��7�죬��8��Ԫ�ض�Ӧ�ڼ��գ�ÿ�����6��ʱ���
} NET_CFG_TIME_SCHEDULE;

// �¼��������ݽṹ��
typedef struct tagNET_CFG_EVENT_TITLE
{
	char					szText[CFG_MAX_CHANNELNAME_LEN];
	DH_POINT				stuPoint;						// �������Ͻ�����, ����0-8191�������ϵ
	DH_SIZE     			stuSize;						// ����Ŀ�Ⱥ͸߶�,����0-8191�������ϵ��ĳ���������Ϊ0��ʾ������������Ӧ���
	NET_COLOR_RGBA			stuFrontColor;					// ǰ����ɫ
	NET_COLOR_RGBA			stuBackColor;					// ������ɫ
} NET_CFG_EVENT_TITLE;

// �ʼ���������
typedef enum tagNET_CFG_ATTACHMENT_TYPE
{
	NET_ATTACHMENT_TYPE_PIC,							// ͼƬ����
	NET_ATTACHMENT_TYPE_VIDEO,							// ��Ƶ����
	NET_ATTACHMENT_TYPE_NUM,							// ������������
} NET_CFG_ATTACHMENT_TYPE;
// �ʼ���ϸ����
typedef struct tagNET_CFG_MAIL_DETAIL
{
	NET_CFG_ATTACHMENT_TYPE		emAttachType;                 // ��������
	int							nMaxSize;                     // �ļ���С���ޣ���λkB
	int							nMaxTimeLength;               // ���¼��ʱ�䳤�ȣ���λ�룬��video��Ч
}NET_CFG_MAIL_DETAIL;

// ��Ѳ��������
typedef struct tagNET_CFG_TOURLINK
{
	BOOL					bEnable;									// ��Ѳʹ��
	DH_SPLIT_MODE   	    emSplitMode;								// ��Ѳʱ�ķָ�ģʽ
	int						nChannels[CFG_MAX_VIDEO_CHANNEL_NUM];		// ��Ѳͨ�����б�
	int						nChannelCount;								// ��Ѳͨ������
} NET_CFG_TOURLINK;

// �Ž���������
enum NET_EM_CFG_ACCESSCONTROLTYPE
{
	NET_EM_CFG_ACCESSCONTROLTYPE_NULL = 0,					// ��������
	NET_EM_CFG_ACCESSCONTROLTYPE_AUTO,						// �Զ�
	NET_EM_CFG_ACCESSCONTROLTYPE_OPEN,						// ����
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSE,						// ����
	NET_EM_CFG_ACCESSCONTROLTYPE_OPENALWAYS,				// ��Զ����
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSEALWAYS,				// ��Զ�ر�
};

// �����з���
typedef enum tagNET_EM_CALLER_TYPE
{
	NET_EM_CALLER_DEVICE = 0,								// �豸����
}NET_EM_CALLER_TYPE;

// ���Э��
typedef enum tagNET_EM_CALLER_PROTOCOL_TYPE
{
	NET_EM_CALLER_PROTOCOL_CELLULAR = 0,					// �ֻ���ʽ
}NET_EM_CALLER_PROTOCOL_TYPE;

// ������������Ϣ
typedef struct tagNET_CFG_TALKBACK_INFO
{
	BOOL							bCallEnable;					// ������ʹ��
	NET_EM_CALLER_TYPE				emCallerType;					// �����з���
	NET_EM_CALLER_PROTOCOL_TYPE		emCallerProtocol;				// ������Э��
}NET_CFG_TALKBACK_INFO;

// �绰��������������Ϣ
typedef struct tagNET_CFG_PSTN_ALARM_SERVER
{
	BOOL				bNeedReport;									// �Ƿ��ϱ����绰��������
	int					nServerCount;									// �绰��������������					
	BYTE 				byDestination[CFG_MAX_PSTN_SERVER_NUM];			// �ϱ��ı��������±�
}NET_CFG_PSTN_ALARM_SERVER;

typedef enum tagNET_EM_CFG_OPERATE_TYPE
{
    NET_EM_CFG_SNAP_MODE,                   // ץͼģʽ����,��Ӧ�ṹ�� NET_SNAP_MODE
    NET_EM_CFG_DEV_CAR_COACH,               // ��·��¼����, ��Ӧ�ṹ�� NET_DEV_CAR_COACH_INFO
	NET_EM_CFG_YUEQING_SUPPLYLIGHTING,		// ������ӵƹ�����, ��Ӧ�ṹ�� NET_YUEQING_SUPPLYLIGHTING_INFO
	NET_EM_CFG_MEDIA_GLOBAL,                // ý�����ȫ������, ��Ӧ�ṹ�� NET_MEDIA_GLOBAL_INFO

	/*********OSD�����������*************************************************************************************************/
	NET_EM_CFG_CHANNELTITLE = 1000,         // ����ͨ�������������ã���Ӧ�ṹ�� NET_OSD_CHANNEL_TITLE,���нṹ���е�emOsdBlendTypeΪ�������
	NET_EM_CFG_TIMETITLE,               	// ����ʱ������������ã���Ӧ�ṹ�� NET_OSD_TIME_TITLE,���нṹ���е�emOsdBlendTypeΪ�������
	NET_EM_CFG_CUSTOMTITLE,             	// �����Զ�������������ã���Ӧ�ṹ�� NET_OSD_CUSTOM_TITLE,���нṹ���е�stuCustomTitle.emOsdBlendTypeΪ�������
	NET_EM_CFG_CUSTOMTITLETEXTALIGN,    	// �����Զ��������뷽ʽ�������ã���Ӧ�ṹ�� NET_OSD_CUSTOM_TITLE_TEXT_ALIGN
	NET_EM_CFG_OSDCOMMINFO,             	// ���ӹ����������ã���Ӧ�ṹ�� NET_OSD_COMM_INFO
	NET_EM_CFG_OSD_PTZZOOM,					// �䱶�������ã���Ӧ�ṹ�� NET_OSD_PTZZOOM_INFO
	NET_EM_CFG_GPSTITLE,					// ����GPS������ʾ���ã���Ӧ�ṹ�� NET_OSD_GPS_TITLE
	NET_EM_CFG_OSD_NUMBERSTATPLAN,			// ����ͳ�Ƽƻ�����OSD����, ֧��NumberStatPlan�㷨����ʱ(���)ʹ�ã���Ӧ�ṹ��NET_OSD_NUMBER_STATPLAN

	/*********encode �������*************************************************************************************************/
	NET_EM_CFG_ENCODE_VIDEO = 1100,			// ������Ƶ��ʽ�������ã���Ӧ�ṹ�� NET_ENCODE_VIDEO_INFO
	NET_EM_CFG_ENCODE_VIDEO_PACK,			// ������Ƶ��ʽ���ģʽ���ã���Ӧ�ṹ�� NET_ENCODE_VIDEO_PACK_INFO
	NET_EM_CFG_ENCODE_VIDEO_SVC,			// ������Ƶ��ʽSVC���ã���Ӧ�ṹ�� NET_ENCODE_VIDEO_SVC_INFO
	NET_EM_CFG_ENCODE_VIDEO_PROFILE,		// ������Ƶ��ʽprofile���ã���Ӧ�ṹ�� NET_ENCODE_VIDEO_PROFILE_INFO
	NET_EM_CFG_ENCODE_AUDIO_COMPRESSION,	// ������Ƶѹ����ʽ���ã���Ӧ�ṹ�� NET_ENCODE_AUDIO_COMPRESSION_INFO
	NET_EM_CFG_ENCODE_AUDIO_INFO,			// ������Ƶ��ʽ���ã���Ӧ�ṹ�� NET_ENCODE_AUDIO_INFO
	NET_EM_CFG_ENCODE_SNAP_INFO,			// ����ץͼ���ã���Ӧ�ṹ�� NET_ENCODE_SNAP_INFO
	NET_EM_CFG_ENCODE_SNAPTIME, 			// ����ץͼʱ��������ã���Ӧ�ṹ�� NET_ENCODE_SNAP_TIME_INFO
	NET_EM_CFG_ENCODE_CHANNELTITLE,			// ͨ���������ã���Ӧ�ṹ�� NET_ENCODE_CHANNELTITLE_INFO
		
	/**********��Ƶ�������***************************************************************************************************/
	NET_EM_CFG_AUDIOIN_SOURCE = 1200,		// ��Ƶ�����������ã���Ӧ�ṹ�� NET_ENCODE_AUDIO_SOURCE_INFO
	NET_EM_CFG_AUDIOIN_DENOISE,				// ��Ƶ�������ã���Ӧ�ṹ�� NET_AUDIOIN_DENOISE_INFO
	NET_EM_CFG_AUDIOIN_VOLUME,				// ��Ƶ�����������ã���Ӧ�ṹ�� NET_AUDIOIN_VOLUME_INFO
	NET_EM_CFG_AUDIOOUT_VOLUME,				// ��Ƶ����������ã���Ӧ�ṹ�� NET_AUDIOOUT_VOLUME_INFO
	
	/**********videoin �������***********************************************************************************************/
	NET_EM_CFG_VIDEOIN_SWITCHMODE = 1300,	// �л�ģʽ���ã���Ӧ�ṹ�� NET_VIDEOIN_SWITCH_MODE_INFO
	NET_EM_CFG_VIDEOIN_COLOR,				// ��Ƶ������ɫ���ã���Ӧ�ṹ�� NET_VIDEOIN_COLOR_INFO			
	NET_EM_CFG_VIDEOIN_IMAGE_OPT,			// ͼ���������ã���Ӧ�ṹ�� NET_VIDEOIN_IMAGE_INFO
	NET_EM_CFG_VIDEOIN_STABLE,				// ͼ��������ã���Ӧ�ṹ�� NET_VIDEOIN_STABLE_INFO
	NET_EM_CFG_VIDEOIN_IRISAUTO,			// �Զ���Ȧ���ã���Ӧ�ṹ�� NET_VIDEOIN_IRISAUTO_INFO
	NET_EM_CFG_VIDEOIN_IMAGEENHANCEMENT,	// ͼ����ǿ���ã���Ӧ�ṹ�� NET_VIDEOIN_IMAGEENHANCEMENT_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_NORMAL,		// �ع�ͨ���������ã���Ӧ�ṹ�� NET_VIDEOIN_EXPOSURE_NORMAL_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_OTHER,		// �����ع��������ã���Ӧ�ṹ�� NET_VIDEOIN_EXPOSURE_OTHER_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_SHUTTER,	// �ع�������ã���Ӧ�ṹ�� NET_VIDEOIN_EXPOSURE_SHUTTER_INFO
	NET_EM_CFG_VIDEOIN_BACKLIGHT,			// �������ã���Ӧ�ṹ�� NET_VIDEOIN_BACKLIGHT_INFO
	NET_EM_CFG_VIDEOIN_INTENSITY,			// ��������Ӧ�Աȶ�ǿ�����ã���Ӧ�ṹ�� NET_VIDEOIN_INTENSITY_INFO
	NET_EM_CFG_VIDEOIN_LIGHTING,			// ��������ã���Ӧ�ṹ�� NET_VIDEOIN_LIGHTING_INFO
	NET_EM_CFG_VIDEOIN_DEFOG,				// ͸�����ã���Ӧ�ṹ�� NET_VIDEOIN_DEFOG_INFO
	NET_EM_CFG_VIDEOIN_FOCUSMODE,			// �۽�ģʽ���ã���Ӧ�ṹ�� NET_VIDEOIN_FOCUSMODE_INFO
	NET_EM_CFG_VIDEOIN_FOCUSVALUE,			// �۽���Ϣ���ã���Ӧ�ṹ�� NET_VIDEOIN_FOCUSVALUE_INFO
	NET_EM_CFG_VIDEOIN_WHITEBALANCE,		// ��ƽ�����ã���Ӧ�ṹ�� NET_VIDEOIN_WHITEBALANCE_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT,			// ��ҹģʽ���ã���Ӧ�ṹ�� NET_VIDEOIN_DAYNIGHT_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT_ICR,		// ��ҹģʽICR�л��������ã���Ӧ�ṹ�� NET_VIDEOIN_DAYNIGHT_ICR_INFO
	NET_EM_CFG_VIDEOIN_SHARPNESS,			// ������ã���Ӧ�ṹ�� NET_VIDEOIN_SHARPNESS_INFO
	NET_EM_CFG_VIDEOIN_COMM_DENOISE,		// ͨ�ý������ã���Ӧ�ṹ�� NET_VIDEOIN_DENOISE_INFO
	NET_EM_CFG_VIDEOIN_3D_DENOISE,			// 3D �������ã���Ӧ�ṹ�� NET_VIDEOIN_3D_DENOISE_INFO

	/***********ͥ���������**************************************************************************************************/
	NET_EM_CFG_ENCODE_PLAN = 1400,			// ��¼���̱���ƻ�, ��Ӧ�ṹ�� NET_ENCODE_PLAN_INFO

	/**********���������������***********************************************************************************************/
    NET_EM_CFG_ALARM_SOUND = 1500,           // ����������������, ��Ӧ�ṹ�� NET_ALARM_SOUND_INFO 

    /**********����Ӧ���������***********************************************************************************************/
    NET_EM_CFG_ACCESS_POINT = 1600,         // ����WiFi���������(�ȵ㹦��), ��Ӧ�ṹ�� NET_NETAPP_ACCESSPOINT

	/**************��ȫ��������***************************************************************************************/
	NET_EM_CFG_NAS			= 1700,			// NAS ����, ��Ӧ�ṹ�� NET_NAS_INFO   
	NET_EM_CFG_PPPOE,						// PPPOE ���ã���Ӧ�ṹ�� NET_PPPOE_INFO   
	NET_EM_CFG_EMAIL,						// Email ���ã���Ӧ�ṹ�� NET_EAMIL_INFO  
	NET_EM_CFG_DDNS,						// DDNS ���ã���Ӧ�ṹ�� NET_DDNS_INFO  

	/**************SCADA��������****************************************************************************************/
	NET_EM_CFG_SCADA_PROTOCOLS_MANAGER  = 1800,   // Э��������ã���Ӧ�ṹ�� NET_SCADA_PROTOCOLS_MANAGER
	NET_EM_CFG_SCADA_DEVICEINFO_CFG,			  // �豸��Ϣ���ã���Ӧ�ṹ�� NET_SCADA_DEVICEINFO_CFG

	/**************NetApp��������****************************************************************************************/
	NET_EM_CFG_NETAPP_LINK_LAYER_VPN = 1900,	  // ��·��VPN����,��Ӧ�ṹ�� NET_NETAPP_LINK_LAYER_VPN_CFG

	/**************�й�����ƽ̨����****************************************************************************************/
	NET_EM_CFG_VSP_CHINA_TOWER = 2000,			  // �����γ�ƽ̨��������,��Ӧ�ṹ�� NET_VSP_CHINA_TOWER 
	
	/**********�����������***********************************************************************************************/
	NET_EM_CFG_STEREO_CALIBRATE = 2100,		// ˫Ŀ�궨���, ��Ӧ�ṹ��NET_STEREO_CALIBRATE_INFO
	NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTISENSOR,		 // ��Ŀ����궨����CalibrateMatrix(MultiSensor), ��Ӧ�Ľṹ�� NET_MULTI_SENSOR_INFO
	/**********�״�����***********************************************************************************************/
	NET_EM_CFG_RADAR            = 2200,		// �״����ã���Ӧ�ṹ�� DEV_RADAR_CONFIG
	/**********��Ƶ�Խ��绰ͨ������***********************************************************************************************/
	NET_EM_CFG_VTH_PASSWORD		= 2300,		// ��Ƶ�Խ��绰ͨ������,��Ӧ�ṹ�� NET_CFG_VTH_PASSWORD_INFO
    NET_EM_CFG_REGISTAR         = 2301,     // ע�����������,��Ӧ�ṹ�� NET_CFG_REGISTAR_INFO
    NET_EM_CFG_SIP              = 2302,     // sip����, ��Ӧ�ṹ�� NET_CFG_SIPSERVER_INFO
	/**********��ͷǰ�ڵ�������***********************************************************************************************/
	NET_EM_CFG_AELENSMASK       = 2400,     //��ͷǰ�ڵ������ã���Ӧ�ṹ��NET_CFG_AELENSMASK_INFO

	NET_EM_CFG_ULTRASONIC       = 2500,     //���������ã���Ӧ�ṹ��NET_CFG_ULTRASONIC_INFO 
    /**********���������������***********************************************************************************************/
    NET_EM_CFG_ARMSCHEDULE      = 2600,     // �Զ��������ƻ����ã���Ӧ�ṹ�� NET_CFG_ARMSCHEDULE_INFO
	/**********¼��ץͼ�����������*******************************************************************************************/
	NET_EM_CFG_RECORDEXTRA	= 3610,			// ¼������¼������, ��Ӧ�ṹ�� NET_CFG_RECORDEXTRA_INFO

	/**********��Ƶ����������*******************************************************************************************/
	NET_EM_VIDEODIAGNOSIS_PROJECT = 3700,	// ��Ƶ��ϼƻ�����, ��Ӧ�ṹ��NET_CFG_VIDEODIAGNOSIS_PROJECT_INFO
} NET_EM_CFG_OPERATE_TYPE;


//////////////////////////////////////////////////////////////////////////
// RPC������
//////////////////////////////////////////////////////////////////////////

#define RPC_METHOD_MONITORWALL_ADD      "monitorWallManager.addMonitorWall"     // ��ӵ���ǽ


/***********************************************************************
 ** �ص���������
 ***********************************************************************/

// �������ӶϿ��ص�����ԭ��
typedef void (CALLBACK *fDisConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// �������ӻָ��ص�����ԭ��
typedef void (CALLBACK *fHaveReConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// ��̬�����ӶϿ��ص�����ԭ��
typedef void (CALLBACK *fSubDisConnect)(EM_INTERFACE_TYPE emInterfaceType, BOOL bOnline, LLONG lOperateHandle, LLONG lLoginID, LDWORD dwUser);

// ��Ƶ���ӶϿ��ص�����ԭ��, (param�ڴ���SDK�ڲ������ͷ� )
typedef void (CALLBACK *fRealPlayDisConnect)(LLONG lOperateHandle, EM_REALPLAY_DISCONNECT_EVENT_TYPE dwEventType, void* param, LDWORD dwUser);

// ʵʱ�������ݻص�����ԭ��(pBuffer�ڴ���SDK�ڲ������ͷ�)
// ͨ�� dwDataType ���˵õ���Ӧ��������������������ο� EM_REALDATA_FLAG; ת����ʱ dwDataType ֵ��ο� NET_DATA_CALL_BACK_VALUE ˵��
typedef void (CALLBACK *fRealDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// ʵʱ�������ݻص�����ԭ��--��չ(pBuffer�ڴ���SDK�ڲ������ͷ�)
// ͨ�� dwDataType ���˵õ���Ӧ��������������������ο� EM_REALDATA_FLAG; ת����ʱ dwDataType ֵ��ο� NET_DATA_CALL_BACK_VALUE ˵��
typedef void (CALLBACK *fRealDataCallBackEx)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser);

// ʵʱ�������ݻص�����ԭ��--��չ(pBuffer�ڴ���SDK�ڲ������ͷ�)
// ͨ�� dwDataType ���˵õ���Ӧ��������������������ο� EM_REALDATA_FLAG; ת����ʱ dwDataType ֵ��ο� NET_DATA_CALL_BACK_VALUE ˵��
typedef void (CALLBACK *fRealDataCallBackEx2)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LLONG param, LDWORD dwUser);

// ��Ļ���ӻص�����ԭ��
typedef void (CALLBACK *fDrawCallBack)(LLONG lLoginID, LLONG lPlayHandle, HDC hDC, LDWORD dwUser);

// ��ʱ��طŽ��Ȼص�����ԭ��
typedef void (CALLBACK *fTimeDownLoadPosCallBack) (LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, int index, NET_RECORDFILE_INFO recordfileinfo, LDWORD dwUser);

// ��Ϣ�ص�����ԭ��(pBuf�ڴ���SDK�ڲ������ͷ�)
typedef BOOL (CALLBACK *fMessCallBack)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
// ��������˵��
// bAlarmAckFlag : TRUE,���¼�Ϊ���Խ���ȷ�ϵ��¼���FALSE,���¼��޷�����ȷ��
// nEventID ���ڶ� CLIENT_AlarmAck �ӿڵ���ν��и�ֵ,�� bAlarmAckFlag Ϊ TRUE ʱ,��������Ч
// pBuf�ڴ���SDK�ڲ������ͷ�
typedef BOOL (CALLBACK *fMessCallBackEx1)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, BOOL bAlarmAckFlag, LONG nEventID, LDWORD dwUser);

// �����������ص�����ԭ��
typedef int (CALLBACK *fServiceCallBack)(LLONG lHandle, char *pIp, WORD wPort, LONG lCommand, void *pParam, DWORD dwParamLen, LDWORD dwUserData);

// ����Խ�����Ƶ���ݻص�����ԭ��(pDataBuf�ڴ���SDK�ڲ������ͷ�)
typedef void (CALLBACK *pfAudioDataCallBack)(LLONG lTalkHandle, char *pDataBuf, DWORD dwBufSize, BYTE byAudioFlag, LDWORD dwUser);

// �����豸����ص�����ԭ��
typedef void (CALLBACK *fUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser);

// �����豸����ص�����ԭ��֧��G���������ļ�
typedef void (CALLBACK *fUpgradeCallBackEx) (LLONG lLoginID, LLONG lUpgradechannel, INT64 nTotalSize, INT64 nSendSize, LDWORD dwUser);

// ͸�����ڻص�����ԭ��(pBuffer�ڴ���SDK�ڲ������ͷ�)
typedef void (CALLBACK *fTransComCallBack) (LLONG lLoginID, LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// ��ѯ�豸��־���ݻص�����ԭ��(pBuffer�ڴ���SDK�ڲ������ͷ�)
typedef void (CALLBACK *fLogDataCallBack)(LLONG lLoginID, char *pBuffer, DWORD dwBufSize, DWORD nTotalSize, BOOL bEnd, LDWORD dwUser);

// ץͼ�ص�����ԭ��(pBuf�ڴ���SDK�ڲ������ͷ�)
// EncodeType �������ͣ�10����ʾjpegͼƬ 0��mpeg4��i֡
typedef void (CALLBACK *fSnapRev)(LLONG lLoginID, BYTE *pBuf, UINT RevLen, UINT EncodeType, DWORD CmdSerial, LDWORD dwUser);

// GPS��Ϣ���Ļص�
typedef void (CALLBACK *fGPSRev)(LLONG lLoginID, GPS_Info GpsInfo, LDWORD dwUserData);

// GPS��Ϣ���Ļص�--��չ
typedef void (CALLBACK *fGPSRevEx)(LLONG lLoginID, GPS_Info GpsInfo, ALARM_STATE_INFO stAlarmInfo, LDWORD dwUserData, void *reserved);

// GPS��Ϣ���Ļص�--��չ2
typedef void (CALLBACK *fGPSRevEx2)(LLONG lLoginID, const LPNET_GPS_LOCATION_INFO lpData, LDWORD dwUserData, void *reserved);

// GPS��ʪ����Ϣ���Ļص�
typedef void (CALLBACK *fGPSTempHumidityRev)(LLONG lLoginID, GPS_TEMP_HUMIDITY_INFO GpsTHInfo, LDWORD dwUserData);

// �첽���ݻص�
typedef void (CALLBACK *fMessDataCallBack)(LLONG lCommand, LPNET_CALLBACK_DATA lpData, LDWORD dwUser);

// �ļ�����ص�
typedef void (CALLBACK *fTransFileCallBack)(LLONG lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, LDWORD dwUser);

// ���ܷ������ݻص�;nSequence��ʾ�ϴ�����ͬͼƬ���,Ϊ0ʱ��ʾ�ǵ�һ�γ���,Ϊ2��ʾ���һ�γ��ֻ������һ��,Ϊ1��ʾ�˴�֮����
// int nState = (int*) reserved ��ʾ��ǰ�ص����ݵ�״̬, Ϊ0��ʾ��ǰ����Ϊʵʱ����,Ϊ1��ʾ��ǰ�ص���������������,Ϊ2ʱ��ʾ�������ݴ��ͽ���
typedef int  (CALLBACK *fAnalyzerDataCallBack)(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// �첽�����豸�ص�(pDevNetInfo�ڴ���SDK�ڲ������ͷ�)
typedef void (CALLBACK *fSearchDevicesCB)(DEVICE_NET_INFO_EX *pDevNetInfo, void* pUserData);

// �첽ע���豸�ص�����ԭ��
// typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// �ط�YUV���ݻص�����
typedef void (CALLBACK *fYUVDataCallBack)(LLONG lPlaybackHandle, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser, void *reserved);

/************************************************************************
 ** �ӿڶ���
 ***********************************************************************/

// SDK��ʼ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Init(fDisConnect cbDisConnect, LDWORD dwUser);

// SDK��ʼ��, ͨ��NETSDK_INIT_PARAMָ����ʼ������, �綨��NetSDK���õĳ������紦���߳�����
// ��lpInitParamΪ��ʱ�������CLIENT_InitЧ��һ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitEx(fDisConnect cbDisConnect, LDWORD dwUser, LPNETSDK_INIT_PARAM lpInitParam = NULL);

// SDK�˳�����
CLIENT_NET_API void CALL_METHOD CLIENT_Cleanup();

//------------------------------------------------------------------------

// ���ö��������ɹ��ص�����,���ú�SDK�ڲ������Զ�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetAutoReconnect(fHaveReConnect cbAutoConnect, LDWORD dwUser);

// ���ö�̬�����Ӷ��߻ص�����,ĿǰSVR�豸�ļ��Ӻͻط��Ƕ����ӵġ�
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubconnCallBack(fSubDisConnect cbSubDisConnect, LDWORD dwUser);

// ���غ���ִ��ʧ�ܴ���
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetLastError(void);

// ���������豸��ʱʱ��ͳ��Դ���
CLIENT_NET_API void CALL_METHOD CLIENT_SetConnectTime(int nWaitTime, int nTryTimes);

// ���õ�½���绷��(pNetParam�ڴ����û������ͷ�)
CLIENT_NET_API void CALL_METHOD CLIENT_SetNetworkParam(NET_PARAM *pNetParam);

// ��ȡSDK�İ汾��Ϣ
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetSDKVersion();

//------------------------------------------------------------------------

// ���豸ע��(lpDeviceInfo�ڴ����û������ͷ�)
// ������ʧ��ʱ��   error = 1   �˺Ż��������
//                  error = 2   �û���������
//                  error = 3   ��¼��ʱ
//                  error = 4   �ظ���¼
//                  error = 5   �ʺű�����
//                  error = 6   �ʺű����������
//                  error = 7   ϵͳæ,��Դ����
//                  error = 8   ������ʧ��
//                  error = 9   ������ʧ��
//                  error = 10  �������������
//                  error = 11  ֻ֧��3��Э��
//                  error = 12  �豸δ����U�ܻ�U����Ϣ����
//                  error = 13  �ͻ���IP��ַû�е�¼Ȩ��
//					error = 18  �豸�˺�δ��ʼ�����޷���½

CLIENT_NET_API LLONG CALL_METHOD CLIENT_Login(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// ��չ�ӿڣ�nSpecCap = 0ΪTCP��ʽ�µĵ���,void* pCapParam��NULL
//			 nSpecCap = 2Ϊ����ע��ĵ���,void* pCapParam��NULL
//			 nSpecCap = 3Ϊ�鲥��ʽ�µĵ���,void* pCapParam��NULL
//           nSpecCap = 4ΪUDP��ʽ�µĵ���,void* pCapParam��NULL
//			 nSpecCap = 6Ϊֻ���������µĵ���,void* pCapParam��NULL
//			 nSpecCap = 7ΪSSL����,void* pCapParam��NULL
//           nSpecCap = 9Ϊ��¼Զ���豸,���ʱ��void* pCapParam����Զ���豸�����ֵ��ַ���
//           nSpecCap = 12ΪLDAP��ʽ��¼,void* pCapParam��NULL
//           nSpecCap = 13ΪAD��ʽ��¼,void* pCapParam��NULL
//           nSpecCap = 14ΪRadius��¼��ʽ,void* pCapParam��NULL 
//           nSpecCap = 15ΪSocks5��½��ʽ,���ʱ��void* pCapParam����Socks5��������IP&&port&&ServerName&&ServerPassword�ַ���
//           nSpecCap = 16Ϊ�����½��ʽ,���ʱ��void* pCapParam����SOCKETֵ
//           nSpecCap = 19ΪP2P��½��ʽ,void* pCapParam��NULL
//           nSpecCap = 20Ϊ�ֻ��ͻ��˵���,void* pCapParam��NULL
//			 lpDeviceInfo�ڴ����û������ͷ�
// ������ʧ��ʱ��   error�Ĵ������Ӧ��˵���ο� CLIENT_Login
//			 lpDeviceInfo, pCapParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, int nSpecCap, void* pCapParam, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// ������չ�ӿ�(lpDeviceInfo, pCapParam�ڴ����û������ͷ�)
// ������ʧ��ʱ��   error�Ĵ������Ӧ��˵���ο� CLIENT_Login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx2(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, EM_LOGIN_SPAC_CAP_TYPE emSpecCap, void* pCapParam, LPNET_DEVICEINFO_Ex lpDeviceInfo, int *error = 0);

// �첽���豸ע�� 
// nSpecCap = 0ΪTCP��ʽ�µĵ���,nSpecCap = 6Ϊֻ���������µĵ���
// nSpecCap = 19ΪP2P��¼
// pCapParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLogin(char *pchDVRIP, WORD wDVRPort, char *pchUserName, char *pchPassword, int nSpecCap, void* pCapParam, fHaveLogin cbLogin, LDWORD dwUser);

// ֻ�е�CLIENT_StartLogin()�Ļص�����Ϊ11ʱ��ʹ�øýӿڼ����첽��½(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLoginEx(NET_IN_STARTLOGINEX* pInParam, NET_OUT_STARTLOGINEX* pOutParam);

// ֹͣ���豸ע��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLogin(LLONG lLoginID);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoginEx(LLONG lLoginID);

// ���豸ע��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Logout(LLONG lLoginID);


//------------------------------------------------------------------------

// ��ȡ�豸��Э��汾����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevProtocolType(LLONG lLoginID, EM_DEV_PROTOCOL_TYPE *pemProtocolType);

//------------------------------------------------------------------------
// ��ʼʵʱ����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlay(LLONG lLoginID, int nChannelID, HWND hWnd);

// ��ʼʵʱ����--��չ
// �໭��Ԥ��ʱnChannelID NVR�豸����Ƶ���ͨ����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayEx(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType = DH_RType_Realplay);

//��ʵʱ����,���0��ʾ��ʧ��
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRealPlay(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType, fRealDataCallBackEx cbRealData, fRealPlayDisConnect cbDisconnect, LDWORD dwUser, DWORD dwWaitTime = 10000);

// �໭��ʵʱԤ��
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlay(LLONG lLoginID, HWND hWnd);

// ֹͣ�໭��ʵʱԤ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopMultiPlay(LLONG lMultiHandle);

// ץͼ��hPlayHandleΪ���ӻ�طž��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePicture(LLONG hPlayHandle, const char *pchPicFileName);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx(LLONG hPlayHandle, const char *pchPicFileName, NET_CAPTURE_FORMATS eFormat);

// ����ʵʱ�������ݻص�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBack(LLONG lRealHandle, fRealDataCallBack cbRealData, LDWORD dwUser);

// ʵʱ���ӵ�ʵʱ���ݱ�־, ��Ӧ CLIENT_SetRealDataCallBackEx(Ex2) �е� dwFlag ����
// ֧�� '|' �����, �� dwFlag = REALDATA_FLAG_RAW_DATA | REALDATA_FLAG_YUV_DATA
typedef enum tagEM_REALDATA_FLAG
{	
	REALDATA_FLAG_RAW_DATA				= 0x01,	// ԭʼ���ݱ�־,			��ӦfRealDataCallBack(Ex/Ex2)�ص������� dwDataType Ϊ0, 0x01 = 0x01 << 0
	REALDATA_FLAG_DATA_WITH_FRAME_INFO	= 0x02,	// ����֡��Ϣ�����ݱ�־,	��ӦfRealDataCallBack(Ex/Ex2)�ص������� dwDataType Ϊ1, 0x02 = 0x01 << 1
	REALDATA_FLAG_YUV_DATA				= 0x04,	// YUV ���ݱ�־,			��ӦfRealDataCallBack(Ex/Ex2)�ص������� dwDataType Ϊ2, 0x04 = 0x01 << 2
	REALDATA_FLAG_PCM_AUDIO_DATA		= 0x08,	// PCM ��Ƶ���ݱ�־,		��ӦfRealDataCallBack(Ex/Ex2)�ص������� dwDataType Ϊ3, 0x08 = 0x01 << 3
} EM_REALDATA_FLAG;

// ����ʵʱ�������ݻص�--��չ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx(LLONG lRealHandle, fRealDataCallBackEx cbRealData, LDWORD dwUser, DWORD dwFlag);

// ����ʵʱ�������ݻص�--��չEx2
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx2(LLONG lRealHandle, fRealDataCallBackEx2 cbRealData, LDWORD dwUser, DWORD dwFlag);

// ����ͼ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustFluency(LLONG lRealHandle, int nLevel);

// ��������Ϊ�ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveRealData(LLONG lRealHandle, const char *pchFileName);

// ������������Ϊ�ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSaveRealData(LLONG lRealHandle);

// ����ͼ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientSetVideoEffect(LLONG lPlayHandle, unsigned char nBrightness, unsigned char nContrast, unsigned char nHue, unsigned char nSaturation);

// ��ȡͼ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientGetVideoEffect(LLONG lPlayHandle, unsigned char *nBrightness, unsigned char *nContrast, unsigned char *nHue, unsigned char *nSaturation);

// ������Ļ���ӻص�
CLIENT_NET_API void CALL_METHOD CLIENT_RigisterDrawFun(fDrawCallBack cbDraw, LDWORD dwUser);

// ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSound(LLONG hPlayHandle);

// ����������lPlayHandleΪ���ӻ�طž��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVolume(LLONG lPlayHandle, int nVolume);

// �Ƿ����ø���ͼ���ڲ���������,Ĭ�����á��ò�������ʱ,�ڿ��4��������ʱ,ֻ����I֡,������ʱ,��ÿ֡������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayEnableLargePicAdjustment(LLONG lPlayHandle, BOOL bEnable);

// �ر�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSound();

// ֹͣʵʱԤ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlay(LLONG lRealHandle);

// ֹͣʵʱԤ��--��չ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlayEx(LLONG lRealHandle);

//------------------------------------------------------------------------

// ͨ����̨����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, DWORD dwStep, BOOL dwStop);

// ˽����̨����,param4���û������ͷ��ڴ棬�ڴ��С����DH_EXTPTZ_ControlType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, unsigned char param1, unsigned char param2, unsigned char param3, BOOL dwStop,void* param4=NULL);

// ˽����̨������չ�ӿ�,֧����ά���ٶ�λ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop );

// ˽����̨������չ�ӿ�,֧����ά���ٶ�λ,����,param4���û������ͷ��ڴ棬�ڴ��С����DH_EXTPTZ_ControlType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx2(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop , void* param4 = NULL);

// ����ɨ��ӿڣ���ȡ��������Ϣ(NET_AREASCAN_EPTZ_CMD)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZAreaScan(LLONG lLoginID ,DWORD dwPTZCommand, char* szInBuffer, DWORD dwInBufferSize,char* szOutBuffer = NULL, DWORD dwOutBufferSize = 0, int waittime=1000);

// CLIENT_DHPTZCalibrateSingleDirection ���
typedef struct tagNET_IN_CALIBRATE_SINGLEDIRECTION
{
    DWORD                       dwSize;
    int                         nMode;                      // У׼ģʽ��1��ˮƽУ׼��2����ֱУ׼
}NET_IN_CALIBRATE_SINGLEDIRECTION;

//------------------------------------------------------------------------
// ��ѯĳ�µĸ����Ƿ����¼���ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordStatus(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmMonth, char* pchCardid, LPNET_RECORD_STATUS pRecordStatus, int waittime=1000);
// ��ѯʱ������Ƿ���¼���ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, BOOL *bResult, int waittime=1000);
// ��ѯʱ����ڵ�����¼���ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);

// �첽��ѯʱ����ڵ�����¼���ļ�(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartQueryRecordFile(LLONG lLoginID, NET_IN_START_QUERY_RECORDFILE *pInParam, NET_OUT_START_QUERY_RECORDFILE *pOutParam);

// ���ٲ�ѯʱ����ڵ�¼���ļ�,���ʱ�����¼�񳬹�16��ʱ,ֻ����ʱ�������16��¼��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuickQueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);

// ��ѯ����¼��ʱ��(pFurthrestTime�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryFurthestRecordTime(LLONG lLoginID, int nRecordFileType, char *pchCardid, NET_FURTHEST_RECORD_TIME* pFurthrestTime, int nWaitTime);

// ��ʼ����¼���ļ�
CLIENT_NET_API LLONG    CALL_METHOD CLIENT_FindFile(LLONG lLoginID, int nChannelId, int nRecordFileType, char* cardid, LPNET_TIME time_start, LPNET_TIME time_end, BOOL bTime, int waittime);

// ����¼���ļ�(lpFindData�ڴ����û������ͷ�)
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextFile(LLONG lFindHandle,LPNET_RECORDFILE_INFO lpFindData);

// ����¼���ļ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindClose(LLONG lFindHandle);

// ���ļ���ʽ�ط�(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// ���ļ���ʽ�ط�--��չ(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// ���ļ���ʽ�ط�--�ص��ط��ж��¼�(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByRecordFile(LLONG lLoginID,  LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
                                                             fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                             fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
                                                             fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//���ļ���ʽ�ط�--��֡����(������ʱ����ʹ��)(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
                                                                   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                                   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

// ��ʱ�䷽ʽ�ط�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser);




// ��ʱ�䷽ʽ�ط�--��չ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                     fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);
// ��ʱ�䷽ʽ�ط�--��չ�ڶ���,֧��ֱ�ӵ���,pstNetIn��pstNetOut��Ҫ�û������ڴ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx2(LLONG lLoginID, int nChannelID, 
                        NET_IN_PLAY_BACK_BY_TIME_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_TIME_INFO *pstNetOut);

// ��ʱ�䷽ʽ�ط�--�ص��ط��ж��¼�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByTime(LLONG lLoginID, int nChannelID, 
                                                       LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                       fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser,
                                                       fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
                                                       fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//��ʱ�䷽ʽ�ط�--��֡����(������ʱ����ʹ��)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                             fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                             fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

//��ƵŨ���ļ��ط�(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySynopsisFile(LLONG lLoginID, 
                                                            LPNET_SYNOPSISFILE_INFO lpRecordFile, 
                                                            HWND hWnd, 
                                                            fDownLoadPosCallBack cbDownLoadPos,
                                                            LDWORD dwPosUser, 
                                                            fDataCallBack fDownLoadDataCallBack,
                                                            LDWORD dwDataUser,
                                                            LDWORD dwUser);
                                                            
// ��ͨ��Ԥ���ط�(pParam�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlayBack(LLONG lLoginID, NET_MULTI_PLAYBACK_PARAM *pParam);

// ��λ¼��ط���ʼ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBack(LLONG lPlayHandle, unsigned int offsettime, unsigned int offsetbyte);

// ��ͣ��ָ�¼��ط�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayBack(LLONG lPlayHandle, BOOL bPause);

// ���¼��ط�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayBack(LLONG lPlayHandle);

// ����¼��ط�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayBack(LLONG lPlayHandle);

// ����¼��ط��ٶ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayBackSpeed(LLONG lPlayHandle, EM_PLAY_BACK_SPEED emSpeed);

// ����¼��ط�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StepPlayBack(LLONG lPlayHandle, BOOL bStop);

// ���Ʋ��ŷ���--���Ż��ߵ���
// bBackward FLASE ����,TRUE ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControlDirection(LLONG lPlayHandle, BOOL bBackward);

// ���ûط�֡��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFramePlayBack(LLONG lPlayHandle, int framerate);

// ��ȡ�ط�֡��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFramePlayBack(LLONG lPlayHandle, int *fileframerate, int *playframerate);

// �ָ������ط��ٶ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayBack(LLONG lPlayHandle);

// ���ܼ����ط�(lpPlayBackParam�ڴ��û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SmartSearchPlayBack(LLONG lPlayHandle, LPIntelligentSearchPlay lpPlayBackParam);

// ��ȡ�ط�OSDʱ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlayBackOsdTime(LLONG lPlayHandle, LPNET_TIME lpOsdTime, LPNET_TIME lpStartTime, LPNET_TIME lpEndTime);

// ֹͣ¼��ط�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopPlayBack(LLONG lPlayHandle);

// ����¼���ļ�(lpRecordFile�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// ����¼���ļ�--��չ
// sSavedFileName��Ϊ��, ¼������д�뵽��·����Ӧ���ļ�; fDownLoadDataCallBack��Ϊ��, ¼������ͨ���ص���������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, 
                                                           fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData, 
                                                           fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// ͨ��ʱ������¼��
// nRecordFileType �����Ͳμ� ö��EM_QUERY_RECORD_TYPE
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData);

// ͨ��ʱ������¼��--��չ
// sSavedFileName��Ϊ��, ¼������д�뵽��·����Ӧ���ļ�; fDownLoadDataCallBack��Ϊ��, ¼������ͨ���ص���������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTimeEx(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, 
                                                     fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// ��ѯ¼�����ؽ���,��λKB
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDownloadPos(LLONG lFileHandle, int *nTotalSize, int *nDownLoadSize);

// ֹͣ¼������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownload(LLONG lFileHandle);

//------------------------------------- ָ���ص����ݸ�ʽ ���ӡ��طš����� ��ؽӿ� ---------------------

#define NET_DATA_CALL_BACK_VALUE      1000       // ���EM_REAL_DATA_TYPEʹ��,����ת��������ݻص�����(fRealDataCallBackEx,fDataCallBack)�еĲ���dwDataType��ֵ
                                                 // Ϊ��ת�����������ͼ���NET_DATA_CALL_BACK_VALUE.
                                                 // ��,dwDataType = NET_DATA_CALL_BACK_VALUE + emDataType
                                                 // �ڻص������н�������ת���������,����Ҫ���ж� dwDataType ��ֵ�Ƿ�Ϊ NET_DATA_CALL_BACK_VALUE��emDataType֮��
                                                 // ��,EM_REAL_DATA_TYPE_PRIVATE���������ж�

// ʵʱ���ӻص���������
typedef enum tagEM_REAL_DATA_TYPE
{
    EM_REAL_DATA_TYPE_PRIVATE,       // ˽������
    EM_REAL_DATA_TYPE_GBPS,          // ����PS����
    EM_REAL_DATA_TYPE_TS,            // TS����
    EM_REAL_DATA_TYPE_MP4,           // MP4�ļ�(�ӻص�������������˽����������,����dwDataTypeֵΪ0)
}EM_REAL_DATA_TYPE;

// ��ʼʵʱ���Ӳ�ָ���ص����ݸ�ʽ���
typedef struct tagNET_IN_REALPLAY_BY_DATA_TYPE
{
    DWORD               dwSize;                 // �ṹ���С
    int                 nChannelID;             // ͨ�����
    HWND                hWnd;                   // ���ھ��
    DH_RealPlayType     rType;                  // ��������    
    fRealDataCallBackEx cbRealData;             // ���ݻص�����
    EM_REAL_DATA_TYPE   emDataType;             // �ص����������� 
    LDWORD              dwUser;                 // �û�����
    const char*         szSaveFileName;         // ת������ļ���
}NET_IN_REALPLAY_BY_DATA_TYPE;

// ��ʼʵʱ���Ӳ�ָ���ص����ݸ�ʽ����
typedef struct tagNET_OUT_REALPLAY_BY_DATA_TYPE
{
    DWORD               dwSize;                 // �ṹ���С  
}NET_OUT_REALPLAY_BY_DATA_TYPE;

// ָ���ص��������� ʵʩ����(Ԥ��), ���ݻص����� cbRealData �еõ�����������Ϊ emDataType ��ָ��������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayByDataType(LLONG lLoginID, const NET_IN_REALPLAY_BY_DATA_TYPE* pstInParam, NET_OUT_REALPLAY_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// ��ʼ�طŲ�ָ���ص����ݸ�ʽ ���
typedef struct tagNET_IN_PLAYBACK_BY_DATA_TYPE
{
    DWORD               dwSize;                 // �ṹ���С
    int                 nChannelID;             // ͨ�����
    NET_TIME            stStartTime;            // ��ʼʱ��
    NET_TIME            stStopTime;             // ����ʱ��
    HWND                hWnd;                   // ���Ŵ���, ��ΪNULL
    fDownLoadPosCallBack cbDownLoadPos;         // ���Ȼص�
    LDWORD              dwPosUser;              // ���Ȼص��û���Ϣ
    fDataCallBack       fDownLoadDataCallBack;  // ���ݻص�
    EM_REAL_DATA_TYPE   emDataType;             // �ص����������� 
    LDWORD              dwDataUser;             // ���ݻص��û���Ϣ
    int                 nPlayDirection;         // ���ŷ���, 0:����; 1:����;
}NET_IN_PLAYBACK_BY_DATA_TYPE;

// ��ʼ�طŲ�ָ���ص����ݸ�ʽ ����
typedef struct tagNET_OUT_PLAYBACK_BY_DATA_TYPE
{
    DWORD               dwSize;                 // �ṹ���С  
}NET_OUT_PLAYBACK_BY_DATA_TYPE;

// ָ���ص����ݸ�ʽ  ��ʼ�ط�,  ���ݻص����� fDownLoadDataCallBack �еõ�����������Ϊ emDataType ��ָ��������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByDataType(LLONG lLoginID, const NET_IN_PLAYBACK_BY_DATA_TYPE* pstInParam, NET_OUT_PLAYBACK_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// ��ʼ���ز�ָ���ص����ݸ�ʽ ���
typedef struct tagNET_IN_DOWNLOAD_BY_DATA_TYPE
{
    DWORD                       dwSize;                 // �ṹ���С
    int                         nChannelID;             // ͨ�����
    EM_QUERY_RECORD_TYPE        emRecordType;           // ¼������
    char*                       szSavedFileName;        // ���ص��ļ�·��
    NET_TIME                    stStartTime;            // ��ʼʱ��
    NET_TIME                    stStopTime;             // ����ʱ��
    fTimeDownLoadPosCallBack    cbDownLoadPos;          // ���Ȼص�
    LDWORD                      dwPosUser;              // ���Ȼص��û���Ϣ
    fDataCallBack               fDownLoadDataCallBack;  // ���ݻص�
    EM_REAL_DATA_TYPE           emDataType;             // �ص����������� 
    LDWORD                      dwDataUser;             // ���ݻص��û���Ϣ
}NET_IN_DOWNLOAD_BY_DATA_TYPE;

// ��ʼ���ز�ָ���ص����ݸ�ʽ ����
typedef struct tagNET_OUT_DOWNLOAD_BY_DATA_TYPE
{
    DWORD               dwSize;                 // �ṹ���С  
}NET_OUT_DOWNLOAD_BY_DATA_TYPE;

// ָ���������� ��ʼ����, ���صõ����ļ������ݻص����� fDownLoadDataCallBack �еõ����������;�Ϊ emDataType ��ָ��������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByDataType(LLONG lLoginID, const NET_IN_DOWNLOAD_BY_DATA_TYPE* pstInParam, NET_OUT_DOWNLOAD_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);

//-------------------------------------------------------------------

//�ֲ��Ŵ�(pSrcRect�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayRegion(LLONG lPlayHandle,DWORD nRegionNum, DH_DISPLAYRREGION *pSrcRect, HWND hDestWnd, BOOL bEnable);

// ��ʼ����¼���ļ�֡��Ϣ(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindFrameInfo(LLONG lLoginID, NET_IN_FIND_FRAMEINFO_PRAM *pInParam, NET_OUT_FIND_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// ����¼���ļ�֡��Ϣ����ָ����Ϣ������ѯ(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextFrameInfo(LLONG lFindHandle, NET_IN_FINDNEXT_FRAMEINFO_PRAM *pInParam, NET_OUT_FINDNEXT_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// ���ñ�ǩ��Ϣ
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamSetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// ��ȡ��ǩ��Ϣ
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamGetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_GET_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// �����ǩ��Ϣ
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamClearTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// ���˲�ѯ��ǩ��Ϣ
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamFilterTags(LLONG lFindHandle, NET_IN_FILE_STREAM_FILTER_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// ����¼���ļ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindFrameInfoClose(LLONG lFindHandle);
// pInParam, pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamMotionMatch(LLONG lLoginID, const NET_IN_MOTIONMATCH_PARAM *pInParam, NET_OUT_MOTIONMATCH_PARAM* pOutParam, int nWaitTime);

// ��ѯ��ǩ��Ϣ, lFindHandleͨ��CLIENT_FindFrameInfo��ȡ����ѯ���ı�ǩ��CLIENT_TagManagerStartTag/CLIENT_TagManagerSetSubTag/CLIENT_TagManagerStopTag���õ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamFindTags(LLONG lFindHandle, NET_IN_FINDTAGS_INFO *pInParam, NET_OUT_FINDTAGS_INFO *pOutParam, int nWaitTime);

// ��ȡ��ǩ״̬
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerGetTagState(LLONG lLoginID, NET_IN_TAGMANAGER_GETTAGSTATE_INFO *pInParam, NET_OUT_TAGMANAGER_GETTAGSTATE_INFO *pOutParam, int nWaitTime);

// ��ʼ���ǩ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStartTag(LLONG lLoginID, NET_IN_TAGMANAGER_STARTTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STARTTAG_INFO *pOutParam, int nWaitTime);

// ���ӱ�ǩ, �ӱ�ǩ������Ӧ����20������ʧ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerSetSubTag(LLONG lLoginID, NET_IN_TAGMANAGER_SETSUBTAG_INFO *pInParam, NET_OUT_TAGMANAGER_SETSUBTAG_INFO *pOutParam, int nWaitTime);

// ֹͣ���ǩ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStopTag(LLONG lLoginID, NET_IN_TAGMANAGER_STOPTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STOPTAG_INFO *pOutParam, int nWaitTime);

//------------------------------------------------------------------------

// ���ñ����ص�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBack(fMessCallBack cbMessage,LDWORD dwUser);

CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBackEx1(fMessCallBackEx1 cbMessage,LDWORD dwUser);

// ���豸���ı���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListen(LLONG lLoginID);

// ���豸���ı���--��չ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListenEx(LLONG lLoginID);

// ֹͣ���ı���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListen(LLONG lLoginID);

// ������λ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AlarmReset(LLONG lLoginID, DWORD dwAlarmType, int nChannel, void* pReserved = NULL, int nWaitTime = 1000);

//------------------------------------------------------------------------
 
// ����ע�Ṧ��,�����nTimeout��������Ч
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ListenServer(char* ip, WORD port, int nTimeout, fServiceCallBack cbListen, LDWORD dwUserData);

// ֹͣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListenServer(LLONG lServerHandle);

// ��Ӧ�豸��ע������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResponseDevReg(char *devSerial, char* ip, WORD port, BOOL bAccept);

//------------------------------------------------------------------------

// �����ϴ�����,�����dwTimeOut��������Ч
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartService(WORD wPort, char *pIp = NULL, fServiceCallBack pfscb = NULL, DWORD dwTimeOut = 0xffffffff, LDWORD dwUserData = 0);

// ֹͣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopService(LLONG lHandle);

//------------------------------------------------------------------------

// ��������Խ�ģʽ,�ͻ��˷�ʽ���Ƿ�������ʽ(pValue�ڴ����û������ͷţ���С����EM_USEDEV_MODE��Ӧ�Ľṹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceMode(LLONG lLoginID, EM_USEDEV_MODE emType, void* pValue);

// ������Խ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkEx(LLONG lLoginID, pfAudioDataCallBack pfcb, LDWORD dwUser);

// ��ʼPC��¼��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStart();

// ����PC��¼��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStop();


// ��ʼPC��¼��(��CLIENT_RecordStart()��չ)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStartEx(LLONG lLoginID);

// ����PC��¼��(��CLIENT_RecordStop()��չ)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStopEx(LLONG lLoginID);


// �����������ݵ��豸(pSendBuf�ڴ����û������ͷ�)
CLIENT_NET_API LONG  CALL_METHOD CLIENT_TalkSendData(LLONG lTalkHandle, char *pSendBuf, DWORD dwBufSize);

// ������Ƶ����(pAudioDataBuf�ڴ����û������ͷ�)
CLIENT_NET_API void CALL_METHOD CLIENT_AudioDec(char *pAudioDataBuf, DWORD dwBufSize);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioDecEx(LLONG lTalkHandle, char *pAudioDataBuf, DWORD dwBufSize);

// ��������Խ�������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAudioClientVolume(LLONG lTalkHandle, WORD wVolume);

// ֹͣ����Խ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalkEx(LLONG lTalkHandle);

// ����豸���㲥��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastAddDev(LLONG lLoginID);

// �ӹ㲥����ɾ���豸
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastDelDev(LLONG lLoginID);

// ��Ƶ����--��ʼ��(�ض���׼��ʽ->˽�и�ʽ)
CLIENT_NET_API int  CALL_METHOD CLIENT_InitAudioEncode(DH_AUDIO_FORMAT aft);

// ��Ƶ����--���ݱ���(lpInBuf, lpOutBuf�ڴ����û������ͷ�)
CLIENT_NET_API int    CALL_METHOD    CLIENT_AudioEncode(LLONG lTalkHandle, BYTE *lpInBuf, DWORD *lpInLen, BYTE *lpOutBuf, DWORD *lpOutLen);

// ��Ƶ����--����˳�
CLIENT_NET_API int    CALL_METHOD    CLIENT_ReleaseAudioEncode();

//------------------------------------------------------------------------

// ��ѯ�豸��־(pLogBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLog(LLONG lLoginID, char *pLogBuffer, int maxlen, int *nLogBufferlen, int waittime=3000);

// ��ѯ�豸��־���Է�ҳ��ʽ��ѯ(pQueryParam, pLogBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceLog(LLONG lLoginID, QUERY_DEVICE_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, int waittime=3000);

// ��ѯ�豸��־����(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevLogCount(LLONG lLoginID, NET_IN_GETCOUNT_LOG_PARAM *pInParam, NET_OUT_GETCOUNT_LOG_PARAM* pOutParam , int waittime=3000);

// ���ͨ��¼��״̬(pRSBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, int waittime=1000);

// ���������ͨ��¼��״̬�������ֽ�����ͨ������Ӧ, ÿ���ֽڱ�ʾ��Ӧͨ���ĸ�����¼�����״̬,0-�ر�,1-�ֶ�,2-�Զ�,pRSBuffer�ڴ����û������ͷţ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryExtraRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, void *pReserved, int waittime=1000);

// ��ѯ�豸״̬(pBuf�ڴ����û������ͷ�,����nType����ȷ����Ӧ�ṹ�壬������Ҫ����ṹ���С���ڴ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevState(LLONG lLoginID, int nType, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// ��ѯԶ���豸״̬,nTypeΪDH_DEVSTATE_ALARM_FRONTDISCONNECTʱ��ͨ���Ŵ�1��ʼ(pBuf�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRemotDevState(LLONG lLoginID, int nType, int nChannelID, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// ��ѯϵͳ������Ϣ(pSysInfoBuffer�ڴ����û������ͷţ���С����DH_SYS_ABILITY��Ӧ�Ľṹ�壬��nSystemTypeΪ ABILITY_DYNAMIC_CONNECT ���ڴ��С����Ϊsizeof(BOOL),��nSystemTypeΪABILITY_TRIGGER_MODE���ڴ��СΪsizeof(int))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemInfo(LLONG lLoginID, int nSystemType, char *pSysInfoBuffer, int maxlen, int *nSysInfolen, int waittime=1000);

// ��ϵͳ������ѯ�ӿڣ���ѯϵͳ������Ϣ(��Json��ʽ�����������SDK)(szOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNewSystemInfo(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=1000);

// ��ȡͨ������
CLIENT_NET_API LONG  CALL_METHOD CLIENT_GetStatiscFlux(LLONG lLoginID, LLONG  lPlayHandle);

// ��ȡ��̨��Ϣ(lpOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetPtzOptAttr(LLONG lLoginID,DWORD dwProtocolIndex,LPVOID lpOutBuffer,DWORD dwBufLen,DWORD *lpBytesReturned,int waittime=500);

// �豸��������, ��ӦCLIENT_GetDevCaps�ӿ�
#define NET_DEV_CAP_SEQPOWER            0x01                // ��Դʱ��������, pInBuf=NET_IN_CAP_SEQPOWER*, pOutBuf=NET_OUT_CAP_SEQPOWER*
#define NET_ENCODE_CFG_CAPS             0x02                // �豸�������ö�Ӧ����, pInBuf=NET_IN_ENCODE_CFG_CAPS*, pOutBuf= NET_OUT_ENCODE_CFG_CAPS*
#define NET_VIDEOIN_FISHEYE_CAPS        0x03                // ��������, pInBuf=NET_IN_VIDEOIN_FISHEYE_CAPS*, pOutBuf=NET_OUT_VIDEOIN_FISHEYE_CAPS*
#define NET_COMPOSITE_CAPS              0x04                // ����ָ���Ĵ��ں�Ԥ�Ȼ�ȡ�ںϺ��������, pInBuf=NET_IN_COMPOSITE_CAPS*, pOutBuf=NET_OUT_COMPOSITE_CAPS*
#define NET_VIDEO_DETECT_CAPS           0x05                // ��ȡ��Ƶ�������������,pInBuf=NET_IN_VIDEO_DETECT_CAPS* , pOutBuf=NET_OUT_VIDEO_DETECT_CAPS*
#define NET_THERMO_GRAPHY_CAPS          0x06                // �ȳ�������ͷ��������,pInBuf=NET_IN_THERMO_GETCAPS*, pOutBuf=NET_OUT_THERMO_GETCAPS*
#define NET_RADIOMETRY_CAPS             0x07                // �ȳ������ȫ����������,pInBuf=NET_IN_RADIOMETRY_GETCAPS*, pOutBuf=NET_OUT_RADIOMETRY_GETCAPS*
#define NET_POS_CAPS                    0x08                // POS������,pInBuf = NET_IN_POS_GETCAPS *, pOutBuf = NET_OUT_POS_GETCAPS *
#define NET_USER_MNG_CAPS               0x09                // �û���������, pInBuf = NET_IN_USER_MNG_GETCAPS *, pOutBuf = NET_OUT_USER_MNG_GETCAPS *
#define NET_MEDIAMANAGER_CAPS           0x0a                // ��ȡ VideoInput �ĸ���������,pInBuf=NET_IN_MEDIAMANAGER_GETCAPS*, pOutBuf=NET_OUT_MEDIAMANAGER_GETCAPS*
#define	NET_VIDEO_MOSAIC_CAPS			0x0b				// ��ȡͨ�������˵�������,pInBuf=NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS*, pOutBuf=NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS*
#define NET_SNAP_CFG_CAPS               0x0c                // �豸ץͼ���ö�Ӧ����, pInBuf=NET_IN_SNAP_CFG_CAPS*, pOutBuf= NET_OUT_SNAP_CFG_CAPS*
#define NET_VIDEOIN_CAPS                0x0d                // �豸��Ƶ�������, pInBUf = NET_IN_VIDEOIN_CAPS*, pOutBuf = NET_OUT_VIDEOIN_CAPS*
#define NET_FACE_BOARD_CAPS             0x0e                // ����豸������, pInBuf = NET_IN_FACEBOARD_CAPS*, pOutBuf = NET_OUT_FACEBOARD_CAPS*
#define NET_EXTERNALSENSOR_CAPS			0x0f				// �ⲿ������������������pInBuf = NET_IN_EXTERNALSENSOR_CAPS*, pOutBuf = NET_OUT_EXTERNALSENSOR_CAPS*
#define NET_VIDEO_IMAGECONTROL_CAPS		0x10				// ͼ����ת��������, pInBuf = NET_IN_VIDEO_IMAGECONTROL_CAPS*, pOutBuf = NET_OUT_VIDEO_IMAGECONTROL_CAPS*
#define NET_VIDEOIN_EXPOSURE_CAPS		0x11				// �ع���������, pInBuf = NET_IN_VIDEOIN_EXPOSURE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_EXPOSURE_CAPS*
#define NET_VIDEOIN_DENOISE_CAPS		0x12				// ��������, pInBuf = NET_IN_VIDEOIN_DENOISE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DENOISE_CAPS*
#define NET_VIDEOIN_BACKLIGHT_CAPS		0x13				// ������������, pInBuf = NET_IN_VIDEOIN_BACKLIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_BACKLIGHT_CAPS*
#define NET_VIDEOIN_WHITEBALANCE_CAPS	0x14				// ��ƽ����������, pInBuf = NET_IN_VIDEOIN_WHITEBALANCE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_WHITEBALANCE_CAPS*
#define NET_VIDEOIN_DAYNIGHT_CAPS		0x15				// �����о��ҹ��������, pInBuf = NET_IN_VIDEOIN_DAYNIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DAYNIGHT_CAPS*
#define NET_VIDEOIN_ZOOM_CAPS			0x16				// �䱶��������, pInBuf = NET_IN_VIDEOIN_ZOOM_CAPS*, pOutBuf = NET_OUT_VIDEOIN_ZOOM_CAPS*
#define	NET_VIDEOIN_FOCUS_CAPS			0x17				// �۽���������, pInBuf = NET_IN_VIDEOIN_FOCUS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_FOCUS_CAPS*
#define NET_VIDEOIN_SHARPNESS_CAPS		0x18				// �����������, pInBuf = NET_IN_VIDEOIN_SHARPNESS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_SHARPNESS_CAPS*
#define NET_VIDEOIN_COLOR_CAPS			0x19				// ͼ����������, pInBuf = NET_IN_VIDEOIN_COLOR_CAPS*, pOutBuf = NET_OUT_VIDEOIN_COLOR_CAPS*
#define NET_GET_MASTERSLAVEGROUP_CAPS	0X1a				// ��ȡ����ҵ������, pInBuf = NET_IN_GET_MASTERSLAVEGROUP_CAPS*, pOutBuf = NET_OUT_GET_MASTERSLAVEGROUP_CAPS*
#define NET_FACERECOGNITIONSE_CAPS		0x1b				// ����ʶ�������������ѯ pInBuf = NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY, pOutBuf = NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY *
#define NET_STORAGE_CAPS				0x1c				// ��ȡ�洢������, pInBuf = NET_IN_STORAGE_CAPS*, pOutBuf = NET_OUT_STORAGE_CAPS*
#define NET_VIDEOIN_RAWFRAME_CAPS		0x1d				// ��ȡ��Ƶ������չ������, pInBuf = NET_IN_VIDEOIN_RAWFRAME_CAPS*, pOutBuf = NET_OUT_VIDEOIN_RAWFRAME_CAPS*


// ��ȡ�豸����(pInBuf, pOutBuf�ڴ����û������ͷţ�����nType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevCaps(LLONG lLoginID, int nType, void* pInBuf, void* pOutBuf, int nWaitTime);

// �豸��Ϣ����,��ӦCLIENT_QueryDevInfo�ӿ�
#define NET_QUERY_DEV_STORAGE_NAMES                 0x01                // ��ѯ�豸�Ĵ洢ģ�����б� , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
#define NET_QUERY_DEV_STORAGE_INFOS                 0x02                // ��ѯ�豸�Ĵ洢ģ����Ϣ�б�, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
#define NET_QUERY_RECENCY_JNNCTION_CAR_INFO         0x03                // ��ѯ����Ŀ��ڳ�����Ϣ�ӿ�, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
#define NET_QUERY_LANES_STATE                       0x04                // ��ѯ������Ϣ,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
#define NET_QUERY_DEV_FISHEYE_WININFO               0x05                // ��ѯ���۴�����Ϣ , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
#define NET_QUERY_DEV_REMOTE_DEVICE_INFO            0x06                // ��ѯԶ���豸��Ϣ , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
#define NET_QUERY_SYSTEM_INFO                       0x07                // ��ѯ�豸ϵͳ��Ϣ , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*
#define NET_QUERY_REG_DEVICE_NET_INFO               0x08                // ��ѯ����ע���豸���������� , pInBuf=NET_IN_REGDEV_NET_INFO * , pOutBuf=NET_OUT_REGDEV_NET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_PRESET          0x09                // ��ѯ�ȳ���Ԥ����Ϣ , pInBuf= NET_IN_THERMO_GET_PRESETINFO*, pOutBuf= NET_OUT_THERMO_GET_PRESETINFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION       0x0a                // ��ѯ�ȳ������Ȥ������Ϣ,pInBuf= NET_IN_THERMO_GET_OPTREGION*, pOutBuf= NET_OUT_THERMO_GET_OPTREGION *
#define NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO      0x0b                // ��ѯ�ȳ����ⲿϵͳ��Ϣ, pInBuf= NET_IN_THERMO_GET_EXTSYSINFO*, pOutBuf= NET_OUT_THERMO_GET_EXTSYSINFO *
#define NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER       0x0c                // ��ѯ���µ�Ĳ���ֵ, pInBuf= NET_IN_RADIOMETRY_GETPOINTTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETPOINTTEMPER *
#define NET_QUERY_DEV_RADIOMETRY_TEMPER             0x0d                // ��ѯ������Ĳ���ֵ, pInBuf= NET_IN_RADIOMETRY_GETTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETTEMPER *
#define NET_QUERY_GET_CAMERA_STATE                  0x0e                // ��ȡ�����״̬, pInBuf= NET_IN_GET_CAMERA_STATEINFO*, pOutBuf= NET_OUT_GET_CAMERA_STATEINFO *
#define NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE   0x0f                // ��ȡԶ��ͨ����Ƶ���뷽ʽ, pInBuf= NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO*, pOutBuf= NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO *
#define NET_QUERY_GET_COMM_PORT_INFO                0x10                // ��ȡ�豸������Ϣ, pInBuf=NET_IN_GET_COMM_PORT_INFO* , pOutBuf=NET_OUT_GET_COMM_PORT_INFO* 
#define NET_QUERY_GET_LINKCHANNELS                  0x11                // ��ѯĳ��Ƶͨ���Ĺ���ͨ���б�,pInBuf=NET_IN_GET_LINKCHANNELS* , pOutBuf=NET_OUT_GET_LINKCHANNELS*
#define NET_QUERY_GET_VIDEOOUTPUTCHANNELS           0x12                // ��ȡ����ͨ������ͳ����Ϣ, pInBuf=NET_IN_GET_VIDEOOUTPUTCHANNELS*, pOutBuf=NET_OUT_GET_VIDEOOUTPUTCHANNELS*
#define NET_QUERY_GET_VIDEOINFO                     0x13                // ��ȡ����ͨ����Ϣ, pInBuf=NET_IN_GET_VIDEOINFO*, pOutBuf=NET_OUT_GET_VIDEOINFO*
#define NET_QUERY_GET_ALLLINKCHANNELS               0x14                // ��ѯȫ����Ƶ����ͨ���б�,pInBuf=NET_IN_GET_ALLLINKCHANNELS* , pOutBuf=NET_OUT_GET_ALLLINKCHANNELS*
#define NET_QUERY_VIDEOCHANNELSINFO                 0x15                // ��ѯ��Ƶͨ����Ϣ,pInBuf=NET_IN_GET_VIDEOCHANNELSINFO* , pOutBuf=NET_OUT_GET_VIDEOCHANNELSINFO*
#define NET_QUERY_TRAFFICRADAR_VERSION              0x16                // ��ѯ�״��豸�汾,pInBuf=NET_IN_TRAFFICRADAR_VERSION* , pOutBuf=NET_OUT_TRAFFICRADAR_VERSION*
#define NET_QUERY_WORKGROUP_NAMES                   0x17                // ��ѯ���еĹ���Ŀ¼����,pInBuf=NET_IN_WORKGROUP_NAMES* , pOutBuf=NET_OUT_WORKGROUP_NAMES*
#define NET_QUERY_WORKGROUP_INFO                    0x18                // ��ѯ��������Ϣ,pInBuf=NET_IN_WORKGROUP_INFO* , pOutBuf=NET_OUT_WORKGROUP_INFO*
#define NET_QUERY_WLAN_ACCESSPOINT                  0x19                // ��ѯ��������������Ϣ,pInBuf=NET_IN_WLAN_ACCESSPOINT* , pOutBuf=NET_OUT_WLAN_ACCESSPOINT*
#define NET_QUERY_GPS_INFO							0x1a				// ��ѯ�豸GPS��Ϣ,pInBuf=NET_IN_DEV_GPS_INFO* , pOutBuf=NET_OUT_DEV_GPS_INFO*
#define NET_QUERY_IVS_REMOTE_DEVICE_INFO            0x1b                // ��ѯIVS��ǰ���豸��������Զ���豸��Ϣ, pInBuf = NET_IN_IVS_REMOTE_DEV_INFO*, pOutBuf = NET_OUT_IVS_REMOTE_DEV_INFO*
#define NET_QUERY_SMART_SWITCH_INFO                 0x1c                // ��ѯ���ܲ�����Ϣ, pInBuf = NET_IN_SMART_SWITCH_INFO*,  pOutBuf = NET_OUT_SMART_SWITCH_INFO*
#define NET_QUERY_UPGRADE_STATE                     0x1d                // ��ѯ����״̬��Ϣ, pInBuf = NET_IN_UPGRADE_STATE*, pOutBuf = NET_OUT_UPGRADE_STATE* 
#define NET_QUERY_VIDEO_ENCODE_CAPS					0x1e				// ��ȡ��Ƶ����������, pInBuf = NET_IN_VIDEO_ENCODE_CAPS*, pOutBuf = NET_OUT_VIDEO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_ENCODE_CAPS					0x1f				// ��ȡ��Ƶ����������, pInBuf = NET_IN_AUDIO_ENCODE_CAPS*, pOutBuf = NET_OUT_AUDIO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_IN_CAPS						0x20				// ��ȡ��Ƶ����ͨ��������, pInBuf = NET_IN_AUDIO_IN_CAPS*, pOutBuf = NET_OUT_AUDIO_IN_CAPS* 
#define NET_QUERY_SMART_ENCODE_CAPS					0x21				// ��ѯSmart����������, pInBuf = NET_IN_SMART_ENCODE_CAPS*, pOutBuf = NET_OUT_SMART_ENCODE_CAPS* 
#define NET_QUERY_HARDDISK_TEMPERATURE				0X22				// ��ȡӲ���¶�,pInBuf = NET_IN_HDD_TEMPERATURE*, pOutBuf = NET_OUT_HDD_TEMPERATURE*
#define NET_QUERY_RAWFRAMEDATA						0x23				// ��ȡָ����ʽ��YUV����, pInBuf = NET_IN_RAWFRAMEDATA*, pOutBuf = NET_OUT_RAWFRAMEDARA*
// ��ѯ�豸��Ϣ(pInBuf, pOutBuf�ڴ����û������ͷ�,����nQueryType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_QueryDevInfo(LLONG lLoginID, int nQueryType, void* pInBuf, void* pOutBuf, void *pReserved = NULL , int nWaitTime = 1000);
//------------------------------------------------------------------------

// �����豸
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RebootDev(LLONG lLoginID);

// �ر��豸
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ShutDownDev(LLONG lLoginID);

// �豸����(param�ڴ����û������ͷţ���С����type���Ͷ�Ӧ�Ľṹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDevice(LLONG lLoginID, CtrlType type, void *param, int waittime = 1000);

// �첽�豸����(param�ڴ����û������ͷţ���С����type���Ͷ�Ӧ�Ľṹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartControlDevice(LLONG lLoginID, CtrlType type, void *param);

// �豸������չ�ӿڣ����� CLIENT_ControlDevice (pInBuf, pOutBuf�ڴ����û������ͷ�,����emTypeȷ����Ӧ�ṹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDeviceEx(LLONG lLoginID, CtrlType emType, void* pInBuf, void* pOutBuf = NULL, int nWaitTime = 1000);

#define DH_POS_EXCHANGE_GOODS_MAX				4			//��ѯʱ���֧�ֵ���Ʒ��
#define DH_POS_EXCHANGE_FUSSY_KEY_MAX			4			//ģ����ѯ���֧�ֵĹؼ�������

// POS��ȡ������Ϣģ����ѯKEYֵ����
typedef enum tagEM_NET_POS_EXCHANGE_FUSSY_KEY
{
    EM_NET_POS_EXCHANGE_KEY_NULL = 0,                      // ������ģ����ѯ,������ֻҪ��һ��ֵΪEM_NET_POS_EXCHANGE_KEY_NULL֮�����ֵ��Ŀǰֻ��EM_NET_POS_EXCHANGE_KEY_GOODS��,�ͻ������Ӧ�ֶε�ģ����ѯ
    EM_NET_POS_EXCHANGE_KEY_GOODS = 1,                     // ģ����ѯ��ʱ���� ��Ʒ�� ΪKEYֵ(Ŀǰֻ֧��ģ����ѯ��Ʒ��)
} EM_NET_POS_EXCHANGE_FUSSY_KEY;

// �ӿ� CLIENT_StartFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_IN_POSEXCHANGE_STARTFIND
{
	DWORD                            dwSize;															//�ṹ���С
    int	                             nChannel;															//��Ҫ������ͨ����,��0��ʼ,Ԫ��Ϊ-1ʱ,��ʾȫͨ����
    NET_TIME_EX	                     stuStartTime;														//��ʼʱ��,����, ����û��
    NET_TIME_EX	                     stuEndTime;														//����ʱ��,�����ʾ����Ϊֹ, ����û��
	char						     szGoods[DH_POS_EXCHANGE_GOODS_MAX][DH_COMMON_STRING_32];			//��Ʒ��,��ѡ,�ַ���
	EM_NET_POS_EXCHANGE_FUSSY_KEY    szFuzzyPattern[DH_POS_EXCHANGE_FUSSY_KEY_MAX];	            		//ָ��ģ����ѯ�Ĺؼ���,δָ���ؼ��ֵ�ʹ�þ�ȷ��ѯ,
																								    	//����,����Ҫģ����ѯʱ��NULL
    int                              nPosId;                                                            //PosΨһ��ʶ, -1��ʶȫ��
} NET_IN_POSEXCHANGE_STARTFIND;

// �ӿ� CLIENT_StartFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_OUT_POSEXCHANGE_STARTFIND
{
    DWORD                dwSize;                         // �˽ṹ���С
    unsigned int		 nToken;						 // ��ѯ����
    DWORD                dwTotalCount;                   // �����������ܸ���
}NET_OUT_POSEXCHANGE_STARTFIND;

// �ӿ� CLIENT_DoFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_IN_POSEXCHANGE_DOFIND
{
    DWORD                dwSize;                         // �˽ṹ���С
	unsigned int         nToken;						 // ��ѯ����
	unsigned int		 nBeginNumber;					 // ��ʼ���	0<=dwBeginNumber<=dwTotalCount-1
	unsigned int         nCount;						 // ÿ�β�ѯ��POS������Ϣ����
} NET_IN_POSEXCHANGE_DOFIND;

// POS������Ϣ
typedef struct tagNET_POSEXCHANGE_INFO
{
	NET_TIME			stuExchangeTime;				//���׷���ʱ��
}NET_POSEXCHANGE_INFO;

// POS������Ϣ��չ�ֶ�
typedef struct tagNET_POSEXCHANGE_INFO_EX
{
    int                 nPosId;                         // PosΨһ��ʶ
    char                cDetail[512];                   // ���׵ľ�����Ϣ
    int                 nDetailLen;                     // ���׵ľ�����Ϣ����
    BYTE                reserved[1024];                 // Ԥ��
} NET_POSEXCHANGE_INFO_EX;

// �ӿ� CLIENT_DoFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_OUT_POSEXCHANGE_DOFIND
{
    DWORD						dwSize;												// �˽ṹ���С
    DWORD						dwFound;											// ��ѯ���ĸ���
	NET_POSEXCHANGE_INFO		arrPOSExchangeInfo[DH_MAX_POS_EXCHANGE_INFO];		// ��ѯ���Ľ�����Ϣ�б�
    NET_POSEXCHANGE_INFO_EX     stuInfoEx[DH_MAX_POS_EXCHANGE_INFO];                // ������Ϣ
}NET_OUT_POSEXCHANGE_DOFIND;

// CLIENT_StopFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_IN_POSEXCHANGE_STOPFIND
{   
    DWORD               dwSize;								// �˽ṹ���С
    unsigned int        nToken;								// ��ѯ����
} NET_IN_POSEXCHANGE_STOPFIND;

// CLIENT_StopFind �ӿ� NET_FIND_POS_EXCHANGE �������
typedef struct tagNET_OUT_POSEXCHANGE_STOPFIND
{   
    DWORD               dwSize;								// �˽ṹ���С
} NET_OUT_POSEXCHANGE_STOPFIND;

// �豸��Ϣ����,��Ӧ CLIENT_StartFind CLIENT_DoFind CLIENT_StopFind �ӿ�
typedef enum tagNET_FIND {
    NET_FIND_RADIOMETRY,                            // �ȳ����¶Ȳ�ѯ, pInBuf= NET_IN_RADIOMETRY_*FIND*, pOutBuf= NET_OUT_RADIOMETRY_*FIND*   
	NET_FIND_POS_EXCHANGE,							// POS������Ϣ��ѯ,pInBuf = NET_IN_POSEXCHANGE_*FIND*,pOutBuf= NET_OUT_POSEXCHANGE_*FIND*
} NET_FIND;

// ����ص���ʽ
typedef enum tagNET_VIDEOSTREAM_TYPE
{
	NET_VIDEOSTREAM_NORMAL,							// Ĭ�ϸ�ʽ
	NET_VIDEOSTREAM_YUV,							// YUV��ʽ
} NET_VIDEOSTREAM_TYPE;


#define MAX_EVENT_LINK_QUERY_CODE_NUMBER	8		// ÿ�β�ѯ�������
#define MAX_EVENT_LINK_NAME_NUMBER			16		// ÿ���¼������������

typedef enum tagEM_NET_QUERY_CODE {
		EM_NET_QUERY_CODE_UNKNOWN,					// δ֪
		EM_NET_QUERY_CODE_CROSSLINEDETECTION,		// ������/�����¼�	CrossLineDetection
		EM_NET_QUERY_CODE_CROSSREGIONDETECTION,		// �������¼�		CrossRegionDetection
		EM_NET_QUERY_CODE_TAKENAWAYDETECTION,		// ��Ʒ�����¼�		TakenAwayDetection
		EM_NET_QUERY_CODE_LEFTDETECTION,			// ��Ʒ�����¼�		LeftDetection
		EM_NET_QUERY_CODE_PARKINGDETECTION,			// �Ƿ�ͣ���¼�		ParkingDetection
		EM_NET_QUERY_CODE_WANDERDETECTION,			// �ǻ��¼�			WanderDetection
		EM_NET_QUERY_CODE_MOVEDETECTION,			// �˶�����¼�		MoveDetection
		EM_NET_QUERY_CODE_FACEDETECTION,			// ��������¼�		FaceDetection
		EM_NET_QUERY_CODE_RETROGRADEDETECTION,		// ��Ա�����¼�		RetrogradeDetection
		EM_NET_QUERY_CODE_NUMBERSTAT,				// ������/������ͳ���¼�	NumberStat
		EM_NET_QUERY_CODE_TRAFFICJUNCTION,			// �½�ͨ·���¼�	TrafficJunction
		EM_NET_QUERY_CODE_RIOTERDETECTION,			// �����¼�			RioterDetection
		EM_NET_QUERY_CODE_ALARMLOCAL,				// �����ⲿ�����¼�	AlarmLocal
		EM_NET_QUERY_CODE_VIDEOMOTION,				// ��Ƶ�ƶ�����¼�	VideoMotion
		EM_NET_QUERY_CODE_VIDEOBLIND,				// ��Ƶ�ڵ��¼�		VideoBlind
		EM_NET_QUERY_CODE_AUDIODETECT,				// ��������¼�		AudioDetect
		EM_NET_QUERY_CODE_AUDIOANOMALY,				// �����쳣�¼�		AudioAnomaly
		EM_NET_QUERY_CODE_AUDIOMUTATION,			// ��ǿͻ���¼�		AudioMutation
		EM_NET_QUERY_CODE_SCENECHANGE,				// IPC��������¼�	SceneChange
		EM_NET_QUERY_CODE_VIDEOUNFOCUS,				// ��Ƶ�齹�¼�		VideoUnFocus
		EM_NET_QUERY_CODE_STORAGELOWSPACE,			// Ӳ�̿ռ�ͱ����¼�	StorageLowSpace
		EM_NET_QUERY_CODE_STORAGEFAILURE,			// �洢�����¼�		StorageFailure
		EM_NET_QUERY_CODE_LOGINFAILURE,				// ��½ʧ���¼�		LoginFailure
		EM_NET_QUERY_CODE_STORAGENOTEXIST,			// �洢�鲻�����¼�	StorageNotExist
		EM_NET_QUERY_CODE_IPCONFLICT,				// IP��ͻ�¼�		IPConflict
		EM_NET_QUERY_CODE_NETABORT,					// �豸��������¼�	NetAbort
		EM_NET_QUERY_CODE_HOTPLUG,					// �Ȳ���¼�		HotPlug
		EM_NET_QUERY_CODE_STORAGEFORMAT,			// �洢��ʽ			StorageFormat
		EM_NET_QUERY_CODE_EMERGENCYRECORDPULL,		// ��¼�񱨾��¼�	EmergencyRecordPull
} EM_NET_QUERY_CODE;


typedef enum tagEM_NET_LINK_NAME {
		EM_NET_LINK_NAME_UNKNOWN,				// δ֪
		EM_NET_LINK_NAME_DEFAULT,				// Ĭ������,��eventManager.getCaps��ȡ������		default
		EM_NET_LINK_NAME_TIMESECTIONENABLE,		// ʱ���¼���Ӧ	TimeSectionEnable
		EM_NET_LINK_NAME_RECORDENABLE,			// ¼��			RecordEnable
		EM_NET_LINK_NAME_RECORDCLOUDENABLE,		// ¼���ƴ洢	RecordCloudEnable
		EM_NET_LINK_NAME_ALARMOUTENABLE,		// �������		AlarmOutEnable
		EM_NET_LINK_NAME_PTZLINKENABLE,			// ��̨����		PtzLinkEnable
		EM_NET_LINK_NAME_SNAPSHOTENABLE,		// ����			SnapshotEnable
		EM_NET_LINK_NAME_SNAPSHOTCLOUDENABLE,	// ץͼ�ƴ洢	SnapshotCloudEnable
		EM_NET_LINK_NAME_MAILENABLE,			// �����ʼ�		MailEnable
		EM_NET_LINK_NAME_BEEPENABLE,			// ����			BeepEnable
		EM_NET_LINK_NAME_DEJITTERENABLE,		// ȥ����		DejitterEnable
		EM_NET_LINK_NAME_TIPENABLE,				// ������Ϣ����ʾ	TipEnable
		EM_NET_LINK_NAME_MONITORTOURENABLE,		// ��ѯ��������	MonitorTourEnable
		EM_NET_LINK_NAME_MMSENABLE,				// ����Ϣ		MMSEnable
		EM_NET_LINK_NAME_SUPPORTALARMBELL,		// �������		SupportAlarmBell
		EM_NET_LINK_NAME_SUPPORTACCESSCONTROL,	// �Ž�����		SupportAccessControl
		EM_NET_LINK_NAME_SIPCALLENABLE,			// SIP���		SipCallEnable
		EM_NET_LINK_NAME_SUPPORTALARMSERVER,	// �ϴ�������������	SupportAlarmServer
		EM_NET_LINK_NAME_SUPPORTPTZLINKDELAY,	// ��̨�����ӳ�	SupportPtzLinkDelay
		EM_NET_LINK_NAME_SUPPORTPSTNALARMSERVER,// �ϴ����绰��������	SupportPSTNAlarmServer
		EM_NET_LINK_NAME_SUPPORTICR,			// ICR(˫�˹�Ƭ�л�)�л�	SupportICR
		EM_NET_LINK_NAME_BEEPTIME,				// ����ʱ������	BeepTime
		EM_NET_LINK_NAME_DEJITTERRANGE,			// ȥ������Χ	DejitterRange
		EM_NET_LINK_NAME_ALARMOUTLATCH,			// ���������ʱ	AlarmOutLatch
		EM_NET_LINK_NAME_RECORDLATCH,			// ¼����ʱ		RecordLatch
		EM_NET_LINK_NAME_VOICEENABLE,			// ������ʾ		VoiceEnable
		EM_NET_LINK_NAME_LOGENABLE,				// ������־		LogEnable
		EM_NET_LINK_NAME_SUPPORTLIGHTCONTROL,	// �����ƹ������	SupportLightControl
		EM_NET_LINK_NAME_SUPPORTVIDEOMATRIX,	// ������Ƶ����	SupportVideoMatrix
} EM_NET_LINK_NAME;

// CLIENT_getEventLink �ӿ����
typedef struct tagNET_IN_EVENT_LINK
{   
    DWORD               dwSize;					// �˽ṹ���С
	int					nCodeNum;				// ��ѯ�����¼�����
	EM_NET_QUERY_CODE	szCodeName[MAX_EVENT_LINK_QUERY_CODE_NUMBER];		// ��ѯ�����¼��б�
} NET_IN_EVENT_LINK;

// CLIENT_getEventLink �ӿڳ���
typedef struct tagNET_OUT_EVENT_LINK
{   
    DWORD               dwSize;						// �˽ṹ���С
	EM_NET_LINK_NAME	szLinkName[MAX_EVENT_LINK_QUERY_CODE_NUMBER][MAX_EVENT_LINK_NAME_NUMBER];		// ����������
} NET_OUT_EVENT_LINK;

// ��ʼ��ѯ��Ϣ����ȡ��ѯ�����(pInBuf, pOutBuf�ڴ����û������ͷ�,����emType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// ��ѯ��Ϣ(pInBuf, pOutBuf�ڴ����û������ͷ�,����emType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// ֹͣ��ѯ��Ϣ�����ٲ�ѯ�����(pInBuf, pOutBuf�ڴ����û������ͷ�,����emType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);

// ����ͨ��¼��״̬(pRsBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen);

// ����ͨ��������¼��״̬(pRsBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupExtraRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen, void* pReserved);

// ��ѯIO״̬(pState�ڴ����û������ͷ�,����emType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryIOControlState(LLONG lLoginID, DH_IOTYPE emType, 
                                           void *pState, int maxlen, int *nIOCount, int waittime=1000);

// IO����(pState�ڴ����û������ͷ�,����emType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IOControl(LLONG lLoginID, DH_IOTYPE emType, void *pState, int maxlen);

// ǿ��I֡��nChannelID��ͨ����,nSubChannel����������(0����,1��������1)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MakeKeyFrame(LLONG lLoginID, int nChannelID, int nSubChannel=0);

// ��������ע��
typedef void (CALLBACK *fConnectMessCallBack)(LLONG lConnectHandle, NET_CLOUDSERVICE_CONNECT_RESULT* pConnectResult, void* pReserved, LDWORD dwUser);
// ��������ע��,pConnectParm�ڴ����û������ͷ�,��СΪsizeof(NET_CLOUDSERVICE_CONNECT_PARAM)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ConnectCloudService(LLONG lLoginID, NET_CLOUDSERVICE_CONNECT_PARAM* pConnectParm, fConnectMessCallBack pConnectMessCB, LDWORD dwUser, void* pReserved);
//------------------------------------------------------------------------

// ��ѯ�û���Ϣ(info�ڴ����û������ͷ�,��СΪsizeof(USER_MANAGE_INFO))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfo(LLONG lLoginID, USER_MANAGE_INFO *info, int waittime=1000);

// ��ѯ�û���Ϣ--��չ(info�ڴ����û������ͷ�,��СΪsizeof(USER_MANAGE_INFO_EX))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoEx(LLONG lLoginID, USER_MANAGE_INFO_EX *info, int waittime=1000);

// ��ѯ�û���Ϣ--���֧��64ͨ���豸(info�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoNew(LLONG lLoginID, USER_MANAGE_INFO_NEW *info, void* pReserved, int waittime = 1000);

// �����豸�û�(opParam, subParam�ڴ����û������ͷ�,����nOperateType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfo(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// �����豸�û�--��չ(opParam, subParam�ڴ����û������ͷ�,����nOperateType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoEx(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// �����豸�û�--���֧��64ͨ���豸(opParam, subParam�ڴ����û������ͷ�,����nOperateType��Ӧ�������ҵ���Ӧ�Ľṹ�壬����ȷ�������ڴ��С)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoNew(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, void* pReserved, int waittime = 1000);

//------------------------------------------------------------------------

// ����͸������ͨ��,TransComType��2���ֽڱ�ʾ�������,��2���ֽڱ�ʾ��������,Ŀǰ����֧��0������,1:485
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CreateTransComChannel(LLONG lLoginID, int TransComType, unsigned int baudrate, unsigned int databits, unsigned int stopbits, unsigned int parity, fTransComCallBack cbTransCom, LDWORD dwUser);

// ͸�����ڷ�������(pBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTransComData(LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize);

// �ͷ�ͨ������ͨ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DestroyTransComChannel(LLONG lTransComChannel);

// ��ѯ͸������״̬(pCommState�ڴ����û������ͷ�)
CLIENT_NET_API BOOL   CALL_METHOD CLIENT_QueryTransComParams(LLONG lLoginID, int TransComType, DH_COMM_STATE* pCommState, int nWaitTime = 500);

//------------------------------------------------------------------------

// ��ʼ�����豸����,pchFileName���û������ͷ��ڴ棬��СΪMAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgrade(LLONG lLoginID, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// ��ʼ�����豸����--��չ,pchFileName���û������ͷ��ڴ棬��СΪMAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

//��ʼ�����豸����--��չ֧��G�����ļ�����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx2(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBackEx cbUpgrade, LDWORD dwUser);

// ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendUpgrade(LLONG lUpgradeID);

// ���������豸����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUpgrade(LLONG lUpgradeID);

//------------------------------------------------------------------------

// ��ѯ������Ϣ(lpOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);

// ����������Ϣ(lpInBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// �����ýӿڣ���ѯ������Ϣ(��Json��ʽ�����������SDK)(szOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// �����ýӿڣ�����������Ϣ(��Json��ʽ�����������SDK)(szInBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// ɾ�����ýӿ�(Json��ʽ)(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteDevConfig(LLONG lLoginID, NET_IN_DELETECFG* pInParam, NET_OUT_DELETECFG* pOutParam, int waittime=500);

// ��ȡ���ó�Ա���ƽӿ�(Json��ʽ)(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMemberNames(LLONG lLoginID, NET_IN_MEMBERNAME* pInParam, NET_OUT_MEMBERNAME* pOutParam, int waittime=500);

// ��ȡ������Ϣ(lpInParam, lpOutParam�ڴ����û������ͷ�,��С����emType��Ӧ�Ľṹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNetStat(LLONG lLoginID , EM_NET_QUERY_TYPE emType , void *lpInParam , int nInParamLen , void *lpOutParam , int nOutParamLen , int *pError = NULL , int nWaitTime=1000);
// VideoInAnalyse����(szOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInAnalyse(LLONG 	lLoginID, char* szCommand, int nChannelID, EM_SCENE_CLASS_TYPE emClassType, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// ��ȡָ���¼�������������(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLink(LLONG lLoginID, NET_IN_EVENT_LINK* pInParam, NET_OUT_EVENT_LINK* pOutParam, int nWaitTime);

//------------------------------------------------------------------------

// ��ѯ�豸ͨ������(pChannelName�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryChannelName(LLONG lLoginID, char *pChannelName, int maxlen, int *nChannelCount, int waittime=1000);

// �����豸ͨ������(pbuf �ڴ����û������ͷ�,�����С����Ϊ512�ֽ�)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelName(LLONG lLoginID,char *pbuf, int nbuflen);

// �����豸ͨ���ַ�����(struOsdString�ڴ����û������ͷ�)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelOsdString(LLONG lLoginID, int nChannelNo, DH_CHANNEL_OSDSTRING* struOsdString, int nbuflen);

// ��ѯ�豸��ǰʱ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime, int waittime=1000);

// �����豸��ǰʱ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime);

// ��ѯ�豸��ǰʱ����չ�ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime, int waittime=1000);

// �����豸��ǰʱ����չ�ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime);


// �����豸��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMaxFlux(LLONG lLoginID, WORD wFlux);

//------------------------------------------------------------------------

// ���������ļ�,szFileName���û������ͷ��ڴ棬��СΪMAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportConfigFile(LLONG lLoginID, char *szFileName, fDownLoadPosCallBack cbUploadPos, LDWORD dwUserData, DWORD param=0);

// ֹͣ���������ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportCfgFile(LLONG lImportHandle);

// ���������ļ�,szSavedFilePath���û������ͷ��ڴ棬��СΪMAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportConfigFile(LLONG lLoginID, DH_CONFIG_FILE_TYPE emConfigFileType, char *szSavedFilePath, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// ֹͣ���������ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportCfgFile(LLONG lExportHandle);

//------------------------------------------------------------------------

// ͨ���豸���ֻ����豸���к���DDNS��������ѯ�豸IP
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDVRIPByResolveSvr(char *pchDVRIP, WORD wDVRPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP);

// ������������IPC��NVS���豸(szBuf�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevices(char* szBuf, int nBufLen, int* pRetLen, DWORD dwSearchTime, char* szLocalIp=NULL);

// �첽������������IPC��NVS���豸,pUserData��ʾ�û����ݣ���֧�ֶ��̵߳���
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevices(fSearchDevicesCB cbSearchDevices, void* pUserData, char* szLocalIp=NULL);

// ֹͣ�첽������������IPC��NVS���豸
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSearchDevices(LLONG lSearchHandle);

// �޸��豸IP (pDevNetInfo�ڴ����û������ͷ�):��֧�ֶ��̵߳���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDevice(DEVICE_NET_INFO_EX *pDevNetInfo, DWORD dwWaitTime, int *iError = NULL, char* szLocalIp = NULL, void *reserved = NULL);

// �����������豸IP (pIpSearchInfo�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPs(DEVICE_IP_SEARCH_INFO* pIpSearchInfo, fSearchDevicesCB cbSearchDevices, LDWORD dwUserData, char* szLocalIp, DWORD dwWaitTime);
// pstParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceSearchParam(const NET_DEVICE_SEARCH_PARAM* pstParam);
//------------------------------------------------------------------------

// ƽ̨����ӿ�(lpOutBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);
// lpInBuffer�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// ��ͷ�۽�����
//    dwFocusCommand = 0Ϊ�۽�����
//    dwFocusCommand = 1Ϊ�����۽�����
//    dwFocusCommand = 2Ϊ�Զ��۽�����,���ڽ��������λ�á�nFocus��nZoom��Ч��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FocusControl(LLONG lLoginID, int nChannelID, DWORD dwFocusCommand, double nFocus, double nZoom, void *reserved = NULL, int waittime=500);

///////////////////////////////�����豸�ӿ�///////////////////////////////

// ����ץͼ�ص�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetSnapRevCallBack(fSnapRev OnSnapRevMessage, LDWORD dwUser);

// ץͼ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPicture(LLONG lLoginID, SNAP_PARAMS par);

// ץͼ������չ�ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureEx(LLONG lLoginID, SNAP_PARAMS *par, int *reserved = 0);

// ץͼͬ���ӿ�,��ͼƬ����ֱ�ӷ��ظ��û�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureToFile(LLONG lLoginID, const NET_IN_SNAP_PIC_TO_FILE_PARAM* pInParam, NET_OUT_SNAP_PIC_TO_FILE_PARAM* pOutParam, int nWaitTime);

// ����GPS���Ļص�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBack(fGPSRev OnGPSMessage, LDWORD dwUser);

// ����GPS���Ļص�����--��չ
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX(fGPSRevEx OnGPSMessage, LDWORD dwUser);

// ����GPS���Ļص�����--��չ2
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX2(fGPSRevEx2 OnGPSMessage, LDWORD dwUser);

/**************************************************************************************
*   Funcname: CLIENT_SubcribeGPS
*   Purpose:GPS��Ϣ����
*   InputParam:   LLONG  :lLoginID    //��½���
*   InputParam:   BOOL   :bStart      //TRUE:����  FALSE:ȡ������
*   InputParam:   LONG   :KeepTime    //���ĳ���ʱ��(��λ��) ֵΪ-1ʱ,����ʱ��Ϊ����ֵ,����Ϊ���ö���
*   InputParam:   LONG   :InterTime   //����ʱ����GPS����Ƶ��(��λ��)
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPS (LLONG lLoginID, BOOL bStart, LONG KeepTime, LONG InterTime);

// ����GPS��ʪ�ȶ��Ļص�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSTHCallBack(fGPSTempHumidityRev OnGPSMessage, LDWORD dwUser);

// GPS��ʪ����Ϣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPSTempHumidity (LLONG lLoginID, BOOL bStart,    int InterTime, void* Reserved);

//GPS��־��Ϣ��ѯ(pQueryParam, pLogBuffer�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryGPSLog(LLONG lLoginID,QUERY_GPS_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, BOOL *bContinue, int waittime);

// ��������(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachMission(LLONG lLoginID, NET_IN_ATTACH_MISSION_PARAM *pInParam, NET_OUT_ATTACH_MISSION_PARAM *pOutParam, int nWaitTime);

// ȡ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMission(LLONG lAttachHandle);

// ���������ȷ��(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusConfirmEvent(LLONG lLoginID, const NET_IN_BUS_CONFIRM_EVENT* pInParam, NET_OUT_BUS_CONFIRM_EVENT* pOutParam, int nWaitTime = 3000);

// �����豸��ַ��Ϣ(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevicePosition(LLONG lLoginID, const NET_IN_SET_DEVICE_POSITION* pInParam, NET_OUT_SET_DEVICE_POSITION* pOutParam, int nWaitTime);

// ��ȡ�豸��ַ��Ϣ(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevicePosition(LLONG lLoginID, const NET_IN_GET_DEVICE_POSITION* pInParam, NET_OUT_GET_DEVICE_POSITION* pOutParam, int nWaitTime);

// ����ʱ������ץͼ�����CLIENT_RealLoadPic()��CLIENT_RealLoadPicEx()�ӿ�ʹ��, �����ֶ�ץ��ģʽ(Manual)����,ͼƬͨ���ص����û���(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByEvent(LLONG lLoginID, const NET_IN_SNAP_BY_EVENT* pInParam, NET_OUT_SNAP_BY_EVENT* pOutParam, int nWaitTime);

//////////////////////////////�������豸�ӿ�//////////////////////////////

// ��ѯ��������Ϣ(lpDecInfo�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderInfo(LLONG lLoginID, LPDEV_DECODER_INFO lpDecInfo, int waittime=1000);

// ��ѯ��������ǰTV��Ϣ(lpMonitorInfo�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTVInfo(LLONG lLoginID, int nMonitorID, LPDEV_DECODER_TV lpMonitorInfo, int waittime=1000);

// ��ѯ����ͨ����Ϣ(lpEncoderInfo�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecEncoderInfo(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, int waittime=1000);

// ���ý�����TV���ʹ��(pDecTVOutEnable�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecTVOutEnable(LLONG lLoginID, BYTE *pDecTVOutEnable, int nBufLen, int waittime=1000);

// ���ý�������ʾ������Ϣʹ��,ͨ���Ŵ�0��ʼ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecLayOutEnable(LLONG lLoginID, BYTE bDecLayOutEnable, int nChannel, int waittime=1000);
// ��ȡ��������ʾ������Ϣʹ��,ͨ���Ŵ�0��ʼ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecLayOutEnable(LLONG lLoginID, BYTE *pDecLayOutEnable, int nChannel, int waittime=1000);
//------------------------------------------------------------------------

// �����첽�ص�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOperateCallBack(LLONG lLoginID, fMessDataCallBack cbMessData, LDWORD dwUser);

// ���ƽ�����TV����ָ�,�ӿ�Ϊ�첽��ʽ nSplitType=-1ʱ,pEncoderChannelΪ�ṹ��DH_CTRL_DECTV_SCREENָ��
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CtrlDecTVScreen(LLONG lLoginID, int nMonitorID, BOOL bEnable, int nSplitType, BYTE *pEncoderChannel, int nBufLen, void* userdata=NULL);

// ������TV�����л�,�ӿ�Ϊ�첽��ʽ(lpEncoderInfo�ڴ����û������ͷ�)
//   
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SwitchDecTVEncoder(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, void* userdata=NULL);

//------------------------------------------------------------------------

// ���ӻ������
CLIENT_NET_API int CALL_METHOD CLIENT_AddTourCombin(LLONG lLoginID, int nMonitorID, int nSplitType, BYTE *pEncoderChannnel, int nBufLen, int waittime=1000);

// ɾ���������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int waittime=1000);

// �޸Ļ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int nSplitType, BYTE *pEncoderChannel, int nBufLen, int waittime=1000);

// ��ѯ�������,nCombinID��Χ0��32
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, LPDEC_COMBIN_INFO lpDecCombinInfo, int waittime=1000);

// ������Ѳ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// ��ѯ��Ѳ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// ��ѯ��ǰ����ͨ������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecChannelFlux(LLONG lLoginID, int nDecoderID, LPDEV_DECCHANNEL_STATE lpChannelStateInfo, int waittime=1000);

// ������������Ѳ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecoderTour(LLONG lLoginID, int nMonitorID, DEC_CTRL_TOUR_TYPE emActionParam, int waittime = 1000);
//------------------------------------------------------------------------

typedef void (CALLBACK *fDecPlayBackPosCallBack)(LLONG lLoginID, int nEncoderID, DWORD dwTotalSize, DWORD dwPlaySize, LDWORD dwUser);

// ���ûطŽ��Ȼص�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecPlaybackPos(LLONG lLoginID, fDecPlayBackPosCallBack cbPlaybackPos, LDWORD dwUser);

// ������TV����ط�,�ӿ�Ϊ�첽��ʽ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DecTVPlayback(LLONG lLoginID, int nDecoderID, DEC_PLAYBACK_MODE emPlaybackMode, LPVOID lpInBuffer, DWORD dwInBufferSize, void* userdata=NULL);

// ������TV����طſ���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecPlayback(LLONG lLoginID, int nDecoderID, DEC_CTRL_PLAYBACK_TYPE emCtrlType, int nValue, int waittime=1000);

///////////////////////////////�����豸�ӿ�///////////////////////////////

// ʵʱ�ϴ����ܷ������ݣ�ͼƬ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPicture(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

// ʵʱ�ϴ����ܷ������ݣ�ͼƬ(��չ�ӿ�,bNeedPicFile��ʾ�Ƿ���ͼƬ�ļ�,Reserved����Ϊ RESERVED_PARA)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPictureEx(LLONG lLoginID, int nChannelID, 
                                                     DWORD dwAlarmType, 
                                                     BOOL bNeedPicFile, 
                                                     fAnalyzerDataCallBack cbAnalyzerData, 
                                                     LDWORD dwUser, 
                                                     void* Reserved);

// ֹͣ�ϴ����ܷ������ݣ�ͼƬ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadPic(LLONG lAnalyzerHandle);

// ȷ���ϴ�ͼƬ�Ƿ�����ɣ�ͼƬ
// �ýӿڲ����� CLIENT_RealLoadPictureEx/CLIENT_RealLoadPicture �Ļص�������ͬһ�߳�,���������,������������߳��е���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapManagerConfirmUpload(LLONG lLoginID, const NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD* pstInParam, NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD* pstOutParam, int waittime=1000);

// ����ѯ������ѯ�ļ�,pQueryCondition���û������ͷ��ڴ棬��С����emType��Ӧ�Ľṹ��
CLIENT_NET_API LLONG    CALL_METHOD CLIENT_FindFileEx(LLONG lLoginID, EM_FILE_QUERY_TYPE emType, void* pQueryCondition, void *reserved, int waittime=1000);    

// �����ļ�:nFilecount:��Ҫ��ѯ������, ����ֵΪý���ļ����� ����ֵ<nFilecount����Ӧʱ����ڵ��ļ���ѯ���
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextFileEx(LLONG lFindHandle, int nFilecount, void* pMediaFileInfo, int maxlen, void *reserved, int waittime=1000);

// ����¼���ļ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindCloseEx(LLONG lFindHandle);

// ��ȡ���ϲ�ѯ�������ļ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTotalFileCount(LLONG lFindHandle, int* pTotalCount, void *reserved, int waittime=1000);

// ���ò�ѯ��ת����,pOption���û������ͷ��ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFindingJumpOption(LLONG lFindHandle, NET_FINDING_JUMP_OPTION_INFO* pOption, void *reserved, int waittime=1000);

// ����ָ�������ܷ������� - ͼƬ,lpMediaFileInfo���û������ͷ��ڴ棬�ڴ��С����emTypeȷ����Ӧ�Ľṹ��
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadMediaFile(LLONG lLoginID,EM_FILE_QUERY_TYPE emType, void* lpMediaFileInfo, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData,  void *reserved);

// ֹͣ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownloadMediaFile(LLONG lFileHandle);

// ���������ļ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadMultiFile(LLONG lLoginID, NET_IN_DOWNLOAD_MULTI_FILE *pstInParam, NET_OUT_DOWNLOAD_MULTI_FILE *pstOutParam, int waittime=1000);

// ֹͣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadMultiFile(LLONG lDownLoadHandle);

// �����������ܷ������ݣ�ͼƬ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoadOffLineFile(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, LPNET_TIME_EX lpStartTime, LPNET_TIME_EX lpEndTime, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

//��ͣ���ܷ�����������(bPause=TRUE ��ʾ��ͣ����, bPause=FALSE ��ʾ�ָ�����)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseLoadPic(LLONG lLoadHadle, BOOL bPause);

// ��ͨץ��--���紥����ʽ��pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficSnapByNetwork(LLONG lLoginID, int nChannelID, NET_IN_SNAPSHOT* pstInParam, NET_OUT_SNAPSHOT* pstOutParam);

// ��ͨ����--ǿ�ƺ�ƣ�pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficForceLightState(LLONG lLoginID, int nChannelID, NET_IN_FORCELIGHTSTATE* pstInParamg, NET_OUT_FORCELIGHTSTATE* pstOutParam, int waittime=1000);

//  �ڰ���������,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTrafficList(LLONG lLoginID ,  NET_IN_OPERATE_TRAFFIC_LIST_RECORD* pstInParam , NET_OUT_OPERATE_TRAFFIC_LIST_RECORD *pstOutParam = NULL ,  int waittime = 1000);

// ��ͨ����ͳ��,pstInParamg��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTrafficFluxStat(LLONG lLoginID, NET_IN_TRAFFICFLUXSTAT* pstInParam,NET_OUT_TRAFFICFLUXSTAT* pstOutParam);

// ��������ͳ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTrafficFluxStat(LLONG lFluxStatHandle);

// ��ȡ����ͳ����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFluxStat(LLONG lLoginID, NET_IN_TRAFFICSTARTFINDSTAT* pstInParam, NET_OUT_TRAFFICSTARTFINDSTAT* pstOutParam);

// ������ѯ����ͳ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API int    CALL_METHOD CLIENT_DoFindFluxStat(LLONG lFindHandle, NET_IN_TRAFFICDOFINDSTAT* pstInParam,NET_OUT_TRAFFICDOFINDSTAT* pstOutParam);

// ������ѯ����ͳ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFluxStat(LLONG lFindHandle);

// ��ʼ��ѯ��Ƶͳ����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStat(LLONG lLoginID, NET_IN_FINDNUMBERSTAT* pstInParam, NET_OUT_FINDNUMBERSTAT* pstOutParam);

// ������ѯ��Ƶͳ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API int  CALL_METHOD CLIENT_DoFindNumberStat(LLONG lFindHandle, NET_IN_DOFINDNUMBERSTAT* pstInParam, NET_OUT_DOFINDNUMBERSTAT* pstOutParam);

// ������ѯ��Ƶͳ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStat(LLONG lFindHandle);

// ������Ƶͳ��ժҪ��Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatSummary(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_SUM* pInParam, NET_OUT_ATTACH_VIDEOSTAT_SUM* pOutParam, int nWaitTime);

// ȡ��������Ƶͳ��ժҪ��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatSummary(LLONG lAttachHandle);

// ��Ƶ�����豸�ķ�������,pstInParam��pstOutParam�ڴ����û������ͷţ���С����szCmd��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoAnalyseDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// ��ȡ��Ƶ��������,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseGetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// ������Ƶ��������,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseSetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// �����豸�ķ�������,pstInParam��pstOutParam�ڴ����û������ͷţ���С����szCmd��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCommDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// ���ܸ�������ƽӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlIntelliTracker(LLONG lLoginID, NET_IN_CONTROL_INTELLITRACKER* pstInParam, NET_OUT_CONTROL_INTELLITRACKER* pstOutParam);

// ����ʽ�豸�ķ�������,��������μ����涨��CLIENT_OperateMasterSlaveDevice�ӿڲ�������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// ��Ƶƴ�ӷ�������,pstInParam��pstOutParam�ڴ����û������ͷţ���С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoJoin(LLONG lLoginID, NET_VIDEOJOIN_OPERATE_TYPE emType, void* pstInParam, void* pstOutParam, int nWaitTime);

////  ��Ƶ���

// ʵʱ��ȡ��Ƶ��Ͻ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartVideoDiagnosis(LLONG lLoginID, NET_IN_VIDEODIAGNOSIS *pstInParam, NET_OUT_VIDEODIAGNOSIS *pstOutParam);

// ֹͣ��Ƶ��Ͻ���ϱ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopVideoDiagnosis(LLONG hDiagnosisHandle);

// ��ʼ��Ƶ��Ͻ����ѯ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindDiagnosisResult(LLONG lLoginID, NET_IN_FIND_DIAGNOSIS* pstInParam, NET_OUT_FIND_DIAGNOSIS* pstOutParam);

// ��ȡ��Ƶ��Ͻ����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindDiagnosisResult(LLONG hFindHandle,NET_IN_DIAGNOSIS_INFO* pstInParam, NET_OUT_DIAGNOSIS_INFO* pstOutParam);

// ������Ƶ��Ͻ����ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindDiagnosis(LLONG hFindHandle);

// ��ʵʱ��ϼƻ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartRealTimeProject(LLONG lLoginID,NET_IN_START_RT_PROJECT_INFO* pstInParam, NET_OUT_START_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// ֹͣʵʱ��ϼƻ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealTimeProject(LLONG lLoginID,NET_IN_STOP_RT_PROJECT_INFO* pstInParam, NET_OUT_STOP_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// ��ȡ���ܽ�ͨ��λ״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetParkingSpaceStatus(LLONG lLoginID, NET_IN_GET_PARKINGSPACE_STATUS* pstInParam, NET_OUT_GET_PARKINGSPACE_STATUS* pstOutParam);

// ����ָ���ĳ�λͼƬ��Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachParkingSpaceData(LLONG lLoginID, NET_IN_ATTACH_PARKINGSPACE* pstInParam, NET_OUT_ATTACH_PARKINGSPACE* pstOutParam);

// ȡ������ָ���ĳ�λͼƬ��Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachParkingSpaceData(NET_IN_DETACH_PARKINGSPACE* pstInParam, NET_OUT_DETACH_PARKINGSPACE* pstOutParam);

// ���Ĺ�����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCarPassInfo(LLONG lLoginID, NET_IN_ATTACH_CAR_PASS_INFO* pstInParam, NET_OUT_ATTACH_CAR_PASS_INFO* pstOutParam , int nWaitTime);

// ȡ�����Ĺ�����Ϣ lCarPassInfoHandle Ϊ CLIENT_AttachCarPassInfo ���صľ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCarPassInfo(LLONG lCarPassInfoHandle);

// ����ָ��������Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLanesState(LLONG lLoginID, NET_IN_ATTACH_LANES_STATE* pstInParam, NET_OUT_ATTACH_LANES_STATE* pstOutParam, int nWaitTime);

// ȡ������ָ��������Ϣ lLanesStateHandleΪCLIENT_AttachLanesState���صľ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLanesState(LLONG lLanesStateHandle);

// ��ȡ��λ��״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCarPortLightStatus(LLONG lLoginID, NET_IN_GET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_GET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// ���ó�λ��״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCarPortLightStatus(LLONG lLoginID, NET_IN_SET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_SET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// �������ܷ������ȣ���������Ƶ����ԴΪ¼���ļ�ʱ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachVideoAnalyseState(LLONG lLoginID, NET_IN_ATTACH_VIDEOANALYSE_STATE* pstInParam, NET_OUT_ATTACH_VIDEOANALYSE_STATE* pstOutParam, int nWaittime=1000);

// ֹͣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoAnalyseState(LLONG lAttachHandle);

// ����ǰ���豸�Խ�״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachTalkState(LLONG lLoginID, NET_IN_ATTACH_TALK_STATE* pstInParam, NET_OUT_ATTACH_TALK_STATE* pstOutParam, int nWaitTime = 1000);

// ȡ������ǰ���豸�Խ�״̬, lAttachHandleΪCLIENT_AttachTalkState���صľ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachTalkState(LLONG lAttachHandle);

////////////////////////////////��ƵŨ���ӿ�////////////////////////////////

// �����ƵŨ������,�ýӿڰ��ļ�����������,�������.
// �µ�IVS-S�Ѳ�֧�����ַ�ʽ,��ת��CLIENT_PreHandleVideoSynopsisTask��CLIENT_RunVideoSynopsisTask����Ͻӿ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddVideoSynopsisTask(LLONG lLoginID,   NET_IN_ADD_VIDEOSYNOPSIS* pstInParam, NET_OUT_ADD_VIDEOSYNOPSIS* pstOutParam);

//IVS-S���õ���Ũ����ʽ,�ȶ���Ƶ�ļ�����Ԥ����(�ȽϺ�ʱ),��Ԥ����Ļ����Ͽ��Ե�����Ƶ��������,�Ӷ����ͬһ�ļ����ٵõ���ͬ��Ũ�����.
//��Ƶ�ļ�Ԥ����ӿ�
//����TRUE��ʾ����ȫ���ɹ�,����FALSE��ʾ������һ������ʧ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreHandleVideoSynopsisTask(LLONG lLoginID,  const NET_IN_PRE_HANDLE_VIDEOSYNOPSIS* pstInParam, NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS* pstOutParam);

//��ƵŨ������ӿ�
//����TRUE��ʾ����ȫ���ɹ�,����FALSE��ʾ������һ������ʧ��,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RunVideoSynopsisTask(LLONG lLoginID, const NET_IN_RUN_VIDEOSYNOPSIS_TASK* pstInParam, NET_OUT_RUN_VIDEOSYNOPSIS_TASK* pstOutParam);

// ��ͣ��ƵŨ������,pstInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseVideoSynopsisTask(LLONG lLoginID, NET_IN_PAUSE_VIDEOSYNOPSIS* pstInParam);

// �Ƴ���ƵŨ������,pstInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveVideoSynopsisTask(LLONG lLoginID, NET_IN_REMOVE_VIDEOSYNOPSIS* pstInParam);

// ����ʵʱŨ����Ƶ������ϢpstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadObjectData(LLONG lLoginID, NET_IN_REALLOAD_OBJECTDATA* pstInParam, NET_OUT_REALLOAD_OBJECTDATA* pstOutParam);

// ֹͣ����ʵʱŨ����Ƶ������Ϣ,pstInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadObjectData(LLONG lRealLoadHandle, NET_IN_STOPLOAD_OBJECTDATA* pstInParam);

// ����ʵʱŨ����Ƶ������Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadSynopsisState(LLONG lLoginID, NET_IN_REALLAOD_SYNOPSISSTATE* pstInParam, NET_OUT_REALLOAD_SYNOPSISSTATE* pstOutParam);

// ֹͣ����ʵʱŨ����Ƶ������Ϣ,pstInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynopsisState(LLONG lRealLoadHandle, NET_IN_STOPLOAD_SYNOPSISSTATE* pstInParam);

// ��ѯŨ����Ƶ���������Ϣ�ӿ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoSynopsisInfo(LLONG lLoginID, NET_IN_QUERY_VIDEOSYNOPSIS* pstInParam, NET_OUT_QUERY_VIDEOSYNOPSIS* pstuOutParam);

// ����ѯ������ѯ��ƵŨ���ļ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindSynopsisFile(LLONG lLoginID, NET_IN_FIND_SYNOPSISFILE *pstInParam, NET_OUT_FIND_SYNOPSISFILE *pstOutParam);    

// ������ƵŨ���ļ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextSynopsisFile(LLONG lFindHandle, NET_IN_FINDNEXT_SYNOPSISFILE *pstInParam, NET_OUT_FINDNEXT_SYNOPSISFILE *pstOutParam);

// ������ƵŨ���ļ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SynopsisFindClose(LLONG lFindHandle);

// ������ƵŨ������ļ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadSynosisFile(LLONG lLoginID, NET_IN_DOWNLOAD_SYNOPSISFILE *pstInParam, NET_OUT_DOWNLOAD_SYNOPSISFILE *pstOutParam);

// ֹͣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynosisFile(LLONG lDownLoadHandle);

// ����Ũ����Ƶ�����������ļ�(��)·��,�����ļ���Ϣ,pstInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_SetFilePathInfo(LLONG lLoginID, NET_IN_SET_FILEPATHINFO* pstInParam);

// ��������ļ���Ϣ״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddFileState(LLONG lLoginID, const NET_IN_ADDFILE_STATE* pstInParam, NET_OUT_ADDFILE_STATE *pstOutParam, int nWaitTime = 1000);

// ȡ����������ļ���Ϣ״, lAttachHandle��CLIENT_AttacAddFileState����ֵ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DetachAddFileState(LLONG lAttachHandle);

/////////////////////////////////����ʶ��ӿ�/////////////////////////////////////////
// ����ʶ�����ݿ���Ϣ�������������,�޸ĺ�ɾ����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionDB(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITIONDB* pstInParam, NET_OUT_OPERATE_FACERECONGNITIONDB *pstOutParam, int nWaitTime = 1000);

// ��������ѯ����ʶ���� ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// ��ʼ�������/ע���Ķ�ͨ����ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITION *pstOutParam, int nWaitTime);

// ��������ʶ����:nFilecount:��Ҫ��ѯ������, ����ֵΪý���ļ����� ����ֵ<nFilecount����Ӧʱ����ڵ��ļ���ѯ���(ÿ�����ֻ�ܲ�ѯ20����¼),pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognition(const NET_IN_DOFIND_FACERECONGNITION* pstInParam, NET_OUT_DOFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// ������ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognition(LLONG lFindHandle);

// ��ʼ����ʶ���ͨ����ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognitionRecord(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// ��ͨ�������ļ�:nFilecount:��Ҫ��ѯ������, ����ֵΪý���ļ����� ����ֵ<nFilecount����Ӧʱ����ڵ��ļ���ѯ���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognitionRecord(const NET_IN_DOFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_DOFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// ������ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognitionRecord(LLONG lFindHandle);

// �������(����һ�Ŵ�ͼ,�����ͼ�б�������������ͼƬ),pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectFace(LLONG lLoginID, const NET_IN_DETECT_FACE* pstInParam, NET_OUT_DETECT_FACE *pstOutParam, int nWaitTime = 1000);

// ����ʶ����Ա��������������,�޸ĺ�ɾ����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionGroup(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITION_GROUP* pstInParam, NET_OUT_OPERATE_FACERECONGNITION_GROUP *pstOutParam, int nWaitTime = 1000);

// ����ʶ����Ա���Ͳ������������,�޸ĺ�ɾ����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// ����ʶ���ȡ��Ա����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_GET_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_GET_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// ��ѯ����ʶ����Ա����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindGroupInfo(LLONG lLoginID, const NET_IN_FIND_GROUP_INFO* pstInParam, NET_OUT_FIND_GROUP_INFO *pstOutParam, int nWaitTime = 1000);

// ����ͨ����Ա����Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGroupInfoForChannel(LLONG lLoginID, const NET_IN_SET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_SET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime = 1000);

//����������ѯ״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceFindState(LLONG lLoginID, const NET_IN_FACE_FIND_STATE* pstInParam, NET_OUT_FACE_FIND_STATE *pstOutParam, int nWaitTime = 1000);

//ȡ������������ѯ״̬,lAttachHandleΪCLIENT_AttachFaceFindState���صľ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceFindState(LLONG lAttachHandle);

// ���ü�����ͼƬ��Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionSetSearchImageInfo(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO *pstOutParam, int nWaitTime = 1000);
//////////////////////////////// ��¼�ϴ��ӿ� /////////////////////////////////

// �򿪿�¼�Ự, ���ؿ�¼�Ự���,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartBurnSession(LLONG lLoginID, const NET_IN_START_BURN_SESSION* pstInParam, NET_OUT_START_BURN_SESSION *pstOutParam, int nWaitTime);

// �رտ�¼�Ự
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurnSession(LLONG lBurnSession);

// ��ʼ��¼,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBurn(LLONG lBurnSession, const NET_IN_START_BURN* pstInParam, NET_OUT_START_BURN *pstOutParam, int nWaitTime);

// ֹͣ��¼
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurn(LLONG lBurnSession);

// ��ͣ/�ָ���¼
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseBurn(LLONG lBurnSession, BOOL bPause);

// �ص���,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnMarkTag(LLONG lBurnSession, const NET_IN_BURN_MARK_TAG* pstInParam, NET_OUT_BURN_MARK_TAG *pstOutParam, int nWaitTime);

// ����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnChangeDisk(LLONG lBurnSession, const NET_IN_BURN_CHANGE_DISK* pstInParam, NET_OUT_BURN_CHANGE_DISK *pstOutParam, int nWaitTime);

// ��ȡ��¼״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnGetState(LLONG lBurnSession, const NET_IN_BURN_GET_STATE* pstInParam, NET_OUT_BURN_GET_STATE *pstOutParam, int nWaitTime);

// ������¼״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnState(LLONG lLoginID, const NET_IN_ATTACH_STATE* pstInParam, NET_OUT_ATTACH_STATE *pstOutParam, int nWaitTime = 1000);

// ȡ��������¼״̬,lAttachHandle��CLIENT_AttachBurnState����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnState(LLONG lAttachHandle);

// ��¼�ϴ���ʼ ���ش˴��ϴ��������, ע�����½ӿڲ�����fAttachBurnStateCB�ص������������,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadFileBurned(LLONG lLoginID, const NET_IN_FILEBURNED_START* pstInParam, NET_OUT_FILEBURNED_START *pstOutParam, int nWaitTime = 1000);

// ��¼�ϴ��ļ�,lUploadHandle��CLIENT_StartUploadFileBurned����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendFileBurned(LLONG lUploadHandle);

// ��¼�ϴ�ֹͣ,lUploadHandle��CLIENT_StartUploadFileBurned����ֵ,�˽ӿڲ�����fBurnFileCallBack�ص������е���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadFileBurned(LLONG lUploadHandle);

// ������¼У��״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCheckState(LLONG lLoginID, const NET_IN_ATTACH_BURN_CHECK* pstInParam, NET_OUT_ATTACH_BURN_CHECK* pstOutParam, int nWaitTime = 1000);

// ȡ��������¼У��״̬,lAttachHandle��CLIENT_AttachBurnCheckState����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCheckState(LLONG lAttachHandle);

// ���Ŀ�¼������Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCase(LLONG lLoginID, const NET_IN_ATTACH_BURN_CASE* pInParam, NET_OUT_ATTACH_BURN_CASE* pOutParam, int nWaitTime);

// ȡ�����Ŀ�¼������Ϣ,lAttachHandle��CLIENT_AttachBurnCase����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCase(LLONG lAttachHandle);

// ���Ŀ�¼�豸״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnDevState(LLONG lLoginID, const NET_IN_ATTACH_BURN_DEV_STATE* pInParam, NET_OUT_ATTACH_BURN_DEV_STATE* pOutParam, int nWaitTime = 3000);

// ȡ�����Ŀ�¼�豸״̬, lAttachHandle �� CLIENT_AttachBurnDevState ����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnDevState(LLONG lAttachHandle);


// �໤������
typedef struct tagNET_BODY_MIND_DATA_INFO
{
    DWORD       dwSize;
    UINT        nECG;               // ����ֵ,��λbpm
    UINT        nECGMax;            // ���ʱ�������ֵ,��λbpm
    UINT        nECGMin;            // ���ʱ�������ֵ,��λbpm
    UINT        nSPO2;              // Ѫ��ֵ,��λ%
    UINT        nSPO2Max;           // Ѫ������ֵ����ֵ,��λ%
    UINT        nSPO2Min;           // Ѫ������ֵ����ֵ,��λ%
    UINT        nRESP;              // ����ֵ,��λBrPM
    UINT        nRESPMax;           // ��������ֵ����,��λBrPM
    UINT        nRESPMin;           // ��������ֵ����,��λBrPM
    UINT        nNIBP_SYS;          // ����ѹ����ѹ��ֵ,��λmmHg
    UINT        nNIBP_SYSMax;       // ����ѹ����ֵ����,��λmmHg
    UINT        nNIBP_SYSMin;       // ����ѹ����ֵ����,��λmmHg
    UINT        nNIBP_AVG;          // ƽ��ѹֵ,��λmmHg
    UINT        nNIBP_AVGMax;       // ƽ��ѹ����ֵ����,��λmmHg
    UINT        nNIBP_AVGMin;       // ƽ��ѹ����ֵ����,��λmmHg
    UINT        nNIBP_DIA;          // ����ѹ����ѹ��ֵ,��λmmHg
    UINT        nNIBP_DIAMax;       // ����ѹ����ֵ����,��λmmHg
    UINT        nNIBP_DIAMin;       // ����ѹ����ֵ����,��λmmHg
} NET_BODY_MIND_DATA_INFO;

// �໤�����ݻص�����ԭ��,lAttachHandle��CLIENT_AttachBodyMindData����ֵ
typedef void (CALLBACK *fBodyMindDataCallBack) (LLONG lAttachHandle, const NET_BODY_MIND_DATA_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBodyMindData �ӿ��������
typedef struct tagNET_IN_ATTACH_BODY_MIND_DATA
{
    DWORD                       dwSize;
    fBodyMindDataCallBack       cbBodyMindData;                    // �໤�����ݻص�����
    LDWORD                      dwUser;                            // �û�����
} NET_IN_ATTACH_BODY_MIND_DATA;

// CLIENT_AttachBodyMindData �ӿ��������
typedef struct tagNET_OUT_ATTACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BODY_MIND_DATA;

// CLIENT_DetachBodyMindData �ӿ��������
typedef struct tagNET_IN_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_IN_DETACH_BODY_MIND_DATA;

// CLIENT_DetachBodyMindData �ӿ��������
typedef struct tagNET_OUT_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_DETACH_BODY_MIND_DATA;


// ���ļ໤��������Ϣ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBodyMindData(LLONG lLoginID, const NET_IN_ATTACH_BODY_MIND_DATA* pstInParam, NET_OUT_ATTACH_BODY_MIND_DATA* pstOutParam, int nWaitTime);

// ȡ�����ļ໤��������Ϣ,lAttachHandle��CLIENT_AttachBodyMindData����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBodyMindData(LLONG lAttachHandle, const NET_IN_DETACH_BODY_MIND_DATA* pstInParam, NET_OUT_DETACH_BODY_MIND_DATA *pstOutParam, int nWaitTime);



//////////////////////////////// �߼��豸 /////////////////////////////////////////

// ��������ͷ״̬,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCameraState(LLONG lLoginID, const NET_IN_CAMERASTATE* pstInParam, NET_OUT_CAMERASTATE *pstOutParam, int nWaitTime = 3000);

// ֹͣ��������ͷ״̬,lAttachHandle��CLIENT_AttachCameraState����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCameraState(LLONG lAttachHandle);

// ��ȡ������Ч��ʾԴ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameras(LLONG lLoginID, const DH_IN_MATRIX_GET_CAMERAS* pInParam, DH_OUT_MATRIX_GET_CAMERAS* pOutParam, int nWaitTime = 1000);

// ����߼��豸,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCameras(LLONG lLoginID, const DH_IN_ADD_LOGIC_DEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_DEVICE_CAMERA* pOutParam, int nWaitTime = 1000);

// ���豸��Ϣ�����ʾԴ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByDevice(LLONG lLoginID, const DH_IN_ADD_LOGIC_BYDEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA* pOutParam, int nWaitTime = 1000);

// ���������ƵԴ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByGroup(LLONG lLoginID, const NET_IN_ADD_LOGIC_BYGROUP_CAMERA* pInParam, NET_OUT_ADD_LOGIC_BYGROUP_CAMERA* pOutParam, int nWaitTime = 1000);
//////////////////////////////// ����ӿ� /////////////////////////////////

// ��ѯ��Ʒ����(pstuProdDef�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryProductionDefinition(LLONG lLoginID, DH_PRODUCTION_DEFNITION* pstuProdDef, int nWaitTime = 1000);

// ��ѯ�����ӿ���Ϣ(pstuCardList�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryMatrixCardInfo(LLONG lLoginID, DH_MATRIX_CARD_LIST* pstuCardList, int nWaitTime = 1000);

// ��ѯϵͳ״̬(pstuStatus�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemStatus(LLONG lLoginID, DH_SYSTEM_STATUS* pstuStatus, int nWaitTime = 1000);

// ��ѯ�ָ�����(pstuCaps�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCaps(LLONG lLoginID, int nChannel, DH_SPLIT_CAPS* pstuCaps, int nWaitTime = 1000);

// ��ѯ/������ʾԴ(pstuSplitSrc�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitSource(LLONG lLoginID, int nChannel, int nWindow, DH_SPLIT_SOURCE* pstuSplitSrc, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSource(LLONG lLoginID, int nChannel, int nWindow, const DH_SPLIT_SOURCE* pstuSplitSrc, int nSrcCount, int nWaitTime = 1000);
// ������ʾԴ, ֧���������(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSourceEx(LLONG lLoginID, const NET_IN_SET_SPLIT_SOURCE* pInparam, NET_OUT_SET_SPLIT_SOURCE* pOutParam, int nWaitTime = 1000);

// ��ѯ/���÷ָ�ģʽ(pstuSplitInfo�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitMode(LLONG lLoginID, int nChannel, DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitMode(LLONG lLoginID, int nChannel, const DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);

// ��ѯ�ָ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitGroupCount(LLONG lLoginID, int nChannel, DH_SPLIT_MODE emSplitMode, int* pnGroupCount, int nWaitTime = 1000);

// ��ѯ��Ƶ�������(pstuCaps�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoOutCaps(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_CAPS* pstuCaps, int nWaitTime = 1000);

// ������Ƶ���ѡ��(pstuVideoOut�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVideoOutOption(LLONG lLoginID, int nChannel, const DH_VIDEO_OUT_OPT* pstuVideoOut, int nWaitTime = 1000);

// ��ѯ��Ƶ����ͨ��Ŀǰ���ĸ����������ʾ(pstuWnds�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoOutWindows(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_WINDOW* pstuWnds, int nMaxWndCount, int* pnRetWndCount, int nWaitTime = 1000);

// ���ô���λ��(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_SET_RECT* pInParam, DH_OUT_SPLIT_SET_RECT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_GET_RECT* pInParam, DH_OUT_SPLIT_GET_RECT* pOutParam, int nWaitTime = 1000);

// ����/�ش�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_OPEN_WINDOW* pInParam, DH_OUT_SPLIT_OPEN_WINDOW* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_CLOSE_WINDOW* pInParam, DH_OUT_SPLIT_CLOSE_WINDOW* pOutParam, int nWaitTime = 1000);

// ���ô��ڴ���(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitTopWindow(LLONG lLoginID, const DH_IN_SPLIT_SET_TOP_WINDOW* pInParam, DH_OUT_SPLIT_SET_TOP_WINDOW* pOutParam, int nWaitTime = 1000);

// ��ȡ��ǰ��ʾ�Ĵ�����Ϣ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowsInfo(LLONG lLoginID, const DH_IN_SPLIT_GET_WINDOWS* pInParam, DH_OUT_SPLIT_GET_WINDOWS* pOutParam, int nWaitTime = 1000);

// ����/�����ղؼ�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LoadSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_LOAD_COLLECTION* pInParam, DH_OUT_SPLIT_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_SAVE_COLLECTION* pInParam, DH_OUT_SPLIT_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// ��ȡ�ղؼ���Ϣ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCollections(LLONG lLoginID, const DH_IN_SPLIT_GET_COLLECTIONS* pInParam, DH_OUT_SPLIT_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// �������ղؼ�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_RENAME_COLLECTION* pInParam, DH_OUT_SPLIT_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// ɾ���ղؼ�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_DELETE_COLLECTION* pInParam, DH_OUT_SPLIT_DELETE_COLLECTION* pOutParam, int nWaitTime = 1000);

// �������(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecodePolicy(LLONG lLoginID, const DH_IN_SET_DEC_POLICY* pInParam, DH_OUT_SET_DEC_POLICY* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecodePolicy(LLONG lLoginID, const DH_IN_GET_DEC_POLICY* pInParam, DH_OUT_GET_DEC_POLICY* pOutParam, int nWaitTime = 1000);

// ��Ƶ���ģʽ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitAudioOuput(LLONG lLoginID, const DH_IN_SET_AUDIO_OUTPUT* pInParam, DH_OUT_SET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitAudioOuput(LLONG lLoginID, const DH_IN_GET_AUDIO_OUTPUT* pInParam, DH_OUT_GET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);

// ������ʾԴ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSetCameras(LLONG lLoginID, const DH_IN_MATRIX_SET_CAMERAS* pInParam, DH_OUT_MATRIX_SET_CAMERAS* pOutParam, int nWaitTime = 1000);

// ��ȡ��Ƶ��������(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInCaps(LLONG lLoginID, const DH_IN_GET_VIDEO_IN_CAPS* pInParam, DH_OUT_GET_VIDEO_IN_CAPS* pOutParam, int nWaitTime = 1000);

// ��ȡ��Ƶ���ģʽ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnumVideoOutModes(LLONG lLoginID, const DH_IN_ENUM_VIDEO_OUT_MODES* pInParam, DH_OUT_ENUM_VIDEO_OUT_MODES* pOutParam, int nWaitTime = 1000);

// ��ȡ/���ý��봰�����OSD��Ϣ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_GET_OSD* pInParam, DH_OUT_SPLIT_GET_OSD* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_SET_OSD* pInParam, DH_OUT_SPLIT_SET_OSD* pOutParam, int nWaitTime = 1000);

// ��ȡ/���ý��봰�����OSD��Ϣ��չ�ӿ�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_GET_OSD_EX* pInParam, NET_OUT_SPLIT_GET_OSD_EX* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_SET_OSD_EX* pInParam, NET_OUT_SPLIT_SET_OSD_EX* pOutParam, int nWaitTime = 1000);

// ���ô�����Ѳ��ʾԴ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourSource(LLONG lLoginID, const NET_IN_SET_TOUR_SOURCE* pInParam, NET_OUT_SET_TOUR_SOURCE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTourSource(LLONG lLoginID, const NET_IN_GET_TOUR_SOURCE* pInParam, NET_OUT_GET_TOUR_SOURCE* pOutParam, int nWaitTime);

// ������Ѳ״̬(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSplitTour(LLONG lLoginID, const NET_IN_ATTACH_SPLIT_TOUR* pInParam, NET_OUT_ATTACH_SPLIT_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSplitTour(LLONG lAttachHandle);

// ��λ�����л�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSwitch(LLONG lLoginID, const NET_IN_MATRIX_SWITCH* pInParam, NET_OUT_MATRIX_SWITCH* pOutParam, int nWaitTime);

// ������ʾԴ, ֧��ͬʱ���ö������(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitSetMultiSource(LLONG lLoginID, const NET_IN_SPLIT_SET_MULTI_SOURCE* pInParam, NET_OUT_SPLIT_SET_MULTI_SOURCE* pOutParam, int nWaitTime);

// ��Ƶ�ָ����(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplit(LLONG lLoginID, NET_SPLIT_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);
// ���Ĵ�����ʾԴ��Ϣ
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWindowsSource( LLONG lLoginID, const NET_IN_ATTACH_WINDOW_SOURCE* pInParam, NET_OUT_ATTACH_WINDOW_SOURCE* pOutParam, int nWaitTime );
// ȡ�����Ĵ�����ʾԴ��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWindowsSource( LLONG lAttachHandle );

// ����ͼ��ֲ��Ŵ�(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_WindowRegionEnlarge(LLONG lLoginID, const NET_IN_WINDOW_REGION_ENLARGE* pInParam, NET_OUT_WINDOW_REGION_ENLARGE* pOutParam, int nWaitTime);

// ����ͼ��ֲ��Ŵ�ԭ(pInparam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_WindowEnlargeReduction(LLONG lLoginID, const NET_IN_WINDOW_ENLARGE_REDUCTION* pInParam, NET_OUT_WINDOW_ENLARGE_REDUCTION* pOutParam, int nWaitTime);

// �ָ�ڲ��Ų�������
typedef enum tagNET_PLAYER_OPERATE_TYPE
{
    NET_PLAYER_OPERATE_OPEN,                // �򿪲�������NET_IN_PLAYER_OPEN��
    NET_PLAYER_OPERATE_CLOSE,               // �رղ�������NET_IN_PLAYER_CLOSE
    NET_PLAYER_OPERATE_START,               // ��ʼ���ţ�NET_IN_PLAYER_START
    NET_PLAYER_OPERATE_STOP,                // ֹͣ���ţ�NET_IN_PLAYER_STOP
    NET_PLAYER_OPERATE_PAUSE,               // ��ͣ/�ָ����ţ�NET_IN_PLAYER_PAUSE
    NET_PLAYER_OPERATE_SEEK_TIME,           // ��ת��ָ��ʱ�䲥�ţ�NET_IN_PLAYER_SEEK_TIME
    NET_PLAYER_OPERATE_STEP_FRAME,          // ��֡�ط�, ��Ҫ��ͣ��ʹ�ã�NET_IN_PLAYER_STEP_FRAME
    NET_PLAYER_OPERATE_GET_STATE,           // ȡ��ǰ�ط�״̬��NET_IN_PLAYER_GET_STATE
    NET_PLAYER_OPERATE_GET_TIME,            // ��ȡ��ǰ�ط�ʱ�䣬NET_IN_PLAYER_GET_TIME��NET_OUT_PLAYER_GET_TIME
    NET_PLAYER_OPERATE_GET_SPEED,           // ��ȡ�����ٶȣ�NET_IN_PLAYER_GET_SPEED��NET_OUT_PLAYER_GET_SPEED
    NET_PLAYER_OPERATE_SET_SPEED,           // ���ò����ٶȣ�NET_IN_PLAYER_SET_SPEED
    NET_PLAYER_OPERATE_GET_VOLUME,          // ��ȡ������NET_IN_PLAYER_GET_VOLUME��NET_OUT_PLAYER_GET_VOLUME
    NET_PLAYER_OPERATE_SET_VOLUME,          // ����������NET_IN_PLAYER_SET_VOLUME
    NET_PLAYER_OPERATE_GET_PLAYLIST,        // ��ȡ�ļ��б�NET_IN_PLAYER_GET_PLAYLIST��NET_OUT_PLAYER_GET_PLAYLIST
    NET_PLAYER_OPERATE_GET_PLAYLIST_TS,     // ��ȡ��ǰ�ļ��б�ȫ��ʱ�����Ϣ��NET_IN_PLAYER_GET_PLAYLIST_TS��NET_OUT_PLAYER_GET_PLAYLIST_TS
}NET_PLAYER_OPERATE_TYPE;

// ��������
typedef struct tagNET_PLAYER_OPEN_CONDITION 
{
    DWORD               dwSize;
    char                szDevice[DH_DEV_ID_LEN];        // ָ��Զ�˵��豸
    int                 nChannel;                       // ͨ����
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    NET_STREAM_TYPE     emStreamType;                   // ��������
    int                 nEventNum;                      // �¼����͸���
    int                 nEvent[MAX_IVS_EVENT_NUM];      // �¼�����
}NET_PLAYER_OPEN_CONDITION;

// �򿪲������������, ��Ӧ NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_IN_PLAYER_OPEN 
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
	const char*         pszDevice;                      // ָ���ӱ��ػ���Զ��ȡ¼��, Ϊnull����ӱ���ȡ¼��,
														// bDeviceInfoΪFALSEʱ��Ч
                                                        // ����Ǵ�Զ���豸ȡ,��Ҫ������NET_PLAYER_OPEN_CONDITION��szDeviceһ��
    NET_PLAYER_OPEN_CONDITION stuCondition;             // ��ѯ����
	BOOL				bDeviceInfo;					// ��ʾstuDeviceInfo�Ƿ���Ч
	DH_REMOTE_DEVICE	stuDeviceInfo;					// �豸��Ϣ, bDeviceInfoΪTRUEʱdeviceInfo��Ч
}NET_IN_PLAYER_OPEN;

// �򿪲������������, ��Ӧ NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_OUT_PLAYER_OPEN 
{
    DWORD               dwSize;
}NET_OUT_PLAYER_OPEN;

// �رղ������������, ��Ӧ NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_IN_PLAYER_CLOSE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_CLOSE;

// �رղ������������, ��Ӧ NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_OUT_PLAYER_CLOSE
{
    DWORD               dwSize;
}NET_OUT_PLAYER_CLOSE;

// ��ʼ�����������, ��Ӧ NET_PLAYER_OPERATE_START
typedef struct tagNET_IN_PLAYER_START
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_START;

// ��ʼ�����������, ��Ӧ NET_PLAYER_OPERATE_START
typedef struct tagNET_OUT_PLAYER_START
{
    DWORD               dwSize;
}NET_OUT_PLAYER_START;

// ֹͣ�����������, ��Ӧ NET_PLAYER_OPERATE_STOP
typedef struct tagNET_IN_PLAYER_STOP
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_STOP;

// ֹͣ�����������, ��Ӧ NET_PLAYER_OPERATE_STOP
typedef struct tagNET_OUT_PLAYER_STOP
{
    DWORD               dwSize;
}NET_OUT_PLAYER_STOP;

// ��ͣ/�ָ������������, ��Ӧ NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_IN_PLAYER_PAUSE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    BOOL                bPause;                         // �Ƿ���ͣ, TRUE-��ͣ����, FALSE-�ָ�����
}NET_IN_PLAYER_PAUSE;

// ��ͣ/�ָ������������, ��Ӧ NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_OUT_PLAYER_PAUSE
{
    DWORD               dwSize;
}NET_OUT_PLAYER_PAUSE;

// ��ת��ָ��ʱ�䲥���������, ��Ӧ NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_IN_PLAYER_SEEK_TIME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    NET_TIME            stuTime;                        // ��תʱ��
}NET_IN_PLAYER_SEEK_TIME;

// ��ת��ָ��ʱ�䲥���������, ��Ӧ NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_OUT_PLAYER_SEEK_TIME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SEEK_TIME;

// ��֡�����������, ��Ӧ NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_IN_PLAYER_STEP_FRAME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    BOOL                bForward;                       // �Ƿ�����, TRUE-����, FALSE-����
}NET_IN_PLAYER_STEP_FRAME;

// ��֡�����������, ��Ӧ NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_OUT_PLAYER_STEP_FRAME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_STEP_FRAME;

// ����״̬
typedef enum tagNET_PLAYER_STATE 
{
    NET_PLAYER_STATE_UNKNOWN,               // δ֪
    NET_PLAYER_STATE_ERROR,                 // �д�����
    NET_PLAYER_STATE_READING,               // ����, ���Կ���ط�
    NET_PLAYER_STATE_STANDBY,               // ��ǰ�ļ��ط�ֹͣ, ֻ�ܴ�ͷ��ʼ���»ط�
    NET_PLAYER_STATE_RUNNING,               // ������
    NET_PLAYER_STATE_PAUSED,                // ����ͣ, ���Դ���ͣ������ط�
    NET_PLAYER_STATE_CLOSED,                // �ѹر�, �޷�����, ��������open����Reading״̬����ܻط�
}NET_PLAYER_STATE;

// ��ѯ����״̬�������, ��Ӧ NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_IN_PLAYER_GET_STATE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_GET_STATE;

// ��ѯ����״̬�������, ��Ӧ NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_OUT_PLAYER_GET_STATE
{
    DWORD               dwSize;
    NET_PLAYER_STATE    emState;                        // ״̬
}NET_OUT_PLAYER_GET_STATE;

// ��ȡ��ǰ�ط�ʱ���������, ��Ӧ NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_IN_PLAYER_GET_TIME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_GET_TIME;

// ��ȡ��ǰ�ط�ʱ���������, ��Ӧ NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_OUT_PLAYER_GET_TIME
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // ��ǰ����ʱ��
}NET_OUT_PLAYER_GET_TIME;

// ��ȡ�����ٶ��������, ��Ӧ NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_IN_PLAYER_GET_SPEED
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_GET_SPEED;

// ��ȡ�����ٶ��������, ��Ӧ NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_OUT_PLAYER_GET_SPEED
{
    DWORD               dwSize;
    float               fSpeed;                         // �����ٶ�, >0���򲥷�, <0���򲥷�
                                                        // ����ֵ��ʾ�ٶ�, =1�����ٶ�, >1���, <1����
}NET_OUT_PLAYER_GET_SPEED;

// ���ò����ٶ��������, ��Ӧ NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_IN_PLAYER_SET_SPEED
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    float               fSpeed;                         // �����ٶ�, >0���򲥷�, <0���򲥷�
                                                        // ����ֵ��ʾ�ٶ�, =1�����ٶ�, >1���, <1����
}NET_IN_PLAYER_SET_SPEED;

// ���ò����ٶ��������, ��Ӧ NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_OUT_PLAYER_SET_SPPED
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SET_SPEED;

// ��ȡ���������������, ��Ӧ NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_IN_PLAYER_GET_VOLUME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_GET_VOLUME;

// ��ȡ���������������, ��Ӧ NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_OUT_PLAYER_GET_VOLUME
{
    DWORD               dwSize;
    int                 nVolume;                        // ��������, 0~100
}NET_OUT_PLAYER_GET_VOLUME;

// ���ò��������������, ��Ӧ NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_IN_PLAYER_SET_VOLUME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    int                 nVolume;                        // ��������, 0~100
}NET_IN_PLAYER_SET_VOLUME;

// ���ò��������������, ��Ӧ NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_OUT_PLAYER_SET_VOLUME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SET_VOLUME;

// �����б���Ϣ
typedef struct tagNET_PLAYER_PLAYLIST
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // �ļ�·��, ��Url����ѡһ
    char                szUrl[MAX_PATH];                // URL, ��FilePath����ѡһ
    DH_DEVICE_PROTOCOL  emUrlProtocol;                  // URLЭ������
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
}NET_PLAYER_PLAYLIST;

// ��ȡ��ǰ�����б��������, ��Ӧ NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
    NET_TIME            stuStartTime;                   // ��ʼʱ��
    NET_TIME            stuEndTime;                     // ����ʱ��
    int                 nLimit;                         // ��ѯ���ļ�������, 0��ʾ������
}NET_IN_PLAYER_GET_PLAYLIST;

// ��ȡ��ǰ�����б��������, ��Ӧ NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST
{
    DWORD               dwSize;
    NET_PLAYER_PLAYLIST* pstuPlayLists;                 // �����б�, �û������ڴ�
    int                 nMaxPlayListCount;              // ��󲥷��б�����, �û���д
    int                 nRetPlayListCount;              // ���ز����б�����
}NET_OUT_PLAYER_GET_PLAYLIST;

// ��ȡ��ǰ�ļ��б�ȫ��ʱ�����Ϣ�������, ��Ӧ NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST_TS
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // ����ʵ��ID
}NET_IN_PLAYER_GET_PLAYLIST_TS;

typedef struct tagNET_PLAYLIST_TIMESECTION
{
    DWORD               dwSize;
    int                 nEvent;                         // ¼���¼�����, Ŀǰ��
                                                        // EVENT_ALARM_COMMON, EVENT_ALARM_VIDEOBLIND, EVENT_ALARM_VIDEOLOSS, 
                                                        // EVENT_ALARM_MOTIONDETECT, EVENT_ALARM_LOCALALARM
    LPDH_TSECT          pstuTSs;                        // ʱ�����Ϣ
    DWORD               unMaxTS;                        // ʱ���������
    DWORD               unRetTS;                        // ʵ�ʷ��ص�ʱ��θ���
}NET_PLAYLIST_TIMESECTION;

// ��ȡ��ǰ�ļ��б�ȫ��ʱ�����Ϣ�������, ��Ӧ NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST_TS
{
    DWORD                    dwSize;
    DWORD                    dwEventNum;                // ¼����������
    NET_PLAYLIST_TIMESECTION stuTS[MAX_IVS_EVENT_NUM];  // ��ǰ�ط��б��ʱ�����Ϣ
}NET_OUT_PLAYER_GET_PLAYLIST_TS;

// �ָ�ڲ��Ų���,pInParam��pOutParam�ڴ����û������ͷţ��ڴ��С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplitPlayer(LLONG lLoginID, NET_PLAYER_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// NET_ACCESS_LOCK_VER ���
typedef struct tagNET_ACCESS_LOCK_VER_IN
{
    int                 nChannel;                       // ͨ����
    char                reserved[128];                  // ����
} NET_ACCESS_LOCK_VER_IN;

// NET_ACCESS_LOCK_VER ����
typedef struct tagNET_ACCESS_LOCK_VER_OUT
{
    char                szVersion[32];                  // �汾
    NET_TIME            stuTime;                        // ʱ��
    char                reserved[512];                  // ����
} NET_ACCESS_LOCK_VER_OUT;

// �����汾��, CLIENT_QueryDevState ��ѯ���� DH_DEVSTATE_ACCESS_LOCK_VER
typedef struct tagNET_ACCESS_LOCK_VER
{
    DWORD                    dwSize;
    NET_ACCESS_LOCK_VER_IN   stuIn;                     // ���
    NET_ACCESS_LOCK_VER_OUT  stuOut;                    // ����
} NET_ACCESS_LOCK_VER;

//////////////////////////////////// ����ǽ���� //////////////////////////////////////

// ��Դ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PowerControl(LLONG lLoginID, const DH_IN_WM_POWER_CTRL* pInParam, DH_OUT_WM_POWER_CTRL* pOutParam, int nWaitTime = 1000);

// ��ȡ/������ʾģʽ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayMode(LLONG lLoginID, const DH_IN_WM_SET_DISPLAY_MODE* pInParam, DH_OUT_WM_SET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDisplayMode(LLONG lLoginID, const DH_IN_WM_GET_DISPLAY_MODE* pInParam, DH_OUT_WM_GET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);

// ����/����Ԥ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LoadMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_LOAD_COLLECTION* pInParam, DH_OUT_WM_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_SAVE_COLLECTION* pInParam, DH_OUT_WM_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// ��ȡ����ǽԤ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMonitorWallCollections(LLONG lLoginID, const DH_IN_WM_GET_COLLECTIONS* pInParam, DH_OUT_WM_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// ����ǽԤ��������,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_RENAME_COLLECTION* pInParam, DH_OUT_WM_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// ��ȡ/���õ���ǽ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScene(LLONG lLoginID, const DH_IN_MONITORWALL_GET_SCENE* pInParam, DH_OUT_MONITORWALL_GET_SCENE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScene(LLONG lLoginID, const DH_IN_MONITORWALL_SET_SCENE* pInParam, DH_OUT_MONITORWALL_SET_SCENE* pOutParam, int nWaitTime = 1000);

// ��ȡ����ǽ��ʾ��Ԫ������,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetAttributeCaps(LLONG lLoginID, const DH_IN_MONITORWALL_GET_ARRT_CAPS* pInParam, DH_OUT_MONITORWALL_GET_ARRT_CAPS* pOutParam, int nWaitTime = 1000);

// ����ǽ��ʾ��Ԫ�Զ�����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallAutoAdjust(LLONG lLoginID, const DH_IN_MONITORWALL_AUTO_ADJUST* pInParam, DH_OUT_MONITORWALL_AUTO_ADJUST* pOutParam, int nWaitTime = 1000);

// ���õ���ǽ��ʾ��Ԫ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetAttribute(LLONG lLoginID, const DH_IN_MONITORWALL_SET_ATTR* pInParam, DH_OUT_MONITORWALL_SET_ATTR* pOutParam, int nWaitTime = 1000);

// ���ñ���ģʽ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackLight(LLONG lLoginID, const DH_IN_MONITORWALL_SET_BACK_LIGHT* pInParam, DH_OUT_MONITORWALL_SET_BACK_LIGHT* pOutParam, int nWaitTime = 1000);

// ��ѯ/������Ļ���ؼƻ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetPowerSchedule(LLONG lLoginID, const NET_IN_MW_GET_POWER_SCHEDULE* pInParam, NET_OUT_MW_GET_POWER_SCHEDULE* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetPowerSchedule(LLONG lLoginID, const NET_IN_MW_SET_POWER_SCHEDULE* pInParam, NET_OUT_MW_SET_POWER_SCHEDULE* pOutParam, int nWaitTime);

// ��ѯ/������Ļ���Ʋ���,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_GET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_GET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_SET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_SET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);

// ��ѯ/������Ļ�ʹ��ڱ�����ɫ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetBackgroudColor(LLONG lLoginID, const NET_IN_MW_GET_BACKGROUDND_COLOR* pInParam, NET_OUT_MW_GET_BACKGROUDND_COLOR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackgroudColor(LLONG lLoginID, const NET_IN_MW_SET_BACKGROUD_COLOR* pInParam, NET_OUT_MW_SET_BACKGROUD_COLOR* pOutParam, int nWaitTime);

// ����Ԥ����Ѳ״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MonitorWallAttachTour(LLONG lLoginID, const NET_IN_WM_ATTACH_TOUR* pInParam, NET_OUT_WM_ATTACH_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallDetachTour(LLONG lAttachHandle);

// ����ǽ����,pInParam��pOutParam�ڴ����û������ͷ�,��С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMonitorWall(LLONG lLoginID, NET_MONITORWALL_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// �л���ʾ���������ź�����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSwitchDisplaySignal(LLONG lLoginID, const NET_IN_MW_SWITCH_DISPLAY_SIGNAL* pInParam, NET_OUT_MW_SWITCH_DISPLAY_SIGNAL* pOutParam, int nWaitTime);

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// �յ����ӿ�////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_PLAYDATES_COUNT		32		// ������ڸ���
#define	MAX_SCREENTIME_COUNT	8		// �յ�����󿪹���ʱ�����
#define MAX_WINDOWS_COUNT		16		// �յ�����󴰿ڸ���
#define MAX_ELEMENTS_COUNT		8		// �յ�������֧�ֵ����Ԫ�ظ���
#define MAX_ELEMENTTEXT_LENGTH	512		// �ı�Ԫ������ı�����
#define MAX_NOTE_COUNT			4		// �յ�������Ԫ��ע����Ϣ������
#define MAX_PROGRAMMES_COUNT	32		// ���֧�ֵĽ�Ŀ����

// ��������
typedef enum tagEM_SCREEN_DATE_TYPE
{
	EM_SCREEN_DATE_UNKNOWN,				// δ֪
	EM_SCREEN_DATE_MONTH,				// ÿ��
	EM_SCREEN_DATE_WEEK,				// ÿ��
	EM_SCREEN_DATE_DAY,					// ÿ��
	EM_SCREEN_DATE_CUSTOM,				// �Զ���
} EM_SCREEN_DATE_TYPE;

// ��Ŀʱ����Ϣ
typedef struct tagNET_PROGRAMME_TIME_INFO
{
	DWORD                dwHour;                  // ʱ
    DWORD                dwMinute;                // ��
    DWORD                dwSecond;                // ��
} NET_PROGRAMME_TIME_INFO;

//������ʱ����Ϣ
typedef struct tagNET_SCREEN_TIME_INFO
{
	BOOL					bEnable;							// �Ƿ�����
	EM_SCREEN_DATE_TYPE		emDateType;							// ��������������
	UINT					nDateCount;							// ���������ڸ���'
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];	// ����������
	NET_PROGRAMME_TIME_INFO	stuOpenTime;						// ����ʱ��
	NET_PROGRAMME_TIME_INFO	stuCloseTime;						// ����ʱ��
	BYTE        			byReserved[128];                 	// ����
} NET_SCREEN_TIME_INFO;

// �յ�������������Ϣ
typedef struct NET_GUIDESCREEN_WINDOW_RECT_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// ����ID
	NET_RECT			stuRect;									// ��������
	BYTE				byReserved[128];							// ����
} NET_GUIDESCREEN_WINDOW_RECT_INFO;

// ��ʾ������״̬
typedef enum tagEM_SCREEN_STATUS_TYPE
{
	EM_SCREEN_STATUS_UNKNOWN,		// δ֪
	EM_SCREEN_STATUS_ON,			// ��
	EM_SCREEN_STATUS_OFF,			// ��
} EM_SCREEN_STATUS_TYPE;

// �յ�������������Ϣ
typedef struct tagNET_GUIDESCREEN_ATTRIBUTE_INFO
{
	DWORD           		dwSize;
	char					szScreenID[MAX_COMMON_STRING_64];			// ��ID
	EM_SCREEN_STATUS_TYPE	emStatus;									// ��ʾ������״̬
	BOOL					bIsForeverOpen;								// �Ƿ����ÿ���
	UINT					nScreenTime;								// ������ʱ�����
	NET_SCREEN_TIME_INFO	stuScreenTime[MAX_SCREENTIME_COUNT];		// ������ʱ������
	UINT					nBright;									// ��ʾ������, 1-100 
	UINT					nContrast;									// ��ʾ���Աȶ�, 1-100
	UINT					nSaturation;								// ��ʾ�����Ͷ�, 1-100
	UINT					nWidth;										// ���
	UINT					nHeight;									// �߶�
	UINT					nWindowsCount;								// ���ڸ���
	NET_GUIDESCREEN_WINDOW_RECT_INFO	stuWindows[MAX_WINDOWS_COUNT];	// ������Ϣ
	BYTE        			byReserved[512];							// �����ֽ�
} NET_GUIDESCREEN_ATTRIBUTE_INFO;

// �����յ�����Ļ������Ϣ�������
typedef struct tagNET_IN_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nScreenCount;		// �յ�������������Ϣ����, ֵ���û�ָ��
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;	// �յ�������������Ϣ, �ڴ����û�ά��,
														// ��СΪnScreenCount ��NET_GUIDEESCREEN_ATTRIBUTE_INFO
} NET_IN_SET_GUIDESCREEN_CFG;

// �����յ�����Ļ������Ϣ�������
typedef struct tagNET_OUT_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_OUT_SET_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenCfg
*   Purpose: �����յ���������Ϣ�ӿ�
*   InputParam:	LLONG								:lLoginID		// ��½���
*   InputParam:	NET_IN_SET_GUIDESCREEN_CFG*			:pInParam 		// �ӿ��������
*   OutParam:		NET_OUT_SET_GUIDESCREEN_CFG*	:pstOutPqram	// �ӿ��������
*   InputParam:	int									:nWaitTime		// �ȴ���ʱʱ��
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenCfg(LLONG lLoginID, const NET_IN_SET_GUIDESCREEN_CFG* pInParam, NET_OUT_SET_GUIDESCREEN_CFG *pstOutPqram, const int nWaitTime);


// ͨ���յ���ID ��ȡ�յ���������Ϣ�������
typedef struct tagNET_IN_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	char							szScreenID[MAX_COMMON_STRING_64];		// ��ID
} NET_IN_GET_GUIDESCREEN_CFG_BYID;

// ͨ���յ���ID ��ȡ�յ���������Ϣ�������
typedef struct tagNET_OUT_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	NET_GUIDESCREEN_ATTRIBUTE_INFO	stuGuideScreenCfg;			// �յ���������Ϣ
} NET_OUT_GET_GUIDESCREEN_CFG_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneGuideScreenCfgById
*   Purpose: ͨ���յ���ID ��ȡ�յ���������Ϣ
*   InputParam:		LLONG								:lLoginID	// ��½���
*   InputParam:		NET_IN_GET_GUIDESCREEN_CFG_BYID*	:pInParam	// �������
*   OutPutParam:	NET_OUT_GET_GUIDESCREEN_CFG_BYID*	:pOutParam 	// �������
*   InputParam:		int									:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneGuideScreenCfgById(
										LLONG lLoginID, const NET_IN_GET_GUIDESCREEN_CFG_BYID *pInParam, 
										NET_OUT_GET_GUIDESCREEN_CFG_BYID* pOutParam, const int nWaitTime);



// ��ȡ�����յ���������Ϣ�������
typedef struct tagNET_IN_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_GUIDESCREEN_CFG;

// ��ȡ�����յ���������Ϣ�������
typedef struct tagNET_OUT_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nMaxScreen;					// ����յ�������, ֵ���û�ָ��
	UINT							nRetScreen;					// ʵ�ʷ��ص��յ�������
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;			// ���ڴ�Ż�ȡ�����յ���������Ϣ, �ڴ����û�ά�� 
																// ��СΪnMaxScreen ��NET_GUIDESCREEN_ATTRIBUTE_INFO
} NET_OUT_GET_ALL_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_GetAllGuideScreenCfg
*   Purpose: ��ȡ�����յ���������Ϣ
*   InputParam:		LLONG									:lLoginID	// ��½���
*   InputParam:		NET_IN_GET_ALL_GUIDESCREEN_CFG*			:pInParam	// �������
*   OutPutParam:	NET_OUT_GET_ALL_GUIDESCREEN_CFG*		:pOutParam 	// �������
*   InputParam:		int										:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllGuideScreenCfg(
										LLONG lLoginID, const NET_IN_GET_ALL_GUIDESCREEN_CFG *pInParam, 
										NET_OUT_GET_ALL_GUIDESCREEN_CFG* pOutParam, const int nWaitTime);

// ˮƽ��������
typedef enum tagEM_HORI_ALIGN_TYPE
{
	EM_HORI_ALIGN_UNKNOWN,				// δ֪
	EM_HORI_ALIGN_LEFT,					// �����
	EM_HORI_ALIGN_CENTER,				// ����
	EM_HORI_ALIGN_RIGHT,				// �Ҷ���
} EM_HORI_ALIGN_TYPE;

// ��ֱ��������
typedef enum tagEM_VERT_ALIGN_TYPE
{
	EM_VERT_ALIGN_UNKNOWN,				// δ֪
	EM_VERT_ALIGN_UP,					// �϶���
	EM_VERT_ALIGN_CENTER,				// ����
	EM_VERT_ALIGN_DOWN,					// �¶���
} EM_VERT_ALIGN_TYPE;

// ����(�г�) ���
typedef enum tagEM_PIC_STYLE_TYPE
{
	EM_PIC_STYLE_UNKNOWN,		// δ֪
	EM_PIC_STYLE_DEFAULT,		// Ĭ��
	EM_PIC_STYLE_LEFT,			// ����
	EM_PIC_STYLE_RIGHT,			// ����
	EM_PIC_STYLE_UP,			// ����
	EM_PIC_STYLE_DOWN,			// ����
} EM_PIC_STYLE_TYPE;


//  �ı���Ϣ
typedef struct tagNET_GUIDESCREEN_TEXT_INFO
{
	char					szContent[MAX_ELEMENTTEXT_LENGTH];		// �ı�����
	UINT					nFontSize;								// �����С
	NET_COLOR_RGBA			stuFontColor;							// ������ɫ
	char					szFontStyle[MAX_COMMON_STRING_32];		// ��������
	double					dbLineHeight;							// �и�
	EM_HORI_ALIGN_TYPE		emHoriAlign;							// ˮƽ���뷽��
	EM_VERT_ALIGN_TYPE		emVertAlign;							// ��ֱ���뷽��
	UINT					nStayTime;								// ͣ���������г��ļ��ʱ�䣩��λ��s
	EM_PIC_STYLE_TYPE		emEnterStyle;							// ������
	EM_PIC_STYLE_TYPE		emExitStyle;							// �г����
	BYTE        			byReserved[128];						// �����ֽ�
} NET_GUIDESCREEN_TEXT_INFO;

// �յ�������Ԫ��ע����Ϣ
typedef struct tagNET_GUIDESCREEN_NOTE_INFO
{
	BOOL						bEnable;			// �Ƿ���Ч
	NET_GUIDESCREEN_TEXT_INFO	stuTextInfo;		// ����ע����Ϣ
	NET_RECT					stuRect;			// ����ע�͵�����
	BYTE        				byReserved[128];	// �����ֽ�
} NET_GUIDESCREEN_NOTE_INFO;

// ��ƵԪ����Ϣ
typedef struct tagNET_VIDEO_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// �ز��Զ�������
	BOOL						bFillerState;							// �Ƿ��Ƭ
	char						szPath[MAX_COMMON_STRING_128];			// �ļ���ַ
	UINT						nPlayCount;								// ���Ŵ���
	UINT						nNote;									// ע����Ϣ����
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// ע����Ϣ
	BYTE        				byReserved[128];						// �����ֽ�
} NET_VIDEO_ELEMENT_INFO;

// ͼƬԪ����Ϣ
typedef struct tagNET_PICTURE_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// �ز��Զ�������
	BOOL						bFillerState;							// �Ƿ��Ƭ
	char						szPath[MAX_COMMON_STRING_128];			// ͼƬ�ļ���ַ
	UINT						nPlayTime;								// ����ʱ��, ��λ��
	UINT						nPlayCount;								// ���Ŵ���
	UINT						nDiaphaneity;							// ͸����, 0-100
	UINT						nStayTime;								// ͣ��ʱ��, ��λ��
	EM_PIC_STYLE_TYPE			emEnterStyle;							// ������
	EM_PIC_STYLE_TYPE			emExitStyle;							// �г����
	UINT						nNote;									// ע����Ϣ����
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// ע����Ϣ 
	BYTE        				byReserved[128];						// �����ֽ�
} NET_PICTURE_ELEMENT_INFO;

// �յ��������ı�Ԫ����Ϣ
typedef struct tagNET_TEXT_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// �ز��Զ�������
	BOOL						bFillerState;							// �Ƿ��Ƭ
	NET_GUIDESCREEN_TEXT_INFO	stuElementsText;						// �ı�Ԫ����Ϣ
	UINT						nNote;									// ע����Ϣ����
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// ע����Ϣ 
	BYTE        				byReserved[128];						// �����ֽ�
} NET_TEXT_ELEMENT_INFO;

// �յ�������ռλ��Ԫ����Ϣ
typedef struct tagNET_PLACEHOLDER_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// �ز��Զ�������
	BOOL						bFillerState;							// �Ƿ��Ƭ
	UINT						nNote;									// ע����Ϣ����
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// ע����Ϣ
	BYTE        				byReserved[128];						// �����ֽ�
} NET_PLACEHOLDER_ELEMENT_INFO;

// ץ������
typedef enum tagEM_CAPTURE_TYPE
{
	EM_CAPTURE_UNKNOWN,			// δ֪
	EM_CAPTURE_VIDEO,			// ��Ƶ
	EM_CAPTURE_PICTURE,			// ͼƬ
} EM_CAPTURE_TYPE;

// ץ��Ԫ����Ϣ
typedef struct tagNET_CAPTURE_ELEMENT_INFO
{
	
	char 						szName[MAX_COMMON_STRING_64];			// �ز��Զ�������
	BOOL						bFillerState;							// �Ƿ��Ƭ
	char						szUserName[DH_USER_NAME_LEN_EX];		// �û���
	char						szPassWord[DH_USER_PSW_LEN_EX];			// ����
	char						szIP[DH_MAX_IPADDR_LEN_EX];				// IP��ַ
	UINT						nPort;									// �˿ں�
	UINT						nChannel;								// ͨ����
	EM_CAPTURE_TYPE				emCaptureType;							// ץ������
	UINT						nPlayTime;								// ����ʱ��, ��λ��
	UINT						nNote;									// ע����Ϣ����
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// ע����Ϣ 
	BYTE        				byReserved[128];						// �����ֽ�
} NET_CAPTURE_ELEMENT_INFO;

// �յ�������Ԫ������
typedef enum tagEM_ELEMENTS_TYPE
{
	EM_ELEMENTS_UNKNOWN,			// δ֪
	EM_ELEMENTS_VIDEO,				// ��ƵԪ��, ��ӦNET_VIDEO_ELEMENT_INFO
	EM_ELEMENTS_PICTURE,			// ͼƬԪ��, ��ӦNET_PICTURE_ELEMENT_INFO
	EM_ELEMENTS_TEXT,				// �ı�Ԫ��, ��ӦNET_TEXT_ELEMENT_INFO
	EM_ELEMENTS_PLACEHOLDER,		// ռλ��Ԫ��, ��ӦNET_PLACEHOLDER_ELEMENT_INFO
	EM_ELEMENTS_CAPTURE,			// ץ��Ԫ��, ��ӦNET_CAPTURE_ELEMENT_INFO
} EM_ELEMENTS_TYPE;

//������ѵ��������
typedef enum tagEM_TOURPERIOD_TYPE
{
	EM_TOURPERIOD_UNKNOWN,		// δ֪
	EM_TOURPERIOD_PROGRAMME,	// ��Ŀ����
	EM_TOURPERIOD_PLAN,			// �ƻ�����
	EM_TOURPERIOD_CUSTOM,		// �Զ�������
} EM_TOURPERIOD_TYPE;


// �յ���������Ϣ
typedef struct tagNET_GUIDESCREEN_WINDOW_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// ����ID
	NET_COLOR_RGBA		stuColor;									// ���ڱ�����ɫ
	UINT				nDiaphaneity;								// ���ڱ���͸����0-100
	EM_TOURPERIOD_TYPE	emTourPeriodType;							// ������ѵ����
	UINT				nTourPeriodTime;							// �Զ�����ѵʱ�䣬��λ��, ��ѵ����Ϊ�Զ�����ѵʱ��Ч
	BOOL				bAutoPlay;									// Ԥ���Զ�����,VideoԪ����Ч
	BOOL				bLoopPlay;									// Ԥ��ѭ������,VideoԪ����Ч
	EM_ELEMENTS_TYPE	emElementsType;								// �յ�������Ԫ������
	UINT				nElementsCount;								// �յ�������Ԫ�ظ���
	char*				pstElementsBuf;								// �յ�������Ԫ����Ϣ������, �������Ͷ�Ӧ��ͬ�Ľṹ��,
	UINT				nBufLen;									// �յ�������Ԫ����Ϣ��������С
	BYTE        		byReserved[128];							// �����ֽ�
} NET_GUIDESCREEN_WINDOW_INFO;

// �յ�����ͨ��Ŀ��Ϣ
typedef struct tagNET_ORDINARY_INFO
{
	BOOL						bTempletState;							// ��Ŀ�Ƿ񱣴�Ϊģ��
	char						szDescription[MAX_COMMON_STRING_128];	// ��Ŀ������Ϣ
	UINT						nWhnCount;								// �յ������ڸ���
	NET_GUIDESCREEN_WINDOW_INFO	stuWindowsInfo[MAX_WINDOWS_COUNT];		// �յ���������Ϣ	
	BYTE        				byReserved[128];						// �����ֽ�
} NET_ORDINARY_INFO;

// �յ�����Ŀ������Ϣ
typedef struct tagNET_PROGRAMME_INFO
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// ��Ŀ����
	char						szProgrammeID[MAX_COMMON_STRING_64];	// ��ĿID
	char						szGuideScreenID[MAX_COMMON_STRING_64];	// �յ���ID
	BOOL						bEnable;								// ��Ŀ�Ƿ�����		
	NET_ORDINARY_INFO			stuOrdinaryInfo;						// ��ͨ��Ŀ��Ϣ
	BYTE        				byReserved[512];						// �����ֽ�
} NET_PROGRAMME_INFO;

// ͨ����ĿID ��ȡ��Ŀ��Ϣ�������
typedef struct tagNET_IN_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// ��ĿID
} NET_IN_GET_PROGRAMME_BYID;

// ͨ����ĿID ��ȡ��Ŀ��Ϣ�������
typedef struct tagNET_OUT_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;			// ��Ŀ������Ϣ
} NET_OUT_GET_PROGRAMME_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammeById
*   Purpose: ͨ����ĿID ��ȡ��Ŀ��Ϣ
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_GET_PROGRAMME_BYID*		:pInParam	// �������
*   OutPutParam:	NET_OUT_GET_PROGRAMME_BYID*		:pOutParam 	// �������
*   InputParam:		int								:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammeById(LLONG lLoginID, const NET_IN_GET_PROGRAMME_BYID *pInParam, NET_OUT_GET_PROGRAMME_BYID *pOutParam, const int nWaitTime);


// ��ȡ���н�Ŀ��Ϣ�������
typedef struct tagNET_IN_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMES;

// ��ȡ���н�Ŀ��Ϣ�������
typedef struct tagNET_OUT_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
	UINT						nMaxCnt;					// pstProgrammeInfo���NET_PROGRAMME_INFO ����
	UINT						nRetCnt;					// pstProgrammeInfoʵ�ʷ��ص� NET_PROGRAMME_INFO ����
	NET_PROGRAMME_INFO			*pstProgrammeInfo;			// ��Ŀ������Ϣ, �ڴ����û�ά��
} NET_OUT_GET_ALL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammes
*   Purpose: ��ȡ���н�Ŀ��Ϣ
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_GET_ALL_PROGRAMMES*		:pInParam		// �������
*   OutPutParam:	NET_OUT_GET_ALL_PROGRAMMES*		:pOutParam 		// �������
*   InputParam:		int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_PROGRAMMES* pOutParam, const int nWaitTime);


// ��Ŀ��Ҫ��Ϣ
typedef struct tagNET_BRIEFLY_PROGRAMME_INFO
{
	char				szProgrammeName[MAX_COMMON_STRING_64];	// ��Ŀ����
	char				szProgrammeID[MAX_COMMON_STRING_64];	// ��ĿID
	char				szGuideScreenID[MAX_COMMON_STRING_64];	// �յ���ID
	BOOL				bEnable;								// ��Ŀ�Ƿ�����	
	BOOL				bTempletState;							// ��Ŀ�Ƿ񱣴�Ϊģ��
	BYTE        		byReserved[512];						// �����ֽ�
} NET_BRIEFLY_PROGRAMME_INFO;

// ��ȡ���н�Ŀ�ļ�Ҫ��Ϣ�������
typedef struct tagNET_IN_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_BRIEFLYPROGRAMMES;

// ��ȡ���н�Ŀ�ļ�Ҫ��Ϣ�������
typedef struct tagNET_OUT_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
	UINT							nRetCnt;									// ʵ�ʷ��صĸ���
	NET_BRIEFLY_PROGRAMME_INFO		stuBriProgrammes[MAX_PROGRAMMES_COUNT];		// ��Ŀ��Ҫ��Ϣ
} NET_OUT_GET_ALL_BRIEFLYPROGRAMMES;


/**************************************************************************************
*   Funcname: CLIENT_GetAllBrieflyProgrammes
*   Purpose: ��ȡ���н�Ŀ�ļ�Ҫ��Ϣ
*   InputParam:		LLONG									:lLoginID		// ��½���
*   InputParam:		NET_IN_GET_ALL_BRIEFLYPROGRAMMES*		:pInParam		// �������
*   OutPutParam:	NET_OUT_GET_ALL_BRIEFLYPROGRAMMES*		:pOutParam 		// �������
*   InputParam:		int										:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllBrieflyProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_BRIEFLYPROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_BRIEFLYPROGRAMMES* pOutParam, const int nWaitTime);


// ��ӽ�Ŀ��Ϣ�ӿ��������
typedef struct tagNET_IN_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// ��Ŀ��Ϣ
} NET_IN_ADD_ONE_PROGRAMME;

// ��ӽ�Ŀ��Ϣ�ӿ��������
typedef struct tagNET_OUT_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// ��ĿID
} NET_OUT_ADD_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_AddOneProgramme
*   Purpose: ���һ����Ŀ��Ϣ���յ���
*   InputParam:		LLONG						:lLoginID		// ��½���
*   InputParam:		NET_IN_ADD_ONE_PROGRAMME*	:pInParam 		// �������
*   OutPutParam:	NET_OUT_ADD_ONE_PROGRAMME* 	:pOutParam		// �������
*   InputParam:		int							:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneProgramme(LLONG lLoginID, const NET_IN_ADD_ONE_PROGRAMME* pInParam, NET_OUT_ADD_ONE_PROGRAMME *pOutParam, const int nWaitTime);


// �޸Ľ�Ŀ��Ϣ�ӿ��������
typedef struct tagNET_IN_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// ��Ŀ��Ϣ
} NET_IN_MODIFY_ONE_PROGRAMME;


// �޸Ľ�Ŀ��Ϣ�ӿ��������
typedef struct tagNET_OUT_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneProgrammeByID
*   Purpose: ͨ����ĿID �޸Ľ�Ŀ
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_MODIFY_ONE_PROGRAMME*	:pInParam 		// �������
*   OutputParam:	NET_OUT_MODIFY_ONE_PROGRAMME*	:pOutParam 		// �������
*   InputParam:		int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneProgrammeByID(LLONG lLoginID, const NET_IN_MODIFY_ONE_PROGRAMME* pInParam, NET_OUT_MODIFY_ONE_PROGRAMME* pOutParam, const int nWaitTime);


// ����ɾ����Ŀ��Ϣ�ӿ��������
typedef struct tagNET_IN_DEL_PROGRAMMES
{
	DWORD           dwSize;
	UINT			nProgrammeID;													// ��ĿID����
	char			szProGrammeIdList[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// ��Ҫɾ���Ľ�ĿID�б�
} NET_IN_DEL_PROGRAMMES;

// ����ɾ����Ŀ��Ϣ�ӿ��������
typedef struct tagNET_OUT_DEL_PROGRAMMES
{
	DWORD           dwSize;
} NET_OUT_DEL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammesById
*   Purpose: ����ɾ����Ŀ��Ϣ
*   InputParam:	LLONG					:lLoginID	// ��½���
*   InputParam:	NET_IN_DEL_PROGRAMMES*	:pInParam 	// �������
*   InputParam:	NET_OUT_DEL_PROGRAMMES*	:pOutParam 	// �������
*   InputParam:	int						:nWaitTime	// �ȴ���ʱʱ��
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammesById(
											LLONG lLoginID, const NET_IN_DEL_PROGRAMMES* pInParam, 
											NET_OUT_DEL_PROGRAMMES *pOutParam, const int nWaitTime);

// ��ʱ��Ŀ�ƻ�������Ϣ
typedef struct tagNET_IMMEDIATELY_PLAN_INFO
{
	char			szPlanName[MAX_COMMON_STRING_64];			// ��Ŀ�ƻ�����
	char			szPlanID[MAX_COMMON_STRING_64];				// ��Ŀ�ƻ�ID
	BOOL			bEnable;									// �ƻ��Ƿ�����
	UINT			nPlayTime;									// ����ʱ��, ��λ : ����
	char			szProgrammeName[MAX_COMMON_STRING_64];		// ��ʱ�����Ľ�Ŀ����
	char			szProgrammeID[MAX_COMMON_STRING_64];		// ��ʱ�����Ľ�ĿID
	BYTE        	byReserved[512];							// �����ֽ�
} NET_IMMEDIATELY_PLAN_INFO;

// ��Ŀ���ڸ�ʽ
typedef struct tagNET_PROGRAMME_DATA
{
	DWORD                dwYear;                  // ��
    DWORD                dwMonth;                 // ��
    DWORD                dwDay;                	  // ��
} NET_PROGRAMME_DATA;

// ���״̬
typedef enum tagEM_REVIES_STATE
{
	EM_REVIES_UNKNOWN,			// δ֪
	EM_REVIES_PASS,				// ͨ��
	EM_REVIES_NOTPASS,			// ��ͨ��
} EM_REVIES_STATE;

// ��Ŀ�ƻ��еĽ�Ŀ��Ϣ
typedef struct tagNET_PROGRAMME_OF_PLAN
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// ��Ŀ����
	char						szProgrammeID[MAX_COMMON_STRING_64];	// ��ĿID
	BOOL						bIsBgProgramme;							// �Ƿ񱳾���Ŀ
	NET_PROGRAMME_TIME_INFO		stuSatrtTime;							// ��Ŀ��ʼʱ��
	NET_PROGRAMME_TIME_INFO		stuEndTime;								// ��Ŀ����ʱ��
	BYTE        				byReserved[128];						// �����ֽ�
} NET_PROGRAMME_OF_PLAN;

// ��ʱ��Ŀ�ƻ�������Ϣ
typedef struct tagNET_TIMER_PLAN_INFO
{
	char					szPlanName[MAX_COMMON_STRING_64];			// ��Ŀ�ƻ�����
	char					szPlanID[MAX_COMMON_STRING_64];				// ��Ŀ�ƻ�ID
	EM_SCREEN_DATE_TYPE		emDataType;									// ��Ŀ�ƻ���������
	UINT					nDataCount;									// ��Ŀ�ƻ����ڸ���
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];			// ��Ŀ���������б�
	NET_PROGRAMME_DATA		stuSatrtDate;								// ��Ŀ��ʼ����
	NET_PROGRAMME_DATA		stuEndDate;									// ��Ŀ��������
	EM_REVIES_STATE			emReviewState;								// ���״̬
	char					szReviewOpinion[MAX_COMMON_STRING_64];		// ������
	BOOL					bOverdue;									// �ƻ��Ƿ����
	UINT					nProgrammes;								// ��Ŀ����
	NET_PROGRAMME_OF_PLAN	stuProgrammes[MAX_PROGRAMMES_COUNT];		// ��Ŀ����Ϣ
	BYTE        			byReserved[512];							// �����ֽ�
} NET_TIMER_PLAN_INFO;

// ��ȡ���н�Ŀ�ƻ��������
typedef struct tagNET_IN_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMEPLANS;

// ��ȡ���н�Ŀ�ƻ��������
typedef struct tagNET_OUT_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
	UINT						nMaxPlanCnt;			// ��ʱ��Ŀ�Ͷ�ʱ��Ŀ�ƻ�������, ���û�ָ��
	UINT						nRetImmCnt;				// ʵ�ʷ��صļ�ʱ��Ŀ�ƻ�����
	NET_IMMEDIATELY_PLAN_INFO*	pstImmePlan;			// ��ʱ��Ŀ�ƻ���Ϣ
	UINT						nRetTimerCnt;			// ʵ�ʷ��صĶ�ʱ��Ŀ�ƻ�����
	NET_TIMER_PLAN_INFO*		pstTimerPlan;			// ��ʱ��Ŀ�ƻ���Ϣ
} NET_OUT_GET_ALL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammePlans
*   Purpose: ��ȡ���н�Ŀ�ƻ���Ϣ
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_GET_ALL_PROGRAMMEPLANS*	:pInParam		// �������
*   OutPutParam:	NET_OUT_GET_ALL_PROGRAMMEPLANS*	:pOutParam  	// �������
*   InputParam:		int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammePlans(
											LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMEPLANS *pInParam,
											NET_OUT_GET_ALL_PROGRAMMEPLANS *pOutParam, const int nWaitTime);


// ��Ŀ�ƻ�����
typedef enum tagEM_PROGRAMMEPLAN_TYPE
{
	EM_PROGRAMMEPLAN_UNKNOWN,		// δ֪
	EM_PROGRAMMEPLAN_IMME,			// ��ʱ�ƻ�
	EM_PROGRAMMEPLAN_TIMER,			// ��ʱ�ƻ�
} EM_PROGRAMMEPLAN_TYPE;

// ͨ����Ŀ�ƻ�ID ��ȡ��Ŀ�ƻ��������
typedef struct tagNET_IN_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	char						szPlanID[MAX_COMMON_STRING_64];		// ��Ŀ�ƻ�ID
} NET_IN_GET_PROGRAMMEPLAN_BYID;

// ͨ����Ŀ�ƻ�ID ��ȡ��Ŀ�ƻ��������
typedef struct tagNET_OUT_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	EM_PROGRAMMEPLAN_TYPE		emPlanType;		// ��Ŀ�ƻ�����
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;	// ��ʱ��Ŀ�ƻ���Ϣ, emPlanType ΪEM_PROGRAMMEPLAN_IMMEʱ��Ч
	NET_TIMER_PLAN_INFO			stuTimerPlan;	// ��ʱ��Ŀ�ƻ���Ϣ, emPlanType ΪEM_PROGRAMMEPLAN_TIMERʱ��Ч
} NET_OUT_GET_PROGRAMMEPLAN_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammePlanByID
*   Purpose: ͨ����Ŀ�ƻ�ID ��ȡ��Ŀ�ƻ�
*   InputParam:		LLONG								:lLoginID	// ��½���
*   InputParam:		NET_IN_GET_PROGRAMMEPLAN_BYID*		:pInParam	// �������
*   OutPutParam:	NET_OUT_GET_PROGRAMMEPLAN_BYID*		:pOutParam  // �������
*   InputParam:		int									:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammePlanByID(
										LLONG lLoginID,  NET_IN_GET_PROGRAMMEPLAN_BYID *pInParam,
										NET_OUT_GET_PROGRAMMEPLAN_BYID* pOutParam, const int nWaitTime);

// ���Ӽ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_IN_ADD_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// ��ʱ��Ŀ�ƻ���Ϣ
} NET_IN_ADD_IMME_PROGRAMMEPLAN;

// ���Ӷ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_IN_ADD_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// ��ʱ��Ŀ�ƻ���Ϣ
} NET_IN_ADD_TIMER_PROGRAMMEPLAN;

// ���ӽ�Ŀ�ƻ��������
typedef struct tagNET_OUT_ADD_PROGRAMMEPLAN
{
	DWORD           		dwSize;
	char					szPlanID[MAX_COMMON_STRING_64];				// ��Ŀ�ƻ�ID
} NET_OUT_ADD_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_AddOneImmediProgrammePlan
*   Purpose: ����һ����ʱ��Ŀ�ƻ�
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_ADD_IMME_PROGRAMMEPLAN*	:pInParam  		// �������
*   OutPutParam:	NET_OUT_ADD_PROGRAMMEPLAN*		:pstOutParam  	// �������
*   InputParam:		int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_IMME_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


/**************************************************************************************
*   Funcname: CLIENT_AddOneTimerProgrammePlan
*   Purpose: ����һ����ʱ��Ŀ�ƻ�
*   InputParam:		LLONG							:lLoginID		// ��½���
*   InputParam:		NET_IN_ADD_TIMER_PROGRAMMEPLAN*	:pInParam		// �������
*   OutPutParam:	NET_OUT_ADD_PROGRAMMEPLAN*		:pOutParam  	// �������
*   InputParam:		int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// �޸ļ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_IN_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// ��ʱ��Ŀ�ƻ���Ϣ
} NET_IN_MODIFY_IMME_PROGRAMMEPLAN;

// �޸ļ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_OUT_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_IMME_PROGRAMMEPLAN;


/**************************************************************************************
*   Funcname: CLIENT_ModifyOneImmediProgrammePlan
*   Purpose: �޸�һ����ʱ��Ŀ�ƻ�
*   InputParam:		LLONG								:lLoginID	// ��½���
*   InputParam:		NET_IN_MODIFY_IMME_PROGRAMMEPLAN*	:pInParam  	// �������
*   OutPutParam:	NET_OUT_MODIFY_IMME_PROGRAMMEPLAN*	:pOutParam  // �������
*   InputParam:		int									:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_IMME_PROGRAMMEPLAN* pInParam,
										NET_OUT_MODIFY_IMME_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


// �޸Ķ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_IN_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// ��ʱ��Ŀ�ƻ���Ϣ
} NET_IN_MODIFY_TIMER_PROGRAMMEPLAN;

// �޸Ķ�ʱ��Ŀ�ƻ��������
typedef struct tagNET_OUT_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneTimerProgrammePlan
*   Purpose: �޸�һ����ʱ��Ŀ�ƻ�
*   InputParam:		LLONG								:lLoginID	// ��½���
*   InputParam:		NET_IN_MODIFY_TIMER_PROGRAMMEPLAN*	:pInParam  	// �������
*   OutputParam:	NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN*	:pOutParam  // �������
*   InputParam:		int									:nWaitTime	// �ȴ���ʱʱ��
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// ɾ�������Ŀ�ƻ��������
typedef struct tagNET_IN_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
	UINT		nPlanID;												// ��Ŀ�ƻ�ID����
	char		szPlanID[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// ��Ŀ�ƻ�ID
} NET_IN_DEL_PROGRAMMEPLANS;

// ɾ�������Ŀ�ƻ��������
typedef struct tagNET_OUT_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
} NET_OUT_DEL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammePlans
*   Purpose: ɾ�������Ŀ�ƻ�
*   InputParam:	LLONG							:lLoginID		// ��½���
*   InputParam:	NET_IN_DEL_PROGRAMMEPLANS*		:pInParam  		// �������
*   InputParam:	NET_OUT_DEL_PROGRAMMEPLANS*		:pOutParam  	// �������
*   InputParam:	int								:nWaitTime		// �ȴ���ʱʱ��
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammePlans(
										LLONG lLoginID,  const NET_IN_DEL_PROGRAMMEPLANS* pInParam, 
										NET_OUT_DEL_PROGRAMMEPLANS* pOutParam, const int nWaitTime);

#define MAX_GD_COUNT	42

// �����ɫ����
typedef enum tagEM_GD_COLOR_TYPE
{
	EM_GD_COLOR_RED,		// ��ɫ
	EM_GD_COLOR_GREEN,		// ��ɫ
	EM_GD_COLOR_YELLOW,		// ��ɫ
} EM_GD_COLOR_TYPE;

//���ù��״̬��Ϣ�������
typedef struct tagNET_IN_SET_GD_STATUS
{
	DWORD				dwSize;
	char				szScreenID[MAX_COMMON_STRING_64];		// ����ID, ������ID
	UINT				nGDNum;									// �������
	EM_GD_COLOR_TYPE	emStatus[MAX_GD_COUNT];					// �����Ϣ
} NET_IN_SET_GD_STATUS;

//���ù��״̬��Ϣ�������
typedef struct tagNET_OUT_SET_GD_STATUS
{
	DWORD				dwSize;
} NET_OUT_SET_GD_STATUS;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenGDStatus
*   Purpose: ���ù��״̬��Ϣ
*   InputParam:	LLONG						:lLoginID		// ��½���
*   InputParam:	NET_IN_SET_GD_STATUS*		:pInParam  		// �������
*   InputParam:	NET_OUT_SET_GD_STATUS*		:pOutParam  	// �������
*   InputParam:	int							:nWaitTime		// �ȴ���ʱʱ��
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenGDStatus(
										LLONG lLoginID,  const NET_IN_SET_GD_STATUS* pInParam, 
										NET_OUT_SET_GD_STATUS* pOutParam, const int nWaitTime);



///////////////////////////////// ��֯Ŀ¼���� /////////////////////////////////////////

// ��֯Ŀ¼����-��ӽڵ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationAddNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_ADD_NODES* pInParam, DH_OUT_ORGANIZATION_ADD_NODES* pOutParam, int nWaitTime = 1000);

// ��֯Ŀ¼����-ɾ���ڵ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationDeleteNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_DELETE_NODES* pInParam, DH_OUT_ORGANIZATION_DELETE_NODES* pOutParam, int nWaitTime = 1000);

// ��֯Ŀ¼����-��ȡ�ڵ���Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationGetNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_GET_NODES* pInParam, DH_OUT_ORGANIZATION_GET_NODES* pOutParam, int nWaitTime = 1000);

// ��֯Ŀ¼����-���ýڵ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationSetNode(LLONG lLoginID, const DH_IN_ORGANIZATION_SET_NODE* pInParam, DH_OUT_ORGANIZATION_SET_NODE* pOutParam, int nWaitTime = 1000);


//////////////////////////////// ����ץ�� /////////////////////////////////

// ��ʼץ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSniffer(LLONG lLoginID, const DH_IN_START_SNIFFER* pInParam, DH_OUT_START_SNIFFER* pOutParam, int nWaitTime = 1000);

// ֹͣץ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSniffer(LLONG lLoginID, LLONG lSnifferID);

// ��ȡץ��״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSnifferInfo(LLONG lLoginID, const DH_IN_GET_SNIFFER_INFO* pInParam, DH_OUT_GET_SNIFFER_INFO* pOutParam, int nWaitTime = 1000);

//////////////////////////////// ���ſ���ؽӿ� /////////////////////////////////

//ץȡJPEGͼ��
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_GetPicJPEG(LLONG lPlayHandle, BYTE* pJpegBuf, DWORD dwBufSize,DWORD *pJpegSize,int quality);


//////////////////////////////// Զ���ļ����� /////////////////////////////////

// �½��ļ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CreateRemoteFile(LLONG lLoginID, const DH_IN_CREATE_REMOTE_FILE* pInParam, DH_OUT_CREATE_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// ɾ���ļ���Ŀ¼,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRemoteFiles(LLONG lLoginID, const DH_IN_REMOVE_REMOTE_FILES* pInParam, DH_OUT_REMOVE_REMOTE_FILES* pOutParam, int nWaitTime = 1000);

// ������,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameRemoteFile(LLONG lLoginID, const DH_IN_RENAME_REMOTE_FILE* pInParam, DH_OUT_RENAME_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// ��ʾĿ¼���ļ�����Ŀ¼,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ListRemoteFile(LLONG lLoginID, const DH_IN_LIST_REMOTE_FILE* pInParam, DH_OUT_LIST_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// ͬ���ļ��ϴ�, ֻ������С�ļ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

//  ��ʼ�첽�ļ��ϴ�������ԭ��,lUploadFileHandle Ϊ CLIENT_StartUploadRemoteFile �ӿڷ���ֵ
typedef void (CALLBACK *fUploadFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
// ��ʼ�첽�ļ��ϴ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, fUploadFileCallBack cbUploadFile, LDWORD dwUser);

// ֹͣ�첽�ļ��ϴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadRemoteFile(LLONG lUploadFileID);

// Զ��Ͷ��, ���豸�˲�����Ƶ�ļ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayAudioFile(LLONG lLoginID, const NET_IN_PLAY_AUDIO_FILE* pInParam, NET_OUT_PLAY_AUDIO_FILE* pOutParam, int nWaitTime = 1000);

// �ļ�����, ֻ������С�ļ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadRemoteFile(LLONG lLoginID, const DH_IN_DOWNLOAD_REMOTE_FILE* pInParam, DH_OUT_DOWNLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// ����ָ���ļ�������,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFileAttribute(LLONG lLoginID, const DH_IN_SET_FILEATTRIBUTE* pInParam, DH_OUT_SET_FILEATTRIBUTE* pOutParam, int nWaitTime = 1000);

// �ļ����أ���δ����ְ����ش��ļ���ÿ������ָ���ļ���������ƫ�ƣ�pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadPieceFile(LLONG lLoginID, const NET_IN_DOWNLOAD_PIECE_FILE* pInParam, NET_OUT_DOWNLOAD_PIECE_FILE* pOutParam,int nWaitTime = 1000);
////////////////////////////////// �洢�豸���� ////////////////////////////////////////

// ��ȡISCSI Target�б�, pInParam == NULL��ȡ����targets,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetISCSITargets(LLONG lLoginID, const DH_IN_ISCSI_TARGETS* pInParam, DH_OUT_ISCSI_TARGETS* pOutParam, int nWaitTime = 1000);
// pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetBitmap(LLONG lLoginID , const DH_IN_BITMAP* pInParam, DH_OUT_BITMAP* pOutParam, int nWaitTime = 1000);

// ��ȡ�洢�豸�����б�,pstuNames�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetStorageDeviceNames(LLONG lLoginID, DH_STORAGE_DEVICE_NAME* pstuNames, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);

// ��ȡ�洢�豸��Ϣ,pDevice�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetStorageDeviceInfo(LLONG lLoginID, const char* pszDevName, DH_STORAGE_DEVICE* pDevice, int nWaitTime = 1000);

// ����¼���ļ�������Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordInfo(LLONG lLoginID, const NET_IN_ATTACH_RECORD_INFO* pInParam, NET_OUT_ATTACH_RECORD_INFO* pOutParam, int nWaitTime = 1000);

// ȡ������¼���ļ�������Ϣ,lAttachHandle��CLIENT_AttachRecordInfo�ķ���ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordInfo(LLONG lAttachHandle);

// ����д��Զ�̴洢����Ϣ״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_NetStorageAttachWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_ATTACH_WRITE_INFO* pInParam, NET_OUT_STORAGE_ATTACH_WRITE_INFO* pOutParam, int nWaitTime);

// ȡ��д��Զ���豸��Ϣ,lAttachHandle��CLIENT_NetStorageAttachWriteInfo�ķ���ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageDetachWriteInfo(LLONG lAttachHandle);

// ��ѯԶ�̴洢��д����Ϣ״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageGetWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_GET_WRITE_INFO* pInParam, NET_OUT_STORAGE_GET_WRITE_INFO* pOutParam, int nWaitTime);

// RAID����, ��ͬ�������Ͷ�Ӧ��ͬ�Ľṹ��,pInBuf��pOutBuf�ڴ����û������ͷ�,��С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateRaid(LLONG lLoginID, NET_RAID_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

/////////////////////////////////// �����豸 ///////////////////////////////////////

// ����������ƵԴ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSearch(LLONG lLoginID, const DH_IN_MATRIX_SEARCH* pInParam, DH_OUT_MATRIX_SEARCH* pOutParam, int nWaitTime = 1000);

// ��ȡ�����������б�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMatrixTree(LLONG lLoginID, const DH_IN_GET_MATRIX_TREE* pInParam, DH_OUT_GET_MATRIX_TREE* pOutParam, int nWaitTime = 1000);

// ��ȡ�����ϼ��豸�б���Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSuperiorMatrixList(LLONG lLoginID, const DH_IN_GET_SUPERIOR_MATRIX_LIST* pInParam, DH_OUT_GET_SUPERIOR_MATRIX_LIST* pOutParam, int nWaitTime = 1000);

/************************************************************************/
/*                            ¼�񱸷ݻش�                                */
/************************************************************************/

// ��ʼ¼�񱸷ݻָ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRecordBackupRestore(LLONG lLoginID);

// ֹͣ¼�񱸷ݻָ�
CLIENT_NET_API void CALL_METHOD CLIENT_StopRecordBackupRestore(LLONG lRestoreID);

// ���¼�񱸷ݻָ�����,pInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_ADD_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// ɾ��¼�񱸷ݻָ�����,pInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_REMOVE_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// ��ȡ¼�񱸷ݻָ�������Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_QUERY_REC_BAK_RST_TASK* pInParam, DH_OUT_QUERY_REC_BAK_RST_TASK* pOutParam, int nWaitTime = 1000);

//////////////////////////////// Encode Manager  ////////////////////////////////
// ˾����¼�л�ȡ����ƻ�����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlan(LLONG lLoginID, const DH_IN_GET_ENCODE_PLAN* pInParam, DH_OUT_GET_ENCODE_PLAN* pOutParam, int nWaitTime = 1000);

// ����ָ���Ĺ��������ͷֱ������ʼ���ҵ��ʱ��, pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlanByResolution(LLONG lLoginID, const NET_IN_GET_ENCODEPLANE_BY_RESOLUTION* pInParam, NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION* pOutParam, int nWaitTime /*= 1000*/);

/************************************************************************/
/*                           ���ݿ��¼��ز���                         */
/************************************************************************/
// ����ѯ������ѯ��¼,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecord(LLONG lLoginID, NET_IN_FIND_RECORD_PARAM* pInParam, NET_OUT_FIND_RECORD_PARAM* pOutParam, int waittime=1000);    

// ���Ҽ�¼:nFilecount:��Ҫ��ѯ������, ����ֵΪý���ļ����� ����ֵ<nFilecount����Ӧʱ����ڵ��ļ���ѯ���,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API int CALL_METHOD CLIENT_FindNextRecord(NET_IN_FIND_NEXT_RECORD_PARAM* pInParam, NET_OUT_FIND_NEXT_RECORD_PARAM* pOutParam, int waittime=1000);

// ���Ҽ�¼����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordCount(NET_IN_QUEYT_RECORD_COUNT_PARAM* pInParam, NET_OUT_QUEYT_RECORD_COUNT_PARAM* pOutParam, int waittime=1000);

// ������¼����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecordClose(LLONG lFindHandle);

/************************************************************************/
/*                            ��̨Ԫ���ݽӿڶ���                         */
/************************************************************************/
// ������̨Ԫ���ݽӿ�,pstuInPtzStatusProc��pstuOutPtzStatusProc�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPTZStatusProc(LLONG lLoginID, NET_IN_PTZ_STATUS_PROC *pstuInPtzStatusProc,  NET_OUT_PTZ_STATUS_PROC *pstuOutPtzStatusProc, int nWaitTime = 3000);

// ֹͣ������̨Ԫ���ݽӿ�,lAttachHandle��CLIENT_AttachPTZStatusProc����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPTZStatusProc(LLONG lAttachHandle);

/************************************************************************/
/*                            ��̨��������                               */
/************************************************************************/
// ������̨������,pstuInViewRange��pstuOutViewRange�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachViewRangeState(LLONG lLoginID, NET_IN_VIEW_RANGE_STATE *pstuInViewRange, NET_OUT_VIEW_RANGE_STATE *pstuOutViewRange, int nWaitTime = 3000);

// ֹͣ������̨������,lAttachHandle��CLIENT_AttachViewRangeState����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachViewRangeState(LLONG lAttachHandle);

// ����������Ϣ,pstuInParam��pstuOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWeatherInfo(LLONG lLoginID, NET_IN_WEATHER_INFO *pstuInParam, NET_OUT_WEATHER_INFO *pstuOutParam, int nWaitTime);

// ֹͣ����������Ϣ,lAttachHandle��CLIENT_AttachWeatherInfo����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWeatherInfo(LLONG lAttachHandle);

// ������ࡢ�����С��ռ�������ÿ�����,pInstuParam��pstuOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetViewRangeByObject(LLONG lLoginID, NET_IN_SET_VIEW_RANGE_BY_OBJECT *pInstuParam, NET_OUT_SET_VIEW_RANGE_BY_OBJECT *pstuOutParam,  int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);
// ��ҳ��ȡ��Ϣ��ע��Ϣ�б�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetPointInfos(LLONG lLoginID, NET_IN_SCENICSPOT_GETPOINTINFOS_INFO *pInstuParam, NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO *pstuOutParam,  int nWaitTime);

// ���þ���㣬ԭ��ŵľ���㽫�ᱻ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotSetPointInfo(LLONG lLoginID,  NET_IN_SCENICSPOT_SETPOINTINFO_INFO *pInstuParam,  NET_OUT_SCENICSPOT_SETPOINTINFO_INFO *pstuOutParam,  int nWaitTime);

// ��ȡ�����֧�ֵ�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetCaps(LLONG lLoginID,  const NET_IN_SCENICSPOT_GETCAPS_INFO *pInstuParam,  NET_OUT_SCENICSPOT_GETCAPS_INFO *pstuOutParam,  int nWaitTime);

// ���ñ���Դ��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBackupSources(LLONG lLoginID, const NET_IN_SETBACKUP_SOURCES_INFO *pInstuParam, NET_OUT_SETBACKUP_SOURCES_INFO* pstuOutParam, int nWaitTime);
/************************************************************************/
/*                            BUS����                                   */
/************************************************************************/
// ����Bus״̬,pstuInBus��pstuOutBus�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBusState(LLONG lLoginID, NET_IN_BUS_ATTACH *pstuInBus, NET_OUT_BUS_ATTACH *pstuOutBus, int nWaitTime = 3000);

// ֹͣ����Bus״̬,lAttachHandle��CLIENT_AttachBusState����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBusState(LLONG lAttachHandle);

/************************************************************************/
/*                            ģ��������ͨ�����ݶ���                       */
/************************************************************************/

// ����ģ��������ͨ������,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalogAlarmData(LLONG lLoginID, const NET_IN_ANALOGALARM_DATA* pInParam, NET_OUT_ANALOGALARM_DATA* pOutParam, int nWaitTime);

// ֹͣ����ģ��������ͨ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalogAlarmData(LLONG lAttachHandle);

/************************************************************************/
/*                            ��¼����ӿڶ���                           */
/************************************************************************/

// ���ļ�¼����ӿ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordUpdater(LLONG lLoginID, const NET_IN_RECORDUPDATER_DATA* pInParam, NET_OUT_RECORDUPDATER_DATA* pOutParam, int nWaitTime);

// ֹͣ���ļ�¼����ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordUpdater(LLONG lAttachHandle);

///////////////////////////////����汾�ӿ�///////////////////////////////
// ����־���ܣ�pstLogPrintInfo�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogOpen(LOG_SET_PRINT_INFO *pstLogPrintInfo);

// �ر���־����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogClose();

// ��ѯ�豸��־--��չ,pLogBuffer�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogEx(LLONG lLoginID, DH_LOG_QUERY_TYPE logType, char *pLogBuffer, int maxlen, int *nLogBufferlen, void* reserved, int waittime=3000);

// ��ʼ��ѯ��־(Ŀǰֻ֧���Ž�BSCϵ��),pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartQueryLog(LLONG lLoginID, const NET_IN_START_QUERYLOG* pInParam, NET_OUT_START_QUERYLOG* pOutParam, int nWaitTime);

// ��ȡ��־(Ŀǰֻ֧���Ž�BSCϵ��),pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNextLog(LLONG lLogID, NET_IN_QUERYNEXTLOG* pInParam, NET_OUT_QUERYNEXTLOG* pOutParam, int nWaitTime);

// ������ѯ��־(Ŀǰֻ֧���Ž�BSCϵ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryLog(LLONG lLogID);

/************************************************************************/
/*                            ����ע����ؽӿ�                          */
/************************************************************************/
// ����ע���ض�����,������������
CLIENT_NET_API LONG CALL_METHOD CLIENT_ControlConnectServer(LLONG lLoginID, char* RegServerIP, WORD RegServerPort, int TimeOut=3000);

// ��������ע��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterServer(LLONG lLoginID, LONG ConnectionID, int waittime=1000);

// �Ͽ���������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDisconnectRegServer(LLONG lLoginID, LONG ConnectionID);

// ��ѯ�豸������ע���������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryControlRegServerInfo(LLONG lLoginID, LPDEV_SERVER_AUTOREGISTER lpRegServerInfo, int waittime=2000);

// ��Ӧ CLIENT_ControlRegisterOtherServer �ӿ�,�������
typedef struct tagNET_IN_REGISTER_INFO 
{
	DWORD               dwSize;										 	 // �ṹ���С
    char                szRegServerIP[DH_MAX_IPADDR_LEN_EX];             // ����ע��IP��ַ
    int                 nRegServerPort;                                  // ����ע��˿�
} NET_IN_REGISTER_INFO;

// CLIENT_ControlRegisterOtherServer �������
typedef struct tagNET_OUT_REGISTER_INFO 
{
    DWORD       dwSize;			// �ṹ���С
}NET_OUT_REGISTER_INFO;

// ��ʱ����ע�Ṧ��,����Ⱥ��Խ�����,�����豸ע�ᵽ����������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterOtherServer(LLONG lLoginID, NET_IN_REGISTER_INFO* pInParam, NET_OUT_REGISTER_INFO* pOutParam, int waittime);

// �ļ��ϴ��ӿ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FileTransmit(LLONG lLoginID, int nTransType, char* szInBuf, int nInBufLen, fTransFileCallBack cbTransFile, LDWORD dwUserData, int waittime);

// web��Ϣ�ϴ��ӿ�
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TransmitInfoForWeb(LLONG lLoginID, char* szInBuffer, DWORD dwInBufferSize, char* szOutBuffer, DWORD dwOutBufferSize, void* pExtData, int waittime=500);

// ˮӡ���, *nResult = 0-��ʾ��ǰͼƬδ���޸� *nResult = 1-��ʾ��ǰͼƬ�ѱ��޸�
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_WatermarkVerifyForPicture(char* szFilePath, int* nResult, void* pReserved);

// ��ͨ����ϴ򿪼���,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MultiRealPlay(LLONG lLoginID, DHDEV_IN_MULTIPLAY_PARAM* pInBuf, int nInBufLen, DHDEV_OUT_MULTIPLAY_PARAM* pOutBuf, int nOutBufLen, int* pRetLen);
 
// ��ͨ��ֹͣ����
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopMultiRealPlay(LLONG* lRealHandles, int nNumOfHandles);

// ���ûطŵ�YUV���ݻص��ӿ�,��hwnd��Ϊ��ʱ��Ч
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlaybackYUVCallBack(LLONG lPlayHandle, fYUVDataCallBack cYUVData, LDWORD dwUser);

// web��ȡ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// web��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// ���ò��Ų��Բ���,ֻ��ʵʱ����Ч
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayMethod(LLONG lRealHandle, int nStartTime, int nSlowTime, int nFastTime, int nFailedTime);

// �ر��豸����ע������������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseRegConnect(LLONG lHandle, char *pIp, WORD wPort, void *pParam);

// ���ļ��ط��������-����ʹ��
typedef struct tagNET_IN_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
    LPNET_RECORDFILE_INFO   lpRecordFile;                   // ¼���ļ���Ϣ
    HWND                    hWnd;                           // ���ھ��
    fDownLoadPosCallBack    cbDownLoadPos;                  // �طŽ��Ȼص�
    LDWORD                  dwPosUser;                      // ���Ȼص��û�����
    fDataCallBack           fDownLoadDataCallBack;          // �ط����ݻص�
    LDWORD                  dwDataUser;                     // ���ݻص��û�����
    char                    szDstIP[DH_COMMON_STRING_128];  // �豸IP
}NET_IN_PLAYBACK_BYFILE_PROXY;

// ���ļ��ط��������-����ʹ��
typedef struct tagNET_OUT_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYFILE_PROXY;

// ��ʱ��ط��������-����ʹ��
typedef struct tagNET_IN_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // ͨ����
    LPNET_TIME              lpStartTime;                    // ��ʼʱ��
    LPNET_TIME              lpStopTime;                     // ����ʱ��
    HWND                    hWnd;                           // ���ھ��
    fDownLoadPosCallBack    cbDownLoadPos;                  // �طŽ��Ȼص�
    LDWORD                  dwPosUser;                      // ���Ȼص��û�����
    fDataCallBack           fDownLoadDataCallBack;          // �ط����ݻص�
    LDWORD                  dwDataUser;                     // ���ݻص��û�����
    char                    szDstIP[DH_COMMON_STRING_128];  // �豸IP
}NET_IN_PLAYBACK_BYTIME_PROXY;

// ��ʱ��ط��������-����ʹ��
typedef struct tagNET_OUT_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYTIME_PROXY;

// ���ļ���ʽ�ط�--�����豸IP,������ʹ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYFILE_PROXY* pInParam, NET_OUT_PLAYBACK_BYFILE_PROXY* pOutParam);

// ��ʱ�䷽ʽ�ط�--�����豸IP,������ʹ��,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYTIME_PROXY* pInParam, NET_OUT_PLAYBACK_BYTIME_PROXY* pOutParam);

// ���������ļ�(��JSON��ʽ) pSendBuf: ����������,�û������ڴ�, nSendBufLen: �����ͳ���, reserved: �������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportConfigFileJson(LLONG lLoginID, char *pSendBuf, int nSendBufLen, void* reserved=NULL, int nWaitTime=3000);
// ���������ļ�(��JSON��ʽ) pOutBuffer: ���ջ���,�û������ڴ�, maxlen: ���ջ��峤��, nRetlen: ʵ�ʵ�������, reserved: �������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExportConfigFileJson(LLONG lLoginID, char *pOutBuffer, int maxlen, int *nRetlen, void* reserved=NULL, int nWaitTime=3000);

// ���ð�ȫ��Կ(���ż�������ʹ��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSecurityKey(LLONG lPlayHandle, char* szKey, DWORD nKeyLen);

// RPC������ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRpcMethod(LLONG lLoginID, const char* pszMethod, BOOL* pResult, int nWaitTime);

//////////////////////////////////////////////////////////////////////////
// ����ҵ����ؽӿ�
//////////////////////////////////////////////////////////////////////////

// ��鹫����·,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckBusLine(LLONG lLoginID, const NET_IN_CHECK_BUS_LINE* pstInParam, NET_OUT_CHECK_BUS_LINE* pstOutParam, int nWaitTime = 5000);

// �·�������·��Ϣ,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfo(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO* pstOutParam, int nWaitTime = 5000);

// ������Ӫ����,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusSchedule(LLONG lLoginID, const NET_IN_BUS_SCHEDULE_INFO* pstInParam, NET_OUT_BUS_SCHEDULE_INFO* pstOutParam, int nWaitTime = 5000);

// �·������Ű�ƻ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchWorkPlan(LLONG lLoginID, const NET_IN_BUS_DISPATCH_WORK_PLAN* pstInParam, NET_OUT_BUS_DISPATCH_WORK_PLAN* pstOutParam, int nWaitTime);

// ����Ԥ����Ϣ
typedef struct tagNET_WEATHERFORCAST_INFO
{
	int								nHighTemperature;					// ���£����죩����λ�����϶�
	int								nLowTemperature;					// ���£����죩����λ�����϶�
	int								nCurrentTemperature;				// ��ǰ�¶ȣ���λ�����϶�
	char							szWeatherState[64];					// ��������״̬
	int								nWeatherCode;						// ����״̬codeֵ
	BYTE							byReserved[1024];					// �����ֽ�
}NET_WEATHERFORCAST_INFO;

// ��������Ԥ�����
typedef struct tagNET_IN_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
	NET_WEATHERFORCAST_INFO			stuWeatherInfo;						// ����Ԥ����Ϣ
}NET_IN_PUSH_WEATHERFORCAST;

// ��������Ԥ������
typedef struct tagNET_OUT_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
}NET_OUT_PUSH_WEATHERFORCAST;

// ��������Ԥ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PushWeatherForecast(LLONG lLoginID, const NET_IN_PUSH_WEATHERFORCAST* pstInParam, NET_OUT_PUSH_WEATHERFORCAST* pstOutParam, int nWaitTime);
//////////////////////////////////////////////////////////////////////////

// ��������ķ�������
typedef enum tagNET_MISSION_FEEDBACK_TYPE
{
    NET_MISSION_FEEDBACK_NO = 0,                        // ����Ҫ����
    NET_MISSION_FEEDBACK_YES,                           // ��Ҫ�Է�����, �Է�Ӧ���ظ�DH_ALARM_MISSION_CONFIRM����ȷ���¼�
}NET_MISSION_FEEDBACK_TYPE;

// ��Ϣ����(����)
typedef enum tagNET_MISSION_MESSAGE_TYPE
{
    NET_MISSION_MESSAGE_TEXT = 0 ,      //�ı���Ϣ 
    NET_MISSION_MESSAGE_AD ,            //�����Ϣ
    NET_MISSION_MESSAGE_BROAD ,         //�㲥��Ϣ
    NET_MISSION_MESSAGE_DRIVER ,        //˾����Ϣ
    NET_MISSION_MESSAGE_DISPATCH ,      //����ָ��
    NET_MISSION_MESSAGE_TRANSPARENT ,   //͸������      
    NET_MISSION_MESSAGE_URGENT,         //���¼�
    NET_MISSION_MESSAGE_MAX  ,
}NET_MISSION_MESSAGE_TYPE;

// CLIENT_AddMission()�ӿ��������
typedef struct tagNET_IN_ADD_MISSION 
{
    DWORD           dwSize;
    char            szTitle[DH_COMMON_STRING_256];      // ��������
    char            szMissionID[DH_COMMON_STRING_256];  // ����ID
    char            szComment[DH_COMMON_STRING_256];    // �ظ�����
    NET_MISSION_FEEDBACK_TYPE   emFeedBack;             // ��Ӻ�������
    NET_MISSION_MESSAGE_TYPE    emMessageType;          // ��Ϣ����
	BOOL            bComment;                           // FALSEʱ��szComment��Ч��TRUEʱ��szCommentEx��Ч
	char            szCommentEx[DH_COMMON_STRING_2048]; // �ظ����ݣ�������Ϊ��
	int				nChannel[DH_MAX_CHANNEL_COUNT];		// ���ļ���ͨ�����е��ӣ�֧�ֶ�ͨ��ͬʱ����
	int				nDuration;							// ������ʾʱ����0��ʾһֱ��������һ��Э���·����������ֱ�ʾ��ʾʱ������λ��
	int				nCount;								//  nChannelʵ�ʳ���
}NET_IN_ADD_MISSION;

// CLIENT_AddMission()�ӿ��������
typedef struct tagNET_OUT_ADD_MISSION 
{
    DWORD           dwSize;
}NET_OUT_ADD_MISSION;
//pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMission(LLONG lLoginID, const NET_IN_ADD_MISSION* pstInParam, NET_OUT_ADD_MISSION* pstOutParam, int nWaitTime = 3000);

// CLIENT_ParkingControlStartFind�ӿ��������
typedef struct tagNET_IN_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    BOOL                      bSearchCount;    // ��ѯ��¼�����Ƿ���Ч
    DWORD                     dwSearchCount;   // ��ѯ��¼����, ��ֵ��Χ1~100
    BOOL                      bBegin;          // ��ѯ��ʼʱ���Ƿ���Ч
    NET_TIME                  stuBegin;        // ��ѯ��ʼʱ��
    BOOL                      bEnd;            // ��ѯ����ʱ���Ƿ���Ч
    NET_TIME                  stuEnd;          // ��ѯ����ʱ��
    BOOL                      bCardType;       // �������Ƿ���Ч
    NET_ECK_IC_CARD_USER_TYPE emCardType;      // ������
    BOOL                      bFlag;           // ��������Ƿ���Ч
    NET_ECK_CAR_PASS_FLAG     emFlag;          // �������
} NET_IN_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlStartFind�ӿ��������
typedef struct tagNET_OUT_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    DWORD                     dwTotalCount;    // ���ϴ˴β�ѯ�����Ľ��������
} NET_OUT_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlDoFind�ӿ��������
typedef struct tagNET_IN_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    DWORD                     dwFileCount;     // ��ǰ���ѯ�ļ�¼����
} NET_IN_PARKING_CONTROL_DO_FIND_PARAM;

// ������¼��Ϣ
typedef struct tagNET_CAR_PASS_ITEM
{
    DWORD                      dwSize; 
    NET_TIME                   stuTime;          // ����ʱ��
    DWORD                      dwCardNo;         // ����
    NET_ECK_IC_CARD_USER_TYPE  emCardType;       // ������
    NET_ECK_CAR_PASS_FLAG      emFlag;           // ������¼����
} NET_CAR_PASS_ITEM;

// CLIENT_ParkingControlDoFind�ӿ��������
typedef struct tagNET_OUT_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // �ṹ���С
    NET_CAR_PASS_ITEM        *pstuRecordList;  // ��¼�б�,�û������ڴ�,��СΪsizeof(NET_CAR_PASS_ITEM)*nMaxRecordNum
    int                       nMaxRecordNum;   // �б��¼��
    int                       nRetRecordNum;   // ��ѯ���ļ�¼����,����ѯ��������С�����ѯ������ʱ,��ѯ����
} NET_OUT_PARKING_CONTROL_DO_FIND_PARAM;

// ��ʼ������¼��ѯ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlStartFind(LLONG lLoginID, NET_IN_PARKING_CONTROL_START_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_START_FIND_PARAM* pOutParam, int waittime);

// ��ȡ������¼,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDoFind(LLONG lFindeHandle, NET_IN_PARKING_CONTROL_DO_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_DO_FIND_PARAM* pOutParam, int waittime);

// ����������¼��ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlStopFind(LLONG lFindHandle);

// ���Ĺ�����¼���ݻص�����ԭ��
typedef void (CALLBACK *fParkingControlRecordCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CAR_PASS_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_ParkingControlAttachRecord()�ӿ��������
typedef struct tagNET_IN_PARKING_CONTROL_PARAM
{
    DWORD                           dwSize;
    fParkingControlRecordCallBack   cbCallBack;                 // ���ݻص�����
    LDWORD                          dwUser;                     // �û��������
} NET_IN_PARKING_CONTROL_PARAM;

// CLIENT_ParkingControlDetachRecord()�ӿ��������
typedef struct tagNET_OUT_PARKING_CONTROL_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARKING_CONTROL_PARAM;

// ������¼����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachRecord(LLONG lLoginID, const NET_IN_PARKING_CONTROL_PARAM* pInParam, NET_OUT_PARKING_CONTROL_PARAM* pOutParam, int nWaitTime);

// ȡ��������¼����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachRecord(LLONG lAttachHandle);

// ������״̬
typedef enum tagNET_CAR_DETECTOR_STATE
{
    NET_CAR_DETECTOR_STATE_UNKNOWN = -1,
    NET_CAR_DETECTOR_STATE_OFFLINE = 0,                   // ����
    NET_CAR_DETECTOR_STATE_ONLINE,                        // ����
    NET_CAR_DETECTOR_STATE_LOOPOFFLINE,                   // �ظ���Ȧ����
} NET_CAR_DETECTOR_STATE;

// �����豸ͨ��״̬
typedef enum tagNET_AUXILIARY_DEV_STATE
{
    NET_AUXILIARY_DEV_STATE_UNKNOWN = -1,
    NET_AUXILIARY_DEV_STATE_OFFLINE = 0,                   // ����
    NET_AUXILIARY_DEV_STATE_ONLINE,                        // ����
} NET_AUXILIARY_DEV_STATE;

// ����IC�����������
typedef enum tagNET_IC_CARD_STATUS
{
    NET_IC_CARD_STATUS_UNKNOWN = -1,
    NET_IC_CARD_STATUS_NORMAL = 0,                         // ����
    NET_IC_CARD_STATUS_NOCARD,                             // �޿�
    NET_IC_CARD_STATUS_LOWCARD,                            // �ٿ�
    NET_IC_CARD_STATUS_FULLCARDS,                          // ���տ���
} NET_IC_CARD_STATUS;

// �����豸����ģʽ
typedef enum tagNET_AUXILIARY_WORK_MODE
{
    NET_AUXILIARY_WORK_MODE_UNKNOWN = 0,
    NET_AUXILIARY_WORK_MODE_OFFLINE,                       // �ѻ�����
    NET_AUXILIARY_WORK_MODE_ONLINE,                        // ��������
} NET_AUXILIARY_WORK_MODE;

// �����¼�����DH_ALARM_AUXILIARY_DEV_STATE(�����豸״̬�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_AUXILIARY_DEV_STATE
{
    DWORD                   dwSize;
    NET_CAR_DETECTOR_STATE  emDetector;                   // ������״̬
    NET_AUXILIARY_DEV_STATE emLed;                        // LED״̬������״̬
    NET_AUXILIARY_DEV_STATE emICDetectBoard;              // ���ˢ����
    NET_AUXILIARY_DEV_STATE emICSenderBoard;              // ����ˢ����
    NET_IC_CARD_STATUS      emICCardStatus;               // ����IC�����������
    NET_AUXILIARY_WORK_MODE emWorkMode;                   // ����ģʽ
} ALARM_AUXILIARY_DEV_STATE;

// ͣ������ˢ������
typedef enum tagNET_PARKING_CARD_TYPE
{
    NET_PARKING_CARD_TYPE_UNKNOWN,
    NET_PARKING_CARD_TYPE_SEND,                             // ����
    NET_PARKING_CARD_TYPE_DETECT,                           // ˢ��
} NET_PARKING_CARD_TYPE;

// �����¼�����DH_ALARM_PARKING_CARD(ͣ��ˢ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_PARKING_CARD
{
    DWORD                   dwSize;
    NET_PARKING_CARD_TYPE   emType;                       // ����
    DWORD                   dwCardNo;                     // ����
    char                    szPlate[DH_COMMON_STRING_16]; // ����
} ALARM_PARKING_CARD;

// ����Դ�豸������
typedef enum tagEM_ALARM_TRANSMIT_DEV_SRC_TYPE
{
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_UNKNOWN,             // δ֪
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_DIGIT,               // Digit   ����
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_ANALOG,              // Analog ģ��
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_SMARTLOCK,           // SmartLock ������
}EM_ALARM_TRANSMIT_DEV_SRC_TYPE;

// ��������
typedef enum tagEM_ALARM_TRANSMIT_ALARM_TYPE
{
    EM_ALARM_TRANSMIT_ALARM_TYPE_UNKNOWN,               // δ֪
    EM_ALARM_TRANSMIT_ALARM_TYPE_PREVENTREMOVE,         // "PreventRemove"   ����
    EM_ALARM_TRANSMIT_ALARM_TYPE_LOWERPOWER,            // "LowerPower"  �͵�ѹ
    EM_ALARM_TRANSMIT_ALARM_TYPE_KEY,                   // "Key"          Կ��
    EM_ALARM_TRANSMIT_ALARM_TYPE_DURESS,                // "Duress"       в��
}EM_ALARM_TRANSMIT_ALARM_TYPE;

// ���������¼�(��Ӧ�ṹ��ALARM_PROFILE_ALARM_TRANSMIT_INFO)
typedef struct tagALARM_PROFILE_ALARM_TRANSMIT_INFO
{
    DWORD                           dwSize;
    int                             nChannelID;                             // ͨ����
    int                             nAction;                                // 0:��ʼ 1:ֹͣ
    NET_TIME                        stuTime;                                // �¼�����ʱ��
    NET_SENSE_METHOD                emSenseMethod;                          // ����������
    char                            szUserID[DH_COMMON_STRING_128];         // �����û�,��������
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // ����Դ�豸������
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // ��������
}ALARM_PROFILE_ALARM_TRANSMIT_INFO;

// ���ļ���λ��Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ATTACH_INFO* pInParam, NET_OUT_SCADA_ATTACH_INFO* pOutParam, int nWaitTime);

// ȡ������λ��Ϣ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADADetachInfo(LLONG lAttachHandle);

// ��ȡ��ֵ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAGetThreshold(LLONG lLoginID, const NET_IN_SCADA_GET_THRESHOLD* pInParam, NET_OUT_SCADA_GET_THRESHOLD* pOutParam, int nWaitTime);

// ������ֵ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetThreshold(LLONG lLoginID, const NET_IN_SCADA_SET_THRESHOLD* pInParam, NET_OUT_SCADA_SET_THRESHOLD* pOutParam, int nWaitTime);

// ��ʼ��ѯSCADA��λ��ʷ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindSCADA(LLONG lLoginID, const NET_IN_SCADA_START_FIND* pInParam, NET_OUT_SCADA_START_FIND* pOutParam, int nWaitTime);

// ��ȡSCADA��λ��ʷ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindSCADA(LLONG lFindHandle, const NET_IN_SCADA_DO_FIND* pInParam, NET_OUT_SCADA_DO_FIND* pOutParam, int nWaitTime);

// ֹͣ��ѯSCADA��λ��ʷ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindSCADA(LLONG lFindHandle);

// ���ļ���λ������Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAlarmAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ALARM_ATTACH_INFO* pInParam, NET_OUT_SCADA_ALARM_ATTACH_INFO* pOutParam, int nWaitTime = 3000);

// ȡ�����ļ���λ������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAAlarmDetachInfo(LLONG lAttachHandle);

// ���ü���λ��Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetInfo(LLONG lLoginID, const NET_IN_SCADA_POINT_SET_INFO_LIST* pInParam, NET_OUT_SCADA_POINT_SET_INFO_LIST* pOutParam, int nWaitTime = 3000);

//////////////////////////////////////////////////////////////////////////

// �������߶�����Ϣ�ӿ�,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLowRateWPAN(LLONG lLoginID, const NET_IN_ATTACH_LOWRATEWPAN* pstInParam, NET_OUT_ATTACH_LOWRATEWPAN* pstOutParam, int nWaitTime = 3000);

// ȡ���������߶�����Ϣ�ӿ�,lAttachHandle��CLIENT_AttachLowRateWPAN����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLowRateWPAN(LLONG lAttachHandle);

//��ȡԤ��ʱ����������ʾ�Ĳ��ſ�˿�,�Ի�ȡ���Ķ˿����ر���Դ���͵Ĳ���,��Ӱ���������ܵ�ʹ��
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetRealPlayPort(LLONG lRealPlayHandle);

//��ȡ�ط�ʱ����������ʾ�Ĳ��ſ�˿�,,�Ի�ȡ���Ķ˿����ر���Դ���͵Ĳ���,��Ӱ���������ܵ�ʹ��
CLIENT_NET_API LONG CALL_METHOD  CLIENT_GetPlayBackPort(LLONG lPlayBackHandle);

// ����ͣ��ϵͳ��λ״̬
typedef enum tagNET_ECK_PARK_STATE
{
    NET_ECK_PARK_STATE_UNKOWN,
    NET_ECK_PARK_STATE_PARK,                     // ��λ�г�
    NET_ECK_PARK_STATE_NOPARK,                   // ��λ�޳�
} NET_ECK_PARK_STATE;

// ��λ��Ϣ
typedef struct tagNET_PARK_INFO_ITEM
{
    DWORD                      dwSize; 
    char                       szParkNo[DH_COMMON_STRING_32];   // ��λ��
    NET_ECK_PARK_STATE         emState;                         // ��λ״̬
    DWORD                      dwScreenIndex;                   // ��λ����ʾ��Ӧ���յ���������
    DWORD                      dwFreeParkNum;                   // ������ʾ�ĵ�ǰ���೵λ��Ŀ
} NET_PARK_INFO_ITEM;

// ���ĳ�λ��Ϣ�ص�����ԭ��
typedef void (CALLBACK *fParkInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_PARK_INFO_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// ��λ���������
typedef enum tagNET_ECK_PARK_DETECTOR_TYPE
{
    NET_ECK_PARK_DETECTOR_TYPE_SONIC,                     // ������̽����
    NET_ECK_PARK_DETECTOR_TYPE_CAMERA,                    // ��������
    NET_ECK_PARK_DETECTOR_TYPE_ALL,
} NET_ECK_PARK_DETECTOR_TYPE;

// ��λ�������Ϣ��ѯ����
typedef struct tagNET_PARK_INFO_FILTER
{
    DWORD                      dwSize; 
    DWORD                      dwNum;                                  // ��λ�������������
    NET_ECK_PARK_DETECTOR_TYPE emType[NET_ECK_PARK_DETECTOR_TYPE_ALL]; // ��λ���������
} NET_PARK_INFO_FILTER;

// CLIENT_ParkingControlAttachParkInfo()�ӿ��������
typedef struct tagNET_IN_PARK_INFO_PARAM
{
    DWORD                           dwSize;
    NET_PARK_INFO_FILTER            stuFilter;
    fParkInfoCallBack               cbCallBack;                 // ���ݻص�����
    LDWORD                          dwUser;                     // �û��������
} NET_IN_PARK_INFO_PARAM;

// CLIENT_ParkingControlAttachParkInfo()�ӿ��������
typedef struct tagNET_OUT_PARK_INFO_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARK_INFO_PARAM;

// ��λ״̬����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachParkInfo(LLONG lLoginID, const NET_IN_PARK_INFO_PARAM* pInParam, NET_OUT_PARK_INFO_PARAM* pOutParam, int nWaitTime);

// ȡ����λ״̬����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachParkInfo(LLONG lAttachHandle);

// ������Ƶ�绰״̬��Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVTPCallState(LLONG lLoginID, const NET_IN_VTP_CALL_STATE_ATTACH* pInParam, NET_OUT_VTP_CALL_STATE_ATTACH* pOutParam, int nWaitTime);

// ȡ��������Ƶ�绰״̬��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVTPCallState(LLONG lCallStateHandle);

// �ֻ�����������Ϣ, ʹ��RegisterID��ʶ������,pstuCfg�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// ɾ���ֻ�����������Ϣ, ʹ��RegisterID��ʶ������,pstuIn��pstuOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

// �ֻ�����������Ϣ, ʹ��RegisterID+AppID��ʶ������,AppID���ݲ��ܴ����,��ſ������»��ߴ���,pstuCfg�ڴ����û������ͷ� 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// ɾ���ֻ�����������Ϣ, ʹ��RegisterID+AppID��ʶ������,AppID���ݲ��ܴ����,��ſ������»��ߴ���,pstuIn��pstuOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

////////////////////////////////////////////////////////////////////////////////
// ����Ӧ����� ��������
typedef enum tagEM_RPC_NETAPP_TYPE
{
    EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT,      //  ���������Դͳ��, pstuIn ��Ӧ NET_IN_NETAPP_GET_NET_RESOURCE_STAT*,pstuOut��Ӧ NET_OUT_NETAPP_GET_NET_RESOURCE_STAT*
}EM_RPC_NETAPP_TYPE;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT ���
typedef struct tagNET_IN_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
}NET_IN_NETAPP_GET_NET_RESOURCE_STAT;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT ����
typedef struct tagNET_OUT_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
    int                 nIPChanneIn;             // IPͨ������          ��λ��kbps
    int                 nNetRemain;              // �������ʣ��        ��λ��kbps
    int                 nNetCapability;          // �������������      ��λ��Mbps
    int                 nRemotePreview;          // Զ��Ԥ��            ��λ��kbps
    int                 nRemotePlayAndDownload;  // Զ�̻طż�����      ��λ��kbps
    int                 nRemoteSendRemain;       // Զ�̷���ʣ��        ��λ��kbps
    int                 nRemoteSendCapability;   // Զ�̷���������      ��λ��Mbps
}NET_OUT_NETAPP_GET_NET_RESOURCE_STAT;

// ����Ӧ�����,��˾�ڲ����ƽӿ�
// �����ڻ�ȡǰ���豸��������Դ����,�������շ����ݵ����ʵ�,pstuIn��pstuOut�ڴ����û������ͷţ���С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RPC_NetApp(LLONG lLoginID, EM_RPC_NETAPP_TYPE emType, const void* pstuIn, void* pstuOut, int nWaitTime = 1000);
//pParam�ڴ����û������ͷţ���С����emType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOptimizeMode(EM_OPTIMIZE_TYPE emType, void *pParam);

// ȫ����̨��������
typedef enum tagEM_NET_WIDE_VIEW_CTRL
{
    EM_NET_WIDE_VIEW_CTRL_START,                      // ��ʼ����ȫ��ͼ, startGenerateWideView, �ṹ�� NET_IN_WIDE_VIEW_GENERATE_START �� NET_OUT_WIDE_VIEW_GENERATE_START
    EM_NET_WIDE_VIEW_CTRL_STOP,                       // ֹͣ����ȫ��ͼ, stopGenerateWideView, �ṹ�� NET_IN_WIDE_VIEW_GENERATE_STOP �� NET_OUT_WIDE_VIEW_GENERATE_STOP
    EM_NET_WIDE_VIEW_CTRL_PROGRESS,                   // ��ȡȫ��ͼ���ɵĵ�ǰ����, getWideViewProgress, �ṹ�� NET_IN_WIDE_VIEW_PROGRESS �� NET_OUT_WIDE_VIEW_PROGRESS
    EM_NET_WIDE_VIEW_CTRL_IMAGEINFO,                  // ��ȡȫ��ͼ��Ϣ, getImageInfo, �ṹ�� NET_IN_WIDE_VIEW_IMAGE �� NET_OUT_WIDE_VIEW_IMAGE
    EM_NET_WIDE_VIEW_CTRL_WV_COORD,                   // ����̨����ת����ȫ��ͼ����, getWideViewCoordinates, �ṹ�� NET_IN_WIDE_VIEW_WV �� NET_OUT_WIDE_VIEW_WV
    EM_NET_WIDE_VIEW_CTRL_PTZ_COORD,                  // ��ȫ��ͼת������̨��������, getPtzCoordinates, �ṹ�� NET_IN_WIDE_VIEW_PTZ �� NET_OUT_WIDE_VIEW_PTZ
} EM_NET_WIDE_VIEW_CTRL;

// ��ʼ����ȫ��ͼ���
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
} NET_IN_WIDE_VIEW_GENERATE_START;

// ��ʼ����ȫ��ͼ����
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_START;

//  ֹͣ����ȫ��ͼ���
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
} NET_IN_WIDE_VIEW_GENERATE_STOP;

//  ֹͣ����ȫ��ͼ����
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_STOP;

//  ��ȡȫ��ͼ���ɵĵ�ǰ�������
typedef struct tagNET_IN_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
} NET_IN_WIDE_VIEW_PROGRESS;

//  ��ȡȫ��ͼ���ɵĵ�ǰ���ȳ���
typedef struct tagNET_OUT_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nProgress;               // ȫ��ͼ���ɵĵ�ǰ����, ��Χ0-100
} NET_OUT_WIDE_VIEW_PROGRESS;

//  ��ȡȫ��ͼ��Ϣ���
typedef struct tagNET_IN_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
} NET_IN_WIDE_VIEW_IMAGE;

//  ȫ��ͼ��Ϣ
typedef struct tagNET_WIDE_VIEW_IMAGE_INFO
{
    char                     szImageUrl[MAX_PATH];    // URL
} NET_WIDE_VIEW_IMAGE_INFO;

// ��ȡȫ��ͼ��Ϣ����
typedef struct tagNET_OUT_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    NET_WIDE_VIEW_IMAGE_INFO stuImageInfo;             // ȫ��ͼ��Ϣ
} NET_OUT_WIDE_VIEW_IMAGE;

#define NET_WIDE_VIEW_COORDINATES_MAX (64)

//  ����̨����ת����ȫ��ͼ�������
typedef struct tagNET_IN_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
    int                      nNum;                    // ��Ч����̨�������
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // ��̨������Ŵ���
} NET_IN_WIDE_VIEW_WV;

//  ����̨����ת����ȫ��ͼ�������
typedef struct tagNET_OUT_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // ȫ��ͼ����
} NET_OUT_WIDE_VIEW_WV;

//  ��ȫ��ͼת������̨�����������
typedef struct tagNET_IN_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    int                      nChannel;                // ͨ����
    int                      nNum;                    // ��Ч��ȫ���������
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // ȫ��ͼ����
} NET_IN_WIDE_VIEW_PTZ;

//  ��ȫ��ͼת������̨�����������
typedef struct tagNET_OUT_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // ��̨������Ŵ���
} NET_OUT_WIDE_VIEW_PTZ;

// ȫ����̨��ز����ӿ�, �������Ͳ��� EM_NET_WIDE_VIEW_CTRL,pstuInParam��pstuOutParam�ڴ����û������ͷ�,��С����emCtrlType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WideViewCtrl(LLONG lLoginID, EM_NET_WIDE_VIEW_CTRL emCtrlType, const void *pstuInParam, void *pstuOutParam, int nWaitTime = 1000);
// pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFile(LLONG lLoginID,const NET_IN_SET_MARK_FILE* pInParam, NET_OUT_SET_MARK_FILE* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );
//��ʱ����¼��pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFileByTime(LLONG lLoginID, const NET_IN_SET_MARK_FILE_BY_TIME* pInParam, NET_OUT_SET_MARK_FILE_BY_TIME* pOutParam, int nWaitTime = 1000);

//��ʱ����¼��&&����C5Э��

//��ȡ���¼����Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarkInfo(LLONG lLoginID, const NET_IN_GET_MARK_INFO* pInParam, NET_OUT_GET_MARK_INFO* pOutParam, int nWaitTime = 1000);

// ¼����������
typedef enum tagEM_NET_AUDIO_REC_STREAM
{
    EM_NET_AUDIO_REC_STREAM_UNKNOWN,
    EM_NET_AUDIO_REC_STREAM_MAIN,                    // Main
    EM_NET_AUDIO_REC_STREAM_EXTRA1,                  // Extra1
    EM_NET_AUDIO_REC_STREAM_EXTRA2,                  // Extra2
    EM_NET_AUDIO_REC_STREAM_EXTRA3,                  // Extra3
    EM_NET_AUDIO_REC_STREAM_TALKBACK,                // Talkback
} EM_NET_AUDIO_REC_STREAM;

// ����/�ر���Ƶ¼��õ�¼�������, ��Ӧ����DH_CTRL_AUDIO_REC_START_NAME��DH_CTRL_AUDIO_REC_STOP_NAME
typedef struct tagNET_IN_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // �ýṹ���С
    int                      nChannel;               // ��Ƶͨ����
    EM_NET_AUDIO_REC_STREAM  emStream;               // ��������
} NET_IN_AUDIO_REC_MNG_NAME;

// ����/�ر���Ƶ¼��õ�¼��������, ��Ӧ����DH_CTRL_AUDIO_REC_START_NAME��DH_CTRL_AUDIO_REC_STOP_NAME
typedef struct tagNET_OUT_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // �ýṹ���С
    char                     szFileName[MAX_PATH];   // ¼���ļ���
} NET_OUT_AUDIO_REC_MNG_NAME;

// ����¼������
typedef enum tagEM_NET_REC_EVENT
{
    EM_NET_REC_EVENT_UNKNOWN,                       // δ֪
    EM_NET_REC_EVENT_ALARM,                         // Alarm
} EM_NET_REC_EVENT;

// ����/�ر�ָ��ͨ��¼�����, ����ָ��¼������
typedef struct tagNET_IN_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // �ýṹ���С
    int                      nChannel;               // ͨ����
    EM_NET_REC_EVENT         emType;                 // ¼������, nActionΪ0ʱ��Ч
    int                      nAction;                // 0:����, 1:�ر�
} NET_IN_REC_MNG_CTRL_MPT300;

// ����/�ر�ָ��ͨ��¼�����
typedef struct tagNET_OUT_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_OUT_REC_MNG_CTRL_MPT300;

// ��ʱץͼ(�����ֶ�ץͼ)���, ��Ӧ����DH_CTRL_SNAP_MNG_SNAP_SHOT
typedef struct tagNET_IN_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // �ýṹ���С
    int                      nChannel;               // ͨ����
    int                      nTime;                  // ���Ĵ���, 0��ʾֹͣץ��,������ʾ����ץ�ĵ�����
} NET_IN_SNAP_MNG_SHOT;

// ��ʱץͼ(�����ֶ�ץͼ)����, ��Ӧ����DH_CTRL_SNAP_MNG_SNAP_SHOT
typedef struct tagNET_OUT_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_OUT_SNAP_MNG_SHOT;

// �ر����ݿ�/�ָ����ݿ����, ��Ӧ����DH_CTRL_LOG_STOP��DH_CTRL_LOG_RESUME
typedef struct tagNET_IN_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_IN_LOG_MNG_CTRL;

// �ر����ݿ�/�ָ����ݿ����, ��Ӧ����DH_CTRL_LOG_STOP��DH_CTRL_LOG_RESUME
typedef struct tagNET_OUT_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_OUT_LOG_MNG_CTRL;

// ֱ��͸�����
typedef struct tagNET_IN_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // �ṹ���С
    char                    *szInBuffer;              // ���͸��豸������
    DWORD                    dwInBufferSize;          // ���͸��豸�����ݴ�С
    NET_TRANSMIT_EXT_INFO    stExtData;               // ���͸��豸��������չ, ����������
} NET_IN_TRANSMIT_DIRECTLY;

// ֱ��͸������
typedef struct tagNET_OUT_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // �ṹ���С
    char                    *szOutBuffer;             // �豸���ص�����
    DWORD                    dwOutBufferSize;         // �豸���ص����ݻ����С
    DWORD                    dwRetBufferSize;         // ʵ�ʷ��ص����ݴ�С
} NET_OUT_TRANSMIT_DIRECTLY;

//������Ǳ����,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClearRepeatEnter(LLONG lLoginID, const NET_IN_CLEAR_REPEAT_ENTER* pInParam, NET_OUT_CLEAR_REPEAT_ENTER* pOutParam, int nWaitTime = 1000);

// ��ȡ����Ա�û���,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOperatorName(LLONG lLoginID, const NET_IN_GET_OPERATOR_NAME* pInParam, NET_OUT_GET_OPERATOR_NAME* pOutParam, int nWaitTime = 1000);

// POS�����ӷ�ʽ
typedef enum tagEM_CONN_TYPE
{
    EM_CONN_TYPE_UNKNOWN,                            // δ֪
    EM_CONN_TYPE_NET,                                // ��������
    EM_CONN_TYPE_RS232,                              // RS232
    EM_CONN_TYPE_RS485,                              // RS485
} EM_CONN_TYPE;

// POS������Э��
typedef enum tagEM_CONN_PROT
{
    EM_CONN_PROT_UNKNOWN,                            // δ֪
    EM_CONN_PROT_NONE,                               // �Զ���
    EM_CONN_PROT_POS,                                // POS
} EM_CONN_PROT;

// POS��״̬
typedef enum tagEM_POS_STATUS
{
    EM_POS_STATUS_OTHER = -1,                        // ��������
    EM_POS_STATUS_NO,                                // �޴���
    EM_POS_STATUS_PROT_FORMAT,                       // ������Э���ʽ
    EM_POS_STATUS_NET_ADDR_CONFLICT,                 // �����ַ��ͻ
    EM_POS_STATUS_RS232_ADDR_CONFLICT,               // 232���ڵ�ַ��ͻ
    EM_POS_STATUS_RS485_ADDR_CONFLICT,               // 485���ڵ�ַ��ͻ
    EM_POS_STATUS_LINK_CHANNEL_CONFLICT,             // ����Զ��ͨ����ͻ
    EM_POS_STATUS_NOT_EXIST,                         // ָ��POS������
    EM_POS_STATUS_NUM_LIMIT,                         // ��ӵ�POS�ѳ�������
    EM_POS_STATUS_NAME_CONFLICT,                     // POS���Ƴ�ͻ
} EM_POS_STATUS;

// POS��������������
typedef struct tagNET_POS_NET_ATT
{
    char                     szSrcIp[DH_MAX_IPADDR_LEN_EX];              // POS��IP��ַ
    int                      nSrcPort;                                   // POS���˿�
    char                     szDstIp[DH_MAX_IPADDR_LEN_EX];              // NVR��IP��ַ
    int                      nDstPort;                                   // NVR�Ķ˿ں�
} NET_POS_NET_ATT;

// POS��COM��������, RS232, RS485
typedef struct tagNET_POS_COM_ATT
{
    int                      nCommChannel;                               // ���ںţ�comm���õ��±�ţ�
    int                      nAddress;                                   // RS485��ַ
    DH_COMM_PROP             stuAttr;                                    // RS485��������
} NET_POS_COM_ATT;

// POS���Զ�������Э��
typedef struct tagNET_POS_CUSTOM_PROT
{
    char                     szStartStr[DH_COMMON_STRING_32];            // ��ʼ�ַ�
    BOOL                     bAnyCharater;                               // ��ʼ�ַ�����, TRUE��ʾ��ʼ�ַ�Ϊ�κ��ַ�,FALSE��ʹ��szStartStr�ַ�
    char                     szEndStr[DH_COMMON_STRING_32];              // �����ַ�
    char                     szLineDelimiter[DH_COMMON_STRING_32];       // �����ַ�
    int                      nMoreLine;                                  // POS������Ϣ����Ƶ����ʾ������
    char                     szIgnoreStr[DH_COMMON_STRING_32];           // Э����������ַ�
    BOOL                     bCaseSensitive;                             // �Ƿ����ִ�Сд
    BYTE                     reserved[1024];                             // Ԥ��
} NET_POS_CUSTOM_PROT;

// ��������
typedef enum tagEM_PTZ_LINK_TYPE
{
	EM_PTZ_LINK_TYPE_NONE,							// none
	EM_PTZ_LINK_TYPE_PRESET,						// "Preset" ����Ԥ�õ�
	EM_PTZ_LINK_TYPE_TOUR,							// "Tour" ����Ѳ��
	EM_PTZ_LINK_TYPE_PATTERN,						// "Pattern" ����ģʽ
	EM_PTZ_LINK_TYPE_ZOOM,							// "Zoom" �����䱶
	EM_PTZ_LINK_TYPE_SINGLESCENE,					// "SingleScene" �������ܵ�����
	EM_PTZ_LINK_TYPE_QUICKFOCUS,					// "QuickFocus" �ȳ�����̨�������ٶ�λ
} EM_PTZ_LINK_TYPE;

// ������̨��Ϣ
typedef struct tagNET_CFG_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;						// ��������
	int						nValue;						// ����ȡֵ�ֱ��ӦԤ�õ�ţ�Ѳ���ŵȵ�
} NET_CFG_PTZ_LINK;

// ��̨������
typedef struct tagNET_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;					// ��̨��������
	int						nParam1;				// ��������1
	int						nParam2;				// ��������2
	int						nParam3;				// ��������3
	int						nChannelID;				// ��������̨ͨ��
} NET_PTZ_LINK;


// ��ѯ��������
typedef struct tagNET_MONITOR_TOUR
{
	BOOL					bEnable;				// ��ѯʹ��
	int						nChannels[256];			// ��ѵͨ�����б�
	int						nChannelCount;			// ��Ѳͨ������
	BYTE					reserved[32];			// �����ֽ�
} NET_MONITOR_TOUR;

#define MAX_NUMBER_PTZLINK		256	// ��̨�������
#define	MAX_NUMBER_TOUR			32	// ��ѵ���������������

// POS�¼������ṹ��
typedef struct tagNET_POS_EVENT_LINK
{
	DWORD					dwSize;									// �ṹ���С
	DH_TSECT				stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// ������ʱ���
	BOOL					bRecordEnable;							// ¼��ʹ��
	BOOL					bRecordCloudEnable;						// �Ƿ���¼���ƴ洢
	DWORD					dwRecordMask[DH_MAX_CHANNUM];			// ¼��ͨ������(��λ)
	int						nRecordLatch;							// ¼����ʱʱ��,��λ:��,��Χ:10-300
	BOOL					bAlarmOutEnable;						// �������ʹ��
	DWORD					dwAlarmOutMask[DH_MAX_CHANNUM];			// �������ͨ������(��λ)
	int						nAlarmOutLatch;							// ��������ֹͣ��,�����ʱʱ��,��λ:��,��Χ1-300
	int						nPtzLinkNum;							// ��̨������
	NET_PTZ_LINK			stuPtzLink[MAX_NUMBER_PTZLINK];			// ��̨������
	BOOL					bPtzLinkEnable;							// ��̨����ʹ��
	int						nPtzLinkDelay;							// ��̨�����ӳ�,��λ:��,��Χ1-10
	BOOL					bSnapshotEnable;						// ����ʹ��
	BOOL					bSnapshotCloudEnable;					// �Ƿ���ץͼ�ƴ洢
	DWORD					dwSnapshotMask[DH_MAX_CHANNUM];			// ����ͨ��������(��λ)
	int						nSnapshotPeriod;						// ֡���,ÿ�����֡ץһ��ͼƬ
	int						nSnapshotTimes;							// ���Ĵ���
	BOOL					bTipEnable;								// ������Ϣ����ʾ
	BOOL					bMailEnable;							// �����ʼ�,�����ͼƬ,��Ϊ����
	BOOL					bMessageEnable;							// �ϴ����������ķ�����
	BOOL					bBeepEnable;							// ����
	BOOL					bVoiceEnable;							// ������ʾ
	DWORD					dwVoiceMask[DH_MAX_CHANNUM];			// ������ʾ����ͨ��������
	char					szAudioFileName[MAX_PATH];				// ���������ļ�����·��
	int						nPlayTimes;								// ��������Ŵ���

	int						nDejitter;								// ȥ����ʱ��,ֻ�Բ���start/stop���¼�������,��λ:��,��Χ0-600
	BOOL					bLogEnable;								// �Ƿ��¼��־
	int						nMonitorTourNum;                        // ��ѯ������Ŀ
	NET_MONITOR_TOUR		stuMonitorTour[MAX_NUMBER_TOUR];		// ��ѯ��������
} NET_POS_EVENT_LINK;

// POS����Ϣ
typedef struct tagNET_POS_INFO
{
    BOOL                     bEnable;                // ʹ�ܿ���
    DWORD                    dwPosId;                // Pos��ID��,���POSʱ��Ч
    char                     szName[64];             // POS������
    EM_CONN_TYPE             emConnType;             // ���ӷ�ʽ
    NET_POS_NET_ATT          stuNetAtt;              // ������������, emConnTypeΪEM_CONN_TYPE_NETʱ��Ч
    NET_POS_COM_ATT          stuComAtt;              // ��������, emConnTypeΪEM_CONN_TYPE_RS232����EM_CONN_TYPE_RS485ʱ��Ч
    EM_CONN_PROT             emConnProt;             // ����Э��
    NET_POS_CUSTOM_PROT      stuCustom;              // emConnProtΪEM_CONN_PROT_NONEʱ��Ч
    int                      nTimeOut;               // ������Ϣ��ʱʱ��, ��λ��
    int                      nLinkChannel[32];       // ÿ̨POS�ӹ�����ͨ��
    int                      nLinkChannelNum;        // nLinkChannel��Ч����
    int                      nPlayBackTime;          // POS��Ϣ������Ƶ��ʱ��, ��λ��

	BOOL					 bPreviewBlend;			 // ���ӵ�Ԥ����Ƶ
    BYTE                     reserved[1020];         // Ԥ��
} NET_POS_INFO;

// ����/�޸�һ��Pos�豸���, ��Ӧ����DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_IN_POS_ADD
{
    DWORD                    dwSize;                 // �ýṹ���С
    NET_POS_INFO             stuPosInfo;             // POS����Ϣ
	NET_POS_EVENT_LINK		 stuPosEventLink;		 // EventLink��ʽ
} NET_IN_POS_ADD;

// ����/�޸�һ��Pos�豸����, ��Ӧ����DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_OUT_POS_ADD
{
    DWORD                    dwSize;                 // �ýṹ���С
    DWORD                    dwPosId;                // Pos��ID��, �豸��Ψһ, DH_CTRL_POS_MODIFY��Ч
    EM_POS_STATUS            emStatus;               // ����״̬
} NET_OUT_POS_ADD;

// ɾ��һ��Pos�豸���, ��Ӧ����DH_CTRL_POS_REMOVE
typedef struct tagNET_IN_POS_REMOVE
{
    DWORD                    dwSize;                 // �ýṹ���С
    DWORD                    dwPosId;                // Pos��ID��
} NET_IN_POS_REMOVE;

// ɾ��һ��Pos�豸����, ��Ӧ����DH_CTRL_POS_REMOVE
typedef struct tagNET_OUT_POS_REMOVE
{
    DWORD                    dwSize;                 // �ýṹ���С
    EM_POS_STATUS            emStatus;               // ����״̬
} NET_OUT_POS_REMOVE;

// ����ɾ��Pos�豸���, ��Ӧ����DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_IN_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // �ýṹ���С
    DWORD                    dwPosId[16];            // Pos��ID��, -1��ʾȫ��
    int                      nPosNum;                // dwPosId����
} NET_IN_POS_REMOVE_MULTI;

// ����ɾ��Pos�豸����, ��Ӧ����DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_OUT_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // �ýṹ���С
    EM_POS_STATUS            emStatus;               // ����״̬, ���ʧ�ܷ��ص�һ��ɾ��ʧ��ʱ�Ĵ���״̬
    DWORD                    dwPosIdFailed[16];      // ʧ�ܵ�Pos��ID��
    int                      nPosNum;                // dwPosIdFailed����
} NET_OUT_POS_REMOVE_MULTI;

// ��ȡȫ��Pos�豸, ��Ӧ����DH_DEVSTATE_GET_ALL_POS
typedef struct tagNET_POS_ALL_INFO
{
    DWORD                    dwSize;                 // �ýṹ���С
	int						 nMaxNum;				 // POS��������
	int                      nRetPosNum;             // posʵ�ʷ��ظ���
    NET_POS_INFO             stuPos[256];            // pos��Ϣ
	NET_POS_EVENT_LINK		 *pstuPosEventLink;		 // EventLink��ʽ,��stuPosһһ��Ӧ, �û������ڴ�,��СΪsizeof(NET_POS_EVENT_LINK)*nMaxNum
} NET_POS_ALL_INFO;

// �¼����� DH_ALARM_POS_MANAGE (POS�����¼��¼�)��Ӧ������������Ϣ
typedef struct tagALARM_POS_MANAGE_INFO
{
    int                      nEventAction;                   // �¼�����, 0:Pulse, 1:Start, 2:Stop
    int                      nType;                          // ��������, 0:add, 1:remove, 2:modify
    DWORD                    dwPosId;                        // Pos��ID��
    char                     szName[DH_COMMON_STRING_64];    // Pos�Զ�������
    int                      nLinkChannel[32];               // ÿ̨POS�ӹ�����ͨ��
    int                      nLinkChannelNum;                // nLinkChannel��Ч����
    EM_CONN_PROT             emConnProt;                     // ����Э��
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_POS_MANAGE_INFO;

// �¼����� DH_ALARM_LOCK_BREAK (�����¼�)��Ӧ�Ľṹ��
typedef struct tagALARM_LOCK_BREAK_INFO
{
    int                      nDoor;                          // ��ͨ����
    int                      nAction;                        // 0:��ʼ 1:ֹͣ
    NET_TIME_EX              UTC;                            // �¼�������ʱ��
    BYTE                     reserved[1024];                 // Ԥ���ֶ�
}ALARM_LOCK_BREAK_INFO;
 
// �����ֶε���������
typedef enum tagEM_POS_DATA_TYPE
{
	EM_POS_DATA_TYPE_UNKNOWN,				// δ֪��������
	EM_POS_DATA_TYPE_STORE_INF0,			// �̼���Ϣ
	EM_POS_DATA_TYPE_PRODUCT_INFO,			// ��Ʒ��Ϣ
}EM_POS_DATA_TYPE;

// �̼���Ϣ
typedef struct tagNET_STORE_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];				// СƱ���׺ţ�����ʶ����Ʒ��Ϣ��������СƱ
	char					 szNo[MAX_STORE_NO_LEN];					// ���
	char					 szName[MAX_STORE_NAME_LEN];				// ����
	char					 szEmPloyeeID[MAX_STORE_EMPLOYEE_ID_LEN];	// ����Ա���ų���
	unsigned int			 nSeviceType;								// ��������,0-����,1-�˻�
	unsigned int			 nAmount;									// �ܼۣ���λ����
	BYTE					 byReserved[1024];							// Ԥ���ֽ�
}NET_STORE_INFO;

// ��Ʒ��Ϣ
typedef struct tagNET_PRODUCT_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];			// СƱ���׺ţ�����ʶ����Ʒ��Ϣ��������СƱ
	char					 szNo[MAX_PRODUCT_NO_LEN];				// ��Ʒ����
	char					 szName[MAX_PRODUCT_NAME_LEN];			// ��Ʒ����
	char					 szCategory[MAX_PRODUCT_CATEGORY_LEN];	// ��Ʒ���
	unsigned int			 nPrice;								// ��Ʒ���ۣ���λ:��
	double					 dbQuantity;							// ��Ʒ����������ǧ��
	BYTE					 byReserved[1024];						// Ԥ���ֽ�
}NET_PRODUCT_INFO;

// POS������Ϣ
typedef struct tagNET_POS_TRADE_INFO
{
    DWORD                    dwPosId;										// Pos��ID��
    NET_TIME                 stuTime;										// ����ʱ�豸��ʱ��
    BYTE                    *pbyComment;									// ���׵�����, ����������
    DWORD                    dwCommentLen;									// pbyComment����
	EM_POS_DATA_TYPE		 emDataType;									// �����ֶε���������
	BOOL					 bEnd;											// ���������ɸ��ֶ��ж�һ��СƱ�Ƿ������EndֵΪtrue��ʾһ��СƱ������
	void*					 pPosData;										// �������Ϣ����emDataType������������Ϣ
																			// ���emDataTypeΪEM_POS_DATA_TYPE_STORE_INF0,��������̼���Ϣ,��Ӧ�Ľṹ��ΪNET_STORE_INFO
																			// ���emDataTypeΪEM_POS_DATA_TYPE_PRODUCT_INFO,���������Ʒ��Ϣ,��Ӧ�Ľṹ��ΪNET_PRODUCT_INFO
    BYTE                     reserved[1012];								// Ԥ���ֽ�
} NET_POS_TRADE_INFO;

// ����POS������Ϣ�ص�����ԭ��
typedef void (CALLBACK *fPosTradeCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_POS_TRADE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// ����POS������Ϣ �������
typedef struct tagNET_IN_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // �ýṹ���С
    fPosTradeCallBack           cbCallState;            // ״̬�ص�����
    LDWORD                      dwUser;                 // �û�����
} NET_IN_POS_TRADE_ATTACH;

// ����POS������Ϣ �������
typedef struct tagNET_OUT_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // �ýṹ���С
} NET_OUT_POS_TRADE_ATTACH;

// CLIENT_GetDevCaps �ӿ� NET_POS_CAPS �������
typedef struct tagNET_IN_POS_GETCAPS
{
    DWORD               dwSize;
} NET_IN_POS_GETCAPS;

// CLIENT_GetDevCaps �ӿ� NET_POS_CAPS �������
typedef struct tagNET_OUT_POS_GETCAPS
{
    DWORD               dwSize;
    EM_CONN_TYPE        emConnType[10];                    // ���ӷ�ʽ
    int                 nConnTypeNum;                      // ���ӷ�ʽ����
    EM_CONN_PROT        emConnProt[10];                    // Pos�����豸������Э��
    int                 nConnProtNum;                      // ����Э������
    int                 nMaxPos;                           // �豸֧����ӵ�POS����Ŀ
	BOOL				bSupportPosRecord;				   // �Ƿ�֧��POS¼��
} NET_OUT_POS_GETCAPS;

// ����POS���͹�������Ʒ�嵥,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPosTrade(LLONG lLoginID, const NET_IN_POS_TRADE_ATTACH* pInParam, NET_OUT_POS_TRADE_ATTACH* pOutParam, int nWaitTime);

// ȡ������POS���͹�������Ʒ�嵥
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPosTrade(LLONG lAttachHandle);

// CLIENT_GetDevCaps �ӿ� NET_USER_MNG_CAPS �������
typedef struct tagNET_IN_USER_MNG_GETCAPS
{
    DWORD               dwSize;
} NET_IN_USER_MNG_GETCAPS;

// CLIENT_GetDevCaps �ӿ� NET_USER_MNG_CAPS �������
typedef struct tagNET_OUT_USER_MNG_GETCAPS
{
    DWORD               dwSize;
    BOOL                bAccountLimitation;							// �˻�����,���Ծ�ȷ����ÿ���û�����ͬʱ���е�����
    BOOL                bIndividualAccessFilter;					// �ڰ������Ƿ�֧����Ե���IP�Ĺ���
    DWORD               dwMaxPageSize;								// ��ҳ��ѯʱ���β�ѯ������û���Ϣ����
	unsigned int		nMaxPwdLen;									// ������볤��
	unsigned int		nMinPwdLen;									// ��С���볤��	
	char				szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// ֧�ֵĻ����ַ������б�����Number���֣�LowerСд��ĸ��Upper��д��ĸ���ַ�����ʽ:"Number,Lower,Upper"
	char				szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// ֧�ֵ������ַ�����"~!@#$%^" 
	int					nCombine;									// �������Ҫ��0-������Ҫ��1-�����������ַ����������ޣ�2-�������2����������(���֡���д��Сд�������ַ�)
} NET_OUT_USER_MNG_GETCAPS;

//CLIENT_GetDevCaps �ӿ� NET_EXTERNALSENSOR_CAPS �������
typedef struct tagNET_IN_EXTERNALSENSOR_CAPS
{
	DWORD				dwSize;
}NET_IN_EXTERNALSENSOR_CAPS;

// CLIENT_GetDevCaps �ӿ� NET_GET_MASTERSLAVEGROUP_CAPS �������
typedef struct tagNET_IN_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD				dwSize;
}NET_IN_GET_MASTERSLAVEGROUP_CAPS;

typedef enum tagEM_MASTERSLAVEGROUP_MODE
{
	EM_MASTERSLAVEGROUP_MODE_UNKNOWN,		//  δ֪
	EM_MASTERSLAVEGROUP_MODE_COMMANDER,	    //  Commander ָ�ӹ٣���һǹһ���ǹ
	EM_MASTERSLAVEGROUP_MODE_PROPOSER,      //  Proposer �����ˣ���ǹһ��ҵ���ǹ
	EM_MASTERSLAVEGROUP_MODE_JUDGE,			//  Judge����Ա����ǹһ��ҵ�����
	EM_MASTERSLAVEGROUP_MODE_HAWKEYE,		//  HawkEyeӥ��
	EM_MASTERSLAVEGROUP_MODE_MULTISENSOR,	//  MultiSensor��Ŀ,�궨�㷨��ͬ,����ʹ�õ��ֶ�Ҳ��ͬ
	EM_MASTERSLAVEGROUP_MODE_GLOBALCAMERA,	//  GlobalCameraǹ��һ��ʽ���
	EM_MASTERSLAVEGROUP_MODE_NEWCOMMANDER,  //  NewCommander��ָ�ӹ�,�궨ʹ��CalibrateMatrix(MultiSensor)����
	EM_MASTERSLAVEGROUP_MODE_NEWHAWEYE,     //  NewHawEye��ӥ��(������),�궨ʹ��CalibrateMatrix(MultiSensor)����
}EM_MASTERSLAVEGROUP_MODE;

// CLIENT_GetDevCaps �ӿ� NET_GET_MASTERSLAVEGROUP_CAPS �������
typedef struct tagNET_OUT_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD									dwSize;
	EM_MASTERSLAVEGROUP_MODE				emRole;
}NET_OUT_GET_MASTERSLAVEGROUP_CAPS;

// CLIENT_GetDevCaps �ӿ� NET_STORAGE_CAPS�������
typedef struct tagNET_IN_STORAGE_CAPS
{
	DWORD									dwSize;
}NET_IN_STORAGE_CAPS;

// ��ʽ��Ӳ�̺��Ƿ���Ҫ����
typedef enum tagNET_EM_FORMAT_NEEDREBOOT
{
	EM_FORMAT_NEEDREBOOT_UNKNOWN,					// δ֪
	EM_FORMAT_NEEDREBOOT_NOREBOOT,					// ����Ҫ����
	EM_FORMAT_NEEDREBOOT_REBOOT						// ��Ҫ����, ����CLIENT_ControlDevice��ʽ��ʹ������DH_CTRL_SDCARD��DH_CTRL_DISK���Զ�ִ������
													// ʹ������DH_CTRL_FORMAT_PATITION��Ҫ�ͻ��˷�������
}NET_EM_FORMAT_NEEDREBOOT;

// CLIENT_GetDevCaps �ӿ� NET_STORAGE_CAPS�������
typedef struct tagNET_OUT_STORAGE_CAPS
{
	DWORD									dwSize;
	NET_EM_FORMAT_NEEDREBOOT				emReboot;	// ��ʽ��Ӳ�̺��Ƿ���Ҫ����
}NET_OUT_STORAGE_CAPS;

// �ⲿ������������ʽ
typedef enum tagEM_SENSOR_NERWORKING_MODE
{
	EM_SENSOR_NERWORKING_MODE_UNKNOWN,			// δ֪��ʽ
	EM_SENSOR_NETWORKING_MODE_RS485,			// RS-485
	EM_SENSOR_NETWORKING_MODE_RFID,				// RFID
}EM_SENSOR_NERWORKING_MODE;
// CLIENT_GetDevCaps �ӿ� NET_EXTERNALSENSOR_CAPS �������
typedef struct tagNET_OUT_EXTERNALSENSOR_CAPS
{
	DWORD								dwSize;
	BOOL								bIsSupport;								// �Ƿ�֧���ⲿ���������ݲɼ�
	EM_SENSOR_NERWORKING_MODE			emNetworkingMode;						// �ⲿ������������ʽ
	int									nChannel;								// ֧�ֵ����ɼ�·��
}NET_OUT_EXTERNALSENSOR_CAPS;



// ����ң��������ģʽ
typedef enum tagEM_WIRELESS_CTRL_WORK_MODE
{
    EM_WIRELESS_CTRL_WORK_MODE_UNKNOWN,                     // δ֪
    EM_WIRELESS_CTRL_WORK_MODE_NORMAL,                      // ��ͨģʽ
    EM_WIRELESS_CTRL_WORK_MODE_POLLING,                     // Ѳ��ģʽ
} EM_WIRELESS_CTRL_WORK_MODE;

// �¼����� DH_ALARM_REMOTE_CTRL_STATUS (����ң����״̬�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_REMOTE_CTRL_STATUS
{
    NET_TIME_EX              UTC;                            // �¼�������ʱ��
    DWORD                    dwID;                           // ң����ID
    char                     szName[32];                     // ����
    char                     szUser[32];                     // �û���,ָ�����豸����������������ĳ���û���,����Ȩ�޸�������û�
    EM_WIRELESS_CTRL_WORK_MODE emMode;                       // ����ģʽ
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_REMOTE_CTRL_STATUS;

typedef enum tagEM_PASSENGER_CARD_CHECK_TYPE
{
    EM_PASSENGER_CARD_CHECK_TYPE_UNKOWN = 0,                // δ֪
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNIN,                    // ǩ��/�ϳ�
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNOUT,                   // ǩ��/�³�
    EM_PASSENGER_CARD_CHECK_TYPE_NORMAL,                    // ����ˢ�������������³�
}EM_PASSENGER_CARD_CHECK_TYPE;

// �¼����� DH_ALARM_PASSENGER_CARD_CHECK (�˿�ˢ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_PASSENGER_CARD_CHECK
{
    BOOL                     bEventConfirm;                  // �Ƿ���Ҫ�ظ�
    char                     szCardNum[DH_MAX_BUSCARD_NUM];  // ��������
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS��Ϣ
    NET_TIME_EX              UTC;                            // ˢ��ʱ��
    int                      nTime;                          // UTC����
    EM_PASSENGER_CARD_CHECK_TYPE    emType;                  // ˢ������
    char                     szMac[DH_MAX_POS_MAC_NUM];      // ˢ����Mac�� (Ĭ��"0000",�������豸)
    BYTE                     reserved[1012];                 // Ԥ��
} ALARM_PASSENGER_CARD_CHECK;

// �¼����� DH_ALARM_BUS_TIRED_DRIVE_CHECK (ƣ�ͼ�ʻ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_TIRED_DRIVE_CHECK_INFO
{
    BOOL                     bEventConfirm;                  // �Ƿ���Ҫ�ظ�
    int                      nAction;                        // �¼�����, 0:Start, 1:Stop
    int                      nDriveTime;                     // ��ʻʱ�� ��λ����
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS��Ϣ
    NET_TIME_EX              UTC;                            // �¼��ϱ�ʱ��
    int                      nTime;                          // �¼��ϱ�ʱ��,UTC����
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_TIRED_DRIVE_CHECK_INFO;

// �¼����� DH_ALARM_SOUND (�����¼�)��Ӧ������������Ϣ
typedef struct tagALARM_SOUND
{
    int                      nChannel;                       // ͨ����
    NET_TIME_EX              UTC;                            // ˢ��ʱ��
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_SOUND;

// ���������������, ��Ӧ���� DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_IN_SOUND_ALARM
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_IN_SOUND_ALARM;

// ����������������, ��Ӧ���� DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_OUT_SOUND_ALARM
{
    DWORD                    dwSize;                 // �ýṹ���С
} NET_OUT_SOUND_ALARM;

//��Ƶ�����Ͽ��ƾ�������ͨ��
typedef struct tagNET_SILENCE_CHANNEL
{
	int				nMatrix;										//��Ҫ����ľ����
	int				nOutChannel;									// ��Ҫ��������ͨ����
	int				nOutPutChannel[DH_MAX_AUDIO_MATRIX_OUTPUT];	    //�þ�������Ҫ��������ͨ��
	BYTE			bReserved[512];									//�����ֽ�
}NET_SILENCE_CHANNEL;

// ��Ƶ����һ����������������
typedef struct tagNET_IN_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;				// �û�ʹ��ʱ��ֵsizeof(NET_IN_AUDIO_MATRIX_SILENCE)
	BOOL					bEnable;			// һ������ʹ�ܿ����ر�(true:���� false:��������)
	int						nListCount;			// ��Ҫ���ƾ�������ͨ����
	NET_SILENCE_CHANNEL*	pstSlienceChannel;	// ��Ҫ���ƾ�������ͨ����Ϣ,�û������ڴ�,��СΪsizeof(NET_SILENCE_CHANNEL)*nListCount
} NET_IN_AUDIO_MATRIX_SILENCE;

//��Ƶ����һ��������Ʋ���������� 
typedef struct tagNET_OUT_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;		//�û�ʹ��ʱ��ֵsizeof(NET_OUT_AUDIO_MATRIX_SILENCE)
} NET_OUT_AUDIO_MATRIX_SILENCE;

// Ŀ�Ķ�����
typedef enum tagEM_TARGET_TYPE
{
    EM_TARGET_TYPE_CLIENT,              // "client"    �ͻ���
    EM_TARGET_TYPE_FTP_SERVER,          // "FTPServer" FTP������
}EM_TARGET_TYPE;

// ��������Ϣ
typedef struct tagNET_MANUAL_UPLOAD_FILTER_INFO
{
    EM_TARGET_TYPE           emTargetType;                      //Ŀ�Ķ�����, "Client" - �ͻ���, "FTPServer" - FTP������
    char                     szClientIP[DH_MAX_IPADDR_LEN];     //�ͻ���IP��ַ,����Ϊ "Client"��Ч
    NET_TIME                 stuStartTime;                      //ͼƬ��ʼʱ��
    NET_TIME                 stuEndTime;                        //ͼƬ����ʱ��
}NET_MANUAL_UPLOAD_FILTER_INFO;

// �����ֶ��ϴ��������,��Ӧ���� DH_CTRL_MANUAL_UPLOAD_PICTURE
typedef struct tagNET_IN_MANUAL_UPLOAD_PICTURE
{
    DWORD                                 dwSize;               //�û�ʹ��ʱ��ֵsizeof(NET_IN_MANUAL_UPLOAD_PICTURE)
    NET_MANUAL_UPLOAD_FILTER_INFO         stuFilter;            //�ֶ��ϴ�������             
}NET_IN_MANUAL_UPLOAD_PICTURE;

// �����ֶ��ϴ��������,��Ӧ���� DH_CTRL_MANUAL_UPLOAD_PICTURE
typedef struct tagNET_OUT_MANUAL_UPLOAD_PICTURE
{
    DWORD					dwSize;		                        //�û�ʹ��ʱ��ֵsizeof(NET_OUT_MANUAL_UPLOAD_PICTURE)
}NET_OUT_MANUAL_UPLOAD_PICTURE;

// ������������豸�����������Ӧ����DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_IN_REBOOT_NET_DECODING_DEV
{
    DWORD               dwSize;                                 //�ýṹ���С���û�ʹ��ʱ��ֵsizeof(NET_IN_REBOOT_NET_DECODING_DEV)
    char				szDeviceID[DH_COMMON_STRING_64];	    //�豸ID
    int                 nRebootDelayTime;                       //������ʱʱ��, ��λΪ��
}NET_IN_REBOOT_NET_DECODING_DEV;


//������������������Σ���Ӧ�ӿ�CLIENT_SetDefenceArmMode
typedef struct tagNET_IN_SET_DEFENCEMODE 
{
    DWORD                   dwSize;
    char                    szPassword[DH_COMMON_STRING_64];           // �û���¼����
    int                     nChannel;                                  // ͨ����
    EM_DEFENCEMODE          emDefenceMode;                             // ����ģʽ
}NET_IN_SET_DEFENCEMODE;

//�������������������Σ���Ӧ�ӿ� CLIENT_SetDefenceArmMode
typedef struct tagNET_OUT_SET_DEFENCEMODE
{
    DWORD                   dwSize;
}NET_OUT_SET_DEFENCEMODE;

//��ϵͳ������������Σ���Ӧ�ӿ� CLIENT_SetSubSystemArmMode
typedef struct tagNET_IN_SET_SUBSYSTEMMODE 
{
    DWORD                   dwSize;
    int                     nChannel;                                  // ��ϵͳ��,��0��ʼ
    char                    szPassword[DH_COMMON_STRING_64];           // �û���¼����
    EM_DEFENCEMODE          emDefenceMode;                             // ����ģʽ
}NET_IN_SET_SUBSYSTEMMODE;

//��ϵͳ�������������Σ���Ӧ�ӿ� CLIENT_SetSubSystemArmMode
typedef struct tagNET_OUT_SET_SUBSYSTEMMODE
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // �б���Դ���벼��ʧ�ܵ���ϵͳ����
    int                 nSource[ARM_DISARM_ZONE_MAX];       // �б���Դ����ʧ�ܵ���ϵͳ��, ��ϵͳ�Ŵ�0��ʼ
    DWORD               dwLinkNum;                          // ��������������ʧ�ܵ���ϵͳ����
    int                 nLink[ARM_DISARM_ZONE_MAX];         // ����������ʧ�ܵ���ϵͳ��, ��ϵͳ�Ŵ�0��ʼ
}NET_OUT_SET_SUBSYSTEMMODE;

// ��ȡ����������״̬��Σ���Ӧ�ӿ� CLIENT_GetDefenceArmMode
typedef struct tagNET_IN_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // ������Ч����
    int                      anDefence[DH_MAX_ALARMIN];              // ����ѯ�ķ�����
}NET_IN_GET_DEFENCEMODE;

// ��ȡ����������״̬���Σ���Ӧ�ӿ� CLIENT_GetDefenceArmMode
typedef struct tagNET_OUT_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // ������Ч����
    EM_DEFENCEMODE           anDefenceState[DH_MAX_ALARMIN];         // ����״̬��Ϣ
}NET_OUT_GET_DEFENCEMODE;

// ��ȡ��ϵͳ������״̬��Σ���Ӧ�ӿ� CLIENT_GetSubSystemArmMode
typedef struct tagNET_IN_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
}NET_IN_GET_SUBSYSTEMMODE;

// ��ȡ��ϵͳ������״̬���Σ���Ӧ�ӿ� CLIENT_GetSubSystemArmMode
typedef struct tagNET_OUT_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
    int                      nSubSystemNum;                            // ��ϵͳ��Ч����
    EM_SUBSYSTEMMODE         anSubSystemState[DH_MAX_ALARM_SUBSYSTEM_NUM];         // ��ϵͳ״̬��Ϣ
}NET_OUT_GET_SUBSYSTEMMODE;

// �ֶ�����PSTN����״̬���,��Ӧ�ӿ� CLIENT_ManualCheckPSTN
typedef struct tagNET_IN_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
}NET_IN_PSTN_MANUALCHECK_STATE;

// �ֶ�����PSTN����״̬����,��Ӧ�ӿ� CLIENT_ManualCheckPSTN
typedef struct tagNET_OUT_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
    NET_THREE_STATUS_BOOL    emState;            //���Խ�� 
}NET_OUT_PSTN_MANUALCHECK_STATE;

// ������������豸�����������Ӧ���� DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_OUT_REBOOT_NET_DECODING_DEV
{
    DWORD					dwSize;		                        //�ýṹ���С���û�ʹ��ʱ��ֵsizeof(NET_OUT_REBOOT_NET_DECODING_DEV)
}NET_OUT_REBOOT_NET_DECODING_DEV;

// ���÷����豸�����������Ӧ���� DH_CTRL_SET_IC_SENDER
typedef struct tagNET_IN_SET_IC_SENDER
{
	DWORD					dwSize;								// �ýṹ���С���û�ʹ��ʱ��ֵsizeof(NET_IN_SET_IC_SENDER)
	BOOL					bEnable;							// True����������False����ֹ�������豸��ʱĬ��������
}NET_IN_SET_IC_SENDER;

// ���÷����豸�����������Ӧ���� DH_CTRL_SET_IC_SENDER
typedef struct tagNET_OUT_SET_IC_SENDER
{
	DWORD					dwSize;								// �ýṹ���С���û�ʹ��ʱ��ֵsizeof(NET_OUT_SET_IC_SENDER)
}NET_OUT_SET_IC_SENDER;


// �¼����� DH_ALARM_DRIVE_AFTER_WORK (�ǹ���ʱ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_DVRIVE_AFTER_WORK
{
    BOOL                     bEventConfirm;                  // �Ƿ���Ҫ�ظ�
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS��Ϣ
    NET_TIME_EX              stuUtc;                         // ˢ��ʱ��
    DWORD                    dwUtc;                          // ˢ��ʱ��, ��stuUtcֵһ��,��ʽ��ͬ,�����¼�ȷ�Ͻӿ����
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_DVRIVE_AFTER_WORK;

// �¼����� DH_ALARM_UPLOAD_PIC_FAILED (Υ�������ϴ�ʧ���¼�)��Ӧ������������Ϣ
typedef struct tagALARM_UPLOAD_PIC_FAILED_INFO
{
    int                      nAction;                        // 0:��⵽Υ�������ϴ�ʧ��, 1:Υ�������ϴ�ʧ�ܺ��һ���ϴ��ɹ�
    BYTE                     reserved[1024];                 // Ԥ��
} ALARM_UPLOAD_PIC_FAILED_INFO;

// ��ȡ���м�·�α�����Ϣ, ��Ӧ����DH_DEVSTATE_GET_ROAD_LIST
typedef struct tagNET_ROAD_LIST_INFO
{
    DWORD                    dwSize;                 // �ýṹ���С
    char                     szCity[32];             // ���������ĳ�����Ϣ
    char                     szRoadList[2048][256];  // ��·������Ϣ
    int                      nRoadNum;               // ��·��Ϣ����, ָʾszRoadList�ĵ�1ά
} NET_ROAD_LIST_INFO;

// �����豸����
typedef enum tagEM_WIRELESS_DEV_TYPE
{
    EM_WIRELESS_DEV_TYPE_UNKNOWN,                            // δ֪
    EM_WIRELESS_DEV_TYPE_STATION,                            // "Station":վ��
    EM_WIRELESS_DEV_TYPE_AP,                                 // "AccessPoint":���߽����
} EM_WIRELESS_DEV_TYPE;

// �����豸��֤��ʽ
typedef enum tagEM_WIRELESS_AUTHENTICATION
{
    EM_WIRELESS_AUTHENTICATION_UNKNOWN,                             // UnKnown
    EM_WIRELESS_AUTHENTICATION_OPEN,                                // OPEN
    EM_WIRELESS_AUTHENTICATION_SHARED,                              // SHARED
    EM_WIRELESS_AUTHENTICATION_WPA,                                 // WPA
    EM_WIRELESS_AUTHENTICATION_WPAPSK,                              // WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2,                                // WPA2
    EM_WIRELESS_AUTHENTICATION_WPA2PSK,                             // WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPANONE,                             // WPA-NONE
    EM_WIRELESS_AUTHENTICATION_WPAPSK_WPA2PSK,                      // WPA-PSK|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPA2,                            // WPA|WPA2
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK,                          // WPA | WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2_WPA2PSK,                        // WPA2|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK_WPA2_WPA2PSK,             // WPA|WPA-PSK|WPA2|WPA2-PSK
} EM_WIRELESS_AUTHENTICATION;

// �������ݼ��ܷ�ʽ��ʽ
typedef enum tagEM_WIRELESS_DATA_ENCRYPT
{
    EM_WIRELESS_DATA_ENCRYPT_UNKNOWN,                            // UnKnown
    EM_WIRELESS_DATA_ENCRYPT_NONE,                               // NONE
    EM_WIRELESS_DATA_ENCRYPT_WEP,                                // WEP
    EM_WIRELESS_DATA_ENCRYPT_TKIP,                               // TKIP
    EM_WIRELESS_DATA_ENCRYPT_AES,                                // AES(CCMP)
    EM_WIRELESS_DATA_ENCRYPT_TKIP_AES,                           // TKIP+AES
} EM_WIRELESS_DATA_ENCRYPT;

// ��������WIFI�豸��Ϣ
typedef struct tagNET_WIFI_DEV_INFO
{
    char                     szMac[DH_MACADDR_LEN];          // Wifi�豸��Mac��ַ
    int                      nLinkQuality;                   // ���������ٷֱ�, 0~100
    NET_TIME_EX              stuEnterTime;                   // ��һ����������ʱ��
    NET_TIME_EX              stuLeaveTime;                   // ��ʧ��ʱ��
    int                      nSearchedCount;                 // ���������Ĵ���
    char                     szSSID[24];                     // ��������
    NET_TIME_EX              UTC;                            // �¼�����ʱ��
    EM_WIRELESS_DEV_TYPE     emDevType;                      // WIFI�豸����
    int                      nChannel;                       // Wifi�豸��ǰ���ڵ��ŵ�
    EM_WIRELESS_AUTHENTICATION emAuth;                       // ��֤��ʽ
    EM_WIRELESS_DATA_ENCRYPT emEncrypt;                      // ���ݼ��ܷ�ʽ
    char                     szAPMac[DH_MACADDR_LEN];        // �����ȵ�Mac
    int                      nAPChannel;                     // �����ȵ�Ƶ��
    char                     szAPSSID[24];                   // �����ȵ�SSID
    EM_WIRELESS_DATA_ENCRYPT emAPEncrypt;                    // �����ȵ��������
	int						 nRssiQuality;                   // �ź�ǿ��
	char					 szManufacturer[MAX_MANUFACTURER_LEN];			// Mac��ַ����������
	char					 szMacHistorySSID[MAX_MACHISTORY_SSID_NUM][MAX_MACHISTORY_SSID_LEN];     // ���豸�������ӹ�����ʷSSID�б�
	unsigned int			 nRetMacHistorySSIDNum;			 // ���豸ʵ�����ӹ���SSID����
    BYTE                     reserved[264];                  // Ԥ��
   
} NET_WIFI_DEV_INFO;

// ��������WIFI������Ϣ
typedef struct tagNET_WIFI_BASIC_INFO
{
	UINT nPeriodUTC;      //�������ϱ�����ʼʱ�䣬Ϊͬһ�ϱ����ڵı�ʶ����ͬһ�ϱ��������豸�������������ϱ���������ʱ��Ҫ����ϱ��¼�����ֵ��Ϊͬһ�ϱ������ڶ���ϱ��¼��ı�ʶ�룻
	int  nDeviceSum;      //�������ϱ���wifi������ͬһ�ϱ������ڵ��¼��еĸ�ֵ��ӦΪ�������ϱ���wifi����
	int  nCurDeviceCount; //�����¼��ϱ���Wifi�豸������Ӧ��ALARM_WIFI_SEARCH_INFO�ṹ���е�nWifiNumֵһ�£�ͬһ�ϱ������ڸ�ֵ���ۻ�������nDeviceSumһ�¡�
	BYTE reserved[500];   //Ԥ���ֽ�
}NET_WIFI_BASIC_INFO;

// ��λ���
typedef enum tagNET_GPS_POSITION_RESULT
{			
	NET_GPS_POSITION_RESULT_UNKNOWN = 0,					// δ֪
	NET_GPS_POSITION_RESULT_FAILED = 1,						// ��GPS����,����λʧ��,��ʱ��λ����������
	NET_GPS_POSITION_RESULT_SUCCEED = 2,					// ��GPS����,�Ҷ�λ�ɹ�,��ʱ��λ����������
} NET_GPS_POSITION_RESULT;

// �������ĵص���Ϣ
typedef struct tagNET_WIFI_GPS_INFO
{
	NET_GPS_POSITION_RESULT			emPositioningResult;	// ��λ���
	unsigned int 					nLongitude;				// ����(��λ�ǰ����֮һ��)
															// ������0 - 180000000				ʵ��ֵӦΪ: 180*1000000 �C dwLongitude
															// ������180000000 - 360000000		ʵ��ֵӦΪ: dwLongitude �C 180*1000000
															// ��: 300168866ӦΪ��300168866 - 180*1000000��/1000000 ������120.168866��
	unsigned int					nLatidude;				// γ��(��λ�ǰ����֮һ��)
															// ��γ��0 - 90000000				ʵ��ֵӦΪ: 90*1000000 �C dwLatidude
															// ��γ��90000000 �C 180000000		ʵ��ֵӦΪ: dwLatidude �C 90*1000000
															// ��: 120186268ӦΪ (120186268 - 90*1000000)/1000000 ����γ30. 186268��
	unsigned int					nSpeed;					// �ٶ�, ��λǧ��֮һkm/H
	BYTE							reserved[112];			// �����ֶ�
} NET_WIFI_GPS_INFO;

// �¼����� DH_ALARM_WIFI_SEARCH (����WIFI�豸)��Ӧ������������Ϣ
typedef struct tagALARM_WIFI_SEARCH_INFO
{
    int                      nWifiNum;                       // WIFI�豸����, ָʾstuWifi����Ч����
    NET_WIFI_DEV_INFO        stuWifi[1024];                  // ��ΧWifi�豸����Ϣ
	int                      nChannel;                       // ͨ����
	NET_WIFI_BASIC_INFO      stuWifiBasiInfo;				 // Wifi�¼��ϱ�������Ϣ
	BOOL					 bGPSinfo;						 // �Ƿ����GPS��Ϣ
	NET_WIFI_GPS_INFO		 stuWifiGPSInfo;				 // GPS��Ϣ
    BYTE                     reserved[376];                  // Ԥ��
} ALARM_WIFI_SEARCH_INFO;


// ��������WIFI�豸���������Ϣ
typedef struct tagNET_WIFI_VIRTUALINFO
{
	NET_TIME_EX				stuAccessTime;								// ����ʱ�䣬ʱ�䲻��ȷ�����ο�
	char					szSrcMac[DH_MACADDR_LEN];					// ������Ϣ����ԴMAC,��ĸ��д����"-"�ָ�
    char					szDstMac[DH_MACADDR_LEN];					// ������Ϣ��Ŀ��MAC,��ĸ��д����"-"�ָ�
	int						nProtocal;									// Э����ţ�����Ӧ�ö�Ӧ�ı�ʶ��
	char					szUrl[DH_MAX_URL_LEN];						// ����url
	char					szDomain[MAX_VIRTUALINFO_DOMAIN_LEN];		// ������
	char					szTitle[MAX_VIRTUALINFO_TITLE_LEN];			// ��������
	char					szUsrName[MAX_VIRTUALINFO_USERNAME_LEN];	// �û���
	char					szPassWord[MAX_VIRTUALINFO_PASSWORD_LEN];	// ����
	char					szPhoneNum[MAX_VIRTUALINFO_PHONENUM_LEN];	// �ֻ���
	char					szImei[MAX_VIRTUALINFO_IMEI_LEN];			// �����ƶ��豸��ʶ
	char					szImsi[MAX_VIRTUALINFO_IMSI_LEN];			// �����ƶ��û�ʶ����
	char					szLatitude[MAX_VIRTUALINFO_LATITUDE_LEN];	// ����
	char					szLongitude[MAX_VIRTUALINFO_LONGITUDE_LEN];	// γ��
	char					szSrcIP[DH_MAX_IPADDR_LEN_EX];				// ԴIP
	char					szDstIP[DH_MAX_IPADDR_LEN_EX];				// Ŀ��IP
	UINT					nSrcPort;									// Դ�˿�
	UINT					nDstPort;									// Ŀ�Ķ˿�
    char                    szSiteNum[MAX_COMMON_STRING_16];            // �������
    char                    szDevNum[MAX_COMMON_STRING_32];             // �ɼ��豸���
    char                    szUserID[MAX_COMMON_STRING_32];             // �����û�ID
    char                    szIDFA[MAX_COMMON_STRING_64];               // ƻ���ֻ���IDFA
	BYTE                    reserved[368];								// Ԥ��
}NET_WIFI_VIRTUALINFO;

// �¼����� DH_ALARM_WIFI_VIRTUALINFO_SEARCH (��ȡ��Χwifi�豸������Ϣ�¼�)��Ӧ������������Ϣ
typedef struct tagALARM_WIFI_VIRTUALINFO_SEARCH_INFO
{
    int                      nVirtualInfoNum;								// WIFI�豸�����������, ָʾstuVirtualInfo����Ч����
    NET_WIFI_VIRTUALINFO     stuVirtualInfo[MAX_VIRTUALINFO_NUM];           // ��ΧWifi���������Ϣ
	int                      nChannel;										// ͨ����
	BYTE                     reserved[512];									// Ԥ�� 
} ALARM_WIFI_VIRTUALINFO_SEARCH_INFO;

// �¼����� DH_ALARM_USER_LOCK_EVENT (�û����������¼�)��Ӧ������������Ϣ
typedef struct tagALARM_USER_LOCK_EVENT_INFO
{	 
    char                    szUser[DH_NEW_USER_NAME_LENGTH];				// �û���
	char					szGroup[DH_NEW_USER_NAME_LENGTH];				// ����
	char                    szIP[DH_MAX_IPADDR_LEN_EX];						// �豸IP
	BYTE                    reserved[512];									// Ԥ�� 
} ALARM_USER_LOCK_EVENT_INFO;

//�����豸����
typedef enum tagNET_WIRELESSDEV_LOWPOWER_TYPE
{
    NET_WIRELESSDEV_UNKNOWN = 0,                                // δ֪�豸
    NET_WIRELESSDEV_CONTROL = 1,                                // ����ң����
    NET_WIRELESSDEV_DEFENCE = 2,                                // ���߷���
    NET_WIRELESSDEV_KEYBOARD = 3,                               // ���߼���
    NET_WIRELESSDEV_MAGNETOMER = 4,                             // �����Ŵ�
	NET_WIRELESSDEV_ALARMBELL = 5,								// ���߾���
} NET_WIRELESSDEV_LOWPOWER_TYPE;

//�����豸�͵��������¼��ṹ��
typedef struct tagALARM_WIRELESSDEV_LOWPOWER_INFO
{
    NET_THREE_STATUS_BOOL         emResult;                  // �Ƿ�Ϊ�͵���true�͵���,false ��������,unknownδ֪
    NET_TIME                      stuTime;                   // �¼�������ʱ��
    int                           nId;                       // �����豸ID
    NET_WIRELESSDEV_LOWPOWER_TYPE emType;                    // �����豸����
    BYTE                          reserved[1024];            // Ԥ��
} ALARM_WIRELESSDEV_LOWPOWER_INFO;

// �����¼����� DH_ALARM_BUS_PAD_SHUTDOWN(PAD�ػ��¼�)��Ӧ������������Ϣ
typedef struct tagALARM_BUS_PAD_SHUTDOWN_INFO
{
    int                nDelayTime;                      // �ػ���ʱʱ��,��λ����
    BOOL               bConfirm;                        // �Ƿ���Ҫȷ��
    NET_TIME_EX        stuUtcTime;                      // �¼�������ʱ��
    DWORD              dwUtc;                           // �¼�������ʱ��, ����ȷ��
    BYTE               byReserved[512];                 // Ԥ���ֽ�
} ALARM_BUS_PAD_SHUTDOWN_INFO;

// �ȶ�ͼ��������
typedef enum tagEM_HEAT_PIC_DATA_TYPE
{
	EM_HEAT_PIC_DATA_TYPE_UNKNOWN,					// δ֪����
	EM_HEAT_PIC_DATA_TYPE_GRAYDATA,					// �Ҷ�����
	EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,				// ԭʼ����
}EM_HEAT_PIC_DATA_TYPE;
// ��ȡ�ȶ�ͳ����Ϣ���
typedef struct tagNET_IN_QUERY_HEAT_MAP
{
    int                      nChannel;                       // ͨ����
    NET_TIME_EX              stuBegin;                       // ��ʼʱ��    
    NET_TIME_EX              stuEnd;                         // ����ʱ��
    UINT                     nPlanID;                        // �ƻ�ID,�������Ч,��1��ʼ
	EM_HEAT_PIC_DATA_TYPE	 emDataType;					 // ϣ����ȡ����������
    BYTE                     reserved[1016];                 // Ԥ��
} NET_IN_QUERY_HEAT_MAP;

// ��ȡ�ȶ�ͳ����Ϣ����
typedef struct tagNET_OUT_QUERY_HEAT_MAP
{
    int                      nWidth;                         // ͼƬ���
    int                      nHeight;                        // ͼƬ�߶�
    char *                   pBufData;                       // �ȶ����ݻҽ�λͼ, �û������ڴ�,��СΪnBufLen
															 // ��emDataTypeΪEM_HEAT_PIC_DATA_TYPE_GRAYDATA,��һ���ֽڱ�ʾһ����
															 // ��emDataTypeΪEM_HEAT_PIC_DATA_TYPE_SOURCEDATA,���ĸ��ֽڱ�ʾһ����
    int                      nBufLen;                        // pBufData��󳤶�
    int                      nBufRet;                        // ʵ�ʷ��صĳ���
    int                      nAverage;                       // ��ֵ��Ϣ
	UINT					 nPlanID;						 // �ƻ�ID,������NET_IN_QUERY_HEAT_MAP��nPlanID��Ӧ
	EM_HEAT_PIC_DATA_TYPE    emDataType;					 // ��ȡ������������
	UINT					 nPixelMax;						 // ʵ�����ص�����ֵ
	UINT					 nPixelMin;						 // ʵ�����ص����Сֵ
    BYTE                     reserved[1004];                 // Ԥ��
} NET_OUT_QUERY_HEAT_MAP;

// ��ȡ�ȶ�ͳ����Ϣ, ��Ӧ����DH_DEVSTATE_GET_HEAT_MAP
typedef struct tagNET_QUERY_HEAT_MAP
{
    DWORD                    dwSize;                         // �ýṹ���С
    NET_IN_QUERY_HEAT_MAP    stuIn;                          // �ȶ�ͳ����Ϣ��ѯ����
    NET_OUT_QUERY_HEAT_MAP   stuOut;                         // �ȶ�ͳ����Ϣ��ѯ���
} NET_QUERY_HEAT_MAP;

//GPS��Ϣ��ѯ����
typedef struct tagNET_IN_DEV_GPS_INFO
{
	DWORD                    dwSize;                         // �ýṹ���С
    int                      nChannel;                       // �豸ͨ����
} NET_IN_DEV_GPS_INFO;

//GPS����״̬
typedef enum tagNET_GPS_WORK_STATUS
{
	EM_WORK_STATE_UNKNOWN = 0,			//δ֪����״̬
	EM_NO_POSITIONING,					//δ��λ
	EM_NO_DIFFERENTIAL_POSITIONING,		//�ǲ�ֶ�λ
	EM_DIFFERENTIAL_POSITIONING,		//��ֶ�λ
	EM_INVALID_PPS,						//��ЧPPS
	EM_EVALUATING,						//���ڹ���
}NET_GPS_WORK_STATUS;


//GPS��Ϣ��ѯ���
typedef struct tagNET_OUT_DEV_GPS_INFO
{
	DWORD                   dwSize;                          // �ýṹ���С
    NET_TIME				stuLocalTime;                    // ��ǰʱ�� 
	double                  dbLongitude;                     // ����(��λ�ǰ����֮��,��Χ0-360��)
    double                  dbLatitude;                      // γ��(��λ�ǰ����֮��,��Χ0-180��)
	double                  dbAltitude;                      // �߶�(��λ:��)
	double                  dbSpeed;                         // �ٶ�(��λ:km/H)
	double                  dbBearing;                       // �����(��λ:��)
	NET_THREE_STATUS_BOOL   emAntennasStatus;				 // ����״̬(0:�� 1:��)
	NET_THREE_STATUS_BOOL   emPositioningResult;             // ��λ״̬(0:����λ 1:��λ)
	DWORD					dwSatelliteCount;				 // ���Ǹ���
	NET_GPS_WORK_STATUS     emworkStatus;                    // ����״̬
	int                     nAlarmCount;					 // ��������
	int                     nAlarmState[128];                // �����ı���λ��,ֵ���ܶ��
	float					fHDOP;							 // ˮƽ��������
} NET_OUT_DEV_GPS_INFO;

// GPS״̬��Ϣ
typedef struct tagNET_SET_GPS_STATUS_INFO
{
	EM_DATE_SOURCE          emDateSource;						// ������Դ
	NET_TIME				stuLocalTime;						// ��ǰʱ�� 
	double                  dbLongitude;						// ����(��λ�Ƕ�,��Χ0-360��)
    double                  dbLatitude;							// γ��(��λ�Ƕ�,��Χ0-180��)
	double                  dbAltitude;							// �߶�(��λ:��)
	double                  dbSpeed;							// �ٶ�(��λ:km/H)
	double                  dbBearing;							// �����(��λ:��)
	NET_THREE_STATUS_BOOL   emAntennasStatus;					// ����״̬(0:�� 1:��)
	NET_THREE_STATUS_BOOL   emPositioningResult;				// ��λ״̬(0:����λ 1:��λ)
	int						nSatelliteCount;					// ���Ǹ���
	NET_GPS_WORK_STATUS     emWorkStatus;						// ����״̬
	int                     nAlarmCount;						// ��������
	int                     nAlarmState[128];					// �����ı���λ��,ֵ���ܶ��
	double					dbHDOP;								// ˮƽ��������
	BYTE					byReserved[1024];					// �����ֽ�
} NET_SET_GPS_STATUS_INFO;

// CLIENT_SetGPSStatus ����GPS״̬�������
typedef struct tagNET_IN_SET_GPS_STATUS
{
	DWORD						dwSize;	
	BOOL						bEnable;						// ʹ����, �Ƿ�ʹ�����õ�����
	int							nChannel;						// ͨ����
	NET_SET_GPS_STATUS_INFO		stGPSInfo;						// GPS ״̬��Ϣ
} NET_IN_SET_GPS_STATUS;

// CLIENT_SetPositionStatus ����GPS״̬�������
typedef struct tagNET_OUT_SET_GPS_STATUS
{
	DWORD					dwSize;								
} NET_OUT_SET_GPS_STATUS;

// ����GPS״̬��Ϣ(pInParam, pOutParam�ڴ����û������ͷ�)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGPSStatus(LLONG lLoginID, const NET_IN_SET_GPS_STATUS* pInParam, NET_OUT_SET_GPS_STATUS* pOutParam, int nWaitTime);


// ��ѯ IVS ǰ���豸���
typedef struct tagNET_IN_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // �ýṹ���С   
    int                     nChannel;                       // ͨ����
}NET_IN_IVS_REMOTE_DEV_INFO;

// ��ѯ IVS ǰ���豸����
typedef struct tagNET_OUT_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // �ýṹ���С 
    int                     nPort;                          // �˿�
    char                    szIP[64];                       // �豸IP
    char                    szUser[64];                     // �û���
    char                    szPassword[64];                 // ����    
    char                    szAddress[128];	                // ��������ص�
}NET_OUT_IVS_REMOTE_DEV_INFO;

// ��ѯ���ܲ�����Ϣ��� 
typedef struct tagNET_IN_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // �ýṹ���С 
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // �豸���к� 
}NET_IN_SMART_SWITCH_INFO;

// ��ѯ���ܲ�����Ϣ����
typedef struct tagNET_OUT_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // �ýṹ���С 
    BOOL                    bSwitchEable;                   // ����״̬, TRUE ��, FALSE ��
    double                  dbCurrentPower;                 // ��ʱ����, unit: W 
    double                  dbHistoryPowerUsed;             // ��ʷ�õ���, unit: kw/h
    double                  dbTodayPowerUsed;               // �����õ���, unit: kw/h
    double                  dbMonthPowerUsed[NET_MAX_MONTH_NUM]; // ÿ���õ���, unit: kw/h
}NET_OUT_SMART_SWITCH_INFO; 

// ��ѯ����״̬���
typedef struct tagNET_IN_UPGRADE_STATE
{
    DWORD                   dwSize;                         // �ýṹ���С 
}NET_IN_UPGRADE_STATE;

// ��������
enum CFG_EM_STREAM_TYPES
{
	CFG_EM_STREAMTYPE_ERR,                  // ����
	CFG_EM_STREAMTYPE_MAIN,					// "Main"-������
	CFG_EM_STREAMTYPE_EXTRA_1,				// "Extra1"-������1
	CFG_EM_STREAMTYPE_EXTRA_2,				// "Extra2"-������2
	CFG_EM_STREAMTYPE_EXTRA_3,				// "Extra3"-������3
	CFG_EM_STREAMTYPE_SNAPSHOT,				// "Snapshot"-ץͼ����
	CFG_EM_STREAMTYPE_TALKBACK,				// "Talkback"-�Խ�����
};

// ��ȡ��Ƶ�������������
typedef struct tagNET_IN_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;                         // �ýṹ���С
	int						nChannel;						// ͨ����
	int						nGroup;							// ���
	CFG_EM_STREAM_TYPES		stStreamType;					// ��������
}NET_IN_VIDEO_ENCODE_CAPS;

// ��ȡ��Ƶ��������������
typedef struct tagNET_OUT_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;																// �ýṹ���С
	int						nSvcEncodeTypesNum;													// ֧��SVC�������Ƶ��ʽ����
	char					szSvcEncodeTypes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];			// ֧��SVC�������Ƶ��ʽ
	int						nGOPCustomEncodesNum;												// ֧���Զ���I֡������������
	char					szGOPCustomEncodes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// ֧���Զ���I֡��������
	int						nMaxSVCTLevel;														// ���SVC-T֧�ֲ���
}NET_OUT_VIDEO_ENCODE_CAPS;

// ��ȡ��Ƶ�������������
typedef struct tagNET_IN_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;                         // �ýṹ���С
	int						nChannel;						// ͨ����
	CFG_EM_STREAM_TYPES		stStreamType;					// ��������
}NET_IN_AUDIO_ENCODE_CAPS;

// ��ȡ��Ƶ��������������
typedef struct tagNET_OUT_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;														// �ýṹ���С
	BOOL					bSupportSourceSelect;										// �Ƿ�֧�ֶ�·��Ƶ����
	int						nSourceTypeNum;												// ��ƵԴ���͸���
	char					szSourceType[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// ��ƵԴ�����б�
}NET_OUT_AUDIO_ENCODE_CAPS;

// ��ȡ��Ƶ����ͨ�����������
typedef struct tagNET_IN_AUDIO_IN_CAPS
{
	DWORD					dwSize;                         // �ýṹ���С
	int						nChannel;						// ͨ����
}NET_IN_AUDIO_IN_CAPS;

// ��ȡ��Ƶ����ͨ������������
typedef struct tagNET_IN_AUDIO_OUT_CAPS
{
	DWORD					dwSize;                         // �ýṹ���С
	int						nMicNum;						// ��˷��������,����0��ʾ֧�ֶԽ�����
	int						nLineInNum;						// �����������,����0��ʾ֧�ְ�������
}NET_OUT_AUDIO_IN_CAPS;

// Smart������Ϣ
typedef struct tagSMART_ENCODE_INFO
{
	DWORD					dwSize;							   // �ýṹ���С
	char					szCompression[MAX_COMMON_STRING_8]; // ��Ƶ����ѹ����ʽ����"H.264", "H.265"
	int						nPolicy;						   // Smart�������
	bool					bEnable;						   // �����Ƿ�ʹ��
	int						nWidth;							   // ��Ƶ��ȣ�ѡ��
	int						nHeight;						   // ��Ƶ�߶ȣ�ѡ��
	float					fFPS;							   // ��Ƶ֡�ʣ�ѡ��
}SMART_ENCODE_INFO;

// ��ѯSmart�������������
typedef struct tagNET_IN_SMART_ENCODE_CAPS
{
	DWORD					dwSize;								// �ýṹ���С
	int						nChannel;							// ͨ����
	int						nStreamNum;							// ʵ����������
	SMART_ENCODE_INFO		stSmartEncodeInfo[MAX_STREAM_NUM];  // ÿ��������Ӧ��Smart������Ϣ�����ʵ����������Ϊ3�����±�0��1��2�ֱ������������������1��������2�ı�����Ϣ	
}NET_IN_SMART_ENCODE_CAPS;

// Smart����ʹ��
typedef struct tagSMART_ENCODE_CAPS_INFO
{
	DWORD					dwSize;																// �ýṹ���С
	int						nSmartEncodeCap;													// 1֧�ֿ�������ض�λP֡���ܣ�0��֧��Smart����(���������ͨ����)��-1��֧�ֱ���(�����������ֱ��ʹ��󣬵�����Դ���㣬������2���ܱ��룬�������������ֱ��ʣ���2������������)
}SMART_ENCODE_CAPS_INFO;

//��ѯSmart��������������
typedef struct tagNET_OUT_SMART_ENCODE_CAPS
{
	DWORD						dwSize;																// �ýṹ���С
	int							nSmartEncodeCapsNum;												// Smart����ʹ�������
	SMART_ENCODE_CAPS_INFO		stSmartEncodeCaps[MAX_STREAM_NUM];									// ÿ������Smart������Ϣ��Ӧ����ʹ�ܡ�
}NET_OUT_SMART_ENCODE_CAPS;

// ����������
typedef enum tagEM_UPGRADE_PACKAGE_TYPE
{
    EM_UPGRADE_PACKAGE_TYPE_UNKNOWN,                       // δ֪����
    EM_UPGRADE_PACKAGE_TYPE_REGULAR,                       // һ������
    EM_UPGRADE_PACKAGE_TYPE_EMERGENCY,                     // ǿ������
}EM_UPGRADE_PACKAGE_TYPE;

// ������������״̬
typedef enum tagEM_UPGRADE_STATE
{
    EM_UPGRADE_STATE_UNKNOWN,                               // δ֪״̬
    EM_UPGRADE_STATE_NONE,                                  // û�м�⵽����״̬
    EM_UPGRADE_STATE_INVALID,                               // ����������ȷ
    EM_UPGRADE_STATE_NOT_ENOUGH_MEMORY,                     // �ڴ治��
    EM_UPGRADE_STATE_DOWNLOADING,                           // ������������
    EM_UPGRADE_STATE_DOWNLOAD_FAILED,                       // ����ʧ��
    EM_UPGRADE_STATE_DOWNLOAD_SUCCESSED,                    // ���سɹ�
    EM_UPGRADE_STATE_PREPARING,                             // ׼������
    EM_UPGRADE_STATE_UPGRADING,                             // ������
    EM_UPGRADE_STATE_UPGRADE_FAILED,                        // ����ʧ��
    EM_UPGRADE_STATE_UPGRADE_SUCCESSED,                     // �����ɹ�
    EM_UPGRADE_STATE_UPGRADE_CANCELLED,                     // ȡ������ 
    EM_UPGRADE_STATE_FILE_UNMATCH,                          // ��������ƥ��
}EM_UPGRADE_STATE;

// �豸����״̬�¼�
typedef struct tagALARM_UPGRADE_STATE
{
    EM_UPGRADE_STATE        emState;                        // ������������״̬
    int                     nProgress;                      // ��������, 0 ~ 100
    char                    szFileName[DH_COMMON_STRING_64];// ���ڲ������ļ���
    BYTE		            byReserved[1024];
}ALARM_UPGRADE_STATE;

// �洢�豸����״̬
typedef enum tagEM_LABELDATA_STATE
{
	EM_LABELDATA_STATE_ENTER,		                            // Enter (����)
	EM_LABELDATA_STATE_LEAVE,									// Leave (�뿪)
}EM_LABELDATA_STATE;

// IPC����(2017.4),RFID��ǩ��Ϣ�ɼ��¼�
typedef struct tagALARM_LABELINFO
{
	int						nChannelID;							// ͨ����
	char					szIndexIs[DH_COMMON_STRING_8];		// �¼�Index����ĺ��壬���޸��ֶΣ��޷�����
	int						nVideoIndex;						// ��Ƶͨ����
	UINT					nACK;								// ȷ��ID
	char					szReceiverID[DH_COMMON_STRING_16];	// ������ID
	char					szLabelID[DH_COMMON_STRING_16];		// RFID��ǩ
	NET_TIME_EX				stuDateTime;						// �ɼ�ʱ��UTC
	EM_LABELDATA_STATE		emLabelDataState;					// ��ǩ������״̬�����롢�뿪��
	BYTE					byReserve[1024];					// �����ֽ�
}ALARM_LABELINFO;
				
// ��ѯ����״̬����
typedef struct tagNET_OUT_UPGRADE_STATE
{
    DWORD                   dwSize;                         // �ýṹ���С
    char                    szOldVersion[DH_COMMON_STRING_64]; // �ɰ汾��
    char                    szNewVersion[DH_COMMON_STRING_64];  // �°汾��
    EM_UPGRADE_STATE        emState;                        // ������������״̬
    EM_UPGRADE_PACKAGE_TYPE emType;                         // ����������
    int                     nProgress;                      // ��������, 0 ~ 100
}NET_OUT_UPGRADE_STATE;

//��ѯӲ���¶����
typedef struct tagNET_IN_HDD_TEMPERATURE
{
	DWORD					dwSize;
	char					szHardDiskName[DH_COMMON_STRING_16];		//�洢�豸����
	
}NET_IN_HDD_TEMPERATURE;

//��ѯӲ���¶ȳ���
typedef struct tagNET_OUT_HDD_TEMPERATURE
{
	DWORD					dwSize;
	int						nID;										// ����ID
	char					szName[DH_COMMON_STRING_64];				// ������
	int						nCurrent;									// ����ֵ
	int						nWorst;										// ������ֵ
	int						nThreshold;									// ��ֵ
	char					szRaw[DH_COMMON_STRING_32];					// ʵ��ֵ
	int						nPredict;									// ״̬
	int						nSync;										// Raidͬ��״̬,0 ����Ӧ��1 ͬ�����ȣ�I/O���ȷָ�Raidͬ��;2 ҵ�����ȣ�I/O���ȷָ�Ӳ��д����;3 ����																		
}NET_OUT_HDD_TEMPERATURE; 

// ��ȡָ����ʽ��YUV�������
typedef struct tagNET_IN_RAWFRAMEDATA
{
	DWORD					dwSize;										
	int						nChannel;									// ��Ƶ����ͨ����
	int						nSensorID;									// sensor ID
	char					szRawFrameType[DH_COMMON_STRING_32];		// YUV���ݸ�ʽ,֧�ֵķ�Χͨ��CLIENT_GetDevCaps����, ����: NET_VIDEOIN_RAWFRAME_CAPS��ȡ
}NET_IN_RAWFRAMEDATA;

// ��ȡָ����ʽ��YUV���ݳ���
typedef struct tagNET_OUT_RAWFRAMEDATA
{
	DWORD					dwSize;
	UINT					nHeight;									// ����ͼƬ�ĸ߶�
	UINT					nWidth;										// ����ͼƬ�Ŀ�
	UINT					nDataLen;									// YUV���������ݴ�С����λ�ֽ�
	char*					pszBuffer;									// YUV���ݣ����û������ڴ棬��СΪ��nBufferLen
	int						nBufferLen;									// �û�����YUV�����ڴ��С
}NET_OUT_RAWFRAMEDARA;

//��������ģʽ
typedef enum tagNET_DOORWORK_MODE
{
    NET_DOORWORK_MODE_UNKNOWN = 0,                                // δ֪
    NET_DOORWORK_MODE_NORMAL = 1,                                 // ����ģʽ
    NET_DOORWORK_MODE_SHUTLOCK = 2,                               // ����
    NET_DOORWORK_MODE_UNUSED = 3,                                 // ͣ��
    NET_DOORWORK_MODE_OPENDOORCONTINUE = 4,                       // ������
} NET_DOORWORK_MODE;

// ��ȡ��������ģʽ����Ӧ����DH_DEVSTATE_GET_ACCESSCONTROLMODE
typedef struct tagNET_GET_DOORWORK_MODE
{
    DWORD                    dwSize;
    int                      nChannel;              // �Ž�ͨ����
    NET_DOORWORK_MODE   emControlMode;              // ��������ģʽ      
}NET_GET_DOORWORK_MODE;

// VT�¼�����
typedef enum tagEM_AUDIO_CB_FLAG
{
    EM_AUDIO_CB_FLAG_UNKNOWN,
    EM_AUDIO_CB_FLAG_NEWCALL,                   // �к�н���
    EM_AUDIO_CB_FLAG_REMOTE_HANGUP,             // �Է��Ҷ�
    EM_AUDIO_CB_FLAG_DISCONNECT,                // ����
    EM_AUDIO_CB_FLAG_RING,                      // �Զ�����
} EM_AUDIO_CB_FLAG;

// VT�ص�����
typedef int (CALLBACK *pfVtEventCallBack)(LLONG instId, LLONG ulRegisterId, LLONG ulSessionId, int nEvent, char *pDataBuf, DWORD dwBufSize, LDWORD dwUser);

// ����¼�������EM_AUDIO_CB_FLAG_NEWCALL
typedef enum tagEM_NEWCALL_ACTION
{
    EM_NEWCALL_ACTION_UNKNOWN,                  // �޲���
    EM_NEWCALL_ACTION_REFUSE,                   // �ܽ�
    EM_NEWCALL_ACTION_ACCEPT,                   // ����
} EM_NEWCALL_ACTION;

typedef enum tagEM_VT_PARAM_VALID
{
    EM_VT_PARAM_VALID_EVENT_CB     = 0x0001,
    EM_VT_PARAM_VALID_USER_DATA    = 0x0002,
    EM_VT_PARAM_VALID_MID_NUM      = 0x0004,
    EM_VT_PARAM_VALID_ACTION       = 0x0008,
    EM_VT_PARAM_VALID_WAITTIME     = 0x0010,
    EM_VT_PARAM_VALID_VIDEOWND     = 0x0020,
    EM_VT_PARAM_VALID_CSMODE       = 0x0040,
    EM_VT_PARAM_VALID_AUDIO_ENCODE = 0x0080,
    EM_VT_PARAM_VALID_LOCAL_IP     = 0x0100,
} EM_VT_PARAM_VALID;

// VT�Խ�����
typedef struct tagNET_VT_TALK_PARAM
{
    DWORD               dwSize;                  // �ṹ���С
    int                 nValidFlag;              // ��λ��ʶ������ֶ��Ƿ���Ч, EM_VT_PARAM_VALID�����
    pfVtEventCallBack   pfEventCb;               // �¼��ص�����, EM_VT_PARAM_VALID_EVENT_CB
    LDWORD              dwUser;                  // �¼��ص������Զ�������, EM_VT_PARAM_VALID_USER_DATA
    char                szPeerMidNum[16];        // �����к�, 8λ, EM_VT_PARAM_VALID_MID_NUM
    EM_NEWCALL_ACTION   emAction;                // �Ժ�еĲ���, 0:�޲���, 1:�ܽ�, 2:����, EM_VT_PARAM_VALID_ACTION
    int                 nWaitTime;               // ��ʱʱ��, ��λms, EM_VT_PARAM_VALID_WAITTIME
    HWND                hVideoWnd;               // ���ӶԽ���Ƶ��ʾ����, EM_VT_PARAM_VALID_VIDEOWND
    BOOL                bClient;                 // �ͻ���/������ģʽ, TRUE:�ͻ���, FALSE:������, EM_VT_PARAM_VALID_CSMODE
    DHDEV_TALKDECODE_INFO stAudioEncode;         // ���������Ϣ, EM_VT_PARAM_VALID_AUDIO_ENCODE
} NET_VT_TALK_PARAM;

// VTC��¼VTO
CLIENT_NET_API LLONG CALL_METHOD CLIENT_VT_RegisterVto(const char *pszIp, int nPort = 13801);

// VTC�ǳ�VTO
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VT_UnRegisterVto(LLONG ulLongId);

/////////////////////////////////// ���˻��ӿ� ///////////////////////////////////////

// ���˻�������Ϣ�ṹ
typedef struct tagNET_UAV_FLY_INFO 
{
    float               fAltitude;                          // ��ֱ�߶�,�����ˮƽ��	��λ����
    float               fDistance;                          // ˮƽ����,�����ң����	��λ����
    float               fHorizontalSpeed;                   // ˮƽ�ٶ�,��������ˮƽ����ķ����ٶ�	��λ����/��
    float               fVerticalSpeed;                     // ��ֱ�ٶ�,�������ڴ�ֱ����ķ����ٶ�	��λ����/��
    int                 nRCLinkQuality;                     // ң������·�ź����� ��Χ��0~100
    char                reserved[512];
} NET_UAV_FLY_INFO;

// ���˻�������Ϣ�ص�����ԭ��,lAttachHandle �� CLIENT_AttachUavFly ����ֵ
typedef void (CALLBACK *fUavFlyCallBack) (LLONG lAttachHandle, NET_UAV_FLY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachUavFly ���
typedef struct tagNET_IN_ATTACH_UAV_FLY 
{
    DWORD               dwSize;
    fUavFlyCallBack     cbUavFly;                           // ������Ϣ�ص�����
    DWORD               dwUser;                             // �û�����                   
} NET_IN_ATTACH_UAV_FLY;

// CLIENT_AttachUavFly ����
typedef struct tagNET_OUT_ATTACH_UAV_FLY 
{
    DWORD                dwSize;
} NET_OUT_ATTACH_UAV_FLY;

// �������˻�������Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachUavFly(LLONG lLoginID, const NET_IN_ATTACH_UAV_FLY* pInParam, NET_OUT_ATTACH_UAV_FLY* pOutParam, int nWaitTime);

// ȡ���������˻�������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachUavFly(LLONG lAttachHandle);

////////////////////////////////////////////////////////////////////////////////

// ��ȡ�豸�Լ���Ϣ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSelfCheckInfo(LLONG lLoginID, const NET_IN_GET_SELTCHECK_INFO* pInParam, NET_SELFCHECK_INFO* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////������������������ӿ�/////////////////////////////////

// �򿪻�رռ��������
typedef struct tagLASER_IN_INFO
{
	DWORD		dwSize;				// �ṹ���С
	UINT		nChannelID;			// ͨ����
} LASER_IN_INFO;

// �򿪻�رռ���������
typedef struct tagLaser_OUT_INFO 
{
	DWORD		dwSize;			// �ṹ���С
} LASER_OUT_INFO;

//�򿪻�رյ������������
typedef struct tagEIS_IN_INFO 
{
	DWORD		dwSize;				// �ṹ���С
	UINT		nChannelID;			// ͨ����
} EIS_IN_INFO;

//�򿪹رյ����������ӿڳ���
typedef struct tagEIS_OUT_INFO 
{
	DWORD		dwSize;			// �ṹ���С
} EIS_OUT_INFO;


//�򿪼�����,pLaserDataIn��pLaserDataOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

//�رռ�����,pLaserDataIn��pLaserDataOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

//�򿪵���������,pEISDataIn��pEISDataOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);

//�رյ���������,pEISDataIn��pEISDataOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);

// �ֶ�����PSTN����״̬,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ManualCheckPSTN(LLONG lLoginID, const NET_IN_PSTN_MANUALCHECK_STATE* pInBuf, NET_OUT_PSTN_MANUALCHECK_STATE* pOutBuf, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

#define  MAX_NUM_EX_MODULE          16              // ��չģ���������
#define  MAX_NUM_ADDR_IN_BUS        256             // �����ϵĵ�ַ�ŵ��������

// ��ȡ��չģ��ʹ��������
typedef struct tagNET_IN_EXMODULE_INFO 
{
    DWORD		dwSize;				                                        // �ṹ���С
} NET_IN_EXMODULE_INFO;

// ������չģ��ʹ�����
typedef struct tagNET_OUT_EXMODULE_INFO
{
    NET_BUS_TYPE		emBusType;                                          // ��������
    int                 nChannelID;	                                        // ���ߺ�
    int                 nAddrCount;                                         // ��Ч�ĵ�ַ�Ÿ���
    int                 nAddr[MAX_NUM_ADDR_IN_BUS];                         // �����ϵĵ�ַ��
    char                reserved[1024];                                     // �����ֽ�
} NET_OUT_EXMODULE_INFO;

// ��ȡ��չģ��ʹ������ӿڳ���
typedef struct tagNET_OUT_EXMODULE_INFO_ALL
{
    DWORD		                dwSize;			                            // �ṹ���С
    int                         nExModuleCount;                             // ��������
    NET_OUT_EXMODULE_INFO       stuExModuleInfo[MAX_NUM_EX_MODULE];         // ��չģ��ʹ���������
} NET_OUT_EXMODULE_INFO_ALL;

/**************************************************************************************
*   Funcname: CLIENT_GetExModuleState
*   Purpose:��ȡ��չģ��ʹ�����
*   InputParam:   LLONG                        :lLoginID        //��½���
*   InputParam:   NET_IN_EXMODULE_INFO*        :pInParam        //�������,����,����ΪNULL,������dwSize,���û������ͷ��ڴ�
*   InputParam:   NET_OUT_EXMODULE_INFO_ALL*   :pOutParam       //��������,����,����ΪNULL,������dwSize,���û������ͷ��ڴ�
*   InputParam:   int                          :nWaitTime       //��ʱʱ��
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetExModuleState(LLONG lLoginID, const NET_IN_EXMODULE_INFO* pInParam, NET_OUT_EXMODULE_INFO_ALL* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

///////////////////////////////�����豸������ӿ�//////////////////////////

#define MASTERSALVE_CLASS_LEN           16

typedef struct tagNET_IN_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;                              // �ṹ���
    int                    nGroupID;                            // �豸���
    int                    nSlaveID;                            // �ӻ���� 
}NET_IN_MSGROUP_OPEN_INFO;

typedef struct tagNET_OUT_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;                              // �ṹ���С
    DWORD                  dwToken;                             // ���Ӹ�������
}NET_OUT_MSGROUP_OPEN_INFO;

typedef struct tagNET_IN_MSGROUP_LOCATE_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
    DWORD                   dwToken;                            // ���Ӹ�������
    DH_POINT                stuPoint;                           // ��������
    short                   snMasterInfo[3];                    // ����Բ��������뾶, ����Ϊ[������, ������, �뾶]
}NET_IN_MSGROUP_LOCATE_INFO;

typedef struct tagNET_OUT_MSGROUP_LOCATE_INTO
{
    DWORD                   dwSize;                             // �ṹ���С
    short                   snPTZ[3];                           // ����������ϵľ�������
}NET_OUT_MSGROUP_LOCATE_INTO;

typedef struct tagNET_IN_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
    DWORD                   dwToken;                            // ���Ӹ�������
    char                    szClass[MASTERSALVE_CLASS_LEN];     // �㷨��������
    DWORD                   dwObjectID;                         // �㷨Ŀ��ID
}NET_IN_MSGROUP_TRACK_INFO;

typedef struct tagNET_OUT_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
}NET_OUT_MSGROUP_TRACK_INFO;

typedef struct tagNET_IN_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
    DWORD                   dwToken;                            // ���Ӹ�������
}NET_IN_MSGROUP_CLOSE_INFO;

typedef struct tagNET_OUT_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
}NET_OUT_MSGROUP_CLOSE_INFO;

// ������������������ EM_MSGROUP_OPERATE_RECTLOCATE ���
typedef struct tagNET_IN_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
    DWORD                   dwToken;                            // ���Ӹ�������, �� EM_MSGROUP_OPERATE_OPEN ������ȡ
    NET_RECT                stuRect;                            // ѡ���ľ��ο�����
    int                     nRectDirection;                     // ��ѡ�ķ���, 0-�����ϵ�����, ��ʾ�Ŵ�; 1-�����µ����ϣ���ʾ��С
}NET_IN_MSGROUP_RECTLOCATE_INFO;

// ������������������, EM_MSGROUP_OPERATE_RECTLOCATE ����
typedef struct tagNET_OUT_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                             // �ṹ���С
    int                     nPTZ[3];                            // ����������ϵľ�������
}NET_OUT_MSGROUP_RECTLOCATE_INFO;

// ���ٱ�����Ϣ
typedef struct tagNET_MSGROUP_NOTIFY_INFO 
{
    DWORD                    dwSubscribeID;                     // ����˶���ID
    int                      nSlaveID;                          // �������дӻ����
    char                     szClass[MASTERSALVE_CLASS_LEN];    // �㷨��������
    DWORD                    dwObjectID;                        // �㷨Ŀ��ID
    NET_RECT                 stuBoundingBox;                    // ���������Χ��
    BYTE                     byReserved[512];                   // �����ֽ� 
}NET_MSGROUP_NOTIFY_INFO;

// �Զ����ٻص�����, lAttachHandle Ϊ CLIENT_AttachMasterSlaveGroup ���صĽ��
typedef void (CALLBACK *fMasterSlaveCallBack)(LLONG lAttachHandle, NET_MSGROUP_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachMasterSlaveGroup ���
typedef struct tagNET_IN_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
    fMasterSlaveCallBack     cbNotify;                          // �ص�����
    LDWORD                   dwUser;                            // �û���Ϣ
    int                      nGroupID;                          // �豸���
}NET_IN_MSGROUP_ATTACH_INFO;

// CLIENT_AttachMasterSlaveGroup ����
typedef struct tagNET_OUT_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
}NET_OUT_MSGROUP_ATTACH_INFO;

// ������������������, �ӿ� CLIENT_OperateMasterSlaveGroup
typedef enum tagEM_MSGROUP_OPERATE_TYPE
{
    EM_MSGROUP_OPERATE_OPEN,                                    // �����Ӹ�����, ��Ӧ NET_IN_MSGROUP_OPEN_INFO �� NET_OUT_MSGROUP_OPEN_INFO
    EM_MSGROUP_OPERATE_LOCATE,                                  // �������Ӹ�����, ��Ӧ NET_IN_MSGROUP_LOCATE_INFO �� NET_OUT_MSGROUP_LOCATE_INTO
    EM_MSGROUP_OPERATE_TRACK,                                   // �ֶ�ѡ��Ŀ�����, ��Ӧ NET_IN_MSGROUP_TRACK_INFO �� NET_OUT_MSGROUP_TRACK_INFO
    EM_MSGROUP_OPERATE_CLOSE,                                   // �ر�����ʽ������ʵ��, ��Ӧ NET_IN_MSGROUP_CLOSE_INFO �� NET_OUT_MSGROUP_CLOSE_INFO
    EM_MSGROUP_OPERATE_RECTLOCATE,                              // �����豸ѡ����ο��������豸, ��Ӧ NET_IN_MSGROUP_RECTLOCATE_INFO �� NET_OUT_MSGROUP_RECTLOCATE_INFO
}EM_MSGROUP_OPERATE_TYPE;

// ����������, �����ӿ�,pInParam��pOutParam�ڴ����û������ͷ�,��С����emOperateType��Ӧ�Ľṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveGroup(LLONG lLoginID, EM_MSGROUP_OPERATE_TYPE emOperateType, void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// �����Զ�����Ŀ�� ,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMasterSlaveGroup(LLONG lLoginID, const NET_IN_MSGROUP_ATTACH_INFO *pInParam, NET_OUT_MSGROUP_ATTACH_INFO *pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// �˶��Զ�����Ŀ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMasterSlaveGroup(LLONG lAttachHandle);
//////////////////////////////////////////////////////////////////////////

#define     MAX_TRAFFIC_LANE_NUM            16                  // ��󳵵�����
#define     MAX_CAMERA_PERIPHERAL_NUM       8                   // ���������������
#define     MAX_STORAGE_NUM                 8                   // �洢�豸������
#define     MAX_PARTITION_NUM               8                   // ����������

// �洢�豸������Ϣ
typedef struct tagNET_PARTITION_INFO
{
    double                      dbTotalBytes;                   // �����ܿռ�
    double                      dbUsedBytes;                    // ����ʹ�õĿռ�
    BOOL                        bError;                         // �Ƿ��쳣
    BYTE                        byReserved[64];                 // �����ֶ�
}NET_PARTITION_INFO;

// �洢�豸����״̬
typedef enum tagENUM_STORAGE_STATE
{
    ENUM_STORAGE_STATE_UNKONWN,                                 // δ֪״̬
    ENUM_STORGAE_STATE_READ_ERROR,                              // �豸��ȡʧ��
    ENUM_STORAGE_STATE_INITIALIZING,                            // ���ڶ�ȡ�豸
    ENUM_STORAGE_STATE_READ_SUCCESS,                            // �豸��ȡ�ɹ�
}ENUM_STORAGE_STATE;

// �洢�豸��Ϣ
typedef struct tagNET_STORAGE_INFO
{
    ENUM_STORAGE_STATE       emState;                           // �洢�豸״̬
    int                      nPartitonNum;                      // ��������
    NET_PARTITION_INFO       stuPartions[MAX_PARTITION_NUM];    // ������Ϣ
    BYTE                     byReserved[128];                   // �����ֶ�
}NET_STORAGE_INFO;

// ������Դ
typedef struct tagNET_RESOURCE_STATE
{
	int						nIPChanneIn;					// IPͨ�������ٶ�, ��λ: kbps
	int						nNetRemain;						// �������ʣ������, ��λ: kbps
	int						nNetCapability;					// �������������, ��λ: kbps
	int						nRemotePreview;					// Զ��Ԥ������, ��λ: kbps
	int						nRmtPlayDownload;				// Զ�̻طż���������, ��λ: kbps
	int						nRemoteSendRemain;				// Զ�̷���ʣ������, ��λ: kbps
	int						nRemoteSendCapability;			// Զ�̷���������, ��λ: kbps
	BYTE                    byReserved[32];                 // �����ֽ�
} NET_RESOURCE_STATE;

// �豸����״̬
typedef struct tagNET_WORKSTATE
{
    BOOL                     bOnline;                           // �豸�Ƿ�����
    char                     szFirmwareVersion[DH_COMMON_STRING_128];  // �̼��汾��
    float                    fTemperature;                      // �¶�ֵ, ��λ���϶�
    float                    fPowerDissipation;                 // ����, ��λW
    int                      nUtilizationOfCPU;                 // CPU ʹ����
    
    int                      nStorageNum;                       // �洢�豸����
    NET_STORAGE_INFO         stuStorages[MAX_STORAGE_NUM];      // �洢�豸��Ϣ
    int					 	 nUpTimeLast;						// �ϴ��ϵ�ʱ��, ��λ: ��
    int					 	 nUpTimeTotal;						// �ܹ��ϵ�ʱ��, ��λ: ��
    double					 dbMemInfoTotal;					// ���ڴ��С, ��λ: �ֽ�
    double					 dbMemInfoFree;						// ʣ���ڴ��С, ��λ: �ֽ�
    BYTE					 byReserved1[4];					// �ֽڶ��룬�Ǳ����ֽ�
    char					 szDevType[32];						// �豸�ͺ�
    NET_RESOURCE_STATE		 stuResourceStat;					// ������Դ
    BYTE                     byReserved[8];                     // �����ֽ�
}NET_WORKSTATE;

// ��ѯ���ӹ���״̬, ��Ӧ���� DH_DEVSTATE_GET_WORK_STATE
typedef struct tagNET_QUERY_WORK_STATE
{
    DWORD                    dwSize;                            // �����ֶ�
    NET_WORKSTATE            stuWorkState;                      // ����״̬
}NET_QUERY_WORK_STATE;

// ��ѯ����������״̬���,��Ӧ�ӿ� CLIENT_GetCapsuleLockState
typedef struct tagNET_IN_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                       dwSize;                         // �ṹ���С
    int                         nChannel;                       // ͨ����
}NET_IN_QUERY_CAPSULE_LOCKSTATE;

// ����״̬
typedef enum tagNET_EM_ONLINESTATE
{
	NET_EM_ONLINESTATE_UNKNOWN,									 // δ֪
    NET_EM_ONLINESTATE_ONLINE,                                   // ����
    NET_EM_ONLINESTATE_OFFLINE,                                  // ����
}NET_EM_ONLINESTATE;

// ����״̬
typedef enum  tagNET_EM_LOCKSTATE
{
    NET_EM_LOCKSTATE_UNKNOWN,                                   // δ֪
    NET_EM_LOCKSTATE_Open,                                      // ��
    NET_EM_LOCKSTATE_CLOSE,                                     // �ر�
    NET_EM_LOCKSTATE_ABNORMAL,                                  // �쳣
    NET_EM_LOCKSTATE_FAKELOCKED,                                // ����
}NET_EM_LOCKSTATE;

// ��ѯ����������״̬���Σ���Ӧ�ӿ� CLIENT_GetCapsuleLockState
typedef struct tagNET_OUT_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                       dwSize;                         // �ṹ���С
    NET_EM_LOCKSTATE            emLockState;                    // ����״̬    
    NET_EM_ONLINESTATE			emOnLineState;					// ����״̬
}NET_OUT_QUERY_CAPSULE_LOCKSTATE;

// ��ȡ���������������
typedef struct tagNET_IN_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // �ṹ���С
    int                         nChannel;                       // ͨ����
}NET_IN_QUERY_CAPSULE_HUMANNUM;

// ��ȡ����������������
typedef struct tagNET_OUT_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // �ṹ���С
    UINT                        nHumanNum;                      // ����
}NET_OUT_QUERY_CAPSULE_HUMANNUM;

// ¼��ģʽ
typedef enum tagNET_EM_RECORD_MODE
{
    NET_EM_RECORD_MODE_UNKNOWN,                                 // δ֪
    NET_EM_RECORD_MODE_COURSE,                                  // �γ�¼��ģʽ
    NET_EM_RECORD_MODE_NORMAL,                                  // ��ͨģʽ
}NET_EM_RECORD_MODE;

// ����¼��ģʽ��Σ���Ӧ�ӿ�CLIENT_SetCourseRecordMode
typedef struct tagNET_IN_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
    NET_EM_RECORD_MODE          emRecordMode;                   // ¼��ģʽ
    int                         nClassRoomID;                   // ����id��
}NET_IN_SET_COURSE_RECORD_MODE;

// ����¼��ģʽ���Σ���Ӧ�ӿ�CLIENT_SetCourseRecordMode
typedef struct tagNET_OUT_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
}NET_OUT_SET_COURSE_RECORD_MODE;

// ��ȡ¼��ģʽ��Σ���Ӧ�ӿ�CLIENT_GetCourseRecordMode
typedef struct tagNET_IN_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;  
    int                         nClassRoomID;                   // ����id��
}NET_IN_GET_COURSE_RECORD_MODE;

// ��ȡ¼��ģʽ���Σ���Ӧ�ӿ�CLIENT_GetCourseRecordMode
typedef struct tagNET_OUT_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize; 
    NET_EM_RECORD_MODE          emRecordMode;                   // ¼��ģʽ
}NET_OUT_GET_COURSE_RECORD_MODE;

// �豸������Ϣ
typedef struct tagNET_DEVICE_COMMON_INFO
{
    char                     szVendor[DH_COMMON_STRING_32];     // ��������
    char                     szDviceType[DH_COMMON_STRING_32];  // �豸�ͺ�
    char                     szVersion[DH_COMMON_STRING_128];   // �豸�汾��Ϣ
    char                     szSerialNo[DH_COMMON_STRING_128];  // �豸���
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_DEVICE_COMMON_INFO;

// ��������Ϣ
typedef struct tagNET_VEHICLE_DETECTOR_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    int                      nLaneNum;                          // ��������
    int                      nUsageOfLane[MAX_TRAFFIC_LANE_NUM];// ÿ������ռ����, 0-100
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_VEHICLE_DETECTOR_INFO;

// �źż������Ϣ
typedef struct tagNET_SIGNAL_DETECTOR_INFO 
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_SIGNAL_DETECTOR_INFO;

// Ƶ������Ϣ
typedef struct tagNET_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_STROBOSCOPIC_LAMP_INFO;

// RS485 Ƶ������Ϣ
typedef struct tagNET_RS485_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����

    int                      nPeripheralAddress;                // �����ַ
    int                      nPeripheralStateCode;              // ���������: 1-�豸����Ӧ, 2-�������, 3-δ��Ƶ���ź�     
    int                      nLuminance;                        // ����, 1-20
    int                      nSensibility;                      // �����, 1-255
    float                    fPowerDissipation;                 // ����

    BYTE                     byReserved[128];                   // �����ֽ�
}NET_RS485_STROBOSCOPIC_LAMP_INFO;

// ��������Ϣ
typedef struct tagNET_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_FLASH_LAMP_INFO;

// RS485 ��������Ϣ
typedef struct tagNET_RS485_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    
    int                      nPeripheralAddress;                // �����ַ
    int                      nPeripheralStateCode;              // ���������: 1-�豸����Ӧ, 2-�������, 3-δ��Ƶ���ź�     
    int                      nLuminance;                        // ����, 1-20
    int                      nSensibility;                      // �����, 1-255
    float                    fPowerDissipation;                 // ����
    
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_RS485_FLASH_LAMP_INFO;

// RS485 ��������Ϣ
typedef struct tagNET_RS485_STEADY_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // �豸��Ϣ
    int                      nWokingState;                      // ����״̬: 0-����, 1-��������, 2-�ر�
    int                      nMatchState;                       // ��Ȧƥ��״̬: 0-��ƥ��, 1-ƥ��, 2-�����
    
    int                      nPeripheralAddress;                // �����ַ
    int                      nPeripheralStateCode;              // ���������: 1-�豸����Ӧ, 2-�������, 3-δ��Ƶ���ź�     
    int                      nLuminance;                        // ����, 1-20
    int                      nSensibility;                      // �����, 1-255
    float                    fPowerDissipation;                 // ����
    
    BYTE                     byReserved[128];                   // �����ֽ�
}NET_RS485_STEADY_LAMP_INFO;

// ���������״̬
typedef struct tagNET_CAMERA_PERIPHERAL_INFO
{
    int                         nVehicleDetectorNum;                                // ����������
    NET_VEHICLE_DETECTOR_INFO   stuVehicleDetectors[MAX_CAMERA_PERIPHERAL_NUM];     // ��������Ϣ

    int                         nSignalDetectorNum;                                 // �źż��������
    NET_SIGNAL_DETECTOR_INFO    stuSignalDetectors[MAX_CAMERA_PERIPHERAL_NUM];      // �źż������Ϣ
    
    int                         nStroboscopicLampNum;                               // Ƶ���Ƹ���
    NET_STROBOSCOPIC_LAMP_INFO  stuStroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM];    // Ƶ������Ϣ

    int                         nFlashLampNum;                                      // �����Ƹ���
    NET_FLASH_LAMP_INFO         stuFlashLamps[MAX_CAMERA_PERIPHERAL_NUM];           // ��������Ϣ

    int                         nRS485StroboscopicLampNum;                          // RS485 Ƶ���Ƹ���
    NET_RS485_STROBOSCOPIC_LAMP_INFO    stuRS485StroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM]; // RS485 Ƶ������Ϣ
    
    int                         nRS485FlashLampNum;                                 // RS485 �����Ƹ���
    NET_RS485_FLASH_LAMP_INFO   stuRS485FlashLamps[MAX_CAMERA_PERIPHERAL_NUM];      // RS485 ��������Ϣ

    int                         nRS485SteadyLampNum;                                // RS485 �����Ƹ���
    NET_RS485_STEADY_LAMP_INFO  stuRS485SteadyLamps[MAX_CAMERA_PERIPHERAL_NUM];     // RS485 ��������Ϣ

    BYTE                        byReserved[128];                                    // �����ֽ�
}NET_CAMERA_PERIPHERAL_INFO;

// �豸����״̬�ص���Ϣ
typedef struct tagNET_REMOTECAMERA_NOTIFY_INFO
{
    int                         nChannelID;                     // ���ͨ����
    NET_WORKSTATE               stuNative;                      // �����״̬
    NET_CAMERA_PERIPHERAL_INFO  stuPeripherals;                 // ���������������Ϣ
    BYTE                        byReserved[128];                // �����ֽ�
}NET_REMOTECAMERA_NOTIFY_INFO;

// �豸����״̬�ص�����, lAttachHandle Ϊ CLIENT_AttachRemoteCameraState ���صĽ��
typedef void (CALLBACK *fRemoteCameraStateCallBack)(LLONG lAttachHandle, NET_REMOTECAMERA_NOTIFY_INFO* pstuState, DWORD dwStateSize, LDWORD dwUser);

// CLIENT_AttachRemoteCameraState ���
typedef struct tagNET_IN_REMOTECAMERA_ATTACH_INFO
{
    DWORD                       dwSize;                         // �ṹ���С
    fRemoteCameraStateCallBack  cbNotify;                       // �ص�����
    LDWORD                      dwUser;                         // �û���Ϣ
}NET_IN_REMOTECAMERA_ATTACH_INFO;

// CLIENT_AttachRemoteCameraState ����
typedef struct tagNET_OUT_REMOTECAMERA_ATTACH_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
}NET_OUT_REMOTECAMERA_ATTACH_INFO;

// ��������豸״̬,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemoteCameraState(LLONG lLoginID, const NET_IN_REMOTECAMERA_ATTACH_INFO *pInParam, NET_OUT_REMOTECAMERA_ATTACH_INFO *pOutParam, int nWaitTime);

// ȡ����������豸״̬
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemoteCameraState(LLONG lAttachHandle);

// Ѳ��״̬
typedef enum tagNET_EM_PATROL_STATUS
{
    NET_EM_PATROL_STATUS_UNKNOWN,                               // δ֪״̬
    NET_EM_PATROL_STATUS_BEGIN,                                 // Ѳ����ʼ
    NET_EM_PATROL_STATUS_END,                                   // Ѳ������
    NET_EM_PATROL_STATUS_FAIL,                                  // Ѳ��ʧ��
}NET_EM_PATROL_STATUS;

// CLIENT_SendNotifyToDev ��� (��Ӧö�� NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_IN_PATROL_STATUS_INFO
{
    DWORD                       dwSize;                         // �ṹ���С
    NET_EM_PATROL_STATUS        emPatrolStatus;                 // Ѳ��״̬

}NET_IN_PATROL_STATUS_INFO;

// CLIENT_SendNotifyToDev ���� (��Ӧö�� NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_OUT_PATROL_STATUS_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
}NET_OUT_PATROL_STATUS_INFO;

// ���͵�֪ͨ����,��ӦCLIENT_SendNotifyToDev�ӿ�
typedef enum tagNET_EM_NOTIFY_TYPE
{
    NET_EM_NOTIFY_PATROL_STATUS = 1,                            // ����Ѳ��֪ͨ (��Ӧ�ṹ�� NET_IN_PATROL_STATUS_INFO, NET_OUT_PATROL_STATUS_INFO)
}NET_EM_NOTIFY_TYPE;

// �·�֪ͨ���豸 �ӿ�, ��emNotifyType�������·���֪ͨ����, pInParam �� pOutParam �����û���������ͷ�,��С����emNotifyType��Ӧ�ṹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendNotifyToDev(LLONG lLoginID, NET_EM_NOTIFY_TYPE emNotifyType, const void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );

// �ȶ�ͼԭʼ������Ϣ
typedef struct tagNET_RAWSTREAM_NOTIFY_INFO 
{
    int                      nWidth;                            // ͼƬ���
    int                      nHeight;                           // ͼƬ�߶�
    NET_TIME                 stuStartTime;                      // ��ʼʱ��
    NET_TIME                 stuEndTime;                        // ����ʱ��
    char*                    pStream;                           // ͼƬ����
    int                      nLength;                           // ͼƬ���ݳ���
    BYTE                     byReserved[512];                   // �����ֽ� 
}NET_RAWSTREAM_NOTIFY_INFO;

// �ȶ�ͼԭʼ���ݻص�����, lAttachHandle Ϊ CLIENT_AttachHeatMapRawStream ���صĽ��
typedef void (CALLBACK *fRawStreamCallBack)(LLONG lAttachHandle, NET_RAWSTREAM_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachHeatMapRawStream ���
typedef struct tagNET_IN_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
    fRawStreamCallBack       cbNotify;                          // �ص�����
    LDWORD                   dwUser;                            // �û���Ϣ
    int                      nChannel;                          // ͨ����
}NET_IN_RAWSTREAM_ATTACH_INFO;

// CLIENT_AttachHeatMapRawStream ����
typedef struct tagNET_OUT_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // �ṹ���С
}NET_OUT_RAWSTREAM_ATTACH_INFO;

// �����ȶ�ͼԭʼ���ݽӿ�,pInParam��pOutParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachHeatMapRawStream(LLONG lLoginID, const NET_IN_RAWSTREAM_ATTACH_INFO *pInParam, NET_OUT_RAWSTREAM_ATTACH_INFO *pOutParam, int nWaitTime);

// �˶��ȶ�ͼԭʼ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachHeatMapRawStream(LLONG lAttachHandle);

//������Ϣ
typedef struct tagNET_ANALYSERESULT
{
    char                      szPlateNumber[64];                // ���ƺ�
    NET_RECT                  stuRect;                          // ���ư�Χ������,��������
    BYTE                      byReserved[128];                  // �����ֽ� 
}NET_ANALYSERESULT;

// CLIENT_SetIVSServerAnalyseResult �ӿ����
typedef struct tagNET_IN_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           // �ṹ���С
    int                       nChannel;                         // ͨ���� ��0��ʼ
    int                       nAnalyseResultCount;              // ����ʶ��������
    NET_ANALYSERESULT         stuAnalyseResult[MAX_PLATE_NUM];  // ������Ϣ
	unsigned int			  nFrameSequence;					// �����,���ںͺ��IVSʶ��ȷ��,����
	unsigned int			  nPhysicalLane;					// ����λ��
}NET_IN_SET_ANALYSERESULT_INFO;

// CLIENT_SetIVSServerAnalyseResult �ӿڳ���
typedef struct tagNET_OUT_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           // �ṹ���С
}NET_OUT_SET_ANALYSERESULT_INFO;

// CLIENT_AttachEventRestore �ӿ��������
typedef struct tagNET_IN_ATTACH_EVENT_RESTORE
{
    DWORD                dwSize;															//�ṹ���С
	char 				 szUuid[MAX_EVENT_RESTORE_UUID];									//�ͻ���Ωһ��ʶ
}NET_IN_ATTACH_EVENT_RESTORE;

// �㷨�������ش����ͼƬ��ʶ����,��EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP�¼����ʹ��,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetIVSServerAnalyseResult(LLONG lLoginID, const NET_IN_SET_ANALYSERESULT_INFO* pInBuf,NET_OUT_SET_ANALYSERESULT_INFO* pOutBuf,int nWaitTime);


// ��ȡ����������״̬�ӿ�,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleLockState(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_LOCKSTATE* pInBuf,NET_OUT_QUERY_CAPSULE_LOCKSTATE* pOutBuf, int nWaitTime);

// ��ȡ������������,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleHumanNum(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_HUMANNUM* pInBuf, NET_OUT_QUERY_CAPSULE_HUMANNUM* pOutBuf, int nWaitTime);

// ���ÿγ�¼��ģʽ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordMode(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_MODE* pInBuf, NET_OUT_SET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// ��ȡ�γ�¼��ģʽ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCourseRecordMode(LLONG lLoginID, const NET_IN_GET_COURSE_RECORD_MODE* pInBuf, NET_OUT_GET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// �߼�ͨ����
typedef enum tagNET_EM_LOGIC_CHANNEL
{
    NET_EM_LOGIC_CHANNEL_INVALID = -1,                          // ��Ч
    NET_EM_LOGIC_CHANNEL_COMPOSITE,                             // ��Ƶ���ͨ����
    NET_EM_LOGIC_CHANNEL_PPT,                                   // PPT��ʾ�߼�ͨ����
    NET_EM_LOGIC_CHANNEL_BLACKBOARD,                            // ������д�߼�ͨ����
    NET_EM_LOGIC_CHANNEL_STUDENTFEATURE,                        // ѧ����д�߼�ͨ����
    NET_EM_LOGIC_CHANNEL_STUDENTFULLVIEW,                       // ѧ��ȫ���߼�ͨ����
    NET_EM_LOGIC_CHANNEL_TEACHERFEATURE,                        // ��ʦ��д�߼�ͨ����
    NET_EM_LOGIC_CHANNEL_TEACHERFULLVIEW,                       // ��ʦȫ���߼�ͨ����
    NET_EM_LOGIC_CHANNEL_TEACHERDETECT,                         // ��ʦ����߼�ͨ����
    NET_EM_LOGIC_CHANNEL_BLACKBOARDDETECT,                      // �������߼�ͨ����
}NET_EM_LOGIC_CHANNEL;

// ͨ����Ϣ
typedef struct  tagNET_LOGIC_CHANNEL_INFO
{
    int                         nRoomID;                        // ����ID��
    NET_EM_LOGIC_CHANNEL        emLogicChannel;                 // �߼�ͨ����
    BYTE                        byReserved[32];                 // �����ֽ�
}NET_LOGIC_CHANNEL_INFO;

// ��ȡ��ʵͨ������Σ���Ӧ�ӿ� CLIENT_GetRealPreviewChannel
typedef struct tagNET_IN_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelCount;                  // ��Ҫ��ȡ��ͨ����
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];             // �߼�ͨ����Ϣ���±�Ϊ��Ҫ��ȡ����ʵͨ����
}NET_IN_GET_REAL_PREVIEW_CHANNEL;

// ��ȡ��ʵͨ���ų��Σ���Ӧ�ӿ� CLIENT_GetRealPreviewChannel
typedef struct tagNET_OUT_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                       // ͨ������
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM]; // ͨ����
}NET_OUT_GET_REAL_PREVIEW_CHANNEL;

// ��ȡ��ʵԤ��ͨ����,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRealPreviewChannel(LLONG lLoginID, const NET_IN_GET_REAL_PREVIEW_CHANNEL* pInBuf, NET_OUT_GET_REAL_PREVIEW_CHANNEL* pOutBuf, int nWaitTime);

// ��ȡĬ����ʵͨ������Σ���Ӧ�ӿ� CLIENT_GetDefaultRealChannel
typedef struct tagNET_IN_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelCount;                  // ��Ҫ��ȡ��ͨ����
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];             // �߼�ͨ����Ϣ���±�Ϊ��Ҫ��ȡ����ʵͨ����
}NET_IN_GET_DEFAULT_REAL_CHANNEL;

// ��ȡĬ����ʵͨ���ų��Σ���Ӧ�ӿ� CLIENT_GetDefaultRealChannel
typedef struct tagNET_OUT_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                       // ͨ������
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM]; // ͨ����
}NET_OUT_GET_DEFAULT_REAL_CHANNEL;

// ��ȡ¼������Ĭ����ʵͨ����,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefaultRealChannel(LLONG lLoginID, const NET_IN_GET_DEFAULT_REAL_CHANNEL* pInBuf, NET_OUT_GET_DEFAULT_REAL_CHANNEL* pOutBuf, int nWaitTime);

// ��ȡ¼������Ĭ����ʵͨ������Σ���Ӧ�ӿ� CLIENT_GetLogicChannel
typedef struct tagNET_IN_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                       // ͨ������
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM]; // ͨ����
}NET_IN_GET_COURSE_LOGIC_CHANNEL;

// ��ȡ¼������Ĭ����ʵͨ���ų��Σ���Ӧ�ӿ� CLIENT_GetLogicChannel
typedef struct tagNET_OUT_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize;
    int                         nChannelCount;                                          // ��ȡ�����߼�ͨ����
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // �߼�ͨ����Ϣ���±�Ϊ��Ҫ��ȡ����ʵͨ����
}NET_OUT_GET_COURSE_LOGIC_CHANNEL;

// ��ȡ¼�������߼�ͨ����,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLogicChannel(LLONG lLoginID, const NET_IN_GET_COURSE_LOGIC_CHANNEL* pInBuf,NET_OUT_GET_COURSE_LOGIC_CHANNEL* pOutBuf, int nWaitTime);

// �����߼�ͨ���ź���ʵͨ���ŵİ󶨹�ϵ��� ����Ӧ�ӿ�CLIENT_SetBlindRealChannel
typedef struct tagNET_IN_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                                            // ͨ������
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM];                      // ͨ����
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // �߼�ͨ����Ϣ���±�Ϊ��Ҫ���õ���ʵͨ����
}NET_IN_SET_BLIND_REAL_CHANNEL;

// �����߼�ͨ���ź���ʵͨ���ŵİ󶨹�ϵ���� ����Ӧ�ӿ�CLIENT_SetBlindRealChannel
typedef struct tagNET_OUT_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
}NET_OUT_SET_BLIND_REAL_CHANNEL;

// �����߼�ͨ���ź���ʵͨ���ŵİ󶨹�ϵ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBlindRealChannel(LLONG lLoginID, const NET_IN_SET_BLIND_REAL_CHANNEL* pInBuf,NET_OUT_SET_BLIND_REAL_CHANNEL* pOutBuf, int nWaitTime);

// ��ȡ¼������ͨ������ý�������� ����Ӧ�ӿ�CLIENT_GetInputChannelMedia
typedef struct tagNET_IN_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize; 
    int                             nChannelNum;                       // ͨ������
    int                             nChannel[MAX_PREVIEW_CHANNEL_NUM]; // ͨ����
}NET_IN_GET_INPUT_CHANNEL_MEDIA;

// ����ý�����
typedef enum tagNET_ENUM_INPUT_CHANNEL_MEDIA
{
    NET_ENUM_INPUT_MEDIA_UNKNOWN,                                       // δ֪
    NET_ENUM_INPUT_MEDIA_VGA,                                           // VGA
    NET_ENUM_INPUT_MEDIA_HDMI,                                          // HDMI
}NET_ENUM_INPUT_CHANNEL_MEDIA;

// ��ȡ¼������ͨ������ý����ʳ��� ����Ӧ�ӿ�CLIENT_GetInputChannelMedia
typedef struct tagNET_OUT_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize;
    int                             nChannelNum;                              // ͨ������
    NET_ENUM_INPUT_CHANNEL_MEDIA    emInputMedia[MAX_PREVIEW_CHANNEL_NUM];    // ����ý�����
}NET_OUT_GET_INPUT_CHANNEL_MEDIA;

// ��ȡ¼������ͨ������ý�����,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInputChannelMedia(LLONG lLoginID, const NET_IN_GET_INPUT_CHANNEL_MEDIA* pInBuf,NET_OUT_GET_INPUT_CHANNEL_MEDIA* pOutBuf, int nWaitTime);

//�����¼��ش�,pInParam�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachEventRestore(LLONG lLoginID, const NET_IN_ATTACH_EVENT_RESTORE *pInParam, int nWaitTime);

// ֹͣ�����¼��ش�,pInParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachEventRestore(LLONG lAttachHandle);

// CLIENT_GetLaserDistance �ӿ����
typedef struct tagNET_IN_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // �ṹ���С
    int                       nChannel;                         // ͨ����,��0��ʼ
}NET_IN_GET_LASER_DISTANCE;

// CLIENT_GetLaserDistance �ӿڳ���
typedef struct tagNET_OUT_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // �ṹ���С
    UINT                      unDistance;                       // Ŀ����� ��λ:��
}NET_OUT_GET_LASER_DISTANCE;


// ��ȡ��������λ��Ŀ��ľ���,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLaserDistance(LLONG lLoginID, const NET_IN_GET_LASER_DISTANCE* pInBuf, NET_OUT_GET_LASER_DISTANCE* pOutBuf, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );

// CLIENT_GetAtomsphData�ӿ����
typedef struct tagNET_IN_GET_ATOMSPHDATA
{
    DWORD                     dwSize;                           
}NET_IN_GET_ATOMSPHDATA;

// CLIENT_GetAtomsphData�ӿڳ���
typedef struct tagNET_OUT_GET_ATOMSPHDATA
{
    DWORD                     dwSize;
    float                     fWindSpeed;                       // ���٣���λm/s
    float                     fWindDirection;                   // ���򣬵�λ��
    float                     fHumidity;                        // ʪ�ȣ���λ%
    float                     fTemperture;                      // �¶ȣ���λ���϶�
    float                     fAirPressure;                     // ��ѹ����λ����
    float                     fSunBathe;                        // ���գ���λw/m2
}NET_OUT_GET_ATOMSPHDATA;

// ��ȡ������Ϣ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAtomsphData(LLONG lLoginID, const NET_IN_GET_ATOMSPHDATA* pInBuf, NET_OUT_GET_ATOMSPHDATA* pOutBuf,int nWaitTime);

// ����/�ر�ָ��ͨ��¼�����
typedef struct tagNET_IN_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // �ýṹ���С
    int                      nChannel;               // ͨ����
    int                      nAction;                // 0:����, 1:�ر�
}NET_IN_SET_COURSE_RECORD_STATE;

// ����/�ر�ָ��ͨ��¼�����
typedef struct tagNET_OUT_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // �ýṹ���С
}NET_OUT_SET_COURSE_RECORD_STATE;

// ����/�ر�ָ��ͨ��¼��,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordState(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_STATE *pInBuf, NET_OUT_SET_COURSE_RECORD_STATE *pOutBuf, int nWaitTime);

// ��ʼ��ѯ�γ���Ƶ��Ϣ���
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // �ýṹ���С
    NET_TIME                 stuStartTime;                      // ��ѯ��ʼʱ��
    NET_TIME                 stuEndTime;                        // ��ѯ����ʱ��
    char                     szKeyWord[DH_COMMON_STRING_128];    // ��ѯ�ؼ���
}NET_IN_QUERY_COURSEMEDIA_FILEOPEN;

// ��ʼ��ѯ�γ���Ƶ��Ϣ����
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // �ýṹ���С
    UINT                     ntotalNum;                         // ��ѯ�����ܸ���
    UINT                     nfindID;                           // ��ѯID��
}NET_OUT_QUERY_COURSEMEDIA_FILEOPEN;

// ��ʼ��ѯ�γ���Ƶ��Ϣ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILEOPEN *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILEOPEN *pOutBuf, int nWaitTime);

// ��ѯ�γ���Ƶ��Ϣ���
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILE
{
    DWORD                    dwSize;                            // �ýṹ���С
    UINT                     nfindID;                           // ��ѯID��
    int                      nOffset;                           // ��ʼ��ѯƫ��
    int                      nCount;                            // ��Ҫ��ѯ�ĸ���
}NET_IN_QUERY_COURSEMEDIA_FILE;

// ¼���ļ���Ϣ
typedef struct tagNET_RECORD_INFO
{
    int                      nRealChannel;                      // ��ʵͨ����
    NET_TIME                 stuStartTime;                      // ��ѯ��ʼʱ��
    NET_TIME                 stuEndTime;                        // ��ѯ����ʱ��
    UINT                     nFileLen;                          // ͨ��¼���ļ��ܳ��ȵ�32λ,0��ʾ��ͨ��û¼�� 
    UINT                     nFileLenEx;                        // ͨ��¼���ļ��ܳ��ȸ�32λ,��FileLenһ���ʾ¼�񳤶�
    UINT                     nTime;                             // ¼��ʱ��
    UINT                     nFileType;                         // �ļ����ͣ�0:�ü��ļ���1:ԭʼ�ļ�
    BYTE                     byReserved[64];                    // �����ֽ� 
}NET_RECORD_INFO;

// �γ���Ϣ
typedef struct tagNET_COURSE_INFO
{
    char                     szCourseName[DH_COMMON_STRING_64];                 // �γ�����
    char                     szTeacherName[DH_COMMON_STRING_64];                // ��ʦ����
    char                     szIntroduction[DH_COMMON_STRING_128];              // ��Ƶ���
    BYTE                     byReserved[64];                                    // �����ֽ�
}NET_COURSE_INFO;

// ��Ƶ��Ϣ
typedef struct tagNET_COURSEMEDIA_FILE_INFO
{
    int                      nID;                                               // ��Ƶ��ϢID,-1��ʾ�޴˼�¼
    NET_COURSE_INFO          stuCourseInfo;                                     // �γ���Ϣ
    int                      nChannelNum;                                       // ͨ������
    int                      nRecordNum[64];                                    // ��Ӧͨ����¼��ֶ���
    NET_RECORD_INFO          stuRecordInfo[64][16];                             // ¼����Ϣ����һά�±�Ϊӳ��ͨ���ţ��ڶ�άΪ¼��ֶ���
    BYTE                     byReserved[128];                                   // �����ֽ�
}NET_COURSEMEDIA_FILE_INFO;

// ��ѯ�γ���Ƶ��Ϣ����
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILE
{
    DWORD                       dwSize;                                         // �ýṹ���С
    int                         nCountResult;                                   // ��ѯ���ĸ���
    NET_COURSEMEDIA_FILE_INFO   stuCourseMediaFile[64];                         // ��Ƶ��Ϣ
}NET_OUT_QUERY_COURSEMEDIA_FILE;

// ��ѯ�γ���Ƶ��Ϣ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILE *pOutBuf, int nWaitTime);

// �رտγ���Ƶ��ѯ���
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // �ýṹ���С
    UINT                        nFindID;                                        // ��ѯID��
}NET_IN_QUERY_COURSEMEDIA_FILECLOSE;

// �رտγ���Ƶ��ѯ����
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // �ýṹ���С
}NET_OUT_QUERY_COURSEMEDIA_FILECLOSE;

// �رտγ���Ƶ��ѯ,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILECLOSE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILECLOSE *pOutBuf, int nWaitTime);

// �ļ�����״̬���ļ��ֶδ���ʱ���ֿ�ʼ�ͽ���
typedef enum tagNET_EM_AIO_FILE_STATUS
{
	NET_EM_AIO_FILE_STATUS_UNKNOWN,
	NET_EM_AIO_FILE_STATUS_BEGIN,				// Begin, ��ʶ�ϴ���ʼ����������
	NET_EM_AIO_FILE_STATUS_UPLOADING,			// Uploading
	NET_EM_AIO_FILE_STATUS_END,					// End, ��ʶ�ϴ���������������
}NET_EM_AIO_FILE_STATUS;

// �ļ�����
typedef enum tagNET_EM_AIO_FILE_TYPE
{
	NET_EM_AIO_FILE_TYPE_UNKNOWN,
	NET_EM_AIO_FILE_TYPE_UPSYSTEM,				// "upSystem":ϵͳ������
	NET_EM_AIO_FILE_TYPE_UPAPP,					// "upApp"��app������End
}NET_EM_AIO_FILE_TYPE;


// CLIENT_UploadAIOFile �ӿ��������(�ϴ��ļ����豸)
typedef struct tagNET_IN_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
    char*         		pszFileSrc;                     // Դ�ļ�·��
    char*         		pszFileDst;                     // Ŀ���ļ�·��
    char*         		pszFolderDst;                   // Ŀ���ļ���·������ΪNULL, NULLʱ�豸ʹ��Ĭ��·��
    unsigned int        nPacketLen;                     // �ļ��ְ���С(�ֽ�): 0��ʾ���ְ�
	NET_EM_AIO_FILE_TYPE	emType;						// �ļ�����
} NET_IN_UPLOAD_AIO_FILE;

// CLIENT_UploadAIOFile �ӿ��������(�ϴ��ļ����豸)
typedef struct tagNET_OUT_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
} NET_OUT_UPLOAD_AIO_FILE;


// fAttachAIOFileprocCB ����
typedef struct tagNET_CB_AIOFILEPROC
{
    DWORD						dwSize;
    NET_EM_AIO_FILE_STATUS      emStatus;				// �ļ�����״̬, �ļ��ֶδ���ʱ���ֿ�ʼ�ͽ���
    NET_EM_AIO_FILE_TYPE		emType;					// �ļ����� 

    unsigned int				dwLength;				// �ļ���С, ��λ: �ֽ�
	char*						pbFileBuf;				// �ļ�������
	DWORD						dwBufSize;				// �ļ���������С
}NET_CB_AIOFILEPROC;

// ע�������ļ�����ص�����ԭ��,lAttachHandle��CLIENT_attachAIOFileProc����ֵ, ÿ��1��,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachAIOFileprocCB) (LLONG lAttachHandle, NET_CB_AIOFILEPROC* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_attachAIOFileProc()�������
typedef struct tagNET_IN_ATTACH_AIO
{
    DWORD                   dwSize;
    fAttachAIOFileprocCB    cbNotify;						// �ص�����
    LDWORD                  dwUser;                         // �û�����
}NET_IN_ATTACH_AIO;

// CLIENT_attachAIOFileProc �������
typedef struct tagNET_OUT_ATTACH_AIO
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_AIO;

// ��沥��
typedef enum tagNET_EM_ADVERT_ACTION
{
	NET_EM_ADVERT_ACTION_UNKNOWN	= 0,
	NET_EM_ADVERT_ACTION_START,				// start
	NET_EM_ADVERT_ACTION_STOP,				// stop
}NET_EM_ADVERT_ACTION;

// ���λ��
typedef enum tagNET_EM_ADVERT_POSITION
{
	NET_EM_ADVERT_POSITION_UNKNOWN	= 0,
	NET_EM_ADVERT_POSITION_TOP,				// top    ����
	NET_EM_ADVERT_POSITION_MIDDLE,			// middle �м�
	NET_EM_ADVERT_POSITION_BOTTOM,			// bottom �ײ�
}NET_EM_ADVERT_POSITION;

// CLIENT_SetAdvert �ӿ��������(����NVR���)
typedef struct tagNET_IN_SET_ADVERT 
{
    DWORD						dwSize;
    NET_EM_ADVERT_ACTION        emAction;             // ��沥��
    int							nSpeed;               // �������ٶ�
    NET_EM_ADVERT_POSITION		emPosition;           // ���λ��
} NET_IN_SET_ADVERT;

// CLIENT_SetAdvert �ӿ��������(����NVR���)
typedef struct tagNET_OUT_SET_ADVERT
{
    DWORD               dwSize;
} NET_OUT_SET_ADVERT;

// CLIENT_AIOScreen �ӿ��������(NVR����)
typedef struct tagNET_IN_AIO_SCREEN
{
    DWORD						dwSize;
} NET_IN_AIO_SCREEN;

// CLIENT_AIOScreen �ӿ��������(NVR����)
typedef struct tagNET_OUT_AIO_SCREEN
{
    DWORD               dwSize;
	char				szName[DH_COMMON_STRING_256];	// ����ͼƬ·��
} NET_OUT_AIO_SCREEN;

// CLIENT_AIOandroidAdb �ӿ��������(���ư�׿adb�����ر�)
typedef struct tagNET_IN_CONTROL_ANDROID_ADB 
{
    DWORD						dwSize;
	BOOL						bEnable;				// �Ƿ���adb
} NET_IN_CONTROL_ANDROID_ADB;

// CLIENT_AIOandroidAdb �ӿ��������(���ư�׿adb�����ر�)
typedef struct tagNET_OUT_CONTROL_ANDROID_ADB
{
    DWORD               dwSize;
} NET_OUT_CONTROL_ANDROID_ADB;

// ����������Ϣ
typedef struct tagNET_CFG_ALARM_MSG_HANDLE
{
    DWORD                               dwSize;

	//����
    bool                				abChannelCount;                                 // �Ƿ�֧��ͨ������
	bool                				abAlarmOutCount;                                // �Ƿ�֧�ֱ����������

	bool								abRecordMask;                                   // �Ƿ�֧��¼��ͨ��
	bool								abRecordEnable;                                 // �Ƿ�֧��¼��ʹ��
	bool								abRecordLatch;                                  // �Ƿ�֧��¼����ʱ

	bool								abAlarmOutMask;                                 // �Ƿ�֧�ֱ������ͨ��

	bool								abAlarmOutEn;                                   // �Ƿ�֧�ֱ������ʹ��
	bool								abAlarmOutLatch;                                // �Ƿ�֧�ֱ��������ʱ
	bool								abExAlarmOutMask;                               // �Ƿ�֧����չ�������ͨ��
	bool								abExAlarmOutEn;                                 // �Ƿ�֧����չ�������ʹ��

	bool								abPtzLinkEn;                                    // �Ƿ�֧����̨����ʹ��
	bool								abTourMask;                                     // �Ƿ�֧����Ѳ����
	bool								abTourEnable;                                   // �Ƿ�֧����Ѳʹ��

	bool								abSnapshot;                                     // �Ƿ�֧�ֿ���
	bool								abSnapshotEn;                                   // �Ƿ�֧�ֿ���ʹ��
	bool								abSnapshotPeriod;                               // �Ƿ�֧��֡���ÿ�����֡ץһ��ͼƬ
	bool								abSnapshotTimes;                                // �Ƿ�֧�����Ĵ���
	bool								abTipEnable;                                    // �Ƿ�֧�ֱ�����Ϣ����ʾ

	bool								abMailEnable;                                   // �Ƿ�֧�ַ����ʼ�
	bool								abMessageEnable;                                // �Ƿ�֧���ϴ����������ķ�����
	bool								abBeepEnable;                                   // �Ƿ�֧�ַ���
	bool								abVoiceEnable;                                  // �Ƿ�֧��������ʾ

	bool								abMatrixMask;                                   // �Ƿ�֧��������Ƶ��������
	bool								abMatrixEnable;                                 // �Ƿ�֧��������Ƶ����ʹ��
	bool								abEventLatch;                                   // �Ƿ�֧��������ʼ��ʱʱ��
	bool								abLogEnable;                                    // �Ƿ�֧����־ʹ��

	bool								abDelay;                                        // �Ƿ�֧�ֱ�����ʱ
	bool								abVideoMessageEn;                               // �Ƿ�֧�ֵ�����ʾ��Ļ����Ƶ
	bool								abMMSEnable;                                    // �Ƿ�֧�ַ��Ͷ���Ϣ
	bool								abMessageToNetEn;                               // �Ƿ�֧����Ϣ�ϴ�������ʹ��
	bool								abTourSplit;                                    // �Ƿ�֧�ֻ���ָ���Ѳ

	bool								abSnapshotTitleEn;                              // �Ƿ�֧�ֵ���ͼƬ����ʹ��
	bool                				abPtzLinkEx;                                    // �Ƿ�֧����̨����ʹ��
	bool                				abSnapshotTitle;                                // �Ƿ�֧�ֵ���ͼƬ����
	bool                				abMailDetail;                                   // �Ƿ�֧���ʼ�����
	bool                				abVideoTitleEn;                                 // �Ƿ�֧�ֵ�����Ƶ���⣬��Ҫָ������
	bool                				abVideoTitle;                                   // �Ƿ�֧����Ƶ��������

	bool                				abTour;                                         // �Ƿ�֧����Ѳ
	bool                				abDBKeys;                                       // �Ƿ�֧��ָ���¼���ϸ��Ϣ����Ҫд�����ݿ�Ĺؼ���
	bool                				abJpegSummary;                                  // �Ƿ�֧�ֵ��ӵ�JPEGͼƬ��ժҪ��Ϣ
	bool                				abFlashEn;                                      // �Ƿ�֧�ֲ����ʹ��
	bool                				abFlashLatch;                                   // �Ƿ�֧�ֲ������ʱ

    bool								abAudioFileName;                                // �Ƿ�֧�����������ļ�����·��
    bool								abAlarmBellEn;                                  // �Ƿ�֧�־���ʹ��
    bool								abAccessControlEn;                              // �Ƿ�֧���Ž�����ʹ��
    bool								abAccessControl;                                // �Ƿ�֧���Ž�����

    bool								abTalkBack;	                                    // �Ƿ�֧��������
    bool								abPSTNAlarmServer;                              // �Ƿ�֧�ֵ绰��������
    bool								abAlarmBellLatch;                               // �Ƿ�֧�־��������ʱ

	bool                                abPlayTimes;                                    // �Ƿ�֧����������Ŵ���
	bool                                abReboot;                                        // �Ƿ�֧������ʹ��
	bool                                abBeepTime;                                     // �Ƿ�֧�ַ���ʱ��

    BYTE                                byReserved[68];                                 // ���������ֶ�

	//��Ϣ
	NET_CFG_TIME_SCHEDULE				stuTimeSection;									// �¼���Ӧʱ���

	int									nChannelCount;									// �豸����Ƶͨ����
	int									nAlarmOutCount;									// �豸�ı����������

	DWORD								dwRecordMask[CFG_MAX_CHANNEL_COUNT];			// ¼��ͨ������(��λ)
	BOOL								bRecordEnable;									// ¼��ʹ��
	int									nRecordLatch;									// ¼����ʱʱ��(��)
	DWORD								dwAlarmOutMask[CFG_MAX_CHANNEL_COUNT];			// �������ͨ������

	BOOL								bAlarmOutEn;									// �������ʹ��
	int									nAlarmOutLatch;									// ���������ʱʱ��(��)
	DWORD								dwExAlarmOutMask[CFG_MAX_CHANNEL_COUNT];		// ��չ�������ͨ������
	BOOL								bExAlarmOutEn;									// ��չ�������ʹ��

	NET_CFG_PTZ_LINK					stuPtzLink[CFG_MAX_VIDEO_CHANNEL_NUM];			// ��̨������		//���������û�б�������Ӧ���Ǳ���չ���
	BOOL								bPtzLinkEn;										// ��̨����ʹ��
	DWORD								dwTourMask[CFG_MAX_CHANNEL_COUNT];				// ��ѯͨ������
	BOOL								bTourEnable;									// ��ѯʹ��

	DWORD								dwSnapshot[CFG_MAX_CHANNEL_COUNT];				// ����ͨ��������
	BOOL								bSnapshotEn;									// ����ʹ��
	int									nSnapshotPeriod;								// ��������(��)
	int									nSnapshotTimes;									// ���Ĵ���
	BOOL								bTipEnable;										// ������Ϣ����ʾ

	BOOL								bMailEnable;									// �����ʼ��������ͼƬ����Ϊ����
	BOOL								bMessageEnable;									// �ϴ�������������
	BOOL								bBeepEnable;							 		// ����
	
	BOOL								bVoiceEnable;									// ������ʾ
	int                                 nPlayTimes;                                     // ��������Ŵ���bVoiceEnable=TRUEʱ��Ч

	DWORD								dwMatrixMask[CFG_MAX_CHANNEL_COUNT];			// ������Ƶ����ͨ������
	BOOL								bMatrixEnable;									// ������Ƶ����
	int									nEventLatch;									// ������ʼ��ʱʱ��(��)��0��15
	BOOL								bLogEnable;										// �Ƿ��¼��־

	int									nDelay;											// ����ʱ����ʱ����Ч����λΪ��
	BOOL								bVideoMessageEn;								// ������ʾ��Ļ����Ƶ�����ӵ���Ļ�����¼����ͣ�ͨ���ţ����ʱ��
	BOOL								bMMSEnable;										// ���Ͳ���ʹ��
	BOOL								bMessageToNetEn;								// ��Ϣ�ϴ�������ʹ��
	int									nTourSplit;										// ��Ѳʱ�ķָ�ģʽ 0: 1����; 1: 8����

	BOOL								bSnapshotTitleEn;								// �Ƿ����ͼƬ����
	int                 				nPtzLinkExNum;									// ��̨������
	NET_PTZ_LINK 						stuPtzLinkEx[CFG_MAX_VIDEO_CHANNEL_NUM];        // ��չ��̨��Ϣ
	int                 				nSnapTitleNum;									// ͼƬ����������
	NET_CFG_EVENT_TITLE 				stuSnapshotTitle[CFG_MAX_VIDEO_CHANNEL_NUM];	// ͼƬ��������
	NET_CFG_MAIL_DETAIL 				stuMailDetail;									// �ʼ���ϸ����
	BOOL                				bVideoTitleEn;									// �Ƿ������Ƶ���⣬��Ҫָ������
	int                 				nVideoTitleNum;									// ��Ƶ����������Ŀ
	NET_CFG_EVENT_TITLE 				stuVideoTitle[CFG_MAX_VIDEO_CHANNEL_NUM];		// ��Ƶ��������

	int                 				nTourNum;										// ��ѯ������Ŀ
	NET_CFG_TOURLINK    				stuTour[CFG_MAX_VIDEO_CHANNEL_NUM];				// ��ѯ��������
	int                 				nDBKeysNum;										// ָ�����ݿ�ؼ��ֵ���Ч��
	char                				szDBKeys[CFG_MAX_DBKEY_NUM][CFG_MAX_CHANNELNAME_LEN];	// ָ���¼���ϸ��Ϣ����Ҫд�����ݿ�Ĺؼ���
	BYTE                				byJpegSummary[CFG_MAX_SUMMARY_LEN];						// ���ӵ�JPEGͼƬ��ժҪ��Ϣ
	BOOL                				bFlashEnable;											// �Ƿ�ʹ�ܲ����
	int                 				nFlashLatch;											// �������ʱʱ��(��),��ʱʱ�䷶Χ��[10,300]

	char								szAudioFileName[MAX_PATH];						// ���������ļ�����·��
	BOOL								bAlarmBellEn;									// ����ʹ��
	BOOL								bAccessControlEn;								// �Ž�ʹ��
	DWORD								dwAccessControl;								// �Ž�����
	NET_EM_CFG_ACCESSCONTROLTYPE		emAccessControlType[CFG_MAX_ACCESSCONTROL_NUM];	// �Ž�����������Ϣ

	NET_CFG_TALKBACK_INFO				stuTalkback;									// ������������Ϣ
	NET_CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// �绰��������������Ϣ
	int									nAlarmBellLatch;								// ���������ʱʱ��(10-300��)

	BOOL                                bReboot;                                         //����ʹ��TRUE:ʹ�� FALSE:��ʹ��
	int                                 nBeepTime;                                      //����ʱ�����ֵΪ3600��0�����������
} NET_CFG_ALARM_MSG_HANDLE;

// ע�������ļ�����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_attachAIOFileProc(LLONG lLoginID, const NET_IN_ATTACH_AIO* pstInParam, NET_OUT_ATTACH_AIO *pstOutParam, int nWaitTime);

// ע���ļ�����,lAttachHandle��CLIENT_attachAIOFileProc����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_detachAIOFileproc(LLONG lAttachHandle);

// ����NVR���
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SetAIOAdvert(LLONG lLoginID, const NET_IN_SET_ADVERT* pstInParam, NET_OUT_SET_ADVERT *pstOutParam, int nWaitTime);

// NVR����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AIOScreen(LLONG lLoginID, const NET_IN_AIO_SCREEN* pstInParam, NET_OUT_AIO_SCREEN *pstOutParam, int nWaitTime);

//  ��ʼ�첽�ļ��ϴ�������ԭ��,lUploadFileHandle Ϊ CLIENT_StartUploadAIOFile �ӿڷ���ֵ, nError��ʧ�ܵĴ�����
typedef void (CALLBACK *fUploadAIOFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser, int nError);

// ��ʼ�첽�ļ��ϴ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadAIOFile(LLONG lLoginID, const NET_IN_UPLOAD_AIO_FILE* pInParam, NET_OUT_UPLOAD_AIO_FILE* pOutParam, fUploadAIOFileCallBack cbUploadFile, LDWORD dwUser);

// ֹͣ�첽�ļ��ϴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadAIOFile(LLONG lUploadFileID);

// ���ư�׿adb�����ر�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ControlAndroidAdb(LLONG lLoginID, const NET_IN_CONTROL_ANDROID_ADB* pstInParam, NET_OUT_CONTROL_ANDROID_ADB *pstOutParam, int nWaitTime);

// ��ȡ������Ϣ(szOutBuffer�ڴ����û������ͷ�, �����ö������˵��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szOutBuffer, DWORD dwOutBufferSize, int waittime=NET_INTERFACE_DEFAULT_TIMEOUT, void *reserve = NULL);

// ����������Ϣ(szInBuffer�ڴ����û������ͷ�, �����ö������˵��)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szInBuffer, DWORD dwInBufferSize, int waittime=NET_INTERFACE_DEFAULT_TIMEOUT, int *restart = NULL, void *reserve = NULL);
														 
// ������������Ӧ���뻺��������
typedef struct tagNET_IN_BUFFER_POLICY
{
    DWORD                   dwSize;             
    DH_RealPlayType         emRealPlayType;          // �������͡�ֻ֧����������������������Ӧ��������
    UINT                    nPolicy;                 // ������ԣ�0Ĭ�ϣ�1������2ʵʱ
}NET_IN_BUFFER_POLICY; 

// ���ñ��뻺�����,pInBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealplayBufferPolicy(LLONG lPlayHandle,NET_IN_BUFFER_POLICY* pInBuf,int nWaitTime);
  
//////////////////////////////////////////////////////////////////////////
// TestOSD ��������
typedef enum tagEM_TESTOSD_OPERATE_TYPE
{
    EM_TESTOSD_ADD_TEXT,          // ���������Ϣ ��Ӧ NET_IN_TESTOSD_ADD_TEXT �� NET_OUT_TESTOSD_ADD_TEXT
    EM_TESTOSD_GET_TEXT,          // ��ȡ������Ϣ ��Ӧ NET_IN_TESTOSD_GET_TEXT �� NET_OUT_TESTOSD_GET_TEXT
    EM_TESTOSD_MODIFY_TEXT,       // �޸�������Ϣ ��Ӧ NET_IN_TESTOSD_MODIFY_TEXT �� NET_OUT_TESTOSD_MODIFY_TEXT
    EM_TESTOSD_DELETE_TEXT,       // ɾ��������Ϣ ��Ӧ NET_IN_TESTOSD_DELETE_TEXT �� NET_OUT_TESTOSD_DELETE_TEXT
    EM_TESTOSD_ADD_PICTURE,       // ����ͼƬ��Ϣ ��Ӧ NET_IN_TESTOSD_ADD_PIC �� NET_OUT_TESTOSD_ADD_PIC
    EM_TESTOSD_GET_PICTURE,       // ��ȡͼƬ��Ϣ ��Ӧ NET_IN_TESTOSD_GET_PIC �� NET_OUT_TESTOSD_GET_PIC
    EM_TESTOSD_DELETE_PICTURE,    // ɾ��ͼƬ��Ϣ ��Ӧ NET_IN_TESTOSD_DELETE_PIC �� NET_OUT_TESTOSD_DELETE_PIC
}EM_TESTOSD_OPERATE_TYPE;

// �ı���Ϣ
typedef struct tagNET_TEXT_OSD
{   
    char                    szText[DH_COMMON_STRING_256];   // �ı�����
    DH_POINT                stuPoint;                       // �ı�λ��
	NET_COLOR_RGBA			stuTextColor;					// �ı���ɫ
	int						nFontSize;						// �ı������С 0-������С 1-С���� 2-�������
    BYTE                    byReserved[44];                 // �����ֽ�
}NET_TEXT_OSD;

// ͼƬ����
typedef enum tagEM_OSDPIC_TYPE
{
    EM_OSDPIC_UNKNOWN,                                      // δ֪��Ƭ
    EM_OSDPIC_HEADONFACE,                                   // ������
    EM_OSDPIC_SIDEFACE,                                     // ������
    EM_OSDPIC_MAP,                                          // ��ͼ
}EM_OSDPIC_TYPE;

// ͼƬ��Ϣ
typedef struct tagNET_PICTURE_OSD
{
    EM_OSDPIC_TYPE          emPictureType;                  // ͼƬ����
	NET_RECT				stuPictureLocation;				// ͼƬλ��
    BYTE                    byReserved[48];                 // �����ֽ�
}NET_PICTURE_OSD;

// ���������Ϣ��� 
typedef struct tagNET_IN_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize; 
    int                     nMaxCount;                      // ���������Ч����
    NET_TEXT_OSD            *pstuTextInfo;                  // ������Ϣ, �û�����, ����Ϊ nMaxCount   
}NET_IN_TESTOSD_ADD_TEXT;

// ���������Ϣ���� 
typedef struct tagNET_OUT_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    int                     *pnTextID;                      // ������Ϣ��Ӧ��ID��, �û�����, ����Ϊ nMaxCount
    int                     *pnReturnCode;                  // ����������, 0-�ɹ� 1-ʧ��, �û�����, ����Ϊ nMaxCount
}NET_OUT_TESTOSD_ADD_TEXT;

// ��ȡ������Ϣ���
typedef struct tagNET_IN_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // ���������Ч����
    int                     *pnTextID;                      // ������Ϣ��Ӧ��ID��, �û�����, ����Ϊ nMaxCount
}NET_IN_TESTOSD_GET_TEXT;

// ��ȡ������Ϣ����
typedef struct tagNET_OUT_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    NET_TEXT_OSD            *pstuTextInfo;                  // ������Ϣ, �û�����, ����Ϊ nMaxCount
}NET_OUT_TESTOSD_GET_TEXT;

// �޸�������Ϣ���
typedef struct tagNET_IN_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // ���������Ч����
    int                     *pnTextID;                      // ������Ϣ��Ӧ��ID��, �û�����, ����Ϊ nMaxCount
    NET_TEXT_OSD            *pstuTextInfo;                  // ������Ϣ, �û�����, ����Ϊ nMaxCount
}NET_IN_TESTOSD_MODIFY_TEXT;

// �޸�������Ϣ����
typedef struct tagNET_OUT_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    int                     *pnReturnCode;                  // ����������, 0-�ɹ� 1-ʧ�� �û�����, ����Ϊ��ε�nValidCount
}NET_OUT_TESTOSD_MODIFY_TEXT;

// ɾ��������Ϣ���
typedef struct tagNET_IN_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // ���������Ч����
    int                     *pnTextID;                      // ������Ϣ��Ӧ��ID��
}NET_IN_TESTOSD_DELETE_TEXT;

// ɾ��������Ϣ����
typedef struct tagNET_OUT_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    int                     *pnReturnCode;                  // ����������, 0-�ɹ� 1-ʧ��
}NET_OUT_TESTOSD_DELETE_TEXT;

// ���ͼƬ���
typedef struct tagNET_IN_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // ���������Ч����
    char                    (*pszFilePath)[MAX_PATH];       // ͼƬ�洢����·��
    NET_PICTURE_OSD         *pstuPicture;
}NET_IN_TESTOSD_ADD_PIC;

// ���ͼƬ����
typedef struct tagNET_OUT_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    int                     *pnReturnCode;                  // ����������, 0-�ɹ� 1-ʧ��
}NET_OUT_TESTOSD_ADD_PIC;

// ��ȡͼƬ���
typedef struct tagNET_IN_TESTOSD_GET_PIC
{
    DWORD                   dwSize;
    int                     nCount;                         // ��ȡͼƬ����
}NET_IN_TESTOSD_GET_PIC;

// ��ȡͼƬ����
typedef struct tagNET_OUT_TESTOSD_GET_PIC
{
    DWORD                   dwSize;    
    int                     nReturnCount;                   // ������Ч����
    char                    (*pszFilePath)[MAX_PATH];       // ͼƬ�洢����·��
    NET_PICTURE_OSD         *pstuPicture;
}NET_OUT_TESTOSD_GET_PIC;

// ɾ��ͼƬ���
typedef struct tagNET_IN_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // ���������Ч����
    char                    (*pszFilePath)[MAX_PATH];       // ͼƬ�洢����·��    
}NET_IN_TESTOSD_DELETE_PIC;

// ɾ��ͼƬ ����
typedef struct tagNET_OUT_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // ������Ч����
    int                     *pnReturnCode;                  // ����������, 0-�ɹ� 1-ʧ��
}NET_OUT_TESTOSD_DELETE_PIC;


//��ȡ�����¼���־���
typedef struct tagNET_IN_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	UINT 	                nEventID;				        // �¼�ID
}NET_IN_GET_ALARM_EVENT_LOG;

// ��ȡ�����¼���־����
typedef struct tagNET_OUT_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	DWORD			        dwAlarmType;			   // �����¼�����	
	BYTE 			       *byAlarmData;               // �����¼����ݣ����û�����,��������2*1024�ֽ�
	int 			        nMaxDataLen;		       // �����¼�����������󳤶�
	int						nRetDataLen;               // ʵ�ʷ��ص��¼�����
}NET_OUT_GET_ALARM_EVENT_LOG;

// ��ȡ�����¼���־
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLog(LLONG lLoginID, const NET_IN_GET_ALARM_EVENT_LOG *pstuInParam, NET_OUT_GET_ALARM_EVENT_LOG *pstuOutParam, int nWaitTime);

// TestOSD�����ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTestOSD(LLONG lLoginID, EM_TESTOSD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// �����ͽ������ͨ�����߼�ͨ�����
typedef struct tagNET_IN_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
    BOOL                    bLock;                         // TRUE������FALSE ����
    int                     nClassRoomID;                  // ����ID��        
    int                     nLogicChannel;                 // �߼�ͨ����
}NET_IN_COURSECOMPOSITE_LOCK_CONTROL;

// �����ͽ������ͨ�����߼�ͨ������
typedef struct tagNET_OUT_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
}NET_OUT_COURSECOMPOSITE_LOCK_CONTROL;

// ��ȡ����״̬���
typedef struct tagNET_IN_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;
    int                     nClassRoomID;                  // ����ID��
    int                     nLogicChannel;                 // �߼�ͨ����
}NET_IN_COURSECOMPOSITE_GET_LOCKINFO;

// ��ȡ����״̬����
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;             
    BOOL                    bState;                        // ����״̬
}NET_OUT_COURSECOMPOSITE_GET_LOCKINFO;

// ��ȡ���ͨ����Ϣ���
typedef struct tagNET_IN_COURSECOMPOSITE_GET_INFO
{
    DWORD                   dwSize;                        
    int                     nClassRoomId;                  // ����ID��
}NET_IN_COURSECOMPOSITE_GET_INFO;

// ¼��ģʽ
typedef enum tagEM_COMPOSITECHANNEL_MODE
{
    EM_COMPOSITECHANNEL_CUSTOMER = -1,                      // �Զ���
    EM_COMPOSITECHANNEL_INVALID,                            // ��Ч
    EM_COMPOSITECHANNEL_MOVIE,                              // ��Ӱģʽ
    EM_COMPOSITECHANNEL_NORMALCY,                           // ��̬ģʽ
    EM_COMPOSITECHANNEL_PICK,                               // ��Ʒģʽ
}EM_COMPOSITECHANNEL_MODE;

// ���ͨ����Ϣ
typedef struct tagNET_COMPOSITECHANNEL_INFO
{
    char                        szCourseName[DH_COMMON_STRING_128];     // �γ�����
    char                        szTeacherName[DH_COMMON_STRING_64];     // ��ʦ����
    int						    nCompositeChannelMode;                 // ¼��ģʽ; 0:��Ч��1:��Ӱģʽ�� 2:��̬ģʽ�� 3:��Ʒģʽ�� <0:�û��Զ���ģʽ
    int                         nChannelNum;                            // �߼�ͨ������
    BOOL                        bCanStream[MAX_COURSE_LOGIC_CHANNEL];   // �Ƿ����������±��ӦΪ�߼�ͨ����
    BYTE                        byReserved[256];                                                  
}NET_COMPOSITECHANNEL_INFO;

// ��ȡ���ͨ����Ϣ����
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_INFO
{
    DWORD                       dwSize;     
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // ���ͨ����Ϣ
}NET_OUT_COURSECOMPOSITE_GET_INFO;

// �������ͨ����Ϣ���
typedef struct tagNET_IN_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
    int                         nClassRoomId;                            // ����ID��
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // ���ͨ����Ϣ
}NET_IN_COURSECOMPOSITE_SET_INFO;

// �������ͨ����Ϣ����
typedef struct tagNET_OUT_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
}NET_OUT_COURSECOMPOSITE_SET_INFO;

// ���ͨ����Ϣ���µ�time���
typedef struct tagNET_IN_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize;      
    int                         nClassRoomId;                        // ����ID��
    NET_TIME                    stuTime;                             // ��ѯʱ��                     
}NET_IN_COURSECOMPOSITE_UPDATE_INFO;

// ���ͨ����Ϣ���µ�time����
typedef struct tagNET_OUT_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize;                          
}NET_OUT_COURSECOMPOSITE_UPDATE_INFO;

// ¼���������ͨ������
typedef enum tagEM_COURSECOMPOSITE_OPERATE_TYPE
{
    EM_COURSECOMPOSITE_TYPE_LOCK_CONTROL,                   //�������ͨ�����߼�ͨ������Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_LOCK_CONTROL,pOutParam = NET_OUT_COURSECOMPOSITE_LOCK_CONTROL
    EM_COURSECOMPOSITE_TYPE_GET_LOCKINFO,                   //��ȡ���ͨ�����߼�ͨ����������Ϣ����Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_GET_LOCKINFO��pOutParam = NET_OUT_COURSECOMPOSITE_GET_LOCKINFO 
    EM_COURSECOMPOSITE_TYPE_GET_INFO,                       //��ȡ���ͨ����Ϣ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_GET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_GET_INFO 
    EM_COURSECOMPOSITE_TYPE_SET_INFO,                       //�������ͨ����Ϣ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_SET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_SET_INFO 
    EM_COURSECOMPOSITE_TYPE_UPDATE_INFO,                    //�����ͨ����Ϣ���µ�timeʱ����Ϣ����Ӧ�ṹ�� pInParam = NET_IN_COURSECOMPOSITE_UPDATE_INFO, pOutParam = NET_OUT_COURSECOMPOSITE_UPDATE_INFO
}EM_COURSECOMPOSITE_OPERATE_TYPE;

CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannel(LLONG lLoginID, EM_COURSECOMPOSITE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// ¼����������������
#define NET_MAX_WINDOWS_NUMBER	64
// ¼������ģʽ������
#define NET_MAX_MODE_NUMBER		64

// ¼������������Ϣ
typedef struct tagNET_COMPOSITECHANNELMODE_WINDOWS
{
	DH_RECT					stRect;					// ��������, ����8192������ϵ
	int						nLogicChannel;			// �߼�ͨ����, Ϊ-1��ʾ�˴���û�а�ͨ��
	int						nZOrder;				// Z��
	BYTE                    byReserved[64];         // �����ֽ�
}NET_COMPOSITECHANNELMODE_WINDOWS;

// ¼������ģʽ��Ϣ
typedef struct tagNET_COMPOSITECHANNELMODE_INFO
{
	char									szName[DH_COMMON_STRING_128];			// ģʽ����
	int										nWindowNum;								// ʵ�ʴ��ڸ���
	NET_COMPOSITECHANNELMODE_WINDOWS		stWindows[NET_MAX_WINDOWS_NUMBER];		// ������Ϣ
	BYTE									byReserved[64];							// �����ֽ�
}NET_COMPOSITECHANNELMODE_INFO;

// ¼���������ģʽ���
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD							dwSize;								// �ṹ���С
    int								nCount;								// Ҫ��ӵ�ģʽ��Ŀ
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// ģʽ��Ϣ
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// ¼���������ģʽ������Ϣ
typedef struct tagNET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT
{
	int						nMode;					// ģʽ, 0 ��Ч, 1 ��Ӱģʽ, 2 ��̬ģʽ, 3 ��Ʒģʽ, С��0 �Զ���ģʽ
	int						nReturnCode;			// ������, 1 �ɹ�, 2 ʧ��, 3 ����, 4 ��Դ����
	BYTE                    byReserved[64];         // �����ֽ�
}NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT;

// ¼���������ģʽ����
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD											dwSize;								// �ṹ���С
	int												nCount;								// ʵ�ʷ��ظ���
	NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT		stResult[NET_MAX_MODE_NUMBER];		// ��������
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// ¼������ɾ��ģʽ���
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;							// �ṹ���С
	int						nModeNum;						// ɾ����ģʽ����
	int						nMode[NET_MAX_MODE_NUMBER];		// ɾ����ģʽ���
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// ¼������ɾ��ģʽ����
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;									// �ṹ���С
	int						nReturnNum;								// ɾ����ģʽ����
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// ������: 1 �ɹ�, 2 ʧ��
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// ¼�������޸�ģʽ���
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY 
{
	DWORD							dwSize;								// �ṹ���С
	int								nModeNum;							// �޸ĵ�ģʽ����
	int								nMode[NET_MAX_MODE_NUMBER];			// ģʽ���
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// ģʽ��Ϣ
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// ¼�������޸�ģʽ����
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
{
	DWORD					dwSize;									// �ṹ���С
	int						nReturnNum;								// �޸ĵ�ģʽ����, ���޸ĵ�ģʽ������ͬ
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// ������: 1 �ɹ�, 2 ʧ��, 3, ����, 4 ��Դ����
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// ¼��������ȡģʽ���
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET 
{
	DWORD					dwSize;					// �ṹ���С
	int						nCount;					// Ҫ��ȡ��ģʽ����
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET;

// ¼��������ȡģʽ����
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
{
	DWORD							dwSize;								// �ṹ���С
	int								nReturnNum;							// ʵ�ʻ�ȡ��ģʽ����
	int								nMode[NET_MAX_MODE_NUMBER];			// ģʽ���
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// ģʽ��Ϣ
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET;

// ¼���������ͨ��ģʽ����
typedef enum tagNET_COURSECOMPOSITE_MODE_OPERATE_TYPE
{
    NET_COURSECOMPOSITE_MODE_ADD,                   // ���ģʽ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD,	 pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
	NET_COURSECOMPOSITE_MODE_DELETE,                // ɾ��ģʽ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
	NET_COURSECOMPOSITE_MODE_MODIFY,                // �޸�ģʽ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
	NET_COURSECOMPOSITE_MODE_GET,                   // ��ȡģʽ,��Ӧ�ṹ��pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET,	 pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
}NET_COURSECOMPOSITE_MODE_OPERATE_TYPE;

// ¼���������ͨ��ģʽ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannelMode(LLONG lLoginID, NET_COURSECOMPOSITE_MODE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

///////////////////////////////////////////////////////////////////////
#define NET_UPGRADE_COUNT_MAX    256  //�����������

//�豸������
typedef enum tagENUM_VENDOR_TYPE
{
    ENUM_VENDOR_TYPE_UNKNOWN,              //δ֪
	ENUM_VENDOR_TYPE_GENERAL,              //General 
	ENUM_VENDOR_TYPE_DH,                   //DH 
	ENUM_VENDOR_TYPE_OEM,                  //OEM
}ENUM_VENDOR_TYPE;

//��Ƶ��ʽ
typedef enum tagENUM_STANDARD_TYPE
{
    ENUM_STANDARD_TYPE_UNKNOWN,              //δ֪
	ENUM_STANDARD_TYPE_PAL,                  //P-PAL
	ENUM_STANDARD_TYPE_NTSC,                 //N-NTSC
	ENUM_STANDARD_TYPE_PAL_NTSC,             //PN-PAL/NTSCĬ��P��
	ENUM_STANDARD_TYPE_NTSC_PAL,             //NP-NTSC/PALĬ��N��
	ENUM_STANDARD_TYPE_SECAM,                //S-SECAM
}ENUM_STANDARD_TYPE;

//��ȡ��������Ϣ���
typedef struct tagNET_IN_UPGRADER_GETSERIAL
{   
    DWORD               dwSize;					// �˽ṹ���С
} NET_IN_UPGRADER_GETSERIAL;


//��������Ϣ
typedef struct tagNET_UPGRADER_SERIAL_INO
{
    ENUM_VENDOR_TYPE    emVendor;               //����    
    ENUM_STANDARD_TYPE  emStandard;             //��Ƶ��ʽ
    NET_TIME_EX  stuBuild;                      //��������
    char    szChip[DH_COMMON_STRING_16];        //�������ĳ�����
    char    szSerial[DH_COMMON_STRING_256];     // �ڲ��ͺ�
    char    szLanguage[DH_COMMON_STRING_128];   //����
    char    szSn[DH_COMMON_STRING_64];          // ���к�
    char    szSWVersion[DH_COMMON_STRING_64];   // ����汾    
    char    szTag[DH_COMMON_STRING_256];        //�Զ�����
    char    szTag2[DH_COMMON_STRING_256];       //�Զ�����2
    char    reserved[1024];                         
}NET_UPGRADER_SERIAL_INO;

#define MAX_UPGRADER_SERIAL_INFO  8

//��ȡ��������Ϣ����
typedef struct tagNET_OUT_UPGRADER_GETSERIAL
{   
    DWORD                     dwSize;					               // �˽ṹ���С
    NET_UPGRADER_SERIAL_INO   stuSerialInfo[MAX_UPGRADER_SERIAL_INFO]; // ��������Ϣ
    int                       nRetNum;                                 // ���ظ���
} NET_OUT_UPGRADER_GETSERIAL;

//���豸��ȡ��Ϣ�����������ȷ���Ƿ���������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetUpdateSerial(LLONG lLoginID, NET_IN_UPGRADER_GETSERIAL *pstuInGetSerial, NET_OUT_UPGRADER_GETSERIAL *pstuOutGetSerial, int nWaitTime);

// ���������������
typedef struct tagNET_IN_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    ENUM_VENDOR_TYPE       emVendor;                          //����
    ENUM_STANDARD_TYPE     emStandard;                        //��Ƶ��ʽ
    NET_TIME_EX            stuBuild;                          //����ʱ�䣬���ڱȽϰ汾
    char                   szUrl[DH_COMMON_STRING_1024];      // ��URL
    char                   szClass[DH_COMMON_STRING_64];      // �豸����
    char                   szSerial[DH_COMMON_STRING_256];    // �豸Ӳ���ź�ϵ��
    char                   szLanguage[DH_COMMON_STRING_128];  // ����
    char                   szSN[DH_COMMON_STRING_64];         // �豸���к�
    char                   szSWVersion[DH_COMMON_STRING_64];  // �汾�ţ�������ʾ
    char                   szTag1[DH_COMMON_STRING_256];      // Ԥ���ֶΣ������ں������ƻ���չ
    char                   szTag2[DH_COMMON_STRING_256];        // Ԥ���ֶΣ������ں������ƻ���չ
    char                   szAccessKeyId[DH_COMMON_STRING_128];//Access Key ID
    char                   szSecretAccessKey[DH_COMMON_STRING_128];//Secret Access Key
}NET_IN_CLOUD_UPGRADER_CHECK;

// ���������������
typedef struct tagNET_OUT_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    BOOL                   bHasNewVersion;                  // �Ƿ��п������汾
    char                   szVersion[DH_COMMON_STRING_64];  //�汾��Ϣ
    char                   szAttention[DH_COMMON_STRING_1024]; // �����豸��������ʾ��Ϣ
    char                   szPackageUrl[DH_COMMON_STRING_1024]; // �豸��������URL
	char 			       szPackageId[DH_COMMON_STRING_64];    //������ID
}NET_OUT_CLOUD_UPGRADER_CHECK;

// ����ƶ��Ƿ��п��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderCheck(NET_IN_CLOUD_UPGRADER_CHECK *pIn, NET_OUT_CLOUD_UPGRADER_CHECK *pOut, DWORD dwWaitTime);

//������״̬
typedef enum tagemCloudDownloadState
{
    emCloudDownloadState_Unknown,            //δ֪
    emCloudDownloadState_Success,            //�����سɹ�(��Ҫ�رվ��)
    emCloudDownloadState_Failed,             //������ʧ��(����Ҫ�رվ�����᲻�ϳ�������)
    emCloudDownloadState_Downloading,        //����������
    emCloudDownloadState_NoEnoughDiskSpace,  //���̿ռ䲻��
}emCloudDownloadState;

//�����ػص�����ָ��
typedef void (CALLBACK *fCloudDownload_Process_callback)(LLONG lDownHandle, emCloudDownloadState emState, double dwDownloadSpeed, DWORD dwProgressPercentage, LDWORD dwUser);

// �������������������
typedef struct tagNET_IN_CLOUD_UPGRADER_DOWN
{
    DWORD                               dwSize;
    char                                szPackageUrl[DH_COMMON_STRING_1024]; // �豸��������URL
    char                                szSaveFile[DH_COMMON_STRING_1024];    //�����ļ���
    fCloudDownload_Process_callback     pfProcessCallback;                   //���Ȼص�
    LDWORD                              dwUser;                              //�ص��û�����
}NET_IN_CLOUD_UPGRADER_DOWN;

// ��������������������
typedef struct tagNET_OUT_CLOUD_UPGRADER_DOWN
{
    DWORD                  dwSize;
}NET_OUT_CLOUD_UPGRADER_DOWN;

//�� �����������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CloudUpgraderDownLoad(NET_IN_CLOUD_UPGRADER_DOWN *pIn, NET_OUT_CLOUD_UPGRADER_DOWN *pOut);

//ֹͣ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderStop(LLONG lDownloadHandle);

//��ͣ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderPause(LLONG lDownloadHandle, BOOL bPause);

//�������
typedef enum tagNET_UPGRADE_REPORT_RESULT
{
    NET_UPGRADE_REPORT_RESULT_UNKNWON,         //δ֪
    NET_UPGRADE_REPORT_RESULT_SUCCESS,         //�ɹ�
    NET_UPGRADE_REPORT_RESULT_FAILED,          //ʧ��
}NET_UPGRADE_REPORT_RESULT;

//�ϱ���������ṹ��
typedef struct tagNET_UPGRADE_REPORT
{
    int     nDeviceNum;                                                 //�豸����
    char    szDevSerial[NET_UPGRADE_COUNT_MAX][MAX_COMMON_STRING_64];   // ���к�
    char    szPacketID[MAX_COMMON_STRING_128];                          //������ID
    NET_UPGRADE_REPORT_RESULT emResult;                                 //�������
    char    szCode[MAX_COMMON_STRING_128];                              // ��������Ϣ      
    char    reserved[256];
}NET_UPGRADE_REPORT;

//�ϱ�����������
typedef struct tagNET_IN_UPGRADE_REPORT
{
    DWORD                   dwSize;
    int                     nCount;                                  // ����������
    NET_UPGRADE_REPORT      *pstuUpgradeReport;                      //���������Ϣ  
    char                    szAccessKeyId[DH_COMMON_STRING_128];     //����ID
    char                    szSecretAccessKey[DH_COMMON_STRING_128]; //������Կ
    char                    szUrl[DH_COMMON_STRING_1024];            // ��URL
}NET_IN_UPGRADE_REPORT;

//�ϱ������������
typedef struct tagNET_OUT_UPGRADE_REPORT
{
    DWORD                  dwSize;
}NET_OUT_UPGRADE_REPORT;

//�ϱ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderReport(NET_IN_UPGRADE_REPORT *pIn, NET_OUT_UPGRADE_REPORT *pOut, DWORD dwWaitTime);

////////////////////////////////////////////////////////////

// CLIENT_GetRecordState ���
typedef struct tagNET_IN_GET_RECORD_STATE
{
	DWORD				dwSize;				// �ṹ���С
	int					nChannel;			// ͨ����
} NET_IN_GET_RECORD_STATE;

// CLIENT_GetRecordState ����
typedef struct tagNET_OUT_GET_RECORD_STATE
{
	DWORD				dwSize;				// �ṹ���С
	BOOL				bState;				// �Ƿ���¼��
} NET_OUT_GET_RECORD_STATE;

// ��ȡ¼��״̬
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRecordState(LLONG lLoginID, const NET_IN_GET_RECORD_STATE *pInParam, NET_OUT_GET_RECORD_STATE *pOutParam, int nWaitTime);

//  ��ȡָ�����ҵ�¼����Ϣ���
typedef struct tagNET_IN_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // ����ID,0ΪĬ�Ͻ���
}NET_IN_COURSERECORD_GETINFO;

//  ��ȡָ�����ҵ�¼����Ϣ����
typedef struct tagNET_OUT_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nChannelNum;                            // �߼�ͨ������
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:��Ч,1:¼��,2��¼��,�±��ӦΪ�߼�ͨ����
}NET_OUT_COURSERECORD_GETINFO;

//  ����ָ�����ҵ�¼����Ϣ���
typedef struct tagNET_IN_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                           // ����ID,0ΪĬ�Ͻ���
    int                         nChannelNum;                            // �߼�ͨ������
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:��Ч,1:¼��,2��¼��,�±��ӦΪ�߼�ͨ����
}NET_IN_COURSERECORD_SETINFO;

//  ����ָ�����ҵ�¼����Ϣ����
typedef struct tagNET_OUT_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_SETINFO;

// ¼����Ϣ���µ�time���
typedef struct tagNET_IN_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // ����ID,0ΪĬ�Ͻ���
    NET_TIME                    stuTime;                             // ��ѯʱ��
}NET_IN_COURSERECORD_UPDATE_INFO;

// ¼����Ϣ���µ�time����
typedef struct tagNET_OUT_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_UPDATE_INFO;

// ��ȡ��ǰ�γ���¼��ʱ�����
typedef struct tagNET_IN_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // ����ID��0ΪĬ�Ͻ���
}NET_IN_COURSERECORD_GET_TIME;

// ��ȡ��ǰ�γ���¼��ʱ�����
typedef struct tagNET_OUT_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    UINT                        nTime;                               // ��¼��ʱ�䣬��λ:��
}NET_OUT_COURSERECORD_GET_TIME;

// ¼������¼����Ϣ����
typedef enum tagEM_COURSERECORD_OPERATE_TYPE
{
    EM_COURSERECORDE_TYPE_GET_INFO,                       //��ȡ����¼����Ϣ,��Ӧ�ṹ��pInParam = NET_IN_COURSERECORD_GETINFO,pOutParam = NET_OUT_COURSERECORD_GETINFO 
    EM_COURSERECORDE_TYPE_SET_INFO,                       //���ý���¼����Ϣ,��Ӧ�ṹ��pInParam = NET_IN_COURSERECORD_SETINFO,pOutParam = NET_OUT_COURSERECORD_SETINFO 
    EM_COURSERECORDE_TYPE_UPDATE_INFO,                    //��¼����Ϣ���µ�timeʱ����Ϣ,��Ӧ�ṹ�� pInParam = NET_IN_COURSERECORD_UPDATE_INFO, pOutParam = NET_OUT_COURSERECORD_UPDATE_INFO
    EM_COURSERECORDE_TYPE_GET_TIME,                       //��ȡ��ǰ�γ̽�����¼��ʱ��,��Ӧ�ṹ�� pInParam = NET_IN_COURSERECORD_GET_TIME, pOutParam = NET_OUT_COURSERECORD_GET_TIME
}EM_COURSERECORD_OPERATE_TYPE;

// ¼������¼����Ϣ�����ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseRecordManager(LLONG lLoginID, EM_COURSERECORD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

typedef void(CALLBACK *fConfigChangeCallBack)(LLONG lAttachHandle, char* szCommand, char* szBuffer, LDWORD dwUser);
// �������ñ仯���
typedef struct tagNET_IN_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
    char*                           szCfgName;           // ��������,�μ�dhconfigsdk.h��CLIENT_GetNewDevConfig��CLIENT_SetNewDevConfig�ӿڵ���������
    fConfigChangeCallBack           cbNotify;            // �ص�����
    LDWORD                          dwUser;              // �û���Ϣ
}NET_IN_ATTACH_CONFIGCHANNGE;

// �������ñ仯����
typedef struct tagNET_OUT_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
}NET_OUT_ATTACH_CONFIGCHANNGE;

// �������ñ仯�ӿ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachConfigChange(LLONG lLoginID, NET_IN_ATTACH_CONFIGCHANNGE *pInBuf,NET_OUT_ATTACH_CONFIGCHANNGE *pOutBuf, int nWaitTime);

// ȡ���������ñ仯 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachConfigChange(LLONG lAttachHandle);

//CLIENT_GetRingFileList ���
typedef struct tagNET_IN_GET_RINGFILELIST
{
	DWORD 		dwSize;
}NET_IN_GET_RINGFILELIST;

//CLIENT_GetRingFileList ����
typedef struct tagNET_OUT_GET_RINGFILELIST
{
	DWORD       dwSize;
	UINT        nRingFileNum;                                         // ������Ƶ�ļ�����
	char        szRingFileList[MAX_RINGFILE_NUM][DH_COMMON_STRING_64];// ��Ƶ�ļ��б�
}NET_OUT_GET_RINGFILELIST;

//��ȡ������Ƶ�ļ��б�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRingFileList(LLONG lLoginID, NET_IN_GET_RINGFILELIST *pstuInParam, NET_OUT_GET_RINGFILELIST *pstuOutParam, int nWaitTime);

// CLIENT_GetConnetionStatus ���
typedef struct tagNET_IN_GETCONNECTION_STATUS
{
    DWORD       dwSize;                                               
} NET_IN_GETCONNECTION_STATUS;

// CLIENT_GetConnetionStatus ����
typedef struct tagNET_OUT_GETCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                        // ͨ������
    int         nStatus[MAX_ALARMEXT_MODULE_NUM];                   // �±��ʾ����ͨ����,ȡֵ����0:δ����1:����2:����
} NET_OUT_GETCONNECTION_STATUS;

// ����������ȡ��չģ������״̬�ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConnectionStatus(LLONG lLoginID,const NET_IN_GETCONNECTION_STATUS* pstuInParam, NET_OUT_GETCONNECTION_STATUS *pstuOutParam, int nWaitTime);

#define MAX_ALARM_BOX_VIDEO_NUM		16

// CLIENT_GetAlarmBoxVideoConnectionStatus ���
typedef struct tagNET_IN_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;                                               
} NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS;

// CLIENT_GetAlarmBoxVideoConnectionStatus ����
typedef struct tagNET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                        // ������ͨ������
    int         nStatus[MAX_ALARM_BOX_VIDEO_NUM];                   // �±��ʾ������ͨ����,ȡֵ���� 0:δ���뱨���� 1:���� 2:����
} NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS;

// ����������ȡ��ȡ������������״̬�ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmBoxVideoConnectionStatus(LLONG lLoginID,const NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS* pstuInParam, NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS *pstuOutParam, int nWaitTime);

//�û�Ȩ��
typedef enum tagNET_ATTENDANCE_AUTHORITY
{
    NET_ATTENDANCE_AUTHORITY_UNKNOWN = -1,
    NET_ATTENDANCE_AUTHORITY_CUSTOMER,           //��ͨ�û�
    NET_ATTENDANCE_AUTHORITY_ADMINISTRATORS,     //����Ա
}NET_ATTENDANCE_AUTHORITY;

#define MAX_ATTENDANCE_USERNAME_LEN 36
//�����û���Ϣ
typedef struct tagNET_ATTENDANCE_USERINFO
{
    char                     szUserID[MAX_COMMON_STRING_32];   //�û����ID     
    char                     szUserName[MAX_ATTENDANCE_USERNAME_LEN]; //��Ա����
    char                     szCardNo[MAX_COMMON_STRING_32];   // ����
    NET_ATTENDANCE_AUTHORITY emAuthority;                      // �û�Ȩ��
    char                     szPassword[MAX_COMMON_STRING_32]; // ����
    int                      nPhotoLength;                     // ��Ƭ���ݳ���    
	BYTE					 byReserved[256];				   // �����ֽ�    
}NET_ATTENDANCE_USERINFO;

//CLIENT_Attendance_InsertFingerByUserID ���
typedef struct tagNET_IN_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    char 						szUserID[DH_COMMON_STRING_32];			// �û�ID
    int 						nSinglePacketLen;						// ����ָ�����ݰ�����
    int 						nPacketCount;							// ָ�����ݰ��ĸ���
	char*						szFingerPrintInfo;						// ָ������(�����ܳ��ȼ�nSinglePacketLen*nPacketCount)
}NET_IN_FINGERPRINT_INSERT_BY_USERID;


//CLIENT_Attendance_InsertFingerByUserID ����
typedef struct tagNET_OUT_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    int							nFingerPrintID[DH_MAX_FINGER_PRINT];	//ָ��ID����
	int 						nReturnedCount;							//������ʵ�ʷ��صĸ���
	int							nFailedCode;							//������  0���ɹ�;   1����������;  2���������û���ָ������������.
}NET_OUT_FINGERPRINT_INSERT_BY_USERID;
		

//CLIENT_Attendance_RemoveFingerByUserID ���(removeByUserID)
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			// �û�ID
}NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID;

//CLIENT_Attendance_RemoveFingerByUserID ����
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID;


//CLIENT_Attendance_RemoveFingerRecord ���(remove) 
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
	int							nFingerPrintID;							//ָ�Ʊ��
}NET_CTRL_IN_FINGERPRINT_REMOVE;

//CLIENT_Attendance_RemoveFingerRecord ����
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE;


//CLIENT_Attendance_GetFingerRecord ���
typedef struct tagNET_CTRL_IN_FINGERPRINT_GET
{
	DWORD						dwSize;
	int							nFingerPrintID;							//ָ�Ʊ��
}NET_CTRL_IN_FINGERPRINT_GET;

//CLIENT_Attendance_GetFingerRecord ����
typedef struct tagNET_CTRL_OUT_FINGERPRINT_GET
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			// �����û����û�ID
	char 						szFingerPrintName[DH_COMMON_STRING_32]; // ָ������
	int							nFingerPrintID;							// ָ��ID
	int							nRetLength;								// ʵ�ʷ��صĶ�����ָ�����ݳ���
	int							nMaxFingerDataLength;					// ������ָ�����ݵ���󳤶�
	char*						szFingerPrintInfo;						// ָ������
}NET_CTRL_OUT_FINGERPRINT_GET;

//CLIENT_Attendance_FindUser ���
typedef struct tagNET_IN_ATTENDANCE_FINDUSER
{
	DWORD			dwSize;
	int				nOffset;										// ��ѯƫ��
	int				nPagedQueryCount;								// ��ѯ��������ҳ��ѯ����಻����100
}NET_IN_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_FindUser ����
typedef struct tagNET_OUT_ATTENDANCE_FINDUSER
{
	DWORD 							dwSize;
	int								nTotalUser;					// �ܵ��û���
	int								nMaxUserCount;				// �û���Ϣ��󻺴���
	NET_ATTENDANCE_USERINFO*       	stuUserInfo;            	// �û���Ϣ���ڴ����û����룬��СΪ(sizeof(NET_ATTENDANCE_USERINFO)*nMaxUserCount) 
	int								nRetUserCount;				// ʵ�ʷ��ص��û�����
	int                           	nMaxPhotoDataLength;        // ��Ƭ������󳤶�
	int								nRetPhoteLength;			// ʵ�ʷ��ص���Ƭ���ݳ���
	BYTE *                        	pbyPhotoData;           	// ��Ƭ����
}NET_OUT_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_GetFingerByUserID ���
typedef struct tagNET_IN_FINGERPRINT_GETBYUSER
{
	DWORD						 dwSize;
	char                         szUserID[MAX_COMMON_STRING_32];      // �û�ID
}NET_IN_FINGERPRINT_GETBYUSER;

//CLIENT_Attendance_GetFingerByUserID ����
typedef struct tagNET_OUT_FINGERPRINT_GETBYUSER
{
	DWORD						dwSize;
	int							nFingerPrintIDs[DH_MAX_FINGER_PRINT];	// ָ��ID����
	int							nRetFingerPrintCount;					// ʵ�ʷ��ص�ָ��ID��������nFingerPrintIDs������ʵ����Ч����
	int							nSinglePacketLength;					// ����ָ�����ݰ�����
	int							nMaxFingerDataLength;					// ����ָ�����ݵĻ������󳤶�
	int							nRetFingerDataLength;					// ʵ�ʷ��ص��ܵ�ָ�����ݰ��ĳ���
	BYTE*                       pbyFingerData;                       	// ָ������	
}NET_OUT_FINGERPRINT_GETBYUSER;


// CLIENT_Attendance_AddUser ���
typedef struct tagNET_IN_ATTENDANCE_ADDUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;           //�û���Ϣ
    BYTE                       *pbyPhotoData;         // ��Ƭ����
}NET_IN_ATTENDANCE_ADDUSER;

// CLIENT_Attendance_AddUser����
typedef struct tagNET_OUT_ATTENDANCE_ADDUSER
{
    DWORD         dwSize; 
}NET_OUT_ATTENDANCE_ADDUSER;

//�����������û�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_AddUser(LLONG lLoginID, NET_IN_ATTENDANCE_ADDUSER *pstuInAddUser, NET_OUT_ATTENDANCE_ADDUSER *pstuOutAddUser, int nWaitTime);

// CLIENT_Attendance_DelUser ���
typedef struct tagNET_IN_ATTENDANCE_DELUSER
{
    DWORD                      dwSize;  
    char                       szUserID[MAX_COMMON_STRING_32];      //�û�ID
}NET_IN_ATTENDANCE_DELUSER;

// CLIENT_Attendance_DelUser����
typedef struct tagNET_OUT_ATTENDANCE_DELUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_DELUSER;

//����ɾ���û�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_DelUser(LLONG lLoginID, NET_IN_ATTENDANCE_DELUSER *pstuInDelUser, NET_OUT_ATTENDANCE_DELUSER *pstuOutDelUser, int nWaitTime);

// CLIENT_Attendance_ModifyUser ���
typedef struct tagNET_IN_ATTENDANCE_ModifyUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;                         //�û���Ϣ
    BYTE                       *pbyPhotoData;                       // ��Ƭ����
}NET_IN_ATTENDANCE_ModifyUSER;

// CLIENT_Attendance_ModifyUser����
typedef struct tagNET_OUT_ATTENDANCE_ModifyUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_ModifyUSER;

//�����޸��û���Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_ModifyUser(LLONG lLoginID, NET_IN_ATTENDANCE_ModifyUSER *pstuInModifyUser, NET_OUT_ATTENDANCE_ModifyUSER *pstuOutModifyUser, int nWaitTime);

// CLIENT_Attendance_GetUser ���
typedef struct tagNET_IN_ATTENDANCE_GetUSER
{
    DWORD                        dwSize;  
    char                         szUserID[MAX_COMMON_STRING_32];      //�û�ID    
}NET_IN_ATTENDANCE_GetUSER;

// CLIENT_Attendance_GetUser����
typedef struct tagNET_OUT_ATTENDANCE_GetUSER
{
    DWORD                         dwSize;   
    NET_ATTENDANCE_USERINFO       stuUserInfo;            //�û���Ϣ    
    int                           nMaxLength;             // �������Ƭ���ݵĳ���
    BYTE *                        pbyPhotoData;           // ��Ƭ����
}NET_OUT_ATTENDANCE_GetUSER;

//�����޸��û���Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetUser(LLONG lLoginID, NET_IN_ATTENDANCE_GetUSER *pstuInGetUser, NET_OUT_ATTENDANCE_GetUSER *pstuOutGetUser, int nWaitTime);

//���ڻ�  ͨ���û�ID����ָ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_InsertFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_INSERT_BY_USERID* pstuInInsert, NET_OUT_FINGERPRINT_INSERT_BY_USERID* pstuOutInsert, int nWaitTime);

//���ڻ� ɾ�������û�������ָ������
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_RemoveFingerByUserID(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID* pstuOutRemove, int nWaitTime);

//���ڻ� ͨ��ָ��ID��ȡָ������
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_GetFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_GET* pstuInGet, NET_CTRL_OUT_FINGERPRINT_GET* pstuOutGet, int nWaitTime);

//���ڻ� ͨ��ָ��IDɾ��ָ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_RemoveFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE* pstuOutRemove, int nWaitTime);

//���ڻ� �����û�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_FindUser(LLONG lLoginID, NET_IN_ATTENDANCE_FINDUSER *pstuInFindUser, NET_OUT_ATTENDANCE_FINDUSER *pstuOutFindUser, int nWaitTime);

//���ڻ� ͨ���û�ID���Ҹ��û��µ�����ָ������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_GETBYUSER *pstuIn, NET_OUT_FINGERPRINT_GETBYUSER *pstuOut, int nWaitTime);


// �����豸�ӿ�������
typedef enum tagEM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE
{
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UNKNOWN = -1,					// δ֪
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_NONE = 0,						// ˽�б�׼�淶
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_ONVIF,                          // Onvif��׼�淶
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UPNP,                           // UPnP��׼�淶
}EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE;

// fAttachDeviceDiscoveryCB ����
typedef struct tagNET_DEVICE_DISCOVERY_INFO
{
	DWORD				dwSize;
	char				szMachineName[DH_COMMON_STRING_32];					// �豸����
	char				szDeviceClass[DH_COMMON_STRING_32];					// �豸����
	char				szDeviceType[DH_COMMON_STRING_32];					// �豸�ͺ�
	char				szSerialNo[DH_COMMON_STRING_32];					// �豸���к�
	char				szVersion[DH_COMMON_STRING_32];						// �豸����汾��
	char				szMac[DH_COMMON_STRING_32];							// �豸MAC��ַ
	int					nVideoInputChannels;								// �豸��Ƶ����ͨ����
	int					nRemoteVideoInputChannels;							// Զ����Ƶ����ͨ����
	int					nVideoOutputChannels;								// ��Ƶ���ͨ����
	int					nAlarmInputChannels;								// ��������ͨ����
	int					nAlarmOutputChannels;								// �������ͨ����
	int					nAudioInputChannels;								// �豸��Ƶ����ͨ����
	int					nPort;												// ��½�˿�
	char				szVendor[DH_COMMON_STRING_32];						// �ͻ�����
	int					nInit;												// �豸�Ƿ��ѳ�ʼ��:0���߱���ʼ�����ܵ��豸,���Ե�ͬ���ѳ�ʼ�� 1δ��ʼ�� 2�ѳ�ʼ��
	char				szIPv4Address[DH_COMMON_STRING_32];					// IPv4��ַ
	char				szIPv4SubnetMask[DH_COMMON_STRING_32];				// IPv4��������
	char				szIPv4DefaultGateway[DH_COMMON_STRING_32];			// IPv4Ĭ������
	BOOL				bIPv4DhcpEnable;									// IPv4�Ƿ�ʹ��DHCP
	char				szIPv6Address[DH_COMMON_STRING_32];					// IPv6��ַ
	char				szIPv6DefaultGateway[DH_COMMON_STRING_32];			// IPv6Ĭ������
	char				szIPv6LinkLocalAddress[DH_COMMON_STRING_32];		// IPv6������·��ַ,�õ�ַֻ��ֱ��,����ҪGateway
	BOOL				bIPv6DhcpEnable;									// IPv6�Ƿ�ʹ��Dhcp
	char				szProtocol[DH_COMMON_STRING_32];					// �豸������׼
}NET_DEVICE_DISCOVERY_INFO;


// ע���豸��������ص�����ԭ��,lAttachHandle��CLIENT_AttachDeviceDiscovery����ֵ, pDeviceInfoΪ�豸��Ϣ, nDeviceNumΪ�豸��Ϣ�������
typedef void (CALLBACK *fAttachDeviceDiscoveryCB) (LLONG lAttachHandle, NET_DEVICE_DISCOVERY_INFO* pDeviceInfo, int nDeviceNum, LDWORD dwUser);


// CLIENT_AttachDeviceDiscovery �ӿ��������
typedef struct tagNET_IN_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// �ӿ�������
	fAttachDeviceDiscoveryCB						cbNotify;				// �ص�����
	LDWORD											dwUser;					// �û�����
} NET_IN_ATTACH_DEVICE_DISCOVERY;

// CLIENT_AttachDeviceDiscovery �ӿ��������
typedef struct tagNET_OUT_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;
} NET_OUT_ATTACH_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery �ӿ��������
typedef struct tagNET_IN_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// �ӿ�������
    int												nTimeOut;				// ������ʱ,��������ϱ�ʱ��,������ʱ���,�����ϱ��豸��Ϣ. ��λ��
} NET_IN_START_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery �ӿ��������
typedef struct tagNET_OUT_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_START_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery �ӿ��������
typedef struct tagNET_IN_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// �ӿ�������
} NET_IN_STOP_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery �ӿ��������
typedef struct tagNET_OUT_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_STOP_DEVICE_DISCOVERY;

// ע���豸����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDeviceDiscovery(LLONG lLoginID, const NET_IN_ATTACH_DEVICE_DISCOVERY *pInParam, NET_OUT_ATTACH_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// ע���豸����, lAttachHandleΪCLIENT_AttachDeviceDiscovery ����ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDeviceDiscovery(LLONG lAttachHandle);

// ���豸����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartDeviceDiscovery(LLONG lLoginID, const NET_IN_START_DEVICE_DISCOVERY *pInParam, NET_OUT_START_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// ֹͣ�豸����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDeviceDiscovery(LLONG lLoginID, const NET_IN_STOP_DEVICE_DISCOVERY *pInParam, NET_OUT_STOP_DEVICE_DISCOVERY *pOutParam, int nWaitTime);


/////////////////////////////////��̭�ӿ�/////////////////////////////////

// ��ѯϵͳ���������ã��ýӿ�����̭,��ʹ��CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int maxlen, int *nConfigbuflen, int waittime=1000);

// ����ϵͳ���������ã��ýӿ�����̭,��ʹ��CLIENT_SetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int nConfigbuflen, int waittime=1000);

// �ýӿ�����̭,�벻Ҫʹ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Reset(LLONG lLoginID, BOOL bReset);

// ��ѯ����Э�� �� �ýӿ�����̭,��ʹ��CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryComProtocol(LLONG lLoginID, int nProtocolType, char *pProtocolBuffer, int maxlen, int *nProtocollen, int waittime=1000);

// ��ʼ�Խ����ýӿ�����̭,��ʹ��CLIENT_StartTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartTalk(LLONG lRealHandle, BOOL bCustomSend=false);

// �����Խ����ýӿ�����̭,��ʹ��CLIENT_StopTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalk(LLONG lRealHandle);

// �����Զ���Խ����ݣ��ýӿ�����̭,��ʹ��CLIENT_TalkSendData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTalkData_Custom(LLONG lRealHandle, char *pBuffer, DWORD dwBufSize);

// ����ʵʱԤ�������С
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayerBufNumber(LLONG lRealHandle, DWORD dwBufNum);

// ͨ��ʱ�������ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFileByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, char *sSavedFileName);

// ����طſ���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControl(LLONG lPlayHandle, DWORD dwControlCode, DWORD dwInValue, DWORD *lpOutValue);

// ��ѯ�豸����״̬ �ýӿ�����̭,��ʹ��CLIENT_QueryDevState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDEVWorkState(LLONG lLoginID, LPNET_DEV_WORKSTATE lpWorkState, int waittime=1000);

// �첽��ѯ�豸��־
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogCallback(LLONG lLoginID, fLogDataCallBack cbLogData, LDWORD dwUser);

// mpt300����¼����͹ر�,pstRecIn��pstRecOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecMngCtrlMpt300(LLONG lLoginID, const NET_IN_REC_MNG_CTRL_MPT300 *pstRecIn, NET_OUT_REC_MNG_CTRL_MPT300 *pstRecOut, int nWaitTime);

// ͬ��ֱ��͸���ӿ�,pstInTransmit��pstOutTransmit�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaittime = 1000);

// �첽ֱ��͸���ص�����ԭ��
typedef void (CALLBACK *fTransmitInfoDirectlyCallBack)(LLONG lLoginID, LLONG lStartHandle, const char *pszOutBuf, DWORD dwBufLen, LDWORD dwUser);

// �첽ֱ��͸���ӿ�,pstInTransmit��pstOutTransmit�ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, fTransmitInfoDirectlyCallBack cbDirectly, LDWORD dwUser, int nWaitTime = 1000);

// ȡ���첽ֱ��͸���ӿ�,pstInTransmit��pstOutTransmit�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTransmitInfoDirectly(LLONG lStartHandle, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaitTime = 1000);

// ���õ������������ӿ�,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDefenceArmMode(LLONG lLoginID, NET_IN_SET_DEFENCEMODE* pInBuf, NET_OUT_SET_DEFENCEMODE* pOutBuf = NULL, int nWaitTime = 1000);

// ��ȡ������������״̬�ӿ�,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefenceArmMode(LLONG lLoginID, NET_IN_GET_DEFENCEMODE* pInBuf, NET_OUT_GET_DEFENCEMODE* pOutBuf, int nWaitTime = 1000);

// ������ϵͳ�������ӿ�,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSubSystemArmMode(LLONG lLoginID, NET_IN_SET_SUBSYSTEMMODE* pInBuf, NET_OUT_SET_SUBSYSTEMMODE* pOutBuf = NULL, int nWaitTime = 1000);

// ��ȡ��ϵͳ������״̬�ӿ�,pInBuf��pOutBuf�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSubSystemArmMode(LLONG lLoginID, NET_IN_GET_SUBSYSTEMMODE* pInBuf, NET_OUT_GET_SUBSYSTEMMODE* pOutBuf, int nWaitTime = 1000);

// �ֻ�����������Ϣ, ʹ��RegisterID��ʶ������,pstuCfg�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// ɾ���ֻ�����������Ϣ, ʹ��RegisterID��ʶ������,pstuIn��pstuOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

// �ֻ�����������Ϣ, ʹ��RegisterID+AppID��ʶ������,AppID���ݲ��ܴ����,��ſ������»��ߴ���,pstuCfg�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// ɾ���ֻ�����������Ϣ, ʹ��RegisterID+AppID��ʶ������,AppID���ݲ��ܴ����,��ſ������»��ߴ���,pstuIn��pstuOut�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);




// �����·��Ž����ƿ�
// nInsertCount: �·���Ƭ������������ 20
// pInsertCards: ��Ҫ�·��Ŀ�Ƭ��Ϣ��ָ���û����䲢���� NET_RECORDSET_ACCESS_CTL_CARD �ṹ�建�棬����Ϊ nInsertCount
// nRecNo: �·���ļ�¼��ţ��� pInsertCards һһ��Ӧ��-1 ��ʾ�������ʧ�ܣ�ָ���û������ int ���棬����Ϊ nInsertCount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InsertAccessControlCards(LLONG lLoginID, int nInsertCount, const NET_RECORDSET_ACCESS_CTL_CARD* pInsertCards, int* pRecNo, void* reserved = NULL, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);
 
//����ͼƬ�Ƚ���Ϣ
typedef struct tagNET_IMAGE_COMPARE_INFO
{
	DWORD 			   	    dwoffset;			// �ڶ��������ݿ��е�ƫ��,��λ:�ֽ�
	DWORD					dwLength;			// ͼƬ��С,��λ:�ֽ�
	DWORD					dwWidth;			// ͼƬ���
	DWORD					dwHeight;			// ͼƬ�߶�
	BYTE                    byReserved[128];    // �����ֽ�
} NET_IMAGE_COMPARE_INFO;

//CLIENT_MatchTwoFace �������
typedef struct tagNET_MATCH_TWO_FACE_IN
{
	DWORD					dwSize;
	NET_IMAGE_COMPARE_INFO  stuOriginalImage;	// ԭͼ
	NET_IMAGE_COMPARE_INFO  stuCompareImage;	// �Ƚ�ͼ
	char 			   	   *pSendBuf;			// ��������ͼƬ����
	DWORD 					dwSendBufLen;		// ���ݴ�С
} NET_MATCH_TWO_FACE_IN;

//CLIENT_MatchTwoFace �������
typedef struct tagNET_MATCH_TWO_FACE_OUT
{
	DWORD					dwSize;
	int						nSimilarity;		// ����ͼƬ�����ƶ�,��Χ0~100
} NET_MATCH_TWO_FACE_OUT;

// ������������ͼƬ�����ƶ�faceRecognitionServer.matchTwoFace,pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MatchTwoFaceImage(LLONG lLoginID, const NET_MATCH_TWO_FACE_IN *pstInParam, NET_MATCH_TWO_FACE_OUT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// ����֡����
typedef enum tagEM_DECODE_FRAME_TYPE
{
    EM_FRAME_TYPE_UNKNOWN   = -1,               // δ֪��
    EM_FRAME_TYPE_VIDEO     = 0,				// ��Ƶ֡
    EM_FRAME_TYPE_AUDIO     = 1,				// ��Ƶ֡
}EM_DECODE_FRAME_TYPE;

// ����֡��չ��Ϣ
typedef struct tagNET_FRAME_INFO_EX
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//��Ƶ֡����,�����涨��
    int				        nFrameSeq;				//֡���
    int				        nStamp;					//ʱ����Ϣ,��λ����
    int				        nWidth;					//�����,��λ����.�������Ƶ������Ϊ0.
    int 			        nHeight;				//�����,�������Ƶ������Ϊ0
    int				        nFrameRate;				//����ʱ������ͼ��֡��
    int				        nChannels;				//��Ƶͨ����
    int				        nBitPerSample;			//��Ƶ����λ��
    int				        nSamplesPerSec;			//��Ƶ����Ƶ��
    int				        nRemainData;			//����ʣ��������
    NET_TIME_EX		        nDataTime;				//ʱ��
    
}NET_FRAME_INFO_EX;

// ����֡��Ϣ
typedef struct tagNET_FRAME_DECODE_INFO 
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//֡����,�����FRAME_INFO_EX��nFrameType�ֶ�

    void*			        pAudioData;				//��Ƶ����,�������Ƶ֡
    int				        nAudioDataLen;			//��Ƶ���ݳ���

    void*			        pVideoData[3];			//�ֱ��ʾ��Ƶ��YUV��������
    int				        nStride[3];				//�ֱ��ʾYUV���������Ŀ��
    int				        nWidth[3];				//�ֱ��ʾYUV���������Ŀ��
    int				        nHeight[3];				//�ֱ��ʾYUV���������ĸ߶�  
}NET_FRAME_DECODE_INFO;

// ����ص�����
typedef void (CALLBACK *fDecCallBack)(LLONG lLoginID, LLONG lPlayHandle, NET_FRAME_DECODE_INFO* pFrameDecodeInfo, NET_FRAME_INFO_EX* pFrameInfo, LDWORD dwUserData, LLONG nReserved);

// ���ý���ص�����
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBack(fDecCallBack cbDecCallBack, LDWORD dwUserData, LLONG nReserved = 0);

// ���ý���ص�����----��չ
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBackEx(fDecCallBack cbDecCallBack, LDWORD dwUserData, NET_VIDEOSTREAM_TYPE emVideoStreamType, LLONG nReserved);

// ��ȡĬ������(Ŀǰֻʵ����EncodePlane����emCfgOpType == NET_EM_CFG_ENCODE_PLAN)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevDefaultConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                          LPVOID lpOutBuffer, DWORD dwOutBufferSize, int nWaittime/*=NET_INTERFACE_DEFAULT_TIMEOUT*/);

#define NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN 32                        // �Զ��峵λ����󳤶�

// ��λָʾ����ɫ
typedef enum tagEM_PARKINGSPACE_LIGHT_COLOR
{
    EM_PARKINGSPACE_LIGHT_COLOR_UNKNOWN,                                    // δ֪  
    EM_PARKINGSPACE_LIGHT_COLOR_RED,                                        // ��ɫ
    EM_PARKINGSPACE_LIGHT_COLOR_YELLOW,                                     // ��ɫ    
    EM_PARKINGSPACE_LIGHT_COLOR_GREEN,                                      // ��ɫ   
}EM_PARKINGSPACE_LIGHT_COLOR;

// ��λָʾ��״̬
typedef enum tagEM_PARKINGSPACE_LIGHT_STATE
{
    EM_PARKINGSPACE_LIGHT_STATE_UNKNOWN = -1,                               // δ֪  
    EM_PARKINGSPACE_LIGHT_STATE_OFF,                                        // ��
    EM_PARKINGSPACE_LIGHT_STATE_ON,                                         // ��
    EM_PARKINGSPACE_LIGHT_STATE_GLINT,                                      // ��˸
    EM_PARKINGSPACE_LIGHT_STATE_LAST_STATE,                                 // ��һ��״̬
}EM_PARKINGSPACE_LIGHT_STATE;

// ͣ������λָʾ�����Ƽƻ���Ϣ
typedef struct tagNET_PARKING_SPACE_LIGHT_PLAN_INFO
{
    EM_PARKINGSPACE_LIGHT_COLOR emColor;                                    // ��ɫ
    EM_PARKINGSPACE_LIGHT_STATE emState;                                    // ״̬
    int nKeepTime;                                                          // ����ʱ��,��λ�룬-1��ʾ����
    BYTE byReserved[128];                                                   // �����ֽ�
}NET_PARKING_SPACE_LIGHT_PLAN_INFO;

// ���ó�λָʾ�����Ƽƻ����
typedef struct tagNET_IN_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // �ṹ���С                                                           
    int nPhysicalLane;                                                      // ����λ�ţ�������ʹ�ô��ֶ�.ֵΪ����ʱ��ʾ���ֶ���Ч
    char szCustomParkNo[NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN];           // �Զ��峵λ��ţ�����λ���ֶ���Чʱ��ʹ�ô��ֶ�
    int nLightPlanNum;                                                      // ���Ƽƻ���Ŀ
    NET_PARKING_SPACE_LIGHT_PLAN_INFO* pstuLightPlan;                       // ���Ƽƻ���Ϣ�����û�������ͷ��ڴ�
}NET_IN_SET_PARKING_SPACE_LIGHT_PLAN;

// ���ó�λָʾ�����Ƽƻ�����
typedef struct tagNET_OUT_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // �ṹ���С
}NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN;


// ���ó�λ������������Ƽƻ�,pNetDataIn��pNetDataOut���û������ڴ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingSpaceLightPlan(LLONG lLoginID,const NET_IN_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataIn,NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataOut,int nWaitTime);


/************************************************************************
 ** �ֲ�ʽ������Ա�ṹ����ѯЭ��
 ***********************************************************************/
//�ṹ���¼���ͼƬ��Ϣ
typedef struct tagDEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO
{
    char                     szCutPicPath[MAX_PATH];          // ���ֶα�ʾ��ͼ��HTTP·��
    DWORD                    dwWidth;                         // ͼƬ���
    DWORD                    dwHeight;                        // ͼƬ�߶�
    BYTE                     byReserved[256];                 // �����ֽ�
} DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO;

//��Ա�ṹ�������������߽������Ա��Ϣ
typedef struct tagDEV_PERSON_CONDITION_RESULT_FEATURE_INFO 
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE        emSex;                      // �Ա�
    BYTE                                    byAge;                      // ����
    BYTE                                    byCall;                     // �Ƿ��ڴ�绰 , 0-δʶ�� 1-����绰 2-��绰
    BYTE                                    byHat;                      // �Ƿ��ñ��   , 0-δʶ�� 1-����ñ�� 2-��ñ��
    BYTE                                    byBag;                      // �Ƿ񱳰�     , 0-δʶ�� 1-������   2-����
    BYTE                                    byUmbrella;                 // �Ƿ��ɡ     , 0-δʶ�� 1-����ɡ   2-��ɡ
    BYTE                                    byGlasses;                  // �Ƿ���۾�   , 0-δʶ�� 1-�����۾� 2-���۾�
    BYTE                                    byReserved1[2];             // �ֽڶ���
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;                  // ����:΢Ц,��ŭ, ����, ���, ����, ����, ����, ��Ц
    NET_COLOR_RGBA                          stuUpperBodyColor;          // �ϰ�����ɫ
    NET_COLOR_RGBA                          stuLowerBodyColor;          // �°�����ɫ
    BYTE                                    byReserved[256];            // �����ֽ�
} DEV_PERSON_CONDITION_FEATURE_INFO,DEV_PERSON_RESULT_FEATURE_INFO;

// ������������¼� EVENT_IVS_OBJECTSTRUCTLIZE_PERSON
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO
{
    int                                    nChannelID;                           // ͨ����
    char                                   szName[DH_EVENT_NAME_LEN];            // �¼�����
    BYTE                                   bReserved1[4];                        // �ֽڶ���
    double                                 dbPTS;                                // ʱ���(��λ�Ǻ���)
    NET_TIME_EX                            stuUTC;                               // �¼�������ʱ��
    int                                    nEventID;                             // �¼�ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                          // �¼���Ӧ�ļ���Ϣ
    int                                    nEventAction;                         // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;

	char                                   szFilePath[MAX_PATH];                 // ��ͼ�ļ�·��
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                     // ��������
    NET_RECT                               stuBoundingBoxRect;                   // �����ڴ�ͼ�еİ�Χ������,Rect��ʽ8192����ϵ
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                         // ��ͼ�����˿�ͼͼƬ��Ϣ

    int                                    nImageIndex;                          // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD                                  dwSnapFlagMask;                       // ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE                                   bReserved[1024];                      // �����ֽ�,�����չ. 
} DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO;

//�ǻ�������������¼�(���ֳ���Ħ�г����Զ���etc),���ڷǻ�����һ�����ˣ�����¼������ݺ�������������¼����ص������㷨�ļ�������Ƿǻ�����.
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO
{
    int                                    nChannelID;                            // ͨ����
    char                                   szName[DH_EVENT_NAME_LEN];             // �¼�����
    BYTE                                   bReserved1[4];                         // �ֽڶ���
    double                                 dbPTS;                                 // ʱ���(��λ�Ǻ���)
    NET_TIME_EX                            stuUTC;                                // �¼�������ʱ��
    int                                    nEventID;                              // �¼�ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                           // �¼���Ӧ�ļ���Ϣ
    int                                    nEventAction;                          // �¼�����,0��ʾ�����¼�,1��ʾ�������¼���ʼ,2��ʾ�������¼�����;
    
	char                                   szFilePath[MAX_PATH];                  // ��ͼ�ļ�·��
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];// ���ƺ��� 
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                      // �ǻ���������Ա����
    NET_RECT                               stuBoundingBoxRect;                    // �ǻ������ڴ�ͼ�еİ�Χ������,Rect��ʽ8192����ϵ
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                          // ��ͼ�еķǻ�������ͼ��Ϣ

    int                                    nImageIndex;                           // ͼƬ�����, ͬһʱ����(��ȷ����)�����ж���ͼƬ, ��0��ʼ
    DWORD                                  dwSnapFlagMask;                        // ץͼ��־(��λ),����� NET_RESERVED_COMMON    
    BYTE                                   bReserved[1024];                       // �����ֽ�,�����չ. 
} DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO;


//���ر����¼���Ϣ����Ӧ DH_ALARM_TUMBLE_DETECTION ����
typedef struct tagALARM_TUMBLE_DETECTION_INFO       
{     
	int									nAction;							// �¼�����,1��ʾ������ʼ,2��ʾ��������;
	int									nChannelID;							// ͨ����
    double								PTS;								// ʱ���(��λ�Ǻ���)
    NET_TIME_EX							UTC;								// �¼�������ʱ��
    int									nEventID;							// �¼�ID
	int									UTCMS;								// UTCʱ���Ӧ�ĺ�����
	EM_CLASS_TYPE						emClassType;						// �����¼��������
	int									nObjectID;							// Ŀ��ID
	char								szObjectType[DH_COMMON_STRING_16];	// ��������,֧������:
																			// "Unknown", "Human", "Vehicle", "Fire", "Smoke", "Plate", "HumanFace",
																			// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole", "Entity"
	NET_RECT							stuBoundingBox;						// �����Χ��
	BYTE                				byReserved[1024];   				// �����ֽ�     
}ALARM_TUMBLE_DETECTION_INFO; 

//�¼����� EVENT_IVS_TUMBLE_DETECTION(���ر����¼�)��Ӧ���ݿ�������Ϣ
typedef struct tagDEV_EVENT_TUMBLE_DETECTION_INFO
{
    int                     nChannelID;                             // ͨ����
    char                    szName[DH_EVENT_NAME_LEN];              // �¼�����
    char                    bReserved1[4];                          // �ֽڶ���
    double                  PTS;                                    // ʱ���(��λ�Ǻ���)
    NET_TIME_EX             UTC;                                    // �¼�������ʱ��
    int                     nEventID;                               // �¼�ID
	int						UTCMS;									// UTCʱ���Ӧ�ĺ�����	

	EM_CLASS_TYPE			emClassType;							// �����¼��������		
	int						nObjectID;								// Ŀ��ID
	char					szObjectType[DH_COMMON_STRING_16];		// ��������,֧������:
																	//"Unknown", "Human", "Vehicle", "Fire", "Smoke", "Plate", "HumanFace",
																	// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole", "Entity"
	NET_RECT				stuBoundingBox;							// �����Χ��

	BYTE                    bReserved[1024];                        // �����ֽ�
} DEV_EVENT_TUMBLE_DETECTION_INFO;
// ��֤�Ա�ͼƬ��Ϣ
typedef struct tagCITIZEN_PICTURE_COMPARE_IMAGE_INFO
{
    DWORD           dwOffSet;                       // �ļ��ڶ��������ݿ��е�ƫ��λ��, ��λ:�ֽ�
    DWORD           dwFileLenth;                    // �ļ���С, ��λ:�ֽ�
    WORD            wWidth;                         // ͼƬ���, ��λ:����
    WORD            wHeight;                        // ͼƬ�߶�, ��λ:����
    BYTE            byReserved[256];                // �����ֽ�
}CITIZEN_PICTURE_COMPARE_IMAGE_INFO;

// ��֤�ȶ��¼�����ʵʱ�����������Ƭ���͸��˳��е����֤��Ƭ���бȶԣ����ϱ������
// ��Ӧ�¼�����Ϊ EVENT_IVS_CITIZEN_PICTURE_COMPARE
typedef struct tagDEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO
{
    //�����ֶ�
    int                 nChannelID;                         // ͨ����,��0��ʼ
    int                 nEventAction;					    // �¼�����, 0��ʾ����, -1��ʾδ֪
    double              dbPTS;                              // ʱ���(��λ�Ǻ���)
    char                szName[DH_EVENT_NAME_LEN];          // �¼�����    
    NET_TIME_EX         stuUTC;                             // �¼�������ʱ��
    int                 nEventID;                           // �¼�ID

    //�¼���Ӧ�ֶ�
    bool                bCompareResult;                     // ��֤�ȶԽ��,���ƶȴ��ڵ�����ֵ��Ϊ�ȶԳɹ�,true��ʾ�ɹ�,false��ʾʧ��
    BYTE                nSimilarity;                        // ����ͼƬ�����ƶ�,��λ�ٷֱ�,��Χ[1,100]
    BYTE                nThreshold;                         // �����ֵ,��Χ[1,100]
    EM_CITIZENIDCARD_SEX_TYPE emSex;                        // �Ա�
    int                 nEthnicity;                         // ����(����DEV_EVENT_ALARM_CITIZENIDCARD_INFO��nEthnicity����)
    char                szCitizen[DH_COMMON_STRING_64];     // ��������    
    char                szAddress[DH_COMMON_STRING_256];    // סַ
    char                szNumber[DH_COMMON_STRING_64];      // ���֤��
    char                szAuthority[DH_COMMON_STRING_256];  // ǩ������
    NET_TIME            stuBirth;                           // ��������(������)
    NET_TIME            stuValidityStart;                   // ��Ч������ʼ����(������)
    BOOL                bLongTimeValidFlag;                 // ��ֵΪ TRUE, ��ֹ���� ��ʾ������Ч,��ʱ stuValidityEnd ֵ������
                                                            // ��ֵΪ FALSE, ��ʱ ��ֹ���� �鿴 stuValidityEnd ֵ
    NET_TIME            stuValidityEnd;                     // ��Ч���޽�������(������)
    CITIZEN_PICTURE_COMPARE_IMAGE_INFO stuImageInfo[2];     // ͼƬ��Ϣ����һ��Ϊ������Ƭ���ڶ���Ϊ���֤��Ƭ

    BYTE                byReserved[1024];                   // �����ֽ�

}DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO;

// �����ѯ��Χ
typedef struct tagDEV_OBJECT_FIND_SCOPE_INFO
{
    BOOL                bEnable;                    // �Ƿ�������������ѯ
	int                 nMinValue;                  // ��С��ѯֵ
	int                 nMaxValue;                  // ����ѯֵ
} DEV_OBJECT_FIND_SCOPE_INFO;

// ������ѯ��Χ
typedef struct tagDEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO
{
    BYTE                                   byFindType;                 // ��������巽ʽ:1 ���������� 2 ����λ����(����,����ֵ��Ч)
	int                                    nMinSunShieldNum;           // ����������С��ѯֵ(ѡ��)byFindType  Ϊ1ʱʹ��
    int                                    nMaxSunShieldNum;           // ������������ѯֵ(ѡ��)byFindType  Ϊ1ʱʹ��
	NET_SUNSHADE_STATE                     emMasterShield;             // ����ʻ��λ�����״̬(ѡ��)byFindType  Ϊ2ʱʹ��
    NET_SUNSHADE_STATE                     emSlaveShield;              // ����ʻ��λ�����״̬(ѡ��)byFindType  Ϊ2ʱʹ��
} DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO;

//�����ṹ����������
typedef struct tagDEV_VEHICLE_CONDITION_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // ���ƺ��� 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // ��������
	NET_COLOR_RGBA                         stuPlateColor;                                 // ������ɫ
    EM_NET_VEHICLE_TYPE                    emVehicleType;                                 // �������� 
	NET_COLOR_RGBA                         stuVehicleColor;                               // ������ɫ
    char                                   szVehicleLogo[32];                             // ����
    WORD                                   wVehicleSubBrand;                              // ������Ʒ�� ��Ҫͨ��ӳ���õ���������Ʒ�� ӳ�����������ֲ�
    WORD                                   wVehicleYearModel;                             // ����Ʒ����� ��Ҫͨ��ӳ���õ���������� ӳ�����������ֲ�
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // ץ�ĳ���λ��

    NET_SAFEBELT_STATE                     emMainSeat;                                    // ����ʻ��λ��ȫ��״̬(ѡ��)
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // ����ʻ��λ��ȫ��״̬(ѡ��)
	DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO   stuSunShieldInfo;                              // ������ѯ��Ϣ(����)
    DEV_OBJECT_FIND_SCOPE_INFO             stuDropInfo;                                   // ��׹������Χ(ѡ��)
    DEV_OBJECT_FIND_SCOPE_INFO             stuPaperBoxInfo;                               // ֽ��и�����Χ(ѡ��)
    DEV_OBJECT_FIND_SCOPE_INFO             stuAnnualInspectionInfo;                       // ���������Χ(ѡ��)
    BYTE                                   byReserved[256];                               // �����ֽ�
} DEV_VEHICLE_CONDITION_FEATURE_INFO;

//�����ṹ����ѯ���
typedef struct tagDEV_VEHICLE_RESULT_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // ���ƺ��� 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // ��������
	NET_COLOR_RGBA                         stuPlateColor;                                 // ������ɫ
    NET_COLOR_RGBA                         stuVehicleColor;                               // ������ɫ
    char                                   szVehicleLogo[32];                             // ����
    WORD                                   wVehicleSubBrand;                              // ������Ʒ�� ��Ҫͨ��ӳ���õ���������Ʒ�� ӳ�����������ֲ�
    WORD                                   wVehicleYearModel;                             // ����Ʒ����� ��Ҫͨ��ӳ���õ���������� ӳ�����������ֲ�
    int                                    nVehicleWindowNum;                             // ��������                                        
    NET_RECT                               stuVehicleWindow[4];                           // ����λ��,�±�0��ʾǰ�������±�1��ʾ�󳵴��������ʾ�೵��
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // ץ�ĳ���λ��
    
    NET_SAFEBELT_STATE                     emMainSeat;                                    // ����ʻ��λ��ȫ��״̬
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // ����ʻ��λ��ȫ��״̬
    NET_RECT                               stuMasterShield;                               // ����ʻ��λ�����λ��
    NET_RECT                               stuSlaveShield;                                // ����ʻ��λ�����λ��
    int                                    nAnnualInspectionNum;                          // ����־����                                        
    NET_RECT                               stuAnnualInspection[8];                        // ����־
    int                                    nDropNum;                                      // ��׹����                                        
    NET_RECT                               stuDrop[4];                                    // ��׹λ��
    int                                    nPaperBoxNum;                                  // ֽ��и���                                        
    NET_RECT                               stuPaperBox[4];                                // ֽ���λ��
    BYTE                                   byReserved[256];                               // �����ֽ�
} DEV_VEHICLE_RESULT_FEATURE_INFO;

// ����ͼƬ����
typedef enum tagEM_PIC_FEATURE_TYPE
{
    EM_PIC_FEATURE_TYPE_UNKOWN,            // δ֪����
    EM_PIC_FEATURE_TYPE_GLOBAL_SENCE,      // ȫ����ͼ
    EM_PIC_FEATURE_TYPE_SMALL,             // ��дͼ
}EM_PIC_FEATURE_TYPE;

//ͼƬ������Ϣ,
typedef struct tagDEV_IMAGE_REQUEST_FEATURE_INFO
{
    EM_PIC_FEATURE_TYPE      emPicType;            // ͼƬ����(����)
    DWORD                    dwoffset;             // �ڶ��������ݿ��е�ƫ��,��λ:�ֽ�
    DWORD                    dwLength;             // ͼƬ��С,��λ:�ֽ�
    DWORD                    dwWidth;              // ͼƬ���
    DWORD                    dwHeight;             // ͼƬ�߶�
	BOOL                     bEnableRect;          // �Ƿ���Rect��ѯ
    NET_RECT                 stuRect;              // (ѡ��)ͼƬΪGlobalSceneʱ����ʾ��ͼ�е��������꣬ʹ�þ������꣬�����ص�ʵ��λ��
    BYTE                     byReserved[256];      // �����ֽ�
} DEV_IMAGE_REQUEST_FEATURE_INFO;

//ͼƬ�����Ϣ
typedef struct tagDEV_IMAGE_RESULT_FEATURE_INFO
{
    DWORD                   dwSimilarity;                   // ͼƬ�����ƶ�,��Χ0~100
    NET_TIME                stuTime;                        // ͼƬ���/���ʱ��

	DWORD                   dwObjectOffset;                 // ��дͼ�ڶ��������ݿ��е�ƫ��,��λ�ֽ�(ȡ���������NeedData)
	DWORD                   dwObjectLength;                 // ��дͼƬ��С,��λ�ֽ�(ȡ���������NeedData)
    char                    szObjectFilePath[MAX_PATH];     // ��дͼHTTP�ļ�·��(ȡ���������NeedData)

	DWORD                   dwSceneOffset;                  // ȫ��ͼ�ڶ��������ݿ��е�ƫ��,��λ�ֽ�(ȡ���������NeedData)
	DWORD                   dwSceneLength;                  // ȫ��ͼͼƬ��С,��λ�ֽ�(ȡ���������NeedData)
    char                    szSceneFilePath[MAX_PATH];      // ȫ��ͼHTTP�ļ�·��(ȡ���������NeedData)

    NET_RECT                stuObjectRect;                  // Сͼ�ڴ�ͼ��λ�ã��������ص�
    BYTE                    byReserved[256];                // �����ֽ�
} DEV_IMAGE_RESULT_FEATURE_INFO;

// CLIENT_DetectObjectStructlize �ӿ��������
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                                    dwSize; 
    int					                     nWidth;              // ͼƬ���
    int                                      nHeight;             // ͼƬ�߶�
    char                                     *pBuffer;            // ͼƬ���������ݻ����ַ, ���û�����
    int                                      nBufferLen;          // ͼƬ���������ݻ������ݳ���
}NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC;

// ��⵽��������Ϣ
typedef struct tagNET_OBJECT_DETECTED_INFO
{
    DH_POINT                         stuPoint;                       // Сͼ���Ͻ��ڴ�ͼ��λ��, ʹ�þ�������ϵ
    DWORD                            dwWidth;                        // ͼƬ���
    DWORD                            dwHeight;                       // ͼƬ�߶�
    char                             szObjectType[16];               // ��������, �ο� NET_OBJFILTER_INFO �� szObjectType ˵��
    char                             szObjectSubType[32];            // ���������е������, �ο� NET_OBJFILTER_INFO �� szObjectSubType ˵��
    DEV_PERSON_RESULT_FEATURE_INFO   stuPersonResult;                // ��Ա�ṹ����ѯ���
    DEV_VEHICLE_RESULT_FEATURE_INFO  stuVehicleResult;               // �����ṹ����ѯ���
    BYTE                             byReserved[512];                // �����ֽ�
} NET_OBJECT_DETECTED_INFO;

// CLIENT_DetectObjectStructlize �ӿ��������
typedef struct tagNET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                          dwSize; 
    int                            nObjectNum;                                // ��⵽���������
    NET_OBJECT_DETECTED_INFO       stuObjectinfos[DH_MAX_OBJECT_LIST];        // ��⵽������
}NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC;

// �ṹ����ѯ״̬��Ϣ�ص�����, lAttachHandle�� CLIENT_AttachObjectStructlizeFindState �ķ���ֵ
typedef struct tagNET_CB_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //��ѯ����
    int                 nProgress;      //����ȡֵ��Χ��0-100,-1,��ʾ��ѯtoken������(������һ�������ڻ�����Ĳ�ѯʱ)
    int                 nCurrentCount;  //Ŀǰ���ϲ�ѯ����������
}NET_OBJECTSTRUCTLIZE_FIND_STATE;

// �ṹ����ѯ����״̬�ص�����
// pstStates �ĸ����� nStateNum ָ�� 
typedef void (CALLBACK *fObjectStructlizeFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_OBJECTSTRUCTLIZE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

// CLIENT_AttachObjectStructlizeFindState �ӿ��������
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD                              dwSize;             //�ṹ���С,������д
    
    int                                nTokenNum;          //��ѯ������,Ϊ0ʱ,��ʾ�������еĲ�ѯ����
    int                                nTokens[8];         //��ѯ����
    fObjectStructlizeFindState         cbObjectSFindState; //�ص�����
    LDWORD                             dwUser;             //�û�����
}NET_IN_OBJECTSTRUCTLIZE_FIND_STATE;

// CLIENT_AttachObjectStructlizeFindState �ӿ��������
typedef struct  tagNET_OUT_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD           dwSize;
 }NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE;

// CLIENT_StartFindObjectStructlize �ӿ��������
typedef struct tagNET_IN_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD                                      dwSize;
    int                                        nChannelNum;                    // ͨ������
    int                                        stuChannelID[16];               // ���е�ͨ����
	BOOL                                       bTimeEnable;                    // ����ʱ��β�ѯ
    NET_TIME                                   stStartTime;                    // (ѡ��)��ʼʱ��,��ѯץ�Ŀ���Ҫ,ע��ⲻ��Ҫ
    NET_TIME                                   stEndTime;                      // (ѡ��)����ʱ��,��ѯץ�Ŀ���Ҫ,ע��ⲻ��Ҫ
    //����Ϊ��ѯ��������
    char                                       szObjectType[16];               // (����)��������, ͬ NET_OBJFILTER_INFO �ֶ�
    char                                       szObjectSubType[32];            // (ѡ��)���������е������ͬ NET_OBJFILTER_INFO �ֶ�
    int                                        nSimilarity;                    // (����)�Ͳ�ѯͼƬ�����ƶȣ��ٷֱ�,��Χ0~100

    DEV_PERSON_CONDITION_FEATURE_INFO          stuPersonCondition;             // ��Ա������Ϣ������ֻ��֣����������AND��ϵ
    DEV_VEHICLE_CONDITION_FEATURE_INFO         stuVehicleCondition;            // ������������������ֻ��֣����������AND��ϵ
    DEV_IMAGE_REQUEST_FEATURE_INFO             stuImageRequestInfo;            // ͼƬ��Ϣ
    int                                        nRectNum;                       // ��Ч���������������
    NET_RECT                                   stuRect[4];                     // ����������
    
    // ͼƬ����������
    char                                       *pBuffer;                       // �����ַ, ���û�����
    int                                        nBufferLen;                     // �������ݳ���         
}NET_IN_STARTFIND_OBJECTSTRUCTLIZE;

// CLIENT_StartFindObjectStructlize �ӿ��������
typedef struct tagNET_OUT_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD               dwSize;
    int                 nTotalCount;                   // ���صķ��ϲ�ѯ�����ļ�¼���� 
    // -1��ʾ������δ����,Ҫ�Ƴٻ�ȡ
    // ʹ�� CLIENT_AttachObjectStructlizeFindState �ӿ�״̬
    
    LLONG               lFindHandle;                   // ��ѯ���
    int                 nToken;                        // ��ȡ���Ĳ�ѯ����
}NET_OUT_STARTFIND_OBJECTSTRUCTLIZE;



// CLIENT_DoFindObjectStructlize �ӿ��������
typedef struct tagNET_IN_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                          dwSize;
    LLONG                          lFindHandle;                // (����)��ѯ���
    int                            nBeginNum;                  // (����)��ѯ��ʼ���,0<=beginNumber<= totalCount-1
    int                            nCount;                     // (����)��ǰ���ѯ�ļ�¼���� 
    EM_NEEDED_PIC_RETURN_TYPE      emNeededData;               // (����)��ѯ�������ͼƬ��ʽ    
}NET_IN_DOFIND_OBJECTSTRUCTLIZE;

// doFind��⵽��������Ϣ
typedef struct tagNET_DODBFIND_OBJECT_DETECTED_INFO
{
    int                                nChannelID;                       // ͨ����
    char                               szObjectType[16];                 // ��������, ͬ NET_OBJFILTER_INFO �ֶ�
    char                               szObjectSubType[32];              // ���������е������, ͬ NET_OBJFILTER_INFO �ֶ�
    DEV_PERSON_RESULT_FEATURE_INFO     stuPersonResult;                  // ��Ա�ṹ����ѯ���
    DEV_VEHICLE_RESULT_FEATURE_INFO    stuVehicleResult;                 // �����ṹ����ѯ���
    int                                nImageNum;                        // ��⵽��ͼƬ��������ѯץ�Ŀ����鳤��1;ע������鳤�ȿ��ܴ���1
    DEV_IMAGE_RESULT_FEATURE_INFO      stuImageResults[4];               // ��⵽��ͼƬ��Ϣ���
    BYTE                               byReserved[512];                  // �����ֽ�
} NET_DODBFIND_OBJECT_DETECTED_INFO;

// CLIENT_DoFindObjectStructlize �ӿ��������
typedef struct tagNET_OUT_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                                  dwSize;
    int                                    nfoundNum;                                // ��ѯ��������
    int                                    nObjectNum;                               // ��⵽���������
    NET_DODBFIND_OBJECT_DETECTED_INFO      stuObjectinfos[DH_MAX_OBJECT_LIST];       // ��⵽������
    
    // ͼƬ����������
    char                                   *pBuffer;                                // �����ַ, ���û�����
    int                                    nBufferLen;                              // �������ݳ���
	int                                    nBufRet;                                 // ʵ�ʷ��صĳ���
}NET_OUT_DOFIND_OBJECTSTRUCTLIZE;

// ��������ֵ��ȡ, ��ͼ��ͼ pstInParam �� pstOutPara m�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectObjectStructlize(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC *pstOutParam, int nWaitTime );

// ���Ľṹ����ѯ״̬ pstInParam �� pstOutParam �ڴ����û������ͷ�
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachObjectStructlizeFindState(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_FIND_STATE* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE *pstOutParam, int nWaitTime );

// ȡ���ṹ����ѯ״̬ lAttachHandle Ϊ CLIENT_AttachObjectStructlizeFindState ���صľ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachObjectStructlizeFindState(LLONG lAttachHandle);

// ��������ѯ�ṹ��ʶ���� pstInParam �� pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindObjectStructlize(LLONG lLoginID, const NET_IN_STARTFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_STARTFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// ���ҽṹ��ʶ����:nFilecount:��Ҫ��ѯ������, ����ֵΪý���ļ����� ����ֵ<nFilecount����Ӧʱ����ڵ��ļ���ѯ���(ÿ�����ֻ�ܲ�ѯ20����¼),pstInParam��pstOutParam�ڴ����û������ͷ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindObjectStructlize(const NET_IN_DOFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_DOFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// �����ṹ����ѯ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindObjectStructlize(LLONG lFindHandle);

typedef enum tagEM_STATIS_GRANULARITY
{
	EM_STATIS_GRANULARITY_UNKNOWN,					// δ֪����
	EM_STATIS_GRANULARITY_BY_HOUR,					// ��Сʱȡһ������������
	EM_STATIS_GRANULARITY_BY_DAY,					// ����ȡһ������������
	EM_STATIS_GRANULARITY_BY_MONTH,					// ����ȡһ������������
}EM_STATIS_GRANULARITY;
//CLIENT_StartFindExternalSensor �ӿ��������
typedef struct tagNET_IN_STARTFIND_EXTERNALSENSOR
{
	DWORD						dwSize;
	NET_TIME					stStartTime;					// ��ʼʱ��
	NET_TIME					stEndTime;						// ����ʱ��
	EM_STATIS_GRANULARITY		emGranularity;					// ��ѯҪ�󷵻ص�ͳ����Ϣ���ȣ�"Hour"��Сʱ��"Day"ÿ��ȡһ�����������ݣ�"Month"ÿ��ÿ��ȡһ������������
	UINT						nVideoChannel;					// ��Ƶͨ���ţ�DVR/NVR�Խ�ʱ��Ҫ����ĿIPC���Բ������0
	UINT						nIndex;							// �ⲿ������ͨ����
	UINT						nRecordHour;					// ����ʱ��㣬��λСʱ,��Χ[0,23],"szGranularity"ֵΪ"Day"��"Month"ʱ��Ч

}NET_IN_STARTFIND_EXTERNALSENSOR;

// CLIENT_StartFindExternalSensor �ӿ��������
typedef struct tagNET_OUT_STARTFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// ��ѯ����
	UINT				nTotalCount;									// ���ϴ˴β�ѯ������������
}NET_OUT_STARTFIND_EXTERNALSENSOR;

// ��ʼ��ѯ�ⲿ����������
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindExternalSensor(LLONG lLoginID, const NET_IN_STARTFIND_EXTERNALSENSOR* pstInParam, NET_OUT_STARTFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// CLIENT_DoFindExternalSensor �ӿ��������
typedef struct tagNET_IN_DOFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// ��ѯ����
	UINT				nBegin;											// ��ѯ��ʼ��ţ���ʾ��begin����¼��ʼ��ȡnCount����¼����
	UINT				nCount;											// ÿ�β�ѯ������
}NET_IN_DOFIND_EXTERNALSENSOR;

typedef struct tagNET_FIND_EXTERNALSENSOR_INFO
{
	UINT				nVideoChannel;									// ��Ƶͨ����
	UINT				nIndex;											// �ⲿ������ͨ����
	NET_TIME			stRecordTime;									// �ⲿ���������ݴ洢ʱ��
	double				dbData;											// �ⲿ����������
	BYTE				byReserve[1024];								// �����ֽ�
}NET_FIND_EXTERNALSENSOR_INFO;

// CLIENT_DoFindExternalSensor �ӿ��������
typedef struct tagNET_OUT_DOFIND_EXTERNALSENSOR
{
	DWORD								dwSize;
	UINT								nFound;							// ��ѯ��������
	UINT								nMazNum;						// ��ѯ����
	NET_FIND_EXTERNALSENSOR_INFO*		pstuInfo;						// �ⲿ���������ݲ�ѯ������û������ڴ�,��СΪsizeof(NET_FIND_EXTERNALSENSOR_INFO)*nMazNum
}NET_OUT_DOFIND_EXTERNALSENSOR;

// ��ȡ���ϲ�ѯ�������ⲿ����������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindExternalSensor(LLONG lFindHandle, const NET_IN_DOFIND_EXTERNALSENSOR* pstInParam, NET_OUT_DOFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// ֹͣ��ѯ�ⲿ����������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindExternalSensor(LLONG lFindHandle);

// ��ȡ���ٺ���ʾ����
typedef struct tagNET_CFG_TRACKBOX
{
	int				nVideoChannel;				// ��Ƶͨ����
	BOOL			bTargetBox;					// �Ƿ���ʾĿ���
	BOOL			bTrackBox;					// �Ƿ���ʾ���ٿ�
	BOOL			bTargetNumber;				// �Ƿ���ʾĿ����
	BYTE			byReserved[1024];
}NET_CFG_TRACKBOX;

typedef struct tagNET_IN_GET_TRACKBOX
{
	DWORD				dwSize;
	int					nVideoChannel;				// ��Ƶͨ����
}NET_IN_GET_TRACKBOX;

typedef struct tagNET_OUT_GET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuGetTrackBox;
}NET_OUT_GET_TRACKBOX;

// ��ȡ���ٺ���ʾ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackBox(LLONG lLoginID, const NET_IN_GET_TRACKBOX* pstInParam, NET_OUT_GET_TRACKBOX *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuSetTrackBox;
}NET_IN_SET_TRACKBOX;

typedef struct tagNET_OUT_SET_TRACKBOX
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKBOX;

// ���ø��ٺ���ʾ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackBox(LLONG lLoginID, const NET_IN_SET_TRACKBOX* pstInParam, NET_OUT_SET_TRACKBOX *pstOutParam, int nWaitTime);

// ����ģʽ
typedef enum tagEM_TRACK_MODE
{
	EM_TRACK_MODE_UNKNOWN = -1,						// δ֪ģʽ
	EM_TRACK_MODE_AUTO,								// �Զ�����
	EM_TRACK_MODE_SINGLE,							// ��Ŀ�����
	EM_TRACK_MODE_MANUAL,							// �ֶ�����
	EM_TRACK_MODE_ALARM								// ��������
}EM_TRACK_MODE;

typedef struct tagNET_CFG_TRACKMODE
{
	int					nVideoChannel;				// ��Ƶͨ����
	EM_TRACK_MODE		emTrackMode;				// ����ģʽ
	BYTE				byReserved[1024];			// �����ֶ�
}NET_CFG_TRACKMODE;

typedef struct tagNET_IN_GET_TRACKMODE
{
	DWORD				dwSize;
	int					nVideoChannel;				// ��Ƶͨ����
}NET_IN_GET_TRACKMODE;

typedef struct tagNET_OUT_GET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuGetTrackMode;
}NET_OUT_GET_TRACKMODE;

// ��ȡ����ģʽ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackMode(LLONG lLoginID, const NET_IN_GET_TRACKMODE* pstInParam, NET_OUT_GET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuSetTrackMode;
}NET_IN_SET_TRACKMODE;

typedef struct tagNET_OUT_SET_TRACKMODE
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKMODE;

// ���ø���ģʽ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackMode(LLONG lLoginID, const NET_IN_SET_TRACKMODE* pstInParam, NET_OUT_SET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_CFG_LINKPOS
{
	int					nVideoChannel;						// ��Ƶͨ����
	char				szBallip[DH_COMMON_STRING_64];		// �������IP��ַ�����Ժ��Բ���
	unsigned short		nX;									// ��������ٺ���Ƶx�����һ��ֵ������ѡ�������ģ���Χ[0,8191]
	unsigned short		nY;									// ��������ٺ���Ƶy�����һ��ֵ������ѡ��������y�����һ��ֵ����Χ[0,8191]
	float				fZoom;								// zoomΪ������ʾ��ѡ������ֻ�������䱶�����ڵ���0����ʾ��ѡ����
	BYTE				byReserved[1024];					// �����ֶ�
}NET_CFG_LINKPOS;

typedef struct tagNET_IN_SET_LINKPOS
{
	DWORD				dwSize;
	NET_CFG_LINKPOS		stuSetLinkPos; 
}NET_IN_SET_LINKPOS;

typedef struct tagNET_OUT_SET_LINKPOS
{
	DWORD			dwSize;
}NET_OUT_SET_LINKPOS;

// ��ѡ�����Ϳ�ѡ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLinkPos(LLONG lLoginID, const NET_IN_SET_LINKPOS* pstInParam, NET_OUT_SET_LINKPOS *pstOutParam, int nWaitTime);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++�ƴ洢��������ؽӿ�+++++++++++++++++++++++++++++++++++++++++++

// bucket������Ϣ
typedef struct tagNET_BUCKET_NAME_INFO
{
    char szName[DH_COMMON_STRING_64];                       // ����
    BYTE byReserved[256];                                   // �����ֽ�
}NET_BUCKET_NAME_INFO;

// ��ʼ��ѯbucket�������
typedef struct tagNET_IN_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // �ṹ���С
    UINT nOffset;                                           // ��ѯƫ��ֵ
    UINT nCount;                                            // ��ѯ����    
}NET_IN_FIND_BUCKET_NAME;

// ��ʼ��ѯbucket���Ƴ���
typedef struct tagNET_OUT_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // �ṹ���С
    UINT nTotalCount;                                       // �ܵ�bucket��������
    UINT nFindCount;                                        // ʵ�ʲ�ѯ��bucket��������
    NET_BUCKET_NAME_INFO* pBucketName;                      // bucket����ָ�룬���û�����/�ͷ��ڴ棬sdk���������ڴ�
    UINT nNameCount;                                        // bucket���Ƹ������û���д    
}NET_OUT_FIND_BUCKET_NAME;

// bucket������ļ�������Ϣ
typedef struct tagNET_BUCKET_FILE_NAME_INFO
{
    char szName[DH_COMMON_STRING_1024];                     // �ļ�����
    BYTE byReserved[256];                                   // �����ֽ�
}NET_BUCKET_FILE_NAME_INFO;

// ��ʼ��ѯĳ��bucket�µ��ļ�������Ϣ���
typedef struct tagNET_IN_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // �ṹ���С    
    UINT nOffset;                                           // ��ѯƫ����
    UINT nCount;                                            // ��ѯ����
    char szBucketName[DH_COMMON_STRING_64];                 // bucket����    
}NET_IN_FIND_BUCKET_FILE_NAME;

// ��ʼ��ѯĳ��bucket�µ��ļ�������Ϣ����
typedef struct tagNET_OUT_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // �ṹ���С
    UINT nTotalCount;                                       // �ܵ��ļ���������
    UINT nFindCount;                                        // ��ѯ�����ļ���������
    NET_BUCKET_FILE_NAME_INFO* pFileName;                   // file����ָ�룬���û�����/�ͷ��ڴ棬sdk���������ڴ�
    UINT nFileCount;                                        // file���Ƹ������û���д
}NET_OUT_FIND_BUCKET_FILE_NAME;

// ��ѯEFS�豸ϵͳ�е�bucket������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketName(LLONG lLoginID, const NET_IN_FIND_BUCKET_NAME* pstInParam, NET_OUT_FIND_BUCKET_NAME *pstOutParam, int nWaitTime );

// ��ѯĳ��bucket������ļ�������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketFileName(LLONG lLoginID, const NET_IN_FIND_BUCKET_FILE_NAME* pstInParam, NET_OUT_FIND_BUCKET_FILE_NAME *pstOutParam, int nWaitTime );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++�ƴ洢��������ؽӿ�+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++����㲥��ؽӿ�+++++++++++++++++++++++++++++++++++++++++++
//�㲥����Խ����ݻص�����ԭ��
typedef void (CALLBACK *pfAudioBroadcastDataCallBack)(LLONG lSpeakHandle, char *pDataBuf, DWORD dwBufSize, int nToken, LDWORD dwUser);

// ��ָ����ͨ����������㲥���������
typedef struct tagNET_IN_START_CHANNEL_INFO
{
	DWORD							dwSize;
	int 							nChannelCount;			// ָ����ͨ������
	int								nChannel[32];			// ָ����ͨ���ŵ��б�
	pfAudioBroadcastDataCallBack 	pfcb;					// �㲥����Խ����ݻص�����
	LDWORD 							dwUser;					// �û�����
} NET_IN_START_CHANNEL_INFO;

// ��ָ����ͨ����������㲥���������
typedef struct tagNET_OUT_START_CHANNEL_INFO
{
	DWORD					dwSize;
	int						nToken;					// �㲥����
	int						nFrequency;				// ��Ƶ����Ƶ��
	int						nDepth;					// �������
	DH_TALK_CODING_TYPE		emCompressionType;		// ��Ƶ��������
} NET_OUT_START_CHANNEL_INFO;

//CLIENT_TalkChannelSendData�������
typedef struct tagNET_TALK_CHANNEL_SENDDATA_IN
{
	DWORD					dwSize;
	char 			   	   *pSendBuf;		// ��Ҫ���͵���������
	int 					nSendBufLen;	// �������ݳ���
} NET_TALK_CHANNEL_SENDDATA_IN;

//CLIENT_TalkChannelSendData�������
typedef struct tagNET_TALK_CHANNEL_SENDDATA_OUT
{
	DWORD					dwSize;
} NET_TALK_CHANNEL_SENDDATA_OUT;

// ��ָ����ͨ�����й㲥����
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkChannel(LLONG lLoginID, const NET_IN_START_CHANNEL_INFO *pstInParam, NET_OUT_START_CHANNEL_INFO *pstOutParam, int nWaitTime);

// ��ָ����ͨ��������������
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TalkChannelSendData(LLONG lSpeakHandle, const NET_TALK_CHANNEL_SENDDATA_IN *pstInParam, NET_TALK_CHANNEL_SENDDATA_OUT *pstOutParam, int nWaitTime);

// ��������㲥
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopTalkChannel(LLONG lSpeakHandle);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++����㲥��ؽӿ�+++++++++++++++++++++++++++++++++++++++++++



// ��ʼ���豸�˻�����ṹ��
typedef struct tagNET_IN_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;										// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char					szMac[DH_MACADDR_LEN];						// �豸mac��ַ	
	char					szUserName[MAX_USER_NAME_LEN];				// �û���
	char					szPwd[MAX_PWD_LEN];							// �豸����
	char					szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// Ԥ���ֻ���
	char					szMail[MAX_MAIL_LEN];						// Ԥ������
	BYTE					byInitStatus;								// ���ֶ��Ѿ�����															
	BYTE					byPwdResetWay;								// �豸֧�ֵ��������÷�ʽ�������豸�ӿ�(CLIENT_SearchDevices��CLIENT_StartSearchDevices�Ļص�������CLIENT_SearchDevicesByIPs)�����ֶ�byPwdResetWay��ֵ	
																		// ��ֵ�ľ��庬��� DEVICE_NET_INFO_EX �ṹ�壬��Ҫ���豸�����ӿڷ��ص� byPwdResetWay ֵ����һ��
																		// bit0 : 1-֧��Ԥ���ֻ��ţ���ʱ��Ҫ��szCellPhone����������Ԥ���ֻ���(�����Ҫ����Ԥ���ֻ�) ; 
																		// bit1 : 1-֧��Ԥ�����䣬��ʱ��Ҫ��szMail����������Ԥ������(�����Ҫ����Ԥ������)
	BYTE					byReserved[2];								// �����ֶ�
}NET_IN_INIT_DEVICE_ACCOUNT;

// ��ʼ���豸�˻�����ṹ��
typedef struct tagNET_OUT_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
}NET_OUT_INIT_DEVICE_ACCOUNT;

// ��ʼ���˻�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccount(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, char* szLocalIp);

// �����豸IP��ʼ���˻�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccountByIP(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, const char* szLocalIp,const char* szDeviceIP);

// ��Ƶ��ʽ
typedef enum tagEM_VIDEO_STANDARD
{
    EM_VIDEO_STANDARD_UNKNOWN,                               
	EM_VIDEO_STANDARD_PAL,		// "PLA"                               
	EM_VIDEO_STANDARD_NTSC,		// "NTSC"
	EM_VIDEO_STANDARD_SECAM,	// "SECAM"
}EM_VIDEO_STANDARD;

//�������������
typedef struct tagNET_IN_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                       //�ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char			  szMac[DH_MACADDR_LEN];	    // �豸mac��ַ	
	char			  szUserName[MAX_USER_NAME_LEN];// �˺���
	char			  szPwd[MAX_PWD_LEN];		    // �˺�����
	BYTE              byNetAccess;                  // �Ƿ�ʹ�ܽ��빫��(Easy4IP/�ֳ�)0-���漰��������1-�رս��빫��2-�򿪽��빫��
	BYTE              byUpgradeCheck;               // �Ƿ�����������Զ����0-���漰��������1-�ر����������Զ����2-�������������Զ����
	BYTE              byReserved[2];                // �����ֽ�
	EM_VIDEO_STANDARD emVideoStandard;				// ��Ƶ��ʽ
}NET_IN_INIT_DEVICE_ACCESS;

//���������̳���
typedef struct tagNET_OUT_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                   // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
}NET_OUT_INIT_DEVICE_ACCESS;

// ���������̣����빫���������������ȹ���
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccess(const NET_IN_INIT_DEVICE_ACCESS* pInitAccessIn, NET_OUT_INIT_DEVICE_ACCESS* pInitAccessOut, DWORD dwWaitTime, char* szLocalIp);

// ��ȡ����������Ϣ����ṹ��
typedef struct tagNET_IN_DESCRIPTION_FOR_RESET_PWD
{
	DWORD					dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char					szMac[DH_MACADDR_LEN];				// �豸mac��ַ
	char					szUserName[MAX_USER_NAME_LEN];		// �û���	
	BYTE					byInitStatus;						// �豸��ʼ��״̬�������豸�ӿ�(CLIENT_SearchDevices��CLIENT_StartSearchDevices�Ļص�������CLIENT_SearchDevicesByIPs)�����ֶ�byInitStatus��ֵ
	BYTE					byReserved[3];						// �����ֶ�
}NET_IN_DESCRIPTION_FOR_RESET_PWD;

// ��ȡ����������Ϣ����ṹ��
typedef struct tagNET_OUT_DESCRIPTION_FOR_RESET_PWD
{
	DWORD			dwSize;										// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char			szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// Ԥ���ֻ���
	char			szMailAddr[MAX_MAIL_LEN];					// Ԥ������
	char*			pQrCode;									// ��ά����Ϣ,�û������ڴ棨��ǰ��СΪ360�ֽڣ�
	unsigned int	nQrCodeLen;									// �û�����Ķ�ά����Ϣ����
	unsigned int    nQrCodeLenRet;								// �豸���صĶ�ά����Ϣ����
}NET_OUT_DESCRIPTION_FOR_RESET_PWD;

// ��ȡ������Ϣ:�ֻ��š����䡢��ά����Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDescriptionForResetPwd(const NET_IN_DESCRIPTION_FOR_RESET_PWD* pDescriptionIn, NET_OUT_DESCRIPTION_FOR_RESET_PWD* pDescriptionOut, DWORD dwWaitTime, char* szLocalIp);


// ������������ṹ��
typedef struct tagNET_IN_RESET_PWD
{
	DWORD					dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char					szMac[DH_MACADDR_LEN];				// �豸mac��ַ	
	char					szUserName[MAX_USER_NAME_LEN];		// �û���
	char					szPwd[MAX_PWD_LEN];					// ����
	char					szSecurity[MAX_SECURITY_CODE_LEN];	// ƽ̨���͵�Ԥ���ֻ��������еİ�ȫ��
	BYTE					byInitStaus;						// �豸��ʼ��״̬�������豸�ӿ�(CLIENT_SearchDevices��CLIENT_StartSearchDevices�Ļص�������CLIENT_SearchDevicesByIPs)�����ֶ�byInitStatus��ֵ
	BYTE					byPwdResetWay;						// �豸֧�ֵ��������÷�ʽ�������豸�ӿ�(CLIENT_SearchDevices��CLIENT_StartSearchDevices�Ļص�������CLIENT_SearchDevicesByIPs)�����ֶ�byPwdResetWay��ֵ
	BYTE					byReserved[2];						// �����ֶ�					
}NET_IN_RESET_PWD;

// ������������ṹ��
typedef struct tagNET_OUT_RESET_PWD
{
	DWORD					dwSize;// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
}NET_OUT_RESET_PWD;

// ��������
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetPwd(const NET_IN_RESET_PWD* pResetPwdIn, NET_OUT_RESET_PWD* pResetPwdOut, DWORD dwWaitTime, char* szLocalIp);

// �˻�����
typedef enum tagEM_ACCOUNT_TYPE
{
    EM_ACCOUNT_TYPE_UNKNOWN,                                    // δ֪��
    EM_ACCOUNT_TYPE_SDK,                                        // sdk�˻���ϵ
    EM_ACCOUNT_TYPE_WEB,                                        // web�˻���ϵ
}EM_ACCOUNT_TYPE;

// ��ʼ���˻����
typedef struct tagNET_IN_INIT_ACCOUNT
{
    DWORD					dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ    
    char					szUser[MAX_USER_NAME_LEN];		    // �û���
    char					szPwd[MAX_PWD_LEN];					// ����
    char                    szMac[DH_MACADDR_LEN];              // �豸��Mac��ַ
    EM_ACCOUNT_TYPE         emAccountType;                      // �˺�����
}NET_IN_INIT_ACCOUNT;

// ��ʼ���˻�����
typedef struct tagNET_OUT_INIT_ACCOUNT
{
    DWORD               dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ  		
}NET_OUT_INIT_ACCOUNT;

// ����WEB�������
typedef struct tagNET_IN_REST_WEB_PWD
{
    DWORD					dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ   
    char					szWebUser[MAX_USER_NAME_LEN];		// web�û���
    char					szWebPwd[MAX_PWD_LEN];			    // ���ú��web����
}NET_IN_REST_WEB_PWD;

// ����WEB�������
typedef struct tagNET_OUT_REST_WEB_PWD
{
    DWORD               dwSize;								// �ṹ���С:��ʼ���ṹ��ʱ��ֵ  		
}NET_OUT_REST_WEB_PWD;

// ��ʼ���˻�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitAccount(const NET_IN_INIT_ACCOUNT* pInitAccountIn, NET_OUT_INIT_ACCOUNT* pInitAccountOut, int nWaitTime, char* szLocalIp);

// ����web�˻�����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetWebPwd(LLONG lLoginID,const NET_IN_REST_WEB_PWD* pstInParam, NET_OUT_REST_WEB_PWD* pstOutParam, int nWaitTime);


// У�鰲ȫ������ṹ��
typedef struct tagNET_IN_CHECK_AUTHCODE
{
	DWORD					dwSize;									// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
	char					szMac[DH_MACADDR_LEN];					// �豸mac��ַ
	char					szSecurity[MAX_SECURITY_CODE_LEN];		// ƽ̨���͵�Ԥ���ֻ��������еİ�ȫ��
}NET_IN_CHECK_AUTHCODE;


// У�鰲ȫ������ṹ��
typedef struct tagNET_OUT_CHECK_AUTHCODE
{
	DWORD					dwSize;//�ṹ���С:��ʼ���ṹ��ʱ��ֵ
}NET_OUT_CHECK_AUTHCODE;

// ���鰲ȫ��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckAuthCode(const NET_IN_CHECK_AUTHCODE* pCheckAuthCodeIn, NET_OUT_CHECK_AUTHCODE* pCheckAuthCodeOut, DWORD dwWaitTime, char* szLocalIp);



// ����360ȫ���˶����ý�幤��ģʽ���
typedef struct tagNET_IN_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
    UINT                    nMediaMode;                             // �������ģʽ,0:ץͼģʽ,1:¼��ģʽ,2:Liveģʽ
}NET_IN_SET_EVEREST360_MEDIAMODE;


// ����360ȫ���˶����ý�幤��ģʽ����
typedef struct tagNET_OUT_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
}NET_OUT_SET_EVEREST360_MEDIAMODE;

// ����360ȫ���˶����ý�幤��ģʽ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetEverest360MediaMode(LLONG lLoginID, const NET_IN_SET_EVEREST360_MEDIAMODE *pstInParam, NET_OUT_SET_EVEREST360_MEDIAMODE *pstOutParam, int nWaitTime);

// CLIENT_GetPwdSpecification ����ṹ��
typedef struct tagNET_IN_PWD_SPECI
{
	DWORD		dwSize;					// �ṹ���С
	char		szMac[DH_MACADDR_LEN];	// �豸mac��ַ
}NET_IN_PWD_SPECI;

// CLIENT_GetPwdSpecification ����ṹ��
typedef struct tagNET_OUT_PWD_SPECI
{
	DWORD			dwSize;										// �ṹ���С
	unsigned int	nMaxPwdLen;									// ������볤��
	unsigned int	nMinPwdLen;									// ��С���볤��	
	char			szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// ֧�ֵĻ����ַ������б�����Number���֣�LowerСд��ĸ��Upper��д��ĸ���ַ�����ʽ:"Number,Lower,Upper"
	char			szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// ֧�ֵ������ַ�����"~!@#$%^" 
	int				nCombine;									// �������Ҫ��0-������Ҫ��1-�����������ַ����������ޣ�2-�������2����������(���֡���д��Сд�������ַ�)
}NET_OUT_PWD_SPECI;

// ��ȡ����淶
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPwdSpecification(const NET_IN_PWD_SPECI* pPwdSpeciIn, NET_OUT_PWD_SPECI* pPwdSpeciOut, DWORD dwWaitTime, char* szLocalIp);

// CLIENT_SetLowRateWPANPower���
typedef struct tagNET_IN_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// �ṹ���С
    int             nPower;                                     // ���书��
    char            szSmartLockNum[MAX_COMMON_STRING_32];       // ���������к�
}NET_IN_SET_LOWRATEWPAN_POWER;

// CLIENT_SetLowRateWPANPower����
typedef struct tagNET_OUT_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// �ṹ���С   
}NET_OUT_SET_LOWRATEWPAN_POWER;

// ���������������书��
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLowRateWPANPower(LLONG lLoginID, const NET_IN_SET_LOWRATEWPAN_POWER *pstInParam, NET_OUT_SET_LOWRATEWPAN_POWER *pstOutParam, int nWaitTime);

// �Ž���������������
typedef enum tagNET_EM_ACCESS_CTL_MANAGER
{
    NET_EM_ACCESS_CTL_MANAGER_ADDDEVICE,                        // ��ӵ����ֿ���, ��Ӧ�ṹ�� pstInParam = NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
    NET_EM_ACCESS_CTL_MANAGER_MODIFYDEVICE,                     // �޸ķֿ�������, ��Ӧ�ṹ�� pstInParam = NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
    NET_EM_ACCESS_CTL_MANAGER_REMOVEDEVICE,                     // ɾ���ֿ���, ��Ӧ�ṹ�� pstInParam = NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_INFO,                    // ��ȡ�ֿ�����Ϣ, ��Ӧ�ṹ�� pstInParam = NET_IN_GET_SUB_CONTROLLER_INFO, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_INFO
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_STATE,                   // ��ȡ�ֿ���״̬, ��Ӧ�ṹ�� pstInParam = NET_IN_GET_SUB_CONTROLLER_STATE, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_STATE
    NET_EM_ACCESS_CTL_SET_REPEAT_ENTERROUTE,                    // ���÷�Ǳ·����Ϣ, ��Ӧ�ṹ�� pstInparam = NET_IN_SET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_SET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_GET_REPEAT_ENTERROUTE,                    // ��ȡ��Ǳ·����Ϣ, ��Ӧ�ṹ�� pstInparam = NET_IN_GET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_GET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_SET_ABLOCK_ROUTE,                         // ����AB����·����Ϣ, ��Ӧ�ṹ�� pstInparam = NET_IN_SET_ABLOCK_ROUTE, pstOutParam = NET_OUT_SET_ABLOCK_ROUTE
    NET_EM_ACCESS_CTL_GET_ABLOCK_ROUTE,                         // ��ȡAB����·����Ϣ, ��Ӧ�ṹ�� pstInparam = NET_IN_GET_ABLOCK_ROUTE, pstOutParam = NET_OUT_GET_ABLOCK_ROUTE
    NET_EM_ACCESS_CTL_GET_LOGSTATUS,                            // ��ȡ��־ͬ��״̬,��Ӧ�ṹ�� pstInparam = NET_IN_GET_LOGSTATUS, pstOutParam = NET_OUT_GET_LOGSTATUS 
    NET_EM_ACCESS_CTL_SYNCHRO_OFFLINE_LOG,                      // ͬ��������־, ��Ӧ�ṹ�� pstInparam = NET_IN_SYNCHRO_OFFLINE_LOG, pstOutParam = NET_OUT_SYNCHRO_OFFLINE_LOG 
    NET_EM_ACCESS_CTL_SYNCHRO_TIME,                             // ͬ���ֿ���ʱ��,��Ӧ�ṹ�� pstInparam = NET_IN_SYNCHRO_CONTROLLER_TIME, pstOutParam = NET_OUT_SYNCHRO_CONTROLLER_TIME 
}NET_EM_ACCESS_CTL_MANAGER;

// ��ӷֿ������
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // �ֿ���ID��ȡֵ��Χ 1~255
    char            szSubControllerName[MAX_COMMON_STRING_128]; // �ֿ�������
}NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE;

// ��ӷֿ�������
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;   
    int             nErrorCode;                                 // ������0-	��ӳɹ�, 1-�ظ����,2-����,3-��������ʧ��
}NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE;

// �޸ķֿ������
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // �ֿ���ID��ȡֵ��Χ 0~255,0Ϊ����
    char            szSubControllerName[MAX_COMMON_STRING_128]; // �ֿ�������
}NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// �޸ķֿ�������
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
}NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// ɾ���ֿ������
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM]; // �ֿ���ID, ȡֵ��Χ 1~255
    int             nSubControllerNum;                          // ��Ҫɾ���ķֿ�������
}NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// ɾ�����ؽ��
typedef struct tagNET_REMOVEDEVICE_RESULT
{
    int             nSubControllerID;                           // �ֿ���ID
    int             nErrorCode;                                 // ���ؽ��, 0-ɾ���ɹ�,1-ɾ��ʧ�� 2-δ����
    BYTE            byReserved[128];                            
}NET_REMOVEDEVICE_RESULT;

// ɾ���ֿ�������
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD                       dwSize;
    int                         nResultNum;
    NET_REMOVEDEVICE_RESULT     stuResult[MAX_ACCESSSUBCONTROLLER_NUM];     
}NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// ��ȡ�ֿ�����Ϣ���
typedef struct tagNET_IN_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // �ֿ���ID, ȡֵ��Χ -1~255, -1:��ȡ����,0:��ȡ����,1~255:���÷ֿ�
    int                         nSubControllerNum;                              // ��Ҫ��ѯ�ķֿ�������
}NET_IN_GET_SUB_CONTROLLER_INFO;

// ��˫��
typedef enum  tagNET_EM_ACCESS_PROPERTY
{
    NET_EM_ACCESS_PROPERTY_UNKNOWN,                                             // δ֪
    NET_EM_ACCESS_PROPERTY_BIDIRECT,                                            // ˫���Ž�
    NET_EM_ACCESS_PROPERTY_UNIDIRECT,                                           // �����ž�
}NET_ACCESS_PROPERTY;

// ��������Ϣ
typedef struct tagNET_CARDREAD_INFO 
{
    int                         nDoor;                                          // �����
    int                         nReadNum;                                       // ����������
    char                        szReadID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32];  // ������ID
    BYTE                        byReserved[64];  
}NET_CARDREAD_INFO;

// �ֿ�����Ϣ
typedef struct tagNET_SUB_CONTROLLER_INFO 
{
    int                         nSubControllerID;                               // �ֿ���ID��ȡֵ��Χ 0~255,0Ϊ����
    char                        szSubControllerName[MAX_COMMON_STRING_128];     // �ֿ�������
    NET_ACCESS_PROPERTY         emProperty;                                     // �Ž���˫��
    char                        szDeviceType[MAX_COMMON_STRING_128];            // �ֿ����ͺ�
    char                        szVesion[MAX_COMMON_STRING_128];                // �ֿ����汾��
    int                         nDoorNum;                                       // ������
    NET_CARDREAD_INFO           stuReaderInfo[MAX_ACCESSDOOR_NUM];              // �Ŷ�Ӧ�Ķ�������
    BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_INFO;

// ��ȡ�ֿ�����Ϣ����
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_INFO     stuSubControllerInfo[MAX_ACCESSSUBCONTROLLER_NUM];  // �ֿ�����Ϣ
    int                         nRetNum;                                            // ��ѯ���ķֿ�������
}NET_OUT_GET_SUB_CONTROLLER_INFO;

// ��ȡ�ֿ���״̬���
typedef struct tagNET_IN_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];      // �ֿ���ID, ȡֵ��Χ -1~255, -1:��ȡ����,0:��ȡ����,1~255:���÷ֿ�
    int                         nSubControllerNum;                                  // ��Ҫ��ѯ�ķֿ�������
}NET_IN_GET_SUB_CONTROLLER_STATE;

// �ֿ���״̬��Ϣ
typedef struct tagNET_SUB_CONTROLLER_STATE
{
    int                         nSubControllerID;                                   // �ֿ���ID
    int                         nState;                                             // 0:���� 1:���� 2:δ����
    BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_STATE;

// ��ȡ�ֿ���״̬����
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_STATE    stuSubControllerState[MAX_ACCESSSUBCONTROLLER_NUM];  // �ֿ�����Ϣ
    int                         nRetNum;                                             // ��ѯ���ķֿ�������
}NET_OUT_GET_SUB_CONTROLLER_STATE;

// ��Ǳ·������Ϣ
typedef struct tagNET_POINT_READER_INFO
{
    int                         nReaderNum;                                         // ��Ǳ��Ķ���������
    char                        szReaderID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32]; // ������ID 
    BYTE                        byReserved[128];
}NET_POINT_READER_INFO;

// ���÷�Ǳ·�����
typedef struct tagNET_IN_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // ��Ǳ·��������
    int                         nPointNum;                                           // ·���ϵĵ�����
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // ����Ϣ
    int                         nTimeSection;                                        // �Ž�ʱ�������AccessTimeSchedule�±꣬��ϸ���ѯdhconfigsdk.h
    BOOL                        bFlag;                                               // �Ƿ�����
    char                        szRouteName[MAX_COMMON_STRING_128];                  // ·������
}NET_IN_SET_REPEAT_ENTERROUTE;

// ���÷�Ǳ·������
typedef struct tagNET_OUT_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_REPEAT_ENTERROUTE;

// ��ȡ��Ǳ·�����
typedef struct tagNET_IN_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // ��Ǳ·��������
}NET_IN_GET_REPEAT_ENTERROUTE;

// ��ȡ��Ǳ·������
typedef struct tagNET_OUT_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // ·���ϵĵ�����
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // ����Ϣ
    int                         nTimeSection;                                        // �Ž�ʱ�������AccessTimeSchedule�±꣬��ϸ���ѯdhconfigsdk.h
    BOOL                        bFlag;                                               // �Ƿ�����
    char                        szRouteName[MAX_COMMON_STRING_128];                  // ·������
}NET_OUT_GET_REPEAT_ENTERROUTE;

// AB��������Ϣ
typedef struct tagNET_POINT_DOOR_INFO
{
    int                         nDoorNum;                                           // AB����������
    int                         nDoorID[MAX_ACCESSDOOR_NUM];                        // AB���������
    BYTE                        byReserved[128];
}NET_POINT_DOOR_INFO;

// ����AB�������
typedef struct tagNET_IN_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // AB����·��������
    int                         nPointNum;                                           // AB�����ĵ�����
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // ����Ϣ
    int                         nTimeSection;                                        // �Ž�ʱ�������AccessTimeSchedule�±꣬��ϸ���ѯdhconfigsdk.h
    BOOL                        bFlag;                                               // �Ƿ�����
    char                        szRouteName[MAX_COMMON_STRING_128];                  // AB����·������
}NET_IN_SET_ABLOCK_ROUTE;

// ����AB��������
typedef struct tagNET_OUT_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_ABLOCK_ROUTE;

// ��ȡAB����·����Ϣ���
typedef struct tagNET_IN_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // AB����·��������
}NET_IN_GET_ABLOCK_ROUTE;

// ��ȡAB����·����Ϣ����
typedef struct tagNET_OUT_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // AB�����ĵ�����
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // ����Ϣ
    int                         nTimeSection;                                        // �Ž�ʱ�������AccessTimeSchedule�±꣬��ϸ���ѯdhconfigsdk.h
    BOOL                        bFlag;                                               // �Ƿ�����
    char                        szRouteName[MAX_COMMON_STRING_128];                  // AB����·������
}NET_OUT_GET_ABLOCK_ROUTE;

// ��ȡ������־״̬���
typedef struct tagNET_IN_GET_LOGSTATUS
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // �ֿ���ID   ��Χ1 ~255
}NET_IN_GET_LOGSTATUS;

// ��ȡ������־״̬����
typedef struct tagNET_OUT_GET_LOGSTATUS
{
    DWORD                       dwSize;
    BOOL                        bsynchronize;                                         // true ����ͬ�� false û��ͬ��
}NET_OUT_GET_LOGSTATUS;

// ͬ��������־���
typedef struct tagNET_IN_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // �ֿ���ID   ��Χ0 ~255
}NET_IN_SYNCHRO_OFFLINE_LOG;

// ͬ��������־����
typedef struct tagNET_OUT_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
}NET_OUT_SYNCHRO_OFFLINE_LOG;

// ͬ���ֿ���ʱ�����
typedef struct tagNET_IN_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // �ֿ���ID, ȡֵ��Χ -1~255, -1:��ȡ����,0:��ȡ����,1~255:���÷ֿ�
    int                         nSubControllerNum;                              // ͬ���ķֿ�������    
}NET_IN_SYNCHRO_CONTROLLER_TIME;

// ͬ���ֿ���ʱ�����
typedef struct tagNET_OUT_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // �ֿ�����Ϣ
    int                         nRetNum;                                        // ����ʧ�ܵķֿ�������, 0��ʾȫ���ɹ�    
}NET_OUT_SYNCHRO_CONTROLLER_TIME;

//�Ž������������ӿ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessControlManager(LLONG lLoginID, NET_EM_ACCESS_CTL_MANAGER emtype, const void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_SetSmartLockUserName ���
typedef struct tagNET_IN_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// �ṹ���С
	NET_ACCESS_METHOD			emType;										// ������ʽ����
    char						szSerialNumber[MAX_COMMON_STRING_32];       // ���������к�
	char						szUserID[MAX_COMMON_STRING_16];				// �û�ID
	char						szName[MAX_COMMON_STRING_32];				// ��Ҫ�޸ĳɵ�����
} NET_IN_SET_SMART_LOCK_USERNAME;

// CLIENT_SetSmartLockUserName ����
typedef struct tagNET_OUT_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// �ṹ���С   
} NET_OUT_SET_SMART_LOCK_USERNAME;

// �������޸��û���Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSmartLockUsername(LLONG lLoginID, const NET_IN_SET_SMART_LOCK_USERNAME *pstInParam, NET_OUT_SET_SMART_LOCK_USERNAME *pstOutParam, int nWaitTime);

#define MAX_NUMBER_REGISTER_INFO	32

// CLIENT_GetSmartLockRegisterInfo ��� (ÿ�λ�ȡ����ȡ32����Ϣ)
typedef struct tagNET_IN_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD			dwSize;										// �ṹ���С
    char            szSerialNumber[MAX_COMMON_STRING_32];       // �豸���к�
	int				nOffset;									// �û��б��ƫ����
} NET_IN_GET_SMART_LOCK_REGISTER_INFO;

// ע���û�����Ϣ
typedef struct tagNET_SMART_LOCK_REGISTER_INFO
{
	NET_ACCESS_METHOD			emType;										// ������ʽ����
	char						szUserID[MAX_COMMON_STRING_16];				// �û�ID
	char						szName[MAX_COMMON_STRING_32];				// �û�����
	BYTE						byReserved[512];							// �����ֶ�	
} NET_SMART_LOCK_REGISTER_INFO;

// CLIENT_GetSmartLockRegisterInfo ����
typedef struct tagNET_OUT_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD							dwSize;						// �ṹ���С   
	int								nTotalCount;				// �ܵ��û�����
	int								nReturnCount;				// ʵ�ʷ��ص��û�����
	NET_SMART_LOCK_REGISTER_INFO	stuRegisterInfo[MAX_NUMBER_REGISTER_INFO];	// ע���û�����Ϣ
} NET_OUT_GET_SMART_LOCK_REGISTER_INFO;

// ��ȡ��ǰ��������ע���û���Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSmartLockRegisterInfo(LLONG lLoginID, const NET_IN_GET_SMART_LOCK_REGISTER_INFO *pstInParam, NET_OUT_GET_SMART_LOCK_REGISTER_INFO *pstOutParam, int nWaitTime);


// �û���Ϣ
typedef struct tagMATRIX_CAMERA_USERS_INFO 
{	
	unsigned int				nChannel;						// ͨ��
	char						szUser[MAX_USER_NAME_LEN];		// �û���
    char						szPwd[MAX_PWD_LEN];				// ����
	char						szReserve[512];					// �����ֶ�
}MATRIX_CAMERA_USERS_INFO;

// CLIENT_MatrixGetCameraUsers ����ṹ��
typedef struct tagNET_IN_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;							// �ṹ���С	
	unsigned int				nStartChannel;					// ��ʼ��ѯͨ��
	unsigned int				nChannelCount;					// һ�λ�ȡ��ͨ������	
}NET_IN_MATRIX_GET_CAMERA_USERS;

// CLIENT_MatrixGetCameraUsers ����ṹ��
typedef struct tagNET_OUT_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;							// �ṹ���С
	MATRIX_CAMERA_USERS_INFO*	pstuUserInfo;					// ���ص��û���Ϣ���飬�û����估�ͷ��ڴ棬��СΪsizeof(MATRIX_CAMERA_USERS_INFO)*nChannelCount,����nChannelCountΪNET_IN_MATRIX_GET_CAMERA_USERS���ֶ�																
	unsigned int				nChannelCountRet;				// ���ص�ͨ������
}NET_OUT_MATRIX_GET_CAMERA_USERS;

// ��ȡǰ���豸�û���������Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameraUsers(LLONG lLoginID, const NET_IN_MATRIX_GET_CAMERA_USERS* pInParam, NET_OUT_MATRIX_GET_CAMERA_USERS* pOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++MPT����NVR��ؽӿ�+++++++++++++++++++++++++++++++++++++++++++

// MPT״̬
typedef struct tagNET_MPT_STATUS
{
    EM_MPT_STATE eState;                                            // MPT����״̬
    char szSerialNumber[DH_COMMON_STRING_32];                       // MPT�豸���к�,��stateΪ2��3ʱ��ֵ
    BYTE byReserved[256];                                           // �����ֽ�
}NET_MPT_STATUS;

// ��ȡMPT�豸״̬���
typedef struct tagNET_IN_GET_MPT_STATUS
{
    DWORD					dwSize;									// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    UINT                    nOffset;                                // �ӵڼ���USB�ۿ�ʼ
    UINT                    nCount;                                 // ��ȡ����USB��
}NET_IN_GET_MPT_STATUS;

#define MAX_MPT_STATUS_NUM (64)                                     // MPT״̬��Ϣ������

// ��ȡMPT�豸״̬����
typedef struct tagNET_OUT_GET_MPT_STATUS
{
    DWORD					dwSize;									// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    UINT                    nTotalUsbNum;                           // �ܵ�USB������
    UINT                    nStatusNum;                             // ��ȡ��MPT״̬����
    NET_MPT_STATUS          stuStatus[MAX_MPT_STATUS_NUM];          // ��ȡ��MPT״̬����
}NET_OUT_GET_MPT_STATUS;

// ��ȡUSB�۽����MPT״̬
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMPTStatus(LLONG lLoginID,const NET_IN_GET_MPT_STATUS* pstInParam, NET_OUT_GET_MPT_STATUS* pstOutParam, DWORD dwWaitTime);

//  MPT״̬����
typedef enum tagEM_MPTSTATUS_TYPE
{
    EM_MPTSTATUS_UNKNOWN,           // δ֪
    EM_MPTSTATUS_MPTBASE,           // MPT��������״̬,  pOutParam = NET_MPTBASE_STATUS_INFO
    EM_MPTSTATUS_EXTCAMERA,         // ��������ͷ����״̬, pOutParam = NET_EXTCAMERA_STATUS_INFO
    EM_MPTSTATUS_NETCONNECT,        // �������ӷ�ʽ, pOutParam = NET_NETCONNECT_STATUS_INFO
} EM_MPTSTATUS_TYPE;

// MPT ��������״̬����
typedef enum tagNEM_MPTBASE_TYPE
{
    NEM_MPTBASE_UNKNOWN,                // δ֪
    NEM_MPTBASE_ON,                     // ON
    NEM_MPTBASE_OFF,                    // OFF
} NEM_MPTBASE_TYPE;

// ��������ͷ����״̬����
typedef enum tagEM_EXTCAMERA_TYPE
{
    EM_EXTCAMERA_UNKNOWN,               // δ֪
    EM_EXTCAMERA_NORMAL,                //Normal
    EM_EXTCAMERA_ABNORMAL,              //Abnormal
} EM_EXTCAMERA_TYPE;

// �������ӷ�ʽ����
typedef enum tagEM_NETCONNECT_TYPE
{
    EM_NETCONNECT_UNKNOWN,              // δ֪
    EM_NETCONNECT_WIFI,                 // WIFI
    EM_NETCONNECT_MOBILE,               // Mobile
    EM_NETCONNECT_CABLE,                // Cable
    EM_NETCONNECT_MPTBASE,              // MptBase
} EM_NETCONNECT_TYPE;

// MPT��������״̬��Ϣ
typedef struct tagNET_MPTBASE_STATUS_INFO
{
    DWORD                   dwSize;                                 // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    NEM_MPTBASE_TYPE        emMptBase;                              // MPT ��������״̬����
} NET_MPTBASE_STATUS_INFO;

// ��������ͷ����״̬��Ϣ
typedef struct tagNET_EXTCAMERA_STATUS_INFO
{
    DWORD                   dwSize;                                 // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    EM_EXTCAMERA_TYPE       emExtCamera;                            // ��������ͷ����״̬����
} NET_EXTCAMERA_STATUS_INFO;

// �������ӷ�ʽ��Ϣ
typedef struct tagNET_NETCONNECT_STATUS_INFO
{
    DWORD                   dwSize;                                 // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    EM_NETCONNECT_TYPE      emNetConnect;                           // �������ӷ�ʽ����
} NET_NETCONNECT_STATUS_INFO;


// ��ȡMPT �豸����Ϣ״̬
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_QueryMPTStatus(LLONG lLoginID, const EM_MPTSTATUS_TYPE emStatusType, void* pstOutParam, DWORD dwWaitTime);

#define MAX_POLICE_ID_NUM 32                                        // д��ľ�ԱID�������

// ��Ҫд��ľ�ԱID��Ϣ
typedef struct tagNET_WRITE_POLICE_ID_INFO
{
    int                     nUsbSlot;                                               // Ҫд�뾯ԱID��usb�۱��
    int                     nPoliceIDCount;                                         // Ҫд��ľ�ԱID������                         
    char                    szPoliceID[MAX_POLICE_ID_NUM][DH_COMMON_STRING_32];     // Ҫд��ľ�ԱID����
    BYTE                    byReserved[512];                                        // �����ֽ�
}NET_WRITE_POLICE_ID_INFO;

#define MAX_POLICE_ID_INFO_NUM 64                                                   // ���Ա��Ϣ����

// ��MPT�豸д�뾯ԱID��Ϣ���
typedef struct tagNET_IN_WRITE_POLICE_ID
{
    DWORD					    dwSize;						                        // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    int                         nIDInfoNum;                                         // ��ԱID��Ϣ����
    NET_WRITE_POLICE_ID_INFO    stuIDInfo[MAX_POLICE_ID_INFO_NUM];                  // ��ԱID��Ϣ����
}NET_IN_WRITE_POLICE_ID;

// ��MPT�豸д�뾯ԱID��Ϣ����
typedef struct tagNET_OUT_WRITE_POLICE_ID
{
    DWORD					dwSize;									                // �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    int                     nResultCount;                                           // д��������
    BOOL                    bResult[MAX_POLICE_ID_INFO_NUM];                        // ���������� 0-�ɹ�,1-ʧ��
}NET_OUT_WRITE_POLICE_ID;

// ��MPTд�뾯ԱID��Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WritePoliceID(LLONG lLoginID,const NET_IN_WRITE_POLICE_ID* pstInParam, NET_OUT_WRITE_POLICE_ID* pstOutParam, DWORD dwWaitTime);

#define MAX_MPT_MEDIA_TYPE_NUM 64                                                   // MPT¼���ļ�����������

// ���MPT¼���ļ����
typedef struct tagNET_IN_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// �ṹ���С:��ʼ���ṹ��ʱ��ֵ
    int                     nChannelID;                             // ͨ����
    NET_TIME                stuStartTime;                           // ��ʼʱ��
    NET_TIME                stuEndTime;                             // ����ʱ��
    int                     nMediaTypeCount;                        // �ļ����͸���                        
    int                     nMediaType[MAX_MPT_MEDIA_TYPE_NUM];     // �ļ���������,0:��������, 1:jpgͼƬ, 2:dav�ļ�
    int                     nCrimeType;                             // ��������
    int                     nCrimeTag;                              // ������
    char                    szComment[DH_COMMON_STRING_256];        // �û����ļ����ı�ע
}NET_IN_MARK_MPT_RECORD_FILE;

// ���MPT¼���ļ�����
typedef struct tagNET_OUT_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// �ṹ���С:��ʼ���ṹ��ʱ��ֵ   
}NET_OUT_MARK_MPT_RECORD_FILE;

// ���MPT¼���ļ�
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MarkMPTRecordFile(LLONG lLoginID,const NET_IN_MARK_MPT_RECORD_FILE* pstInParam, NET_OUT_MARK_MPT_RECORD_FILE* pstOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++MPT����NVR��ؽӿ�+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++�豸��Ϲ��ܽӿ�+++++++++++++++++++++++++++++++++++++++++++

// ��ѯ�豸�����Ϣ���
typedef struct tagNET_IN_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // �ṹ���С
    UINT nOffset;                                   // ��ѯƫ����
    UINT nCount;                                    // ��ѯ����
}NET_IN_QUERY_DIAGNOSIS_INFO;

// �豸�����Ŀ��Ϣ
typedef struct tagNET_DIAGNOSIS_ITEM_INFO
{
    NET_TIME stuOccurTime;                          // �¼�������ʱ�� 
    UINT nFaultCode;                                // ������ 
    BYTE byReserved[256];                           // �����ֽ�
}NET_DIAGNOSIS_ITEM_INFO;

// ��ѯ�豸�����Ϣ����
typedef struct tagNET_OUT_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // �ṹ���С
    UINT nTotalCount;                               // �ܵ���Ϣ����    
    NET_DIAGNOSIS_ITEM_INFO* pstuItemInfo;          // �����Ϣ����ָ��(���û������ڴ�,sdk�������)
    UINT nMaxCount;                                 // �����Ϣ���������Ŀ����
    UINT nRetCount;                                 // ��ѯ���
}NET_OUT_QUERY_DIAGNOSIS_INFO;

// ��ѯ�����Ϣ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDiagnosisInfo(LLONG lLoginID,const NET_IN_QUERY_DIAGNOSIS_INFO* pstInParam, NET_OUT_QUERY_DIAGNOSIS_INFO* pstOutParam, int nWaitTime);


// �ָ������������
typedef struct tagNET_IN_RESET_SYSTEM
{
    DWORD dwSize;
}NET_IN_RESET_SYSTEM;

// �ָ��������ó���
typedef struct tagNET_OUT_RESET_SYSTEM
{
    DWORD dwSize;
}NET_OUT_RESET_SYSTEM;

// ����ϵͳ,�ָ�����Ĭ��(����������ú�ɾ���˻�)������ʵ��Ӳ��λ����
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetSystem(LLONG lLoginID,const NET_IN_RESET_SYSTEM* pstInParam, NET_OUT_RESET_SYSTEM* pstOutParam, int nWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++�豸��Ϲ��ܽӿ�+++++++++++++++++++++++++++++++++++++++++++

#define MAX_IMSI_LEN		32		// IMSIֵ��󳤶�
#define MAX_ICCID_LEN		32		// ICCIDֵ��󳤶�

// ����ģ������
typedef enum tagEM_WIRELESS_MODE
{
	EM_WIRELESS_UNKNOWN,
	EM_WIRELESS_3G,
	EM_WIRELESS_3G1,
	EM_WIRELESS_3G2,
	EM_WIRELESS_3G3,
} EM_WIRELESS_MODE;

// CLIENT_MobileGetIMSI �ӿ����
typedef struct tagNET_IN_GET_IMSI
{
	DWORD 				dwSize;
	EM_WIRELESS_MODE	emMode;		// ����ģ������
} NET_IN_GET_IMSI;

// CLIENT_MobileGetIMSI �ӿڳ���
typedef struct tagNET_OUT_GET_IMSI
{
	DWORD 		dwSize;
	char 		szIMSI[MAX_IMSI_LEN];			// IMSIֵ
	char		szICCID[MAX_ICCID_LEN];			// ICCID��
} NET_OUT_GET_IMSI;

// ��ȡSIM����IMSI ֵ
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MobileGetIMSI(LLONG lLoginID, const NET_IN_GET_IMSI* pstInParam, NET_OUT_GET_IMSI* pstOutParam, int nWaitTime);

#define MAX_ROOMNUM_COUNT		32		// ����������
#define MAX_FACE_COUTN			20		// ����ģ������������

// ������Ϣ
typedef struct tagNET_FACE_RECORD_INFO
{
	char		szUserName[MAX_USER_NAME_LEN];						// �û���
	int			nRoom;												// �������
	char		szRoomNo[MAX_ROOMNUM_COUNT][DH_COMMON_STRING_16]; 	// ������б�
	int 		nFaceData;											// ����ģ�����ݸ���
	char		szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// ����ģ������
    BYTE        byReserved[512];                                    // �����ֽ�
} NET_FACE_RECORD_INFO;

// ���������¼��Ϣ�������
typedef struct tagNET_IN_ADD_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// �û�ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// ��������
} NET_IN_ADD_FACE_INFO;

// ���������¼��Ϣ�������
typedef struct tagNET_OUT_ADD_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_ADD_FACE_INFO;

// ��ȡ������¼��Ϣ�������
typedef struct tagNET_IN_GET_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// �û�ID
} NET_IN_GET_FACE_INFO;

// ��ȡ������¼��Ϣ�������
typedef struct tagNET_OUT_GET_FACE_INFO
{
	DWORD 			dwSize;
	int 			nFaceData;											// ����ģ�����ݸ���
	char			szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// ����ģ������
} NET_OUT_GET_FACE_INFO;

// ����������¼��Ϣ�������
typedef struct tagNET_IN_UPDATE_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// �û�ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// ��������
} NET_IN_UPDATE_FACE_INFO;

// ����������¼��Ϣ�������
typedef struct tagNET_OUT_UPDATE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_UPDATE_FACE_INFO;


// ɾ��������¼��Ϣ�������
typedef struct tagNET_IN_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// �û�ID
} NET_IN_REMOVE_FACE_INFO;

// ɾ��������¼��Ϣ�������
typedef struct tagNET_OUT_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_REMOVE_FACE_INFO;

// ���������¼��Ϣ�������
typedef struct tagNET_IN_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_IN_CLEAR_FACE_INFO;

// ���������¼��Ϣ�������
typedef struct tagNET_OUT_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_CLEAR_FACE_INFO;


// ������Ϣ��¼��������
typedef enum tagEM_FACEINFO_OPREATE_TYPE
{
	EM_FACEINFO_OPREATE_ADD,				// ���, pInbuf = NET_IN_ADD_FACE_INFO , pOutBuf = NET_OUT_ADD_FACE_INFO
	EM_FACEINFO_OPREATE_GET,				// ��ȡ, pInBuf = NET_IN_GET_FACE_INFO , pOutBuf = NET_OUT_GET_FACE_INFO
	EM_FACEINFO_OPREATE_UPDATE,				// ����, pInbuf = NET_IN_UPDATE_FACE_INFO , pOutBuf = NET_OUT_UPDATE_FACE_INFO
	EM_FACEINFO_OPREATE_REMOVE,				// ɾ��, pInbuf = NET_IN_REMOVE_FACE_INFO , pOutBuf = NET_OUT_REMOVE_FACE_INFO
	EM_FACEINFO_OPREATE_CLEAR,				// ���, pInbuf = NET_IN_CLEAR_FACE_INFO, pOutBuf = NET_OUT_CLEAR_FACE_INFO
} EM_FACEINFO_OPREATE_TYPE;

/**************************************************************************************
*   Funcname: CLIENT_FaceInfoOpreate
*   Purpose:������Ϣ��¼��������
*   InputParam:	LLONG		:lLoginID		// ��½���
*   InputParam:     EM_FACEINFO_OPREATE_TYPE: emType //��������
*   InputParam:	void*		:pInParam	// �ӿ��������, ��Դ���û�ά��
*   OutputParam:	void*		:pOutParam	// �ӿ��������, ��Դ���û�ά��
*   InputParam:	int			:nWaitTime	// �ȴ���ʱʱ��
*   Return:		BOOL
*   Created:		%2017%:%08%:%30%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceInfoOpreate(LLONG lLoginID, EM_FACEINFO_OPREATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);


/**************************************************************************************
*   Funcname: CLIENT_RenderPrivateData
*   Purpose:��ʾ˽�����ݣ��������򣬹���򱨾����ƶ�����
*   InputParam:     LLONG		:lPlayHandle        	// ���ž��
*   InputParam:     BOOL		:bTrue        		// TRUE:�� FALSE:�ر�
*   Return:		BOOL:TRUE �ɹ� FALSE ʧ��
*   Created:	       %2017%:%09%:%25%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenderPrivateData(LLONG lPlayHandle, BOOL bTrue);

#ifdef __cplusplus
}
#endif
#endif // DHNETSDK_H





